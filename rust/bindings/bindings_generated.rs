/* automatically generated by rust-bindgen 0.56.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align> {
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::core::mem::transmute(self)
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
pub const CONFIG_HAVE_ARCH_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_SCSI_DMA: u32 = 1;
pub const CONFIG_NETFILTER_FAMILY_BRIDGE: u32 = 1;
pub const CONFIG_CC_HAS_SANCOV_TRACE_PC: u32 = 1;
pub const CONFIG_DEFAULT_INIT: &'static [u8; 1usize] = b"\0";
pub const CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_VM_PGTABLE: u32 = 1;
pub const CONFIG_INPUT_KEYBOARD: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_INT128: u32 = 1;
pub const CONFIG_SLUB_CPU_PARTIAL: u32 = 1;
pub const CONFIG_RFS_ACCEL: u32 = 1;
pub const CONFIG_IP_NF_TARGET_REDIRECT_MODULE: u32 = 1;
pub const CONFIG_DRM_LEGACY: u32 = 1;
pub const CONFIG_ARCH_WANTS_THP_SWAP: u32 = 1;
pub const CONFIG_CRC32: u32 = 1;
pub const CONFIG_I2C_BOARDINFO: u32 = 1;
pub const CONFIG_PNFS_FLEXFILE_LAYOUT: u32 = 1;
pub const CONFIG_DRM_NOUVEAU_MODULE: u32 = 1;
pub const CONFIG_PCI_ECAM: u32 = 1;
pub const CONFIG_SECCOMP: u32 = 1;
pub const CONFIG_HIGH_RES_TIMERS: u32 = 1;
pub const CONFIG_DT_IDLE_GENPD: u32 = 1;
pub const CONFIG_ARCH_HAS_SET_MEMORY: u32 = 1;
pub const CONFIG_CC_HAVE_STACKPROTECTOR_TLS: u32 = 1;
pub const CONFIG_BLK_DEV_DM_MODULE: u32 = 1;
pub const CONFIG_VLAN_8021Q_MODULE: u32 = 1;
pub const CONFIG_FLATMEM_MANUAL: u32 = 1;
pub const CONFIG_FIX_EARLYCON_MEM: u32 = 1;
pub const CONFIG_XZ_DEC_IA64: u32 = 1;
pub const CONFIG_INOTIFY_USER: u32 = 1;
pub const CONFIG_HDMI: u32 = 1;
pub const CONFIG_NETWORK_FILESYSTEMS: u32 = 1;
pub const CONFIG_SATA_AHCI_PLATFORM: u32 = 1;
pub const CONFIG_GLOB: u32 = 1;
pub const CONFIG_CGROUP_DEVICE: u32 = 1;
pub const CONFIG_MAC80211_STA_HASH_MAX_SIZE: u32 = 0;
pub const CONFIG_HAVE_ARCH_MMAP_RND_BITS: u32 = 1;
pub const CONFIG_EXT4_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_PHYLINK: u32 = 1;
pub const CONFIG_ZSTD_COMPRESS_MODULE: u32 = 1;
pub const CONFIG_SSB_POSSIBLE: u32 = 1;
pub const CONFIG_NFS_V4_2: u32 = 1;
pub const CONFIG_DRM_RADEON_MODULE: u32 = 1;
pub const CONFIG_IP_NF_NAT_MODULE: u32 = 1;
pub const CONFIG_USB_OHCI_LITTLE_ENDIAN: u32 = 1;
pub const CONFIG_NET_SCH_FIFO: u32 = 1;
pub const CONFIG_SWPHY: u32 = 1;
pub const CONFIG_FSNOTIFY: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP_MIN_COUNT: u32 = 8;
pub const CONFIG_STP_MODULE: u32 = 1;
pub const CONFIG_ARCH_FLATMEM_ENABLE: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER_DISABLE_TESTS: u32 = 1;
pub const CONFIG_GENERIC_SMP_IDLE_THREAD: u32 = 1;
pub const CONFIG_NET_VENDOR_QUALCOMM: u32 = 1;
pub const CONFIG_NET_VENDOR_EZCHIP: u32 = 1;
pub const CONFIG_DEFAULT_SECURITY_DAC: u32 = 1;
pub const CONFIG_LDISC_AUTOLOAD: u32 = 1;
pub const CONFIG_IP_VS_NFCT: u32 = 1;
pub const CONFIG_RT_GROUP_SCHED: u32 = 1;
pub const CONFIG_USB_AUTOSUSPEND_DELAY: u32 = 2;
pub const CONFIG_IP6_NF_MANGLE_MODULE: u32 = 1;
pub const CONFIG_HAVE_IRQ_TIME_ACCOUNTING: u32 = 1;
pub const CONFIG_IP_VS_RR_MODULE: u32 = 1;
pub const CONFIG_IPV6: u32 = 1;
pub const CONFIG_HAVE_STACKPROTECTOR: u32 = 1;
pub const CONFIG_NET_9P: u32 = 1;
pub const CONFIG_CRYPTO_AEAD: u32 = 1;
pub const CONFIG_COMPAT: u32 = 1;
pub const CONFIG_BQL: u32 = 1;
pub const CONFIG_DEFAULT_TCP_CONG: &'static [u8; 6usize] = b"cubic\0";
pub const CONFIG_USB_UAS: u32 = 1;
pub const CONFIG_DEVTMPFS: u32 = 1;
pub const CONFIG_OF_IOMMU: u32 = 1;
pub const CONFIG_PNFS_FILE_LAYOUT: u32 = 1;
pub const CONFIG_SUNRPC_BACKCHANNEL: u32 = 1;
pub const CONFIG_IP6_NF_TARGET_REJECT_MODULE: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX: u32 = 17;
pub const CONFIG_ARCH_SPARSEMEM_ENABLE: u32 = 1;
pub const CONFIG_NF_NAT_REDIRECT: u32 = 1;
pub const CONFIG_HOTPLUG_CPU: u32 = 1;
pub const CONFIG_WLAN: u32 = 1;
pub const CONFIG_NAMESPACES: u32 = 1;
pub const CONFIG_ARCH_USE_MEMREMAP_PROT: u32 = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY: u32 = 1;
pub const CONFIG_BLK_DEV_BSG: u32 = 1;
pub const CONFIG_INTEGRITY: u32 = 1;
pub const CONFIG_DEBUG_RT_MUTEXES: u32 = 1;
pub const CONFIG_LEGACY_PTYS: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_MENU_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_RNG2: u32 = 1;
pub const CONFIG_MSDOS_FS: u32 = 1;
pub const CONFIG_NET_CLS_CGROUP_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MICROCHIP: u32 = 1;
pub const CONFIG_NET_VENDOR_DAVICOM: u32 = 1;
pub const CONFIG_PAGE_SIZE_LESS_THAN_256KB: u32 = 1;
pub const CONFIG_GENERIC_PINCTRL_GROUPS: u32 = 1;
pub const CONFIG_OF_RESERVED_MEM: u32 = 1;
pub const CONFIG_SERIAL_8250: u32 = 1;
pub const CONFIG_RANDOM_TRUST_CPU: u32 = 1;
pub const CONFIG_LZO_DECOMPRESS: u32 = 1;
pub const CONFIG_IOMMU_SUPPORT: u32 = 1;
pub const CONFIG_WLAN_VENDOR_CISCO: u32 = 1;
pub const CONFIG_COMPAT_BINFMT_ELF: u32 = 1;
pub const CONFIG_RD_LZMA: u32 = 1;
pub const CONFIG_USB: u32 = 1;
pub const CONFIG_MODULES_USE_ELF_RELA: u32 = 1;
pub const CONFIG_CRYPTO_HMAC_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_ETHERNET: u32 = 1;
pub const CONFIG_CRC_ITU_T: u32 = 1;
pub const CONFIG_HAVE_DMA_CONTIGUOUS: u32 = 1;
pub const CONFIG_DQL: u32 = 1;
pub const CONFIG_VXLAN_MODULE: u32 = 1;
pub const CONFIG_FRAMEBUFFER_CONSOLE: u32 = 1;
pub const CONFIG_SOCK_CGROUP_DATA: u32 = 1;
pub const CONFIG_COREDUMP: u32 = 1;
pub const CONFIG_BCMA_POSSIBLE: u32 = 1;
pub const CONFIG_NF_LOG_IPV4_MODULE: u32 = 1;
pub const CONFIG_VGA_ARB: u32 = 1;
pub const CONFIG_SATA_HOST: u32 = 1;
pub const CONFIG_SCSI_COMMON: u32 = 1;
pub const CONFIG_DRM_NOMODESET: u32 = 1;
pub const CONFIG_PRINTK: u32 = 1;
pub const CONFIG_FB_SYS_FILLRECT_MODULE: u32 = 1;
pub const CONFIG_TIMERFD: u32 = 1;
pub const CONFIG_DNS_RESOLVER: u32 = 1;
pub const CONFIG_CRYPTO_AUTHENC_MODULE: u32 = 1;
pub const CONFIG_RISCV_ISA_C: u32 = 1;
pub const CONFIG_COMPAT_32BIT_TIME: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_HASH: u32 = 1;
pub const CONFIG_SHMEM: u32 = 1;
pub const CONFIG_MIGRATION: u32 = 1;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL: u32 = 1;
pub const CONFIG_BUILD_SALT: &'static [u8; 1usize] = b"\0";
pub const CONFIG_MMC_BLOCK_MINORS: u32 = 8;
pub const CONFIG_DECOMPRESS_LZMA: u32 = 1;
pub const CONFIG_DEVTMPFS_MOUNT: u32 = 1;
pub const CONFIG_DNOTIFY: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV: u32 = 1;
pub const CONFIG_GENERIC_NET_UTILS: u32 = 1;
pub const CONFIG_ATA: u32 = 1;
pub const CONFIG_GPIOLIB_FASTPATH_LIMIT: u32 = 512;
pub const CONFIG_NLS_CODEPAGE_437: u32 = 1;
pub const CONFIG_EXPORTFS: u32 = 1;
pub const CONFIG_NET_INGRESS: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_ERROR_INJECTION: u32 = 1;
pub const CONFIG_SERIO: u32 = 1;
pub const CONFIG_INPUT_MOUSE: u32 = 1;
pub const CONFIG_FB_SYS_IMAGEBLIT_MODULE: u32 = 1;
pub const CONFIG_SUNRPC_GSS: u32 = 1;
pub const CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS: u32 = 1;
pub const CONFIG_KCMP: u32 = 1;
pub const CONFIG_RTC_INTF_SYSFS: u32 = 1;
pub const CONFIG_BLK_DEV_INITRD: u32 = 1;
pub const CONFIG_DM_BUFIO_MODULE: u32 = 1;
pub const CONFIG_PCPU_DEV_REFCNT: u32 = 1;
pub const CONFIG_DRM_VIRTIO_GPU_MODULE: u32 = 1;
pub const CONFIG_NF_CT_PROTO_DCCP: u32 = 1;
pub const CONFIG_ZLIB_INFLATE: u32 = 1;
pub const CONFIG_NET_VENDOR_SYNOPSYS: u32 = 1;
pub const CONFIG_HWMON: u32 = 1;
pub const CONFIG_NET_VENDOR_DLINK: u32 = 1;
pub const CONFIG_AUDITSYSCALL: u32 = 1;
pub const CONFIG_IP_PNP: u32 = 1;
pub const CONFIG_RISCV_SBI: u32 = 1;
pub const CONFIG_RTC_INTF_PROC: u32 = 1;
pub const CONFIG_PM_CLK: u32 = 1;
pub const CONFIG_CC_IMPLICIT_FALLTHROUGH: &'static [u8; 25usize] = b"-Wimplicit-fallthrough=5\0";
pub const CONFIG_CPU_IDLE_GOV_MENU: u32 = 1;
pub const CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR: u32 = 1;
pub const CONFIG_STACKTRACE_SUPPORT: u32 = 1;
pub const CONFIG_RESET_CONTROLLER: u32 = 1;
pub const CONFIG_LOCKD: u32 = 1;
pub const CONFIG_PCIE_DW_HOST: u32 = 1;
pub const CONFIG_CRYPTO_LIB_AES_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RALINK: u32 = 1;
pub const CONFIG_CRYPTO_KPP2: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROCHIP: u32 = 1;
pub const CONFIG_PCI_HOST_GENERIC: u32 = 1;
pub const CONFIG_NET_UDP_TUNNEL_MODULE: u32 = 1;
pub const CONFIG_NO_HZ_IDLE: u32 = 1;
pub const CONFIG_NET_VENDOR_ADAPTEC: u32 = 1;
pub const CONFIG_MOUSE_PS2_BYD: u32 = 1;
pub const CONFIG_SOCK_RX_QUEUE_MAPPING: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_HMAC: u32 = 1;
pub const CONFIG_DRM_BRIDGE: u32 = 1;
pub const CONFIG_NET_VENDOR_SILAN: u32 = 1;
pub const CONFIG_RISCV_TIMER: u32 = 1;
pub const CONFIG_USB_STORAGE: u32 = 1;
pub const CONFIG_NET_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_FPU: u32 = 1;
pub const CONFIG_STANDALONE: u32 = 1;
pub const CONFIG_EFI: u32 = 1;
pub const CONFIG_RATIONAL: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTEL: u32 = 1;
pub const CONFIG_GENERIC_EARLY_IOREMAP: u32 = 1;
pub const CONFIG_NET_VENDOR_WANGXUN: u32 = 1;
pub const CONFIG_NET_L3_MASTER_DEV: u32 = 1;
pub const CONFIG_VMAP_STACK: u32 = 1;
pub const CONFIG_BLOCK: u32 = 1;
pub const CONFIG_ARCH_STACKWALK: u32 = 1;
pub const CONFIG_INIT_ENV_ARG_LIMIT: u32 = 32;
pub const CONFIG_ROOT_NFS: u32 = 1;
pub const CONFIG_NOUVEAU_LEGACY_CTX_SUPPORT: u32 = 1;
pub const CONFIG_AF_UNIX_OOB: u32 = 1;
pub const CONFIG_USER_NS: u32 = 1;
pub const CONFIG_TMPFS_POSIX_ACL: u32 = 1;
pub const CONFIG_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_NETLINK_DIAG: u32 = 1;
pub const CONFIG_BUG: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_WX: u32 = 1;
pub const CONFIG_PCIE_XILINX: u32 = 1;
pub const CONFIG_PM: u32 = 1;
pub const CONFIG_NETFILTER_XTABLES_COMPAT: u32 = 1;
pub const CONFIG_MEMCG: u32 = 1;
pub const CONFIG_SPI: u32 = 1;
pub const CONFIG_RTC_SYSTOHC_DEVICE: &'static [u8; 5usize] = b"rtc0\0";
pub const CONFIG_NOUVEAU_DEBUG_DEFAULT: u32 = 3;
pub const CONFIG_OF_IRQ: u32 = 1;
pub const CONFIG_LIBFDT: u32 = 1;
pub const CONFIG_NET_FAILOVER: u32 = 1;
pub const CONFIG_WLAN_VENDOR_PURELIFI: u32 = 1;
pub const CONFIG_IO_URING: u32 = 1;
pub const CONFIG_VT: u32 = 1;
pub const CONFIG_SECRETMEM: u32 = 1;
pub const CONFIG_DTC: u32 = 1;
pub const CONFIG_MACB: u32 = 1;
pub const CONFIG_SPLIT_PTLOCK_CPUS: u32 = 4;
pub const CONFIG_SBITMAP: u32 = 1;
pub const CONFIG_MCHP_CLK_MPFS: u32 = 1;
pub const CONFIG_POWER_SUPPLY: u32 = 1;
pub const CONFIG_DM_PERSISTENT_DATA_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_SKCIPHER2: u32 = 1;
pub const CONFIG_NLS: u32 = 1;
pub const CONFIG_AS_IS_GNU: u32 = 1;
pub const CONFIG_MICROSEMI_PHY: u32 = 1;
pub const CONFIG_CGROUP_BPF: u32 = 1;
pub const CONFIG_IRQ_WORK: u32 = 1;
pub const CONFIG_PCI_MSI: u32 = 1;
pub const CONFIG_IP_ADVANCED_ROUTER: u32 = 1;
pub const CONFIG_FB_SYS_COPYAREA_MODULE: u32 = 1;
pub const CONFIG_USB_EHCI_PCI: u32 = 1;
pub const CONFIG_USB_COMMON: u32 = 1;
pub const CONFIG_DRM_DISPLAY_HDMI_HELPER: u32 = 1;
pub const CONFIG_IP6_NF_IPTABLES_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_ANCHOR: u32 = 1;
pub const CONFIG_DEBUG_INFO_NONE: u32 = 1;
pub const CONFIG_FIXED_PHY: u32 = 1;
pub const CONFIG_SOC_SIFIVE: u32 = 1;
pub const CONFIG_LOG_CPU_MAX_BUF_SHIFT: u32 = 12;
pub const CONFIG_BLK_DEV_DM_BUILTIN: u32 = 1;
pub const CONFIG_VGA_ARB_MAX_GPUS: u32 = 16;
pub const CONFIG_GENERIC_PINCONF: u32 = 1;
pub const CONFIG_DEBUG_SG: u32 = 1;
pub const CONFIG_NFS_V4_2_SSC_HELPER: u32 = 1;
pub const CONFIG_ARCH_HAS_BINFMT_FLAT: u32 = 1;
pub const CONFIG_SG_POOL: u32 = 1;
pub const CONFIG_DRM_KMS_HELPER_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_PACKET_ENGINES: u32 = 1;
pub const CONFIG_BLK_MQ_PCI: u32 = 1;
pub const CONFIG_RISCV_PMU_LEGACY: u32 = 1;
pub const CONFIG_NLS_ISO8859_1_MODULE: u32 = 1;
pub const CONFIG_R8169: u32 = 1;
pub const CONFIG_USB_EHCI_HCD: u32 = 1;
pub const CONFIG_FS_IOMAP: u32 = 1;
pub const CONFIG_COMPACT_UNEVICTABLE_DEFAULT: u32 = 1;
pub const CONFIG_RD_ZSTD: u32 = 1;
pub const CONFIG_NETDEVICES: u32 = 1;
pub const CONFIG_ARCH_HAS_KCOV: u32 = 1;
pub const CONFIG_CGROUP_FREEZER: u32 = 1;
pub const CONFIG_EVENTFD: u32 = 1;
pub const CONFIG_DEBUG_RWSEMS: u32 = 1;
pub const CONFIG_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_IPV6_SIT: u32 = 1;
pub const CONFIG_XFRM: u32 = 1;
pub const CONFIG_HAVE_KPROBES_ON_FTRACE: u32 = 1;
pub const CONFIG_SERIAL_8250_CONSOLE: u32 = 1;
pub const CONFIG_JUMP_LABEL: u32 = 1;
pub const CONFIG_OVERLAY_FS_MODULE: u32 = 1;
pub const CONFIG_IP_NF_TARGET_MASQUERADE_MODULE: u32 = 1;
pub const CONFIG_HAVE_EBPF_JIT: u32 = 1;
pub const CONFIG_PROC_PAGE_MONITOR: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_MASQUERADE_MODULE: u32 = 1;
pub const CONFIG_BPF: u32 = 1;
pub const CONFIG_RD_LZO: u32 = 1;
pub const CONFIG_CRYPTO_SHA512_MODULE: u32 = 1;
pub const CONFIG_BACKLIGHT_CLASS_DEVICE_MODULE: u32 = 1;
pub const CONFIG_CC_HAS_ASM_INLINE: u32 = 1;
pub const CONFIG_CRYPTO_NULL_MODULE: u32 = 1;
pub const CONFIG_GPIO_CDEV_V1: u32 = 1;
pub const CONFIG_NET_VENDOR_SEEQ: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV4_MODULE: u32 = 1;
pub const CONFIG_SELECT_MEMORY_MODEL: u32 = 1;
pub const CONFIG_VIRTIO_CONSOLE: u32 = 1;
pub const CONFIG_ARCH_CLOCKSOURCE_INIT: u32 = 1;
pub const CONFIG_NETFILTER_ADVANCED: u32 = 1;
pub const CONFIG_GENERIC_STRNLEN_USER: u32 = 1;
pub const CONFIG_RPMSG_VIRTIO: u32 = 1;
pub const CONFIG_WLAN_VENDOR_RSI: u32 = 1;
pub const CONFIG_CRYPTO_JITTERENTROPY_MODULE: u32 = 1;
pub const CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION: u32 = 1;
pub const CONFIG_CRYPTO_GCM_MODULE: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE: u32 = 1;
pub const CONFIG_CDROM: u32 = 1;
pub const CONFIG_PNFS_BLOCK_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_RDC: u32 = 1;
pub const CONFIG_PGTABLE_LEVELS: u32 = 5;
pub const CONFIG_POWER_RESET_SYSCON: u32 = 1;
pub const CONFIG_CPUSETS: u32 = 1;
pub const CONFIG_SPARSE_IRQ: u32 = 1;
pub const CONFIG_IP_NF_MANGLE_MODULE: u32 = 1;
pub const CONFIG_DT_IDLE_STATES: u32 = 1;
pub const CONFIG_SECURITYFS: u32 = 1;
pub const CONFIG_RCU_STALL_COMMON: u32 = 1;
pub const CONFIG_PCIEPORTBUS: u32 = 1;
pub const CONFIG_DEBUG_BUGVERBOSE: u32 = 1;
pub const CONFIG_EFI_GENERIC_STUB: u32 = 1;
pub const CONFIG_IP_NF_FILTER_MODULE: u32 = 1;
pub const CONFIG_MODULES_TREE_LOOKUP: u32 = 1;
pub const CONFIG_FAT_FS: u32 = 1;
pub const CONFIG_BUILDTIME_TABLE_SORT: u32 = 1;
pub const CONFIG_NVMEM: u32 = 1;
pub const CONFIG_INET_TUNNEL: u32 = 1;
pub const CONFIG_NF_LOG_ARP_MODULE: u32 = 1;
pub const CONFIG_NET_9P_VIRTIO: u32 = 1;
pub const CONFIG_PINCONF: u32 = 1;
pub const CONFIG_BLOCK_HOLDER_DEPRECATED: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS: u32 = 1;
pub const CONFIG_OID_REGISTRY: u32 = 1;
pub const CONFIG_RUSTC_VERSION_TEXT: &'static [u8; 36usize] =
    b"rustc 1.66.0 (69f9c33d7 2022-12-12)\0";
pub const CONFIG_GCC12_NO_ARRAY_BOUNDS: u32 = 1;
pub const CONFIG_CONSOLE_TRANSLATIONS: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_ATOMIC_RMW: u32 = 1;
pub const CONFIG_GENERIC_LIB_DEVMEM_IS_ALLOWED: u32 = 1;
pub const CONFIG_RAID6_PQ_MODULE: u32 = 1;
pub const CONFIG_SERIAL_EARLYCON: u32 = 1;
pub const CONFIG_NET_VENDOR_NI: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER: u32 = 1;
pub const CONFIG_MMIOWB: u32 = 1;
pub const CONFIG_ETHTOOL_NETLINK: u32 = 1;
pub const CONFIG_USB_OHCI_HCD: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE: u32 = 1;
pub const CONFIG_USB_PCI: u32 = 1;
pub const CONFIG_NF_REJECT_IPV4_MODULE: u32 = 1;
pub const CONFIG_GENERIC_IOREMAP: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MAX: u32 = 24;
pub const CONFIG_GPIO_SIFIVE: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE: u32 = 1;
pub const CONFIG_TRACE_IRQFLAGS_SUPPORT: u32 = 1;
pub const CONFIG_MFD_SYSCON: u32 = 1;
pub const CONFIG_DETECT_HUNG_TASK: u32 = 1;
pub const CONFIG_PCIE_BUS_DEFAULT: u32 = 1;
pub const CONFIG_CRYPTO_RNG_MODULE: u32 = 1;
pub const CONFIG_DRM_TTM_HELPER_MODULE: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN: u32 = 8;
pub const CONFIG_CRYPTO_LIB_UTILS: u32 = 1;
pub const CONFIG_RD_GZIP: u32 = 1;
pub const CONFIG_HAVE_REGS_AND_STACK_ACCESS_API: u32 = 1;
pub const CONFIG_BLK_PM: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_PARANOID_LOAD: u32 = 1;
pub const CONFIG_MDIO_BUS: u32 = 1;
pub const CONFIG_TREE_RCU: u32 = 1;
pub const CONFIG_ALLOW_DEV_COREDUMP: u32 = 1;
pub const CONFIG_SWIOTLB: u32 = 1;
pub const CONFIG_EXT4_FS_SECURITY: u32 = 1;
pub const CONFIG_GRO_CELLS: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_HASH_DEFAULT: u32 = 1;
pub const CONFIG_RISCV_INTC: u32 = 1;
pub const CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN: u32 = 1;
pub const CONFIG_PCI_MSI_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_NET_VENDOR_CORTINA: u32 = 1;
pub const CONFIG_ELFCORE: u32 = 1;
pub const CONFIG_WQ_WATCHDOG: u32 = 1;
pub const CONFIG_INIT_STACK_NONE: u32 = 1;
pub const CONFIG_BINFMT_ELF: u32 = 1;
pub const CONFIG_AUDIT_GENERIC: u32 = 1;
pub const CONFIG_SOC_MICROCHIP_POLARFIRE: u32 = 1;
pub const CONFIG_SCSI_PROC_FS: u32 = 1;
pub const CONFIG_HAVE_PERF_REGS: u32 = 1;
pub const CONFIG_NFS_V4_SECURITY_LABEL: u32 = 1;
pub const CONFIG_NET_VENDOR_ALTEON: u32 = 1;
pub const CONFIG_NET_VENDOR_RENESAS: u32 = 1;
pub const CONFIG_KEYS: u32 = 1;
pub const CONFIG_DEBUG_MUTEXES: u32 = 1;
pub const CONFIG_NETFILTER_XT_MARK_MODULE: u32 = 1;
pub const CONFIG_NETFILTER_XTABLES_MODULE: u32 = 1;
pub const CONFIG_DRM_PANEL_ORIENTATION_QUIRKS_MODULE: u32 = 1;
pub const CONFIG_SOFTLOCKUP_DETECTOR: u32 = 1;
pub const CONFIG_CRYPTO_ECHAINIV_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_AUDITSYSCALL: u32 = 1;
pub const CONFIG_RTC_DRV_GOLDFISH: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_HASH: u32 = 1;
pub const CONFIG_CRYPTO_HW: u32 = 1;
pub const CONFIG_CLK_ANALOGBITS_WRPLL_CLN28HPC: u32 = 1;
pub const CONFIG_HARDIRQS_SW_RESEND: u32 = 1;
pub const CONFIG_SPI_MASTER: u32 = 1;
pub const CONFIG_VT_HW_CONSOLE_BINDING: u32 = 1;
pub const CONFIG_CRYPTO_SKCIPHER: u32 = 1;
pub const CONFIG_XZ_DEC_X86: u32 = 1;
pub const CONFIG_SERIAL_OF_PLATFORM: u32 = 1;
pub const CONFIG_CONSOLE_LOGLEVEL_QUIET: u32 = 4;
pub const CONFIG_NVME_CORE_MODULE: u32 = 1;
pub const CONFIG_CRC16: u32 = 1;
pub const CONFIG_GENERIC_CALIBRATE_DELAY: u32 = 1;
pub const CONFIG_CRYPTO_GF128MUL_MODULE: u32 = 1;
pub const CONFIG_NET_CLS: u32 = 1;
pub const CONFIG_TMPFS: u32 = 1;
pub const CONFIG_NET_VENDOR_NETERION: u32 = 1;
pub const CONFIG_RANDSTRUCT_NONE: u32 = 1;
pub const CONFIG_USB_OHCI_HCD_PLATFORM: u32 = 1;
pub const CONFIG_FUTEX: u32 = 1;
pub const CONFIG_IP_VS_MH_TAB_INDEX: u32 = 12;
pub const CONFIG_IP_PNP_DHCP: u32 = 1;
pub const CONFIG_VIRTIO_PCI: u32 = 1;
pub const CONFIG_UNIX_SCM: u32 = 1;
pub const CONFIG_MMC_SPI: u32 = 1;
pub const CONFIG_CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const CONFIG_GENERIC_SCHED_CLOCK: u32 = 1;
pub const CONFIG_NET_VENDOR_REALTEK: u32 = 1;
pub const CONFIG_CRYPTO_USER_API: u32 = 1;
pub const CONFIG_RTC_HCTOSYS: u32 = 1;
pub const CONFIG_SECURITY_NETWORK: u32 = 1;
pub const CONFIG_SERIAL_CORE_CONSOLE: u32 = 1;
pub const CONFIG_HUGETLB_PAGE: u32 = 1;
pub const CONFIG_NET_VENDOR_EMULEX: u32 = 1;
pub const CONFIG_USB_HID: u32 = 1;
pub const CONFIG_SLUB_DEBUG: u32 = 1;
pub const CONFIG_UCS2_STRING: u32 = 1;
pub const CONFIG_PAHOLE_VERSION: u32 = 0;
pub const CONFIG_PINCTRL: u32 = 1;
pub const CONFIG_IPV6_NDISC_NODETYPE: u32 = 1;
pub const CONFIG_CGROUP_SCHED: u32 = 1;
pub const CONFIG_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_SYSVIPC: u32 = 1;
pub const CONFIG_RAID6_PQ_BENCHMARK: u32 = 1;
pub const CONFIG_ARCH_HAS_GIGANTIC_PAGE: u32 = 1;
pub const CONFIG_HAVE_DEBUG_KMEMLEAK: u32 = 1;
pub const CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT: u32 = 13;
pub const CONFIG_NF_CONNTRACK_FTP_MODULE: u32 = 1;
pub const CONFIG_PAGE_SIZE_LESS_THAN_64KB: u32 = 1;
pub const CONFIG_MODULES: u32 = 1;
pub const CONFIG_RPMSG: u32 = 1;
pub const CONFIG_DEBUG_PER_CPU_MAPS: u32 = 1;
pub const CONFIG_CONTEXT_TRACKING: u32 = 1;
pub const CONFIG_MQ_IOSCHED_DEADLINE: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE_COLUMNS: u32 = 80;
pub const CONFIG_XXHASH: u32 = 1;
pub const CONFIG_JOLIET: u32 = 1;
pub const CONFIG_CPU_IDLE_MULTIPLE_DRIVERS: u32 = 1;
pub const CONFIG_PROC_CHILDREN: u32 = 1;
pub const CONFIG_UNIX: u32 = 1;
pub const CONFIG_USB_NET_DRIVERS: u32 = 1;
pub const CONFIG_CC_CAN_LINK: u32 = 1;
pub const CONFIG_LD_IS_BFD: u32 = 1;
pub const CONFIG_NO_HZ_COMMON: u32 = 1;
pub const CONFIG_HAVE_CLK: u32 = 1;
pub const CONFIG_CRYPTO_HASH2: u32 = 1;
pub const CONFIG_NET_VENDOR_VERTEXCOM: u32 = 1;
pub const CONFIG_DEFAULT_HOSTNAME: &'static [u8; 7usize] = b"(none)\0";
pub const CONFIG_SRCU: u32 = 1;
pub const CONFIG_CC_HAS_NO_PROFILE_FN_ATTR: u32 = 1;
pub const CONFIG_NFS_FS: u32 = 1;
pub const CONFIG_MEMBARRIER: u32 = 1;
pub const CONFIG_XPS: u32 = 1;
pub const CONFIG_INET_ESP_MODULE: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_DEVELOP: u32 = 1;
pub const CONFIG_SGL_ALLOC: u32 = 1;
pub const CONFIG_LZ4_DECOMPRESS: u32 = 1;
pub const CONFIG_FONT_SUPPORT: u32 = 1;
pub const CONFIG_ADVISE_SYSCALLS: u32 = 1;
pub const CONFIG_MD: u32 = 1;
pub const CONFIG_CRYPTO_ALGAPI: u32 = 1;
pub const CONFIG_GENERIC_IRQ_SHOW_LEVEL: u32 = 1;
pub const CONFIG_NET_VENDOR_WIZNET: u32 = 1;
pub const CONFIG_BRIDGE_MODULE: u32 = 1;
pub const CONFIG_RD_BZIP2: u32 = 1;
pub const CONFIG_SKB_EXTENSIONS: u32 = 1;
pub const CONFIG_GPIO_CDEV: u32 = 1;
pub const CONFIG_CC_VERSION_TEXT: &'static [u8; 60usize] =
    b"riscv64-linux-gnu-gcc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0\0";
pub const CONFIG_KEYBOARD_ATKBD: u32 = 1;
pub const CONFIG_NET_IP_TUNNEL: u32 = 1;
pub const CONFIG_NF_NAT_MODULE: u32 = 1;
pub const CONFIG_BLOCK_LEGACY_AUTOLOAD: u32 = 1;
pub const CONFIG_NET_VENDOR_OKI: u32 = 1;
pub const CONFIG_CPU_IDLE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_INTERSIL: u32 = 1;
pub const CONFIG_NFS_COMMON: u32 = 1;
pub const CONFIG_FAIR_GROUP_SCHED: u32 = 1;
pub const CONFIG_CRYPTO_HASH: u32 = 1;
pub const CONFIG_EFI_PARTITION: u32 = 1;
pub const CONFIG_GOLDFISH: u32 = 1;
pub const CONFIG_LOG_BUF_SHIFT: u32 = 17;
pub const CONFIG_WLAN_VENDOR_ATH: u32 = 1;
pub const CONFIG_EXTRA_FIRMWARE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_NET_VENDOR_8390: u32 = 1;
pub const CONFIG_HAVE_KCSAN_COMPILER: u32 = 1;
pub const CONFIG_VFAT_FS: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE: u32 = 0;
pub const CONFIG_PID_NS: u32 = 1;
pub const CONFIG_CRC32_SLICEBY8: u32 = 1;
pub const CONFIG_EFI_PARAMS_FROM_FDT: u32 = 1;
pub const CONFIG_BLK_DEV_SR: u32 = 1;
pub const CONFIG_CPU_RMAP: u32 = 1;
pub const CONFIG_BLK_DEV_LOOP: u32 = 1;
pub const CONFIG_DEFAULT_HUNG_TASK_TIMEOUT: u32 = 120;
pub const CONFIG_VIRTIO_PCI_LEGACY: u32 = 1;
pub const CONFIG_RUST_IS_AVAILABLE: u32 = 1;
pub const CONFIG_E1000E: u32 = 1;
pub const CONFIG_INPUT_VIVALDIFMAP: u32 = 1;
pub const CONFIG_MULTIUSER: u32 = 1;
pub const CONFIG_GENERIC_VDSO_TIME_NS: u32 = 1;
pub const CONFIG_CROSS_MEMORY_ATTACH: u32 = 1;
pub const CONFIG_CRYPTO_CBC_MODULE: u32 = 1;
pub const CONFIG_SERIAL_8250_RUNTIME_UARTS: u32 = 4;
pub const CONFIG_CLANG_VERSION: u32 = 0;
pub const CONFIG_FS_MBCACHE: u32 = 1;
pub const CONFIG_RTC_CLASS: u32 = 1;
pub const CONFIG_CRC7: u32 = 1;
pub const CONFIG_CRYPTO_RNG_DEFAULT_MODULE: u32 = 1;
pub const CONFIG_TMPFS_XATTR: u32 = 1;
pub const CONFIG_EXT4_USE_FOR_EXT2: u32 = 1;
pub const CONFIG_CPU_PM: u32 = 1;
pub const CONFIG_TIMER_OF: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_TRACER: u32 = 1;
pub const CONFIG_CPU_ISOLATION: u32 = 1;
pub const CONFIG_NF_NAT_TFTP_MODULE: u32 = 1;
pub const CONFIG_DRM_DISPLAY_DP_HELPER: u32 = 1;
pub const CONFIG_ARCH_SELECT_MEMORY_MODEL: u32 = 1;
pub const CONFIG_NETFILTER_XT_TARGET_REDIRECT_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER2: u32 = 1;
pub const CONFIG_SERIAL_8250_DEPRECATED_OPTIONS: u32 = 1;
pub const CONFIG_ARCH_HAS_PTE_SPECIAL: u32 = 1;
pub const CONFIG_NET_VENDOR_MYRI: u32 = 1;
pub const CONFIG_NF_NAT_MASQUERADE: u32 = 1;
pub const CONFIG_PM_GENERIC_DOMAINS_OF: u32 = 1;
pub const CONFIG_DEBUG_VM_PGTABLE: u32 = 1;
pub const CONFIG_CLZ_TAB: u32 = 1;
pub const CONFIG_GENERIC_PCI_IOMAP: u32 = 1;
pub const CONFIG_SLUB: u32 = 1;
pub const CONFIG_XZ_DEC_BCJ: u32 = 1;
pub const CONFIG_I2C_MODULE: u32 = 1;
pub const CONFIG_DEBUG_VM: u32 = 1;
pub const CONFIG_RISCV_ISA_SVPBMT: u32 = 1;
pub const CONFIG_BINFMT_SCRIPT: u32 = 1;
pub const CONFIG_EFI_STUB: u32 = 1;
pub const CONFIG_MOUSE_PS2_CYPRESS: u32 = 1;
pub const CONFIG_FRAME_POINTER: u32 = 1;
pub const CONFIG_MOUSE_PS2_LOGIPS2PP: u32 = 1;
pub const CONFIG_TICK_CPU_ACCOUNTING: u32 = 1;
pub const CONFIG_VM_EVENT_COUNTERS: u32 = 1;
pub const CONFIG_SCHED_STACK_END_CHECK: u32 = 1;
pub const CONFIG_WLAN_VENDOR_BROADCOM: u32 = 1;
pub const CONFIG_DEBUG_FS: u32 = 1;
pub const CONFIG_NET_VENDOR_AMD: u32 = 1;
pub const CONFIG_DRM_TTM_MODULE: u32 = 1;
pub const CONFIG_BASE_FULL: u32 = 1;
pub const CONFIG_FB_CFB_IMAGEBLIT_MODULE: u32 = 1;
pub const CONFIG_ZLIB_DEFLATE: u32 = 1;
pub const CONFIG_SUNRPC: u32 = 1;
pub const CONFIG_RPMSG_NS: u32 = 1;
pub const CONFIG_RSEQ: u32 = 1;
pub const CONFIG_FW_LOADER: u32 = 1;
pub const CONFIG_KALLSYMS: u32 = 1;
pub const CONFIG_COMMON_CLK: u32 = 1;
pub const CONFIG_STACKPROTECTOR_STRONG: u32 = 1;
pub const CONFIG_PCI: u32 = 1;
pub const CONFIG_RTC_HCTOSYS_DEVICE: &'static [u8; 5usize] = b"rtc0\0";
pub const CONFIG_NET_VENDOR_FUNGIBLE: u32 = 1;
pub const CONFIG_NET_VENDOR_ASIX: u32 = 1;
pub const CONFIG_DECOMPRESS_XZ: u32 = 1;
pub const CONFIG_PCI_QUIRKS: u32 = 1;
pub const CONFIG_SIGNALFD: u32 = 1;
pub const CONFIG_NET_CORE: u32 = 1;
pub const CONFIG_MOUSE_PS2_ALPS: u32 = 1;
pub const CONFIG_EXT4_FS: u32 = 1;
pub const CONFIG_MEMORY_BALLOON: u32 = 1;
pub const CONFIG_UNINLINE_SPIN_UNLOCK: u32 = 1;
pub const CONFIG_CRYPTO_SHA1: u32 = 1;
pub const CONFIG_ARCH_WANT_GENERAL_HUGETLB: u32 = 1;
pub const CONFIG_SATA_PMP: u32 = 1;
pub const CONFIG_XZ_DEC: u32 = 1;
pub const CONFIG_NET_VENDOR_TI: u32 = 1;
pub const CONFIG_LOCKD_V4: u32 = 1;
pub const CONFIG_DUMMY_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_ALACRITECH: u32 = 1;
pub const CONFIG_TUNE_GENERIC: u32 = 1;
pub const CONFIG_HAS_IOMEM: u32 = 1;
pub const CONFIG_NF_LOG_IPV6_MODULE: u32 = 1;
pub const CONFIG_PINCTRL_STARFIVE_JH7100: u32 = 1;
pub const CONFIG_CRYPTO_RSA: u32 = 1;
pub const CONFIG_PWRSEQ_EMMC: u32 = 1;
pub const CONFIG_HAVE_MOVE_PUD: u32 = 1;
pub const CONFIG_CRYPTO_ACOMP2: u32 = 1;
pub const CONFIG_HAVE_ARCH_KASAN_VMALLOC: u32 = 1;
pub const CONFIG_SCHED_HRTICK: u32 = 1;
pub const CONFIG_CONSTRUCTORS: u32 = 1;
pub const CONFIG_RESET_STARFIVE_JH7100: u32 = 1;
pub const CONFIG_EPOLL: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MULTI_HANDLER: u32 = 1;
pub const CONFIG_SATA_MOBILE_LPM_POLICY: u32 = 0;
pub const CONFIG_APERTURE_HELPERS: u32 = 1;
pub const CONFIG_FAILOVER: u32 = 1;
pub const CONFIG_CGROUP_HUGETLB: u32 = 1;
pub const CONFIG_RUST_OVERFLOW_CHECKS: u32 = 1;
pub const CONFIG_GENERIC_PTDUMP: u32 = 1;
pub const CONFIG_NET: u32 = 1;
pub const CONFIG_USB_OHCI_HCD_PCI: u32 = 1;
pub const CONFIG_SECURITY_PATH: u32 = 1;
pub const CONFIG_VIRTIO_DMA_SHARED_BUFFER_MODULE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_BLAKE2S_GENERIC: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_CONNTRACK_MODULE: u32 = 1;
pub const CONFIG_BLOCK_COMPAT: u32 = 1;
pub const CONFIG_RISCV_ALTERNATIVE: u32 = 1;
pub const CONFIG_PWRSEQ_SIMPLE: u32 = 1;
pub const CONFIG_PINMUX: u32 = 1;
pub const CONFIG_IRQ_DOMAIN_HIERARCHY: u32 = 1;
pub const CONFIG_ATA_FORCE: u32 = 1;
pub const CONFIG_MPILIB: u32 = 1;
pub const CONFIG_PACKET: u32 = 1;
pub const CONFIG_XFRM_ALGO_MODULE: u32 = 1;
pub const CONFIG_HAVE_CLK_PREPARE: u32 = 1;
pub const CONFIG_CRYPTO_AKCIPHER2: u32 = 1;
pub const CONFIG_BTRFS_FS_POSIX_ACL: u32 = 1;
pub const CONFIG_CLK_STARFIVE_JH7100: u32 = 1;
pub const CONFIG_DUMMY_CONSOLE_ROWS: u32 = 25;
pub const CONFIG_USB_XHCI_PLATFORM: u32 = 1;
pub const CONFIG_NF_CONNTRACK_TFTP_MODULE: u32 = 1;
pub const CONFIG_NFS_V3: u32 = 1;
pub const CONFIG_INET: u32 = 1;
pub const CONFIG_XZ_DEC_POWERPC: u32 = 1;
pub const CONFIG_IP_PNP_BOOTP: u32 = 1;
pub const CONFIG_VIRTIO_NET: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_ADDRTYPE_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_HUAWEI: u32 = 1;
pub const CONFIG_PREVENT_FIRMWARE_BUILD: u32 = 1;
pub const CONFIG_FREEZER: u32 = 1;
pub const CONFIG_PCI_DOMAINS: u32 = 1;
pub const CONFIG_NET_VENDOR_CHELSIO: u32 = 1;
pub const CONFIG_EFIVAR_FS_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_VMAP_STACK: u32 = 1;
pub const CONFIG_NETFILTER_XT_MATCH_IPVS_MODULE: u32 = 1;
pub const CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN: &'static [u8; 11usize] = b"kernel.org\0";
pub const CONFIG_RTC_LIB: u32 = 1;
pub const CONFIG_HAVE_KPROBES: u32 = 1;
pub const CONFIG_CRYPTO_AES_MODULE: u32 = 1;
pub const CONFIG_HAVE_GENERIC_VDSO: u32 = 1;
pub const CONFIG_GPIOLIB: u32 = 1;
pub const CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT: u32 = 1;
pub const CONFIG_FUTEX_PI: u32 = 1;
pub const CONFIG_DM_BIO_PRISON_MODULE: u32 = 1;
pub const CONFIG_AUTOFS_FS: u32 = 1;
pub const CONFIG_ISO9660_FS: u32 = 1;
pub const CONFIG_NETFILTER_XT_NAT_MODULE: u32 = 1;
pub const CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR: u32 = 1;
pub const CONFIG_NET_VENDOR_AQUANTIA: u32 = 1;
pub const CONFIG_SCSI_VIRTIO: u32 = 1;
pub const CONFIG_HVC_DRIVER: u32 = 1;
pub const CONFIG_NETFILTER: u32 = 1;
pub const CONFIG_HAVE_ARCH_KASAN: u32 = 1;
pub const CONFIG_NET_VENDOR_SMSC: u32 = 1;
pub const CONFIG_GENERIC_ARCH_TOPOLOGY: u32 = 1;
pub const CONFIG_NFS_DISABLE_UDP_SUPPORT: u32 = 1;
pub const CONFIG_SERIO_SERPORT: u32 = 1;
pub const CONFIG_CLONE_BACKWARDS: u32 = 1;
pub const CONFIG_RD_XZ: u32 = 1;
pub const CONFIG_AUXILIARY_BUS: u32 = 1;
pub const CONFIG_VGA_CONSOLE: u32 = 1;
pub const CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS: u32 = 1;
pub const CONFIG_ATA_VERBOSE_ERROR: u32 = 1;
pub const CONFIG_NET_FLOW_LIMIT: u32 = 1;
pub const CONFIG_LOCKDEP_SUPPORT: u32 = 1;
pub const CONFIG_RISCV_PMU: u32 = 1;
pub const CONFIG_ARCH_WANT_HUGE_PMD_SHARE: u32 = 1;
pub const CONFIG_DEBUG_ATOMIC_SLEEP: u32 = 1;
pub const CONFIG_POSIX_MQUEUE: u32 = 1;
pub const CONFIG_CC_HAS_WORKING_NOSANITIZE_ADDRESS: u32 = 1;
pub const CONFIG_NOUVEAU_DEBUG: u32 = 5;
pub const CONFIG_NETFILTER_INGRESS: u32 = 1;
pub const CONFIG_PCIE_FU740: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_SID2STR_CACHE_SIZE: u32 = 256;
pub const CONFIG_GENERIC_STRNCPY_FROM_USER: u32 = 1;
pub const CONFIG_HAVE_RSEQ: u32 = 1;
pub const CONFIG_OF_KOBJ: u32 = 1;
pub const CONFIG_CONTEXT_TRACKING_IDLE: u32 = 1;
pub const CONFIG_DEBUG_SPINLOCK: u32 = 1;
pub const CONFIG_NET_VENDOR_DEC: u32 = 1;
pub const CONFIG_AUTOFS4_FS: u32 = 1;
pub const CONFIG_GENERIC_GETTIMEOFDAY: u32 = 1;
pub const CONFIG_ARCH_USE_MEMTEST: u32 = 1;
pub const CONFIG_NET_VENDOR_PENSANDO: u32 = 1;
pub const CONFIG_IP6_NF_FILTER_MODULE: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV_SCREEN_X: u32 = 1024;
pub const CONFIG_EFI_ESRT: u32 = 1;
pub const CONFIG_NEED_DMA_MAP_STATE: u32 = 1;
pub const CONFIG_SERIO_LIBPS2: u32 = 1;
pub const CONFIG_IP_VS_PROTO_TCP: u32 = 1;
pub const CONFIG_SERIAL_SIFIVE_CONSOLE: u32 = 1;
pub const CONFIG_SOC_VIRT: u32 = 1;
pub const CONFIG_PAGE_OFFSET: i64 = -45035996273704960;
pub const CONFIG_FONT_8x8: u32 = 1;
pub const CONFIG_NET_VENDOR_ATHEROS: u32 = 1;
pub const CONFIG_XOR_BLOCKS_MODULE: u32 = 1;
pub const CONFIG_TIME_NS: u32 = 1;
pub const CONFIG_NET_VENDOR_SUN: u32 = 1;
pub const CONFIG_PANIC_TIMEOUT: u32 = 0;
pub const CONFIG_HAVE_ARCH_SECCOMP: u32 = 1;
pub const CONFIG_STACKDEPOT: u32 = 1;
pub const CONFIG_NET_VENDOR_XILINX: u32 = 1;
pub const CONFIG_DECOMPRESS_LZ4: u32 = 1;
pub const CONFIG_PREEMPT_NONE: u32 = 1;
pub const CONFIG_ERRATA_SIFIVE_CIP_453: u32 = 1;
pub const CONFIG_BPF_SYSCALL: u32 = 1;
pub const CONFIG_SMP: u32 = 1;
pub const CONFIG_NET_VENDOR_CADENCE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROSOFT: u32 = 1;
pub const CONFIG_TTY: u32 = 1;
pub const CONFIG_IP_VS_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_I825XX: u32 = 1;
pub const CONFIG_RCU_EXP_CPU_STALL_TIMEOUT: u32 = 0;
pub const CONFIG_GENERIC_ALLOCATOR: u32 = 1;
pub const CONFIG_LIBCRC32C_MODULE: u32 = 1;
pub const CONFIG_GENERIC_BUG: u32 = 1;
pub const CONFIG_CRYPTO_SHA256_MODULE: u32 = 1;
pub const CONFIG_HAVE_FTRACE_MCOUNT_RECORD: u32 = 1;
pub const CONFIG_BRIDGE_VLAN_FILTERING: u32 = 1;
pub const CONFIG_POSIX_TIMERS: u32 = 1;
pub const CONFIG_INET_TCP_DIAG: u32 = 1;
pub const CONFIG_HW_CONSOLE: u32 = 1;
pub const CONFIG_DEVMEM: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_INTROSPECT_POLICY: u32 = 1;
pub const CONFIG_MOUSE_PS2_FOCALTECH: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA1: u32 = 1;
pub const CONFIG_SOC_STARFIVE: u32 = 1;
pub const CONFIG_DM_THIN_PROVISIONING_MODULE: u32 = 1;
pub const CONFIG_PREEMPT_NONE_BUILD: u32 = 1;
pub const CONFIG_RTC_NVMEM: u32 = 1;
pub const CONFIG_ZSTD_COMMON: u32 = 1;
pub const CONFIG_CC_HAS_KASAN_GENERIC: u32 = 1;
pub const CONFIG_POWER_RESET_SYSCON_POWEROFF: u32 = 1;
pub const CONFIG_DEBUG_KERNEL: u32 = 1;
pub const CONFIG_COMPAT_BRK: u32 = 1;
pub const CONFIG_LOCALVERSION: &'static [u8; 1usize] = b"\0";
pub const CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_PAGE_TABLE_CHECK: u32 = 1;
pub const CONFIG_MEMTEST: u32 = 1;
pub const CONFIG_CMODEL_MEDANY: u32 = 1;
pub const CONFIG_SYMBOLIC_ERRNAME: u32 = 1;
pub const CONFIG_CRYPTO: u32 = 1;
pub const CONFIG_SCHED_DEBUG: u32 = 1;
pub const CONFIG_NET_VENDOR_BROCADE: u32 = 1;
pub const CONFIG_BTRFS_FS_MODULE: u32 = 1;
pub const CONFIG_DEFAULT_MMAP_MIN_ADDR: u32 = 4096;
pub const CONFIG_IP_NF_IPTABLES_MODULE: u32 = 1;
pub const CONFIG_CMDLINE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_NET_VENDOR_QLOGIC: u32 = 1;
pub const CONFIG_USB_XHCI_HCD: u32 = 1;
pub const CONFIG_VIRTIO: u32 = 1;
pub const CONFIG_SERIAL_SIFIVE: u32 = 1;
pub const CONFIG_CFS_BANDWIDTH: u32 = 1;
pub const CONFIG_NET_SELFTESTS: u32 = 1;
pub const CONFIG_GENERIC_MSI_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_USB_ARCH_HAS_HCD: u32 = 1;
pub const CONFIG_GENERIC_IRQ_SHOW: u32 = 1;
pub const CONFIG_NVMEM_SYSFS: u32 = 1;
pub const CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE: u32 = 1;
pub const CONFIG_ARCH_HAS_ELF_RANDOMIZE: u32 = 1;
pub const CONFIG_9P_FS: u32 = 1;
pub const CONFIG_NETFS_SUPPORT: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_ARG_ACCESS_API: u32 = 1;
pub const CONFIG_PANIC_ON_OOPS_VALUE: u32 = 0;
pub const CONFIG_NET_VENDOR_SAMSUNG: u32 = 1;
pub const CONFIG_NET_VENDOR_ADI: u32 = 1;
pub const CONFIG_INITRAMFS_PRESERVE_MTIME: u32 = 1;
pub const CONFIG_SCSI_MOD: u32 = 1;
pub const CONFIG_NET_VENDOR_MICREL: u32 = 1;
pub const CONFIG_CRYPTO_CRC32C: u32 = 1;
pub const CONFIG_SERIAL_CORE: u32 = 1;
pub const CONFIG_HAVE_KRETPROBES: u32 = 1;
pub const CONFIG_ASSOCIATIVE_ARRAY: u32 = 1;
pub const CONFIG_NF_DEFRAG_IPV6_MODULE: u32 = 1;
pub const CONFIG_MODULE_COMPRESS_NONE: u32 = 1;
pub const CONFIG_CC_HAS_ZERO_CALL_USED_REGS: u32 = 1;
pub const CONFIG_NFS_V4: u32 = 1;
pub const CONFIG_RCU_NEED_SEGCBLIST: u32 = 1;
pub const CONFIG_HAS_DMA: u32 = 1;
pub const CONFIG_NF_CT_PROTO_SCTP: u32 = 1;
pub const CONFIG_SCSI: u32 = 1;
pub const CONFIG_FB_CFB_FILLRECT_MODULE: u32 = 1;
pub const CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST: u32 = 1;
pub const CONFIG_HID: u32 = 1;
pub const CONFIG_DMA_DECLARE_COHERENT: u32 = 1;
pub const CONFIG_CGROUP_NET_PRIO: u32 = 1;
pub const CONFIG_RANDOM_TRUST_BOOTLOADER: u32 = 1;
pub const CONFIG_FONT_8x16: u32 = 1;
pub const CONFIG_NET_VENDOR_MELLANOX: u32 = 1;
pub const CONFIG_RCU_EQS_DEBUG: u32 = 1;
pub const CONFIG_ARCH_HAS_CURRENT_STACK_POINTER: u32 = 1;
pub const CONFIG_JBD2: u32 = 1;
pub const CONFIG_MEMCG_KMEM: u32 = 1;
pub const CONFIG_NET_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_PHYLIB: u32 = 1;
pub const CONFIG_NET_VENDOR_NVIDIA: u32 = 1;
pub const CONFIG_ARCH_RV64I: u32 = 1;
pub const CONFIG_FB_CMDLINE: u32 = 1;
pub const CONFIG_IRQ_DOMAIN: u32 = 1;
pub const CONFIG_RISCV: u32 = 1;
pub const CONFIG_VIRTIO_BALLOON: u32 = 1;
pub const CONFIG_LSM_MMAP_MIN_ADDR: u32 = 65536;
pub const CONFIG_LOCALVERSION_AUTO: u32 = 1;
pub const CONFIG_INTEGRITY_AUDIT: u32 = 1;
pub const CONFIG_ARCH_HAS_DEBUG_VIRTUAL: u32 = 1;
pub const CONFIG_CLK_STARFIVE_JH7100_AUDIO_MODULE: u32 = 1;
pub const CONFIG_HAVE_ASM_MODVERSIONS: u32 = 1;
pub const CONFIG_IPC_NS: u32 = 1;
pub const CONFIG_MISC_FILESYSTEMS: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS_MIN: u32 = 18;
pub const CONFIG_OF_DMA_DEFAULT_COHERENT: u32 = 1;
pub const CONFIG_DECOMPRESS_BZIP2: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_UPROBES: u32 = 1;
pub const CONFIG_NET_VENDOR_STMICRO: u32 = 1;
pub const CONFIG_XZ_DEC_SPARC: u32 = 1;
pub const CONFIG_SECURITY_APPARMOR_EXPORT_BINARY: u32 = 1;
pub const CONFIG_OF_GPIO: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_HUGETLBFS: u32 = 1;
pub const CONFIG_SERIAL_MCTRL_GPIO: u32 = 1;
pub const CONFIG_REALTEK_PHY: u32 = 1;
pub const CONFIG_DST_CACHE: u32 = 1;
pub const CONFIG_NF_REJECT_IPV6_MODULE: u32 = 1;
pub const CONFIG_RCU_CPU_STALL_TIMEOUT: u32 = 21;
pub const CONFIG_POSIX_CPU_TIMERS_TASK_WORK: u32 = 1;
pub const CONFIG_CHECKPOINT_RESTORE: u32 = 1;
pub const CONFIG_LLD_VERSION: u32 = 0;
pub const CONFIG_SECTION_MISMATCH_WARN_ONLY: u32 = 1;
pub const CONFIG_NETFILTER_EGRESS: u32 = 1;
pub const CONFIG_MDIO_DEVICE: u32 = 1;
pub const CONFIG_TIMER_PROBE: u32 = 1;
pub const CONFIG_MODPROBE_PATH: &'static [u8; 15usize] = b"/sbin/modprobe\0";
pub const CONFIG_POWER_RESET: u32 = 1;
pub const CONFIG_DRM_DISPLAY_HELPER_MODULE: u32 = 1;
pub const CONFIG_IP6_NF_MATCH_IPV6HEADER_MODULE: u32 = 1;
pub const CONFIG_MACVLAN_MODULE: u32 = 1;
pub const CONFIG_PCIEASPM_DEFAULT: u32 = 1;
pub const CONFIG_PROFILING: u32 = 1;
pub const CONFIG_INTERVAL_TREE: u32 = 1;
pub const CONFIG_NET_VENDOR_AMAZON: u32 = 1;
pub const CONFIG_BLK_MQ_STACKING: u32 = 1;
pub const CONFIG_DRM_GEM_SHMEM_HELPER_MODULE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ATMEL: u32 = 1;
pub const CONFIG_GRACE_PERIOD: u32 = 1;
pub const CONFIG_NET_VENDOR_TEHUTI: u32 = 1;
pub const CONFIG_CRYPTO_MANAGER: u32 = 1;
pub const CONFIG_EDAC_SUPPORT: u32 = 1;
pub const CONFIG_RT_MUTEXES: u32 = 1;
pub const CONFIG_LOCK_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_DRM_I2C_SIL164_MODULE: u32 = 1;
pub const CONFIG_HUGETLBFS: u32 = 1;
pub const CONFIG_SLAB_MERGE_DEFAULT: u32 = 1;
pub const CONFIG_KERNFS: u32 = 1;
pub const CONFIG_I2C_ALGOBIT_MODULE: u32 = 1;
pub const CONFIG_MMC_BLOCK: u32 = 1;
pub const CONFIG_PAGE_COUNTER: u32 = 1;
pub const CONFIG_IOMMU_DEFAULT_DMA_STRICT: u32 = 1;
pub const CONFIG_EXPERT: u32 = 1;
pub const CONFIG_WIRELESS: u32 = 1;
pub const CONFIG_RPMSG_CTRL: u32 = 1;
pub const CONFIG_HZ_250: u32 = 1;
pub const CONFIG_ARCH_HAS_STRICT_KERNEL_RWX: u32 = 1;
pub const CONFIG_LOCK_DEBUGGING_SUPPORT: u32 = 1;
pub const CONFIG_NF_LOG_SYSLOG_MODULE: u32 = 1;
pub const CONFIG_FAT_DEFAULT_IOCHARSET: &'static [u8; 10usize] = b"iso8859-1\0";
pub const CONFIG_HAVE_RUST: u32 = 1;
pub const CONFIG_FRAME_WARN: u32 = 2048;
pub const CONFIG_NET_VENDOR_AGERE: u32 = 1;
pub const CONFIG_HID_GENERIC: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_BITS: u32 = 18;
pub const CONFIG_GENERIC_HWEIGHT: u32 = 1;
pub const CONFIG_INITRAMFS_SOURCE: &'static [u8; 1usize] = b"\0";
pub const CONFIG_TASKS_TRACE_RCU: u32 = 1;
pub const CONFIG_CGROUPS: u32 = 1;
pub const CONFIG_MMC: u32 = 1;
pub const CONFIG_LZO_COMPRESS_MODULE: u32 = 1;
pub const CONFIG_VIRTIO_INPUT: u32 = 1;
pub const CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS: u32 = 1;
pub const CONFIG_CRYPTO_SEQIV_MODULE: u32 = 1;
pub const CONFIG_HAVE_GCC_PLUGINS: u32 = 1;
pub const CONFIG_STACKTRACE: u32 = 1;
pub const CONFIG_HAVE_PCI: u32 = 1;
pub const CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC: u32 = 1;
pub const CONFIG_CRYPTO_DRBG_MODULE: u32 = 1;
pub const CONFIG_OF_EARLY_FLATTREE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ADMTEK: u32 = 1;
pub const CONFIG_CGROUP_CPUACCT: u32 = 1;
pub const CONFIG_HAS_IOPORT_MAP: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LIB: u32 = 1;
pub const CONFIG_NET_VENDOR_VIA: u32 = 1;
pub const CONFIG_HZ: u32 = 250;
pub const CONFIG_RUST: u32 = 1;
pub const CONFIG_I2C_HELPER_AUTO: u32 = 1;
pub const CONFIG_SERIAL_8250_PERICOM: u32 = 1;
pub const CONFIG_SIFIVE_PLIC: u32 = 1;
pub const CONFIG_SERIAL_8250_NR_UARTS: u32 = 4;
pub const CONFIG_ARCH_HAS_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_CC_IS_GCC: u32 = 1;
pub const CONFIG_NET_EGRESS: u32 = 1;
pub const CONFIG_NET_VENDOR_ARC: u32 = 1;
pub const CONFIG_CRYPTO_ENGINE: u32 = 1;
pub const CONFIG_DRM_I2C_CH7006_MODULE: u32 = 1;
pub const CONFIG_HAVE_PERF_USER_STACK_DUMP: u32 = 1;
pub const CONFIG_CGROUP_PERF: u32 = 1;
pub const CONFIG_NLATTR: u32 = 1;
pub const CONFIG_TCP_CONG_CUBIC: u32 = 1;
pub const CONFIG_NR_CPUS: u32 = 64;
pub const CONFIG_MMC_SDHCI: u32 = 1;
pub const CONFIG_MOUSE_PS2_TRACKPOINT: u32 = 1;
pub const CONFIG_DRM_NOUVEAU_BACKLIGHT: u32 = 1;
pub const CONFIG_SYSFS: u32 = 1;
pub const CONFIG_USB_DEFAULT_PERSIST: u32 = 1;
pub const CONFIG_DRM_PANEL_BRIDGE: u32 = 1;
pub const CONFIG_USB_EHCI_HCD_PLATFORM: u32 = 1;
pub const CONFIG_BLK_DEV_BSG_COMMON: u32 = 1;
pub const CONFIG_ASN1: u32 = 1;
pub const CONFIG_CLK_SIFIVE_PRCI: u32 = 1;
pub const CONFIG_CRYPTO_DEV_VIRTIO: u32 = 1;
pub const CONFIG_XZ_DEC_ARM: u32 = 1;
pub const CONFIG_PTP_1588_CLOCK_OPTIONAL: u32 = 1;
pub const CONFIG_FB_SYS_FOPS_MODULE: u32 = 1;
pub const CONFIG_HAVE_SYSCALL_TRACEPOINTS: u32 = 1;
pub const CONFIG_IO_WQ: u32 = 1;
pub const CONFIG_DECOMPRESS_ZSTD: u32 = 1;
pub const CONFIG_FB: u32 = 1;
pub const CONFIG_BLK_MQ_VIRTIO: u32 = 1;
pub const CONFIG_I2C_COMPAT: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ZYDAS: u32 = 1;
pub const CONFIG_SPARSEMEM_VMEMMAP_ENABLE: u32 = 1;
pub const CONFIG_IPVLAN_MODULE: u32 = 1;
pub const CONFIG_VIRTUALIZATION: u32 = 1;
pub const CONFIG_MSDOS_PARTITION: u32 = 1;
pub const CONFIG_RTC_I2C_AND_SPI_MODULE: u32 = 1;
pub const CONFIG_HAVE_POSIX_CPU_TIMERS_TASK_WORK: u32 = 1;
pub const CONFIG_SYNC_FILE: u32 = 1;
pub const CONFIG_USB_XHCI_PCI: u32 = 1;
pub const CONFIG_IP_PNP_RARP: u32 = 1;
pub const CONFIG_DEBUG_TIMEKEEPING: u32 = 1;
pub const CONFIG_VETH_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_3COM: u32 = 1;
pub const CONFIG_STACKPROTECTOR: u32 = 1;
pub const CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK: u32 = 1;
pub const CONFIG_MMC_SDHCI_CADENCE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KGDB: u32 = 1;
pub const CONFIG_BLK_DEBUG_FS: u32 = 1;
pub const CONFIG_NET_VENDOR_INTEL: u32 = 1;
pub const CONFIG_RPS: u32 = 1;
pub const CONFIG_SERIAL_8250_EXAR: u32 = 1;
pub const CONFIG_PROC_PID_CPUSET: u32 = 1;
pub const CONFIG_PM_GENERIC_DOMAINS: u32 = 1;
pub const CONFIG_BINDGEN_VERSION_TEXT: &'static [u8; 15usize] = b"bindgen 0.56.0\0";
pub const CONFIG_LEGACY_PTY_COUNT: u32 = 256;
pub const CONFIG_GENERIC_CSUM: u32 = 1;
pub const CONFIG_GENERIC_IDLE_POLL_SETUP: u32 = 1;
pub const CONFIG_RESET_SIMPLE: u32 = 1;
pub const CONFIG_ZISOFS: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MEDIATEK: u32 = 1;
pub const CONFIG_IP_MULTICAST: u32 = 1;
pub const CONFIG_NET_VENDOR_CISCO: u32 = 1;
pub const CONFIG_TICK_ONESHOT: u32 = 1;
pub const CONFIG_CRYPTO_CTR_MODULE: u32 = 1;
pub const CONFIG_HW_RANDOM: u32 = 1;
pub const CONFIG_MUTEX_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_DEBUG_VM_IRQSOFF: u32 = 1;
pub const CONFIG_CGROUP_NET_CLASSID: u32 = 1;
pub const CONFIG_RISCV_SBI_CPUIDLE: u32 = 1;
pub const CONFIG_HAVE_FUNCTION_GRAPH_TRACER: u32 = 1;
pub const CONFIG_OF_MDIO: u32 = 1;
pub const CONFIG_CRYPTO_BLAKE2B_MODULE: u32 = 1;
pub const CONFIG_TREE_SRCU: u32 = 1;
pub const CONFIG_CRYPTO_NULL2: u32 = 1;
pub const CONFIG_ARCH_HAS_MMIOWB: u32 = 1;
pub const CONFIG_BASE_SMALL: u32 = 0;
pub const CONFIG_SECURITY_SELINUX_AVC_STATS: u32 = 1;
pub const CONFIG_COMPACTION: u32 = 1;
pub const CONFIG_NFS_V2: u32 = 1;
pub const CONFIG_PROC_FS: u32 = 1;
pub const CONFIG_CRYPTO_USER_API_ENABLE_OBSOLETE: u32 = 1;
pub const CONFIG_GENERIC_BUG_RELATIVE_POINTERS: u32 = 1;
pub const CONFIG_VIRTIO_MMIO: u32 = 1;
pub const CONFIG_NET_VENDOR_ROCKER: u32 = 1;
pub const CONFIG_SCSI_LOWLEVEL: u32 = 1;
pub const CONFIG_RISCV_PMU_SBI: u32 = 1;
pub const CONFIG_MEMFD_CREATE: u32 = 1;
pub const CONFIG_IRQ_FORCED_THREADING: u32 = 1;
pub const CONFIG_DRM_FBDEV_EMULATION: u32 = 1;
pub const CONFIG_FLATMEM: u32 = 1;
pub const CONFIG_PCIE_DW: u32 = 1;
pub const CONFIG_NET_VENDOR_NATSEMI: u32 = 1;
pub const CONFIG_VIRTIO_PCI_LIB_LEGACY: u32 = 1;
pub const CONFIG_IKCONFIG: u32 = 1;
pub const CONFIG_NET_VENDOR_GOOGLE: u32 = 1;
pub const CONFIG_DEBUG_PLIST: u32 = 1;
pub const CONFIG_GENERIC_IRQ_MIGRATION: u32 = 1;
pub const CONFIG_NET_VENDOR_NETRONOME: u32 = 1;
pub const CONFIG_DEBUG_LIST: u32 = 1;
pub const CONFIG_NFS_USE_KERNEL_DNS: u32 = 1;
pub const CONFIG_ARCH_HAS_FORTIFY_SOURCE: u32 = 1;
pub const CONFIG_GCC_VERSION: u32 = 110300;
pub const CONFIG_CRYPTO_LIB_POLY1305_RSIZE: u32 = 1;
pub const CONFIG_SYSCTL: u32 = 1;
pub const CONFIG_CC_CAN_LINK_STATIC: u32 = 1;
pub const CONFIG_ARCH_HAS_GCOV_PROFILE_ALL: u32 = 1;
pub const CONFIG_BRIDGE_IGMP_SNOOPING: u32 = 1;
pub const CONFIG_PHYS_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_THREAD_INFO_IN_TASK: u32 = 1;
pub const CONFIG_NET_VENDOR_LITEX: u32 = 1;
pub const CONFIG_GENERIC_MSI_IRQ: u32 = 1;
pub const CONFIG_HAVE_ARCH_TRACEHOOK: u32 = 1;
pub const CONFIG_RPMSG_CHAR: u32 = 1;
pub const CONFIG_PCI_DOMAINS_GENERIC: u32 = 1;
pub const CONFIG_DRM_FBDEV_OVERALLOC: u32 = 100;
pub const CONFIG_XFRM_USER_MODULE: u32 = 1;
pub const CONFIG_NET_NS: u32 = 1;
pub const CONFIG_HAVE_PERF_EVENTS: u32 = 1;
pub const CONFIG_ATA_SFF: u32 = 1;
pub const CONFIG_NET_VENDOR_SOLARFLARE: u32 = 1;
pub const CONFIG_DEBUG_MEMORY_INIT: u32 = 1;
pub const CONFIG_XFRM_ESP_MODULE: u32 = 1;
pub const CONFIG_AUDIT: u32 = 1;
pub const CONFIG_NET_9P_FD: u32 = 1;
pub const CONFIG_LTO_NONE: u32 = 1;
pub const CONFIG_PCIEASPM: u32 = 1;
pub const CONFIG_DEBUG_FS_ALLOW_ALL: u32 = 1;
pub const CONFIG_FB_DEFERRED_IO: u32 = 1;
pub const CONFIG_SATA_AHCI: u32 = 1;
pub const CONFIG_SECURITY: u32 = 1;
pub const CONFIG_PORTABLE: u32 = 1;
pub const CONFIG_CLK_SIFIVE: u32 = 1;
pub const CONFIG_USB_EHCI_TT_NEWSCHED: u32 = 1;
pub const CONFIG_FAT_DEFAULT_CODEPAGE: u32 = 437;
pub const CONFIG_BLK_DEV: u32 = 1;
pub const CONFIG_BRIDGE_NETFILTER_MODULE: u32 = 1;
pub const CONFIG_OF_FLATTREE: u32 = 1;
pub const CONFIG_HAVE_ARCH_KFENCE: u32 = 1;
pub const CONFIG_WLAN_VENDOR_SILABS: u32 = 1;
pub const CONFIG_IOMMU_API: u32 = 1;
pub const CONFIG_GPIO_GENERIC: u32 = 1;
pub const CONFIG_TRACING_SUPPORT: u32 = 1;
pub const CONFIG_UNIX98_PTYS: u32 = 1;
pub const CONFIG_DEBUG_VM_PGFLAGS: u32 = 1;
pub const CONFIG_NET_RX_BUSY_POLL: u32 = 1;
pub const CONFIG_NET_VENDOR_SOCIONEXT: u32 = 1;
pub const CONFIG_SECURITY_SELINUX: u32 = 1;
pub const CONFIG_ZONE_DMA32: u32 = 1;
pub const CONFIG_NET_SCHED: u32 = 1;
pub const CONFIG_DRM_PANEL: u32 = 1;
pub const CONFIG_PRINTK_TIME: u32 = 1;
pub const CONFIG_INPUT_MOUSEDEV_SCREEN_Y: u32 = 768;
pub const CONFIG_TASKS_RCU_GENERIC: u32 = 1;
pub const CONFIG_SECCOMP_FILTER: u32 = 1;
pub const CONFIG_IRQCHIP: u32 = 1;
pub const CONFIG_INET_DIAG: u32 = 1;
pub const CONFIG_CRYPTO_GHASH_MODULE: u32 = 1;
pub const CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW: u32 = 1;
pub const CONFIG_SECURITY_SELINUX_SIDTAB_HASH_BITS: u32 = 9;
pub const CONFIG_NF_NAT_FTP_MODULE: u32 = 1;
pub const CONFIG_NF_CT_PROTO_UDPLITE: u32 = 1;
pub const CONFIG_IKCONFIG_PROC: u32 = 1;
pub const CONFIG_ELF_CORE: u32 = 1;
pub const CONFIG_PCI_HOST_COMMON: u32 = 1;
pub const CONFIG_HAVE_CONTEXT_TRACKING_USER: u32 = 1;
pub const CONFIG_MODULE_SECTIONS: u32 = 1;
pub const CONFIG_USB_SUPPORT: u32 = 1;
pub const CONFIG_HAVE_ARCH_KGDB_QXFER_PKT: u32 = 1;
pub const CONFIG_WLAN_VENDOR_ST: u32 = 1;
pub const CONFIG_BLK_DEV_NVME_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_SIS: u32 = 1;
pub const CONFIG_HAVE_64BIT_ALIGNED_ACCESS: u32 = 1;
pub const CONFIG_PAGE_POOL: u32 = 1;
pub const CONFIG_SERIAL_8250_16550A_VARIANTS: u32 = 1;
pub const CONFIG_VT_CONSOLE: u32 = 1;
pub const CONFIG_HW_RANDOM_VIRTIO: u32 = 1;
pub const CONFIG_AS_HAS_INSN: u32 = 1;
pub const CONFIG_MQ_IOSCHED_KYBER: u32 = 1;
pub const CONFIG_AS_VERSION: u32 = 23800;
pub const CONFIG_CC_HAS_INT128: u32 = 1;
pub const CONFIG_EFI_EARLYCON: u32 = 1;
pub const CONFIG_WLAN_VENDOR_MARVELL: u32 = 1;
pub const CONFIG_NET_SOCK_MSG: u32 = 1;
pub const CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE: u32 = 1;
pub const CONFIG_ARCH_MMAP_RND_COMPAT_BITS: u32 = 8;
pub const CONFIG_DRM_MODULE: u32 = 1;
pub const CONFIG_POSIX_MQUEUE_SYSCTL: u32 = 1;
pub const CONFIG_VHOST_MENU: u32 = 1;
pub const CONFIG_DEBUG_MISC: u32 = 1;
pub const CONFIG_FB_CFB_COPYAREA_MODULE: u32 = 1;
pub const CONFIG_NET_VENDOR_MICROSEMI: u32 = 1;
pub const CONFIG_BALLOON_COMPACTION: u32 = 1;
pub const CONFIG_ARCH_OPTIONAL_KERNEL_RWX: u32 = 1;
pub const CONFIG_ARCH_HAS_TICK_BROADCAST: u32 = 1;
pub const CONFIG_BINARY_PRINTF: u32 = 1;
pub const CONFIG_ZSTD_DECOMPRESS: u32 = 1;
pub const CONFIG_WLAN_VENDOR_QUANTENNA: u32 = 1;
pub const CONFIG_ARCH_HAS_SET_DIRECT_MAP: u32 = 1;
pub const CONFIG_SYSVIPC_SYSCTL: u32 = 1;
pub const CONFIG_WLAN_VENDOR_TI: u32 = 1;
pub const CONFIG_DMA_SHARED_BUFFER: u32 = 1;
pub const CONFIG_RTC_SYSTOHC: u32 = 1;
pub const CONFIG_OF_ADDRESS: u32 = 1;
pub const CONFIG_DECOMPRESS_GZIP: u32 = 1;
pub const CONFIG_VIRTIO_MENU: u32 = 1;
pub const CONFIG_VIRTIO_BLK: u32 = 1;
pub const CONFIG_DECOMPRESS_LZO: u32 = 1;
pub const CONFIG_CRYPTO_XXHASH_MODULE: u32 = 1;
pub const CONFIG_64BIT: u32 = 1;
pub const CONFIG_MMC_SDHCI_PLTFM: u32 = 1;
pub const CONFIG_LLC_MODULE: u32 = 1;
pub const CONFIG_ARCH_USE_QUEUED_RWLOCKS: u32 = 1;
pub const CONFIG_REGMAP_MMIO: u32 = 1;
pub const CONFIG_NETWORK_SECMARK: u32 = 1;
pub const CONFIG_GENERIC_CLOCKEVENTS_BROADCAST: u32 = 1;
pub const CONFIG_POWER_SUPPLY_HWMON: u32 = 1;
pub const CONFIG_SERIAL_8250_PCI: u32 = 1;
pub const CONFIG_MOUSE_PS2_SYNAPTICS: u32 = 1;
pub const CONFIG_ATA_BMDMA: u32 = 1;
pub const CONFIG_XZ_DEC_ARMTHUMB: u32 = 1;
pub const CONFIG_NFS_V4_1: u32 = 1;
pub const CONFIG_ARCH_WANT_FRAME_POINTERS: u32 = 1;
pub const CONFIG_REGMAP: u32 = 1;
pub const CONFIG_PCIE_PME: u32 = 1;
pub const CONFIG_HAVE_MOD_ARCH_SPECIFIC: u32 = 1;
pub const CONFIG_ERRATA_SIFIVE: u32 = 1;
pub const CONFIG_FB_NOTIFY: u32 = 1;
pub const CONFIG_STRICT_MODULE_RWX: u32 = 1;
pub const CONFIG_ERRATA_SIFIVE_CIP_1200: u32 = 1;
pub const CONFIG_SYSCTL_EXCEPTION_TRACE: u32 = 1;
pub const CONFIG_SYSVIPC_COMPAT: u32 = 1;
pub const CONFIG_FHANDLE: u32 = 1;
pub const CONFIG_CRYPTO_LIB_SHA256_MODULE: u32 = 1;
pub const CONFIG_SWAP: u32 = 1;
pub const CONFIG_RESET_POLARFIRE_SOC: u32 = 1;
pub const CONFIG_STACKPROTECTOR_PER_TASK: u32 = 1;
pub const CONFIG_IPVLAN_L3S: u32 = 1;
pub const CONFIG_NET_VENDOR_CAVIUM: u32 = 1;
pub const CONFIG_GPIOLIB_IRQCHIP: u32 = 1;
pub const CONFIG_BPF_UNPRIV_DEFAULT_OFF: u32 = 1;
pub const CONFIG_BLK_DEV_SD: u32 = 1;
pub const CONFIG_MODULE_UNLOAD: u32 = 1;
pub const CONFIG_PREEMPT_COUNT: u32 = 1;
pub const CONFIG_NET_VENDOR_ENGLEDER: u32 = 1;
pub const CONFIG_RWSEM_SPIN_ON_OWNER: u32 = 1;
pub const CONFIG_GENERIC_PINMUX_FUNCTIONS: u32 = 1;
pub const CONFIG_CC_HAS_ASM_GOTO_OUTPUT: u32 = 1;
pub const CONFIG_BITREVERSE: u32 = 1;
pub const CONFIG_DEVPORT: u32 = 1;
pub const CONFIG_NF_CONNTRACK_MODULE: u32 = 1;
pub const CONFIG_EFI_RUNTIME_WRAPPERS: u32 = 1;
pub const CONFIG_MDIO_DEVRES: u32 = 1;
pub const CONFIG_LSM: &'static [u8; 55usize] =
    b"landlock,lockdown,yama,loadpin,safesetid,integrity,bpf\0";
pub const CONFIG_ARCH_DMA_ADDR_T_64BIT: u32 = 1;
pub const CONFIG_FILE_LOCKING: u32 = 1;
pub const CONFIG_AIO: u32 = 1;
pub const CONFIG_OF: u32 = 1;
pub const CONFIG_PERF_EVENTS: u32 = 1;
pub const CONFIG_GENERIC_TIME_VSYSCALL: u32 = 1;
pub const CONFIG_IP_NF_TARGET_REJECT_MODULE: u32 = 1;
pub const CONFIG_HAVE_MOVE_PMD: u32 = 1;
pub const CONFIG_KALLSYMS_BASE_RELATIVE: u32 = 1;
pub const CONFIG_IP_VS_TAB_BITS: u32 = 12;
pub const CONFIG_RTC_INTF_DEV: u32 = 1;
pub const CONFIG_SPI_SIFIVE: u32 = 1;
pub const CONFIG_DEBUG_PAGEALLOC: u32 = 1;
pub const CONFIG_MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONFIG_LOCKUP_DETECTOR: u32 = 1;
pub const CONFIG_IP_VS_PROTO_UDP: u32 = 1;
pub const CONFIG_NLS_DEFAULT: &'static [u8; 10usize] = b"iso8859-1\0";
pub const CONFIG_UTS_NS: u32 = 1;
pub const CONFIG_PAGE_REPORTING: u32 = 1;
pub const CONFIG_CGROUP_PIDS: u32 = 1;
pub const CONFIG_CRYPTO_AEAD2: u32 = 1;
pub const CONFIG_MOUSE_PS2: u32 = 1;
pub const CONFIG_IP_VS_SH_TAB_BITS: u32 = 8;
pub const CONFIG_CRYPTO_ALGAPI2: u32 = 1;
pub const CONFIG_INPUT: u32 = 1;
pub const CONFIG_PROC_SYSCTL: u32 = 1;
pub const CONFIG_FWNODE_MDIO: u32 = 1;
pub const CONFIG_RD_LZ4: u32 = 1;
pub const CONFIG_MMU: u32 = 1;
pub const CONFIG_LD_VERSION: u32 = 23800;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __ARG_PLACEHOLDER_1: u32 = 0;
pub const KASAN_ABI_VERSION: u32 = 5;
pub const BITS_PER_LONG: u32 = 64;
pub const BITS_PER_LONG_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const KCSAN_ACCESS_WRITE: u32 = 1;
pub const KCSAN_ACCESS_COMPOUND: u32 = 2;
pub const KCSAN_ACCESS_ATOMIC: u32 = 4;
pub const KCSAN_ACCESS_ASSERT: u32 = 8;
pub const KCSAN_ACCESS_SCOPED: u32 = 16;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const MAX_ERRNO: u32 = 4095;
pub const KERN_SOH: &'static [u8; 2usize] = b"\x01\0";
pub const KERN_SOH_ASCII: u8 = 1u8;
pub const KERN_EMERG: &'static [u8; 3usize] = b"\x010\0";
pub const KERN_ALERT: &'static [u8; 3usize] = b"\x011\0";
pub const KERN_CRIT: &'static [u8; 3usize] = b"\x012\0";
pub const KERN_ERR: &'static [u8; 3usize] = b"\x013\0";
pub const KERN_WARNING: &'static [u8; 3usize] = b"\x014\0";
pub const KERN_NOTICE: &'static [u8; 3usize] = b"\x015\0";
pub const KERN_INFO: &'static [u8; 3usize] = b"\x016\0";
pub const KERN_DEBUG: &'static [u8; 3usize] = b"\x017\0";
pub const KERN_DEFAULT: &'static [u8; 1usize] = b"\0";
pub const KERN_CONT: &'static [u8; 3usize] = b"\x01c\0";
pub const LOGLEVEL_SCHED: i32 = -2;
pub const LOGLEVEL_DEFAULT: i32 = -1;
pub const LOGLEVEL_EMERG: u32 = 0;
pub const LOGLEVEL_ALERT: u32 = 1;
pub const LOGLEVEL_CRIT: u32 = 2;
pub const LOGLEVEL_ERR: u32 = 3;
pub const LOGLEVEL_WARNING: u32 = 4;
pub const LOGLEVEL_NOTICE: u32 = 5;
pub const LOGLEVEL_INFO: u32 = 6;
pub const LOGLEVEL_DEBUG: u32 = 7;
pub const __ALIGN_STR: &'static [u8; 10usize] = b".balign 4\0";
pub const BITS_PER_BYTE: u32 = 8;
pub const HZ: u32 = 100;
pub const EXEC_PAGESIZE: u32 = 4096;
pub const NOGROUP: i32 = -1;
pub const MAXHOSTNAMELEN: u32 = 64;
pub const USER_HZ: u32 = 100;
pub const CLOCKS_PER_SEC: u32 = 100;
pub const MAX_LOCKDEP_SUBCLASSES: u32 = 8;
pub const SPINLOCK_MAGIC: u32 = 3735899821;
pub const DEFAULT_RATELIMIT_INTERVAL: u32 = 1250;
pub const DEFAULT_RATELIMIT_BURST: u32 = 10;
pub const PRINTK_MAX_SINGLE_HEADER_LEN: u32 = 2;
pub const CONSOLE_EXT_LOG_MAX: u32 = 8192;
pub const MESSAGE_LOGLEVEL_DEFAULT: u32 = 4;
pub const CONSOLE_LOGLEVEL_SILENT: u32 = 0;
pub const CONSOLE_LOGLEVEL_MIN: u32 = 1;
pub const CONSOLE_LOGLEVEL_DEBUG: u32 = 10;
pub const CONSOLE_LOGLEVEL_MOTORMOUTH: u32 = 15;
pub const CONSOLE_LOGLEVEL_DEFAULT: u32 = 7;
pub const CONSOLE_LOGLEVEL_QUIET: u32 = 4;
pub const DEVKMSG_STR_MAX_SIZE: u32 = 10;
pub const FW_BUG: &'static [u8; 17usize] = b"[Firmware Bug]: \0";
pub const FW_WARN: &'static [u8; 18usize] = b"[Firmware Warn]: \0";
pub const FW_INFO: &'static [u8; 18usize] = b"[Firmware Info]: \0";
pub const HW_ERR: &'static [u8; 19usize] = b"[Hardware Error]: \0";
pub const DEPRECATED: &'static [u8; 15usize] = b"[Deprecated]: \0";
pub const POISON_POINTER_DELTA: u32 = 0;
pub const PAGE_POISON: u32 = 170;
pub const RED_INACTIVE: u64 = 718624318471594843;
pub const RED_ACTIVE: i64 = -2863912482255763264;
pub const SLUB_RED_INACTIVE: u32 = 187;
pub const SLUB_RED_ACTIVE: u32 = 204;
pub const POISON_INUSE: u32 = 90;
pub const POISON_FREE: u32 = 107;
pub const POISON_END: u32 = 165;
pub const POISON_FREE_INITMEM: u32 = 204;
pub const JBD_POISON_FREE: u32 = 91;
pub const JBD2_POISON_FREE: u32 = 92;
pub const POOL_POISON_FREED: u32 = 167;
pub const POOL_POISON_ALLOCATED: u32 = 169;
pub const ATM_POISON_FREE: u32 = 18;
pub const ATM_POISON: u32 = 3735928559;
pub const MUTEX_DEBUG_INIT: u32 = 17;
pub const MUTEX_DEBUG_FREE: u32 = 34;
pub const KEY_DESTROY: u32 = 189;
pub const PP_SIGNATURE: u32 = 64;
pub const PREEMPT_BITS: u32 = 8;
pub const SOFTIRQ_BITS: u32 = 8;
pub const HARDIRQ_BITS: u32 = 4;
pub const NMI_BITS: u32 = 4;
pub const PREEMPT_SHIFT: u32 = 0;
pub const SOFTIRQ_SHIFT: u32 = 8;
pub const HARDIRQ_SHIFT: u32 = 16;
pub const NMI_SHIFT: u32 = 20;
pub const PREEMPT_OFFSET: u32 = 1;
pub const SOFTIRQ_OFFSET: u32 = 256;
pub const HARDIRQ_OFFSET: u32 = 65536;
pub const NMI_OFFSET: u32 = 1048576;
pub const SOFTIRQ_DISABLE_OFFSET: u32 = 512;
pub const INIT_PREEMPT_COUNT: u32 = 1;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const UINT_MAX: i32 = -1;
pub const ULONG_MAX: i32 = -1;
pub const ULLONG_MAX: i32 = -1;
pub const UINTPTR_MAX: i32 = -1;
pub const RISCV_PTR: &'static [u8; 7usize] = b".dword\0";
pub const RISCV_SZPTR: &'static [u8; 2usize] = b"8\0";
pub const RISCV_LGPTR: &'static [u8; 2usize] = b"3\0";
pub const CUT_HERE: &'static [u8; 38usize] = b"------------[ cut here ]------------\n\0";
pub const BUGFLAG_WARNING: u32 = 1;
pub const BUGFLAG_ONCE: u32 = 2;
pub const BUGFLAG_DONE: u32 = 4;
pub const BUGFLAG_NO_CUT_HERE: u32 = 8;
pub const PANIC_CPU_INVALID: i32 = -1;
pub const TAINT_PROPRIETARY_MODULE: u32 = 0;
pub const TAINT_FORCED_MODULE: u32 = 1;
pub const TAINT_CPU_OUT_OF_SPEC: u32 = 2;
pub const TAINT_FORCED_RMMOD: u32 = 3;
pub const TAINT_MACHINE_CHECK: u32 = 4;
pub const TAINT_BAD_PAGE: u32 = 5;
pub const TAINT_USER: u32 = 6;
pub const TAINT_DIE: u32 = 7;
pub const TAINT_OVERRIDDEN_ACPI_TABLE: u32 = 8;
pub const TAINT_WARN: u32 = 9;
pub const TAINT_CRAP: u32 = 10;
pub const TAINT_FIRMWARE_WORKAROUND: u32 = 11;
pub const TAINT_OOT_MODULE: u32 = 12;
pub const TAINT_UNSIGNED_MODULE: u32 = 13;
pub const TAINT_SOFTLOCKUP: u32 = 14;
pub const TAINT_LIVEPATCH: u32 = 15;
pub const TAINT_AUX: u32 = 16;
pub const TAINT_RANDSTRUCT: u32 = 17;
pub const TAINT_TEST: u32 = 18;
pub const TAINT_FLAGS_COUNT: u32 = 19;
pub const TAINT_FLAGS_MAX: u32 = 524287;
pub const SI_LOAD_SHIFT: u32 = 16;
pub const MSEC_PER_SEC: u32 = 1000;
pub const USEC_PER_MSEC: u32 = 1000;
pub const NSEC_PER_USEC: u32 = 1000;
pub const NSEC_PER_MSEC: u32 = 1000000;
pub const USEC_PER_SEC: u32 = 1000000;
pub const NSEC_PER_SEC: u32 = 1000000000;
pub const PSEC_PER_SEC: u64 = 1000000000000;
pub const FSEC_PER_SEC: u64 = 1000000000000000;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_SGI_CYCLE: u32 = 10;
pub const CLOCK_TAI: u32 = 11;
pub const MAX_CLOCKS: u32 = 16;
pub const CLOCKS_MASK: u32 = 1;
pub const CLOCKS_MONO: u32 = 1;
pub const TIMER_ABSTIME: u32 = 1;
pub const PSEC_PER_NSEC: u32 = 1000;
pub const TIME_UPTIME_SEC_MAX: u32 = 946080000;
pub const ERESTARTSYS: u32 = 512;
pub const ERESTARTNOINTR: u32 = 513;
pub const ERESTARTNOHAND: u32 = 514;
pub const ENOIOCTLCMD: u32 = 515;
pub const ERESTART_RESTARTBLOCK: u32 = 516;
pub const EPROBE_DEFER: u32 = 517;
pub const EOPENSTALE: u32 = 518;
pub const ENOPARAM: u32 = 519;
pub const EBADHANDLE: u32 = 521;
pub const ENOTSYNC: u32 = 522;
pub const EBADCOOKIE: u32 = 523;
pub const ENOTSUPP: u32 = 524;
pub const ETOOSMALL: u32 = 525;
pub const ESERVERFAULT: u32 = 526;
pub const EBADTYPE: u32 = 527;
pub const EJUKEBOX: u32 = 528;
pub const EIOCBQUEUED: u32 = 529;
pub const ERECALLCONFLICT: u32 = 530;
pub const ENOGRACE: u32 = 531;
pub const JUMP_LABEL_NOP_SIZE: u32 = 4;
pub const JUMP_TYPE_FALSE: u32 = 0;
pub const JUMP_TYPE_TRUE: u32 = 1;
pub const JUMP_TYPE_LINKED: u32 = 2;
pub const JUMP_TYPE_MASK: u32 = 3;
pub const RISCV_ISA_EXT_MAX: u32 = 64;
pub const RISCV_ISA_EXT_NAME_LEN_MAX: u32 = 32;
pub const RISCV_ISA_EXT_BASE: u32 = 26;
pub const SR_UXL_SHIFT: u32 = 32;
pub const SATP_ASID_BITS: u32 = 16;
pub const SATP_ASID_SHIFT: u32 = 44;
pub const IRQ_S_SOFT: u32 = 1;
pub const IRQ_VS_SOFT: u32 = 2;
pub const IRQ_M_SOFT: u32 = 3;
pub const IRQ_S_TIMER: u32 = 5;
pub const IRQ_VS_TIMER: u32 = 6;
pub const IRQ_M_TIMER: u32 = 7;
pub const IRQ_S_EXT: u32 = 9;
pub const IRQ_VS_EXT: u32 = 10;
pub const IRQ_M_EXT: u32 = 11;
pub const IRQ_PMU_OVF: u32 = 13;
pub const EXC_INST_MISALIGNED: u32 = 0;
pub const EXC_INST_ACCESS: u32 = 1;
pub const EXC_INST_ILLEGAL: u32 = 2;
pub const EXC_BREAKPOINT: u32 = 3;
pub const EXC_LOAD_ACCESS: u32 = 5;
pub const EXC_STORE_ACCESS: u32 = 7;
pub const EXC_SYSCALL: u32 = 8;
pub const EXC_HYPERVISOR_SYSCALL: u32 = 9;
pub const EXC_SUPERVISOR_SYSCALL: u32 = 10;
pub const EXC_INST_PAGE_FAULT: u32 = 12;
pub const EXC_LOAD_PAGE_FAULT: u32 = 13;
pub const EXC_STORE_PAGE_FAULT: u32 = 15;
pub const EXC_INST_GUEST_PAGE_FAULT: u32 = 20;
pub const EXC_LOAD_GUEST_PAGE_FAULT: u32 = 21;
pub const EXC_VIRTUAL_INST_FAULT: u32 = 22;
pub const EXC_STORE_GUEST_PAGE_FAULT: u32 = 23;
pub const PMP_R: u32 = 1;
pub const PMP_W: u32 = 2;
pub const PMP_X: u32 = 4;
pub const PMP_A: u32 = 24;
pub const PMP_A_TOR: u32 = 8;
pub const PMP_A_NA4: u32 = 16;
pub const PMP_A_NAPOT: u32 = 24;
pub const PMP_L: u32 = 128;
pub const HSTATUS_VSXL_SHIFT: u32 = 32;
pub const HSTATUS_VGEIN_SHIFT: u32 = 12;
pub const HGATP32_MODE_SHIFT: u32 = 31;
pub const HGATP32_VMID_SHIFT: u32 = 22;
pub const HGATP64_MODE_SHIFT: u32 = 60;
pub const HGATP64_VMID_SHIFT: u32 = 44;
pub const HGATP_PAGE_SHIFT: u32 = 12;
pub const HGATP_VMID_SHIFT: u32 = 44;
pub const HGATP_MODE_SHIFT: u32 = 60;
pub const VSIP_TO_HVIP_SHIFT: u32 = 1;
pub const ENVCFG_CBIE_SHIFT: u32 = 4;
pub const CSR_CYCLE: u32 = 3072;
pub const CSR_TIME: u32 = 3073;
pub const CSR_INSTRET: u32 = 3074;
pub const CSR_HPMCOUNTER3: u32 = 3075;
pub const CSR_HPMCOUNTER4: u32 = 3076;
pub const CSR_HPMCOUNTER5: u32 = 3077;
pub const CSR_HPMCOUNTER6: u32 = 3078;
pub const CSR_HPMCOUNTER7: u32 = 3079;
pub const CSR_HPMCOUNTER8: u32 = 3080;
pub const CSR_HPMCOUNTER9: u32 = 3081;
pub const CSR_HPMCOUNTER10: u32 = 3082;
pub const CSR_HPMCOUNTER11: u32 = 3083;
pub const CSR_HPMCOUNTER12: u32 = 3084;
pub const CSR_HPMCOUNTER13: u32 = 3085;
pub const CSR_HPMCOUNTER14: u32 = 3086;
pub const CSR_HPMCOUNTER15: u32 = 3087;
pub const CSR_HPMCOUNTER16: u32 = 3088;
pub const CSR_HPMCOUNTER17: u32 = 3089;
pub const CSR_HPMCOUNTER18: u32 = 3090;
pub const CSR_HPMCOUNTER19: u32 = 3091;
pub const CSR_HPMCOUNTER20: u32 = 3092;
pub const CSR_HPMCOUNTER21: u32 = 3093;
pub const CSR_HPMCOUNTER22: u32 = 3094;
pub const CSR_HPMCOUNTER23: u32 = 3095;
pub const CSR_HPMCOUNTER24: u32 = 3096;
pub const CSR_HPMCOUNTER25: u32 = 3097;
pub const CSR_HPMCOUNTER26: u32 = 3098;
pub const CSR_HPMCOUNTER27: u32 = 3099;
pub const CSR_HPMCOUNTER28: u32 = 3100;
pub const CSR_HPMCOUNTER29: u32 = 3101;
pub const CSR_HPMCOUNTER30: u32 = 3102;
pub const CSR_HPMCOUNTER31: u32 = 3103;
pub const CSR_CYCLEH: u32 = 3200;
pub const CSR_TIMEH: u32 = 3201;
pub const CSR_INSTRETH: u32 = 3202;
pub const CSR_HPMCOUNTER3H: u32 = 3203;
pub const CSR_HPMCOUNTER4H: u32 = 3204;
pub const CSR_HPMCOUNTER5H: u32 = 3205;
pub const CSR_HPMCOUNTER6H: u32 = 3206;
pub const CSR_HPMCOUNTER7H: u32 = 3207;
pub const CSR_HPMCOUNTER8H: u32 = 3208;
pub const CSR_HPMCOUNTER9H: u32 = 3209;
pub const CSR_HPMCOUNTER10H: u32 = 3210;
pub const CSR_HPMCOUNTER11H: u32 = 3211;
pub const CSR_HPMCOUNTER12H: u32 = 3212;
pub const CSR_HPMCOUNTER13H: u32 = 3213;
pub const CSR_HPMCOUNTER14H: u32 = 3214;
pub const CSR_HPMCOUNTER15H: u32 = 3215;
pub const CSR_HPMCOUNTER16H: u32 = 3216;
pub const CSR_HPMCOUNTER17H: u32 = 3217;
pub const CSR_HPMCOUNTER18H: u32 = 3218;
pub const CSR_HPMCOUNTER19H: u32 = 3219;
pub const CSR_HPMCOUNTER20H: u32 = 3220;
pub const CSR_HPMCOUNTER21H: u32 = 3221;
pub const CSR_HPMCOUNTER22H: u32 = 3222;
pub const CSR_HPMCOUNTER23H: u32 = 3223;
pub const CSR_HPMCOUNTER24H: u32 = 3224;
pub const CSR_HPMCOUNTER25H: u32 = 3225;
pub const CSR_HPMCOUNTER26H: u32 = 3226;
pub const CSR_HPMCOUNTER27H: u32 = 3227;
pub const CSR_HPMCOUNTER28H: u32 = 3228;
pub const CSR_HPMCOUNTER29H: u32 = 3229;
pub const CSR_HPMCOUNTER30H: u32 = 3230;
pub const CSR_HPMCOUNTER31H: u32 = 3231;
pub const CSR_SSCOUNTOVF: u32 = 3488;
pub const CSR_SSTATUS: u32 = 256;
pub const CSR_SIE: u32 = 260;
pub const CSR_STVEC: u32 = 261;
pub const CSR_SCOUNTEREN: u32 = 262;
pub const CSR_SSCRATCH: u32 = 320;
pub const CSR_SEPC: u32 = 321;
pub const CSR_SCAUSE: u32 = 322;
pub const CSR_STVAL: u32 = 323;
pub const CSR_SIP: u32 = 324;
pub const CSR_SATP: u32 = 384;
pub const CSR_STIMECMP: u32 = 333;
pub const CSR_STIMECMPH: u32 = 349;
pub const CSR_VSSTATUS: u32 = 512;
pub const CSR_VSIE: u32 = 516;
pub const CSR_VSTVEC: u32 = 517;
pub const CSR_VSSCRATCH: u32 = 576;
pub const CSR_VSEPC: u32 = 577;
pub const CSR_VSCAUSE: u32 = 578;
pub const CSR_VSTVAL: u32 = 579;
pub const CSR_VSIP: u32 = 580;
pub const CSR_VSATP: u32 = 640;
pub const CSR_VSTIMECMP: u32 = 589;
pub const CSR_VSTIMECMPH: u32 = 605;
pub const CSR_HSTATUS: u32 = 1536;
pub const CSR_HEDELEG: u32 = 1538;
pub const CSR_HIDELEG: u32 = 1539;
pub const CSR_HIE: u32 = 1540;
pub const CSR_HTIMEDELTA: u32 = 1541;
pub const CSR_HCOUNTEREN: u32 = 1542;
pub const CSR_HGEIE: u32 = 1543;
pub const CSR_HENVCFG: u32 = 1546;
pub const CSR_HTIMEDELTAH: u32 = 1557;
pub const CSR_HENVCFGH: u32 = 1562;
pub const CSR_HTVAL: u32 = 1603;
pub const CSR_HIP: u32 = 1604;
pub const CSR_HVIP: u32 = 1605;
pub const CSR_HTINST: u32 = 1610;
pub const CSR_HGATP: u32 = 1664;
pub const CSR_HGEIP: u32 = 3602;
pub const CSR_MSTATUS: u32 = 768;
pub const CSR_MISA: u32 = 769;
pub const CSR_MIE: u32 = 772;
pub const CSR_MTVEC: u32 = 773;
pub const CSR_MENVCFG: u32 = 778;
pub const CSR_MENVCFGH: u32 = 794;
pub const CSR_MSCRATCH: u32 = 832;
pub const CSR_MEPC: u32 = 833;
pub const CSR_MCAUSE: u32 = 834;
pub const CSR_MTVAL: u32 = 835;
pub const CSR_MIP: u32 = 836;
pub const CSR_PMPCFG0: u32 = 928;
pub const CSR_PMPADDR0: u32 = 944;
pub const CSR_MVENDORID: u32 = 3857;
pub const CSR_MARCHID: u32 = 3858;
pub const CSR_MIMPID: u32 = 3859;
pub const CSR_MHARTID: u32 = 3860;
pub const CSR_STATUS: u32 = 256;
pub const CSR_IE: u32 = 260;
pub const CSR_TVEC: u32 = 261;
pub const CSR_SCRATCH: u32 = 320;
pub const CSR_EPC: u32 = 321;
pub const CSR_CAUSE: u32 = 322;
pub const CSR_TVAL: u32 = 323;
pub const CSR_IP: u32 = 324;
pub const RV_IRQ_SOFT: u32 = 1;
pub const RV_IRQ_TIMER: u32 = 5;
pub const RV_IRQ_EXT: u32 = 9;
pub const RV_IRQ_PMU: u32 = 13;
pub const REG_FMT: &'static [u8; 7usize] = b"%016lx\0";
pub const STACK_ALIGN: u32 = 16;
pub const NR_CPUS: u32 = 64;
pub const MIN_THREADS_LEFT_FOR_ROOT: u32 = 4;
pub const PIDS_PER_CPU_DEFAULT: u32 = 1024;
pub const PIDS_PER_CPU_MIN: u32 = 8;
pub const PER_CPU_SHARED_ALIGNED_SECTION: &'static [u8; 1usize] = b"\0";
pub const PER_CPU_ALIGNED_SECTION: &'static [u8; 1usize] = b"\0";
pub const PER_CPU_FIRST_SECTION: &'static [u8; 8usize] = b"..first\0";
pub const PER_CPU_BASE_SECTION: &'static [u8; 14usize] = b".data..percpu\0";
pub const BITOP_LE_SWIZZLE: u32 = 0;
pub const PAGE_SHIFT: u32 = 12;
pub const HUGE_MAX_HSTATE: u32 = 2;
pub const PTE_FMT: &'static [u8; 7usize] = b"%016lx\0";
pub const KASAN_STACK_ORDER: u32 = 0;
pub const THREAD_SIZE_ORDER: u32 = 2;
pub const THREAD_SHIFT: u32 = 14;
pub const SHADOW_OVERFLOW_STACK_SIZE: u32 = 1024;
pub const TIF_SYSCALL_TRACE: u32 = 0;
pub const TIF_NOTIFY_RESUME: u32 = 1;
pub const TIF_SIGPENDING: u32 = 2;
pub const TIF_NEED_RESCHED: u32 = 3;
pub const TIF_RESTORE_SIGMASK: u32 = 4;
pub const TIF_MEMDIE: u32 = 5;
pub const TIF_SYSCALL_TRACEPOINT: u32 = 6;
pub const TIF_SYSCALL_AUDIT: u32 = 7;
pub const TIF_SECCOMP: u32 = 8;
pub const TIF_NOTIFY_SIGNAL: u32 = 9;
pub const TIF_UPROBE: u32 = 10;
pub const TIF_32BIT: u32 = 11;
pub const _TIF_SYSCALL_TRACE: u32 = 1;
pub const _TIF_NOTIFY_RESUME: u32 = 2;
pub const _TIF_SIGPENDING: u32 = 4;
pub const _TIF_NEED_RESCHED: u32 = 8;
pub const _TIF_SYSCALL_TRACEPOINT: u32 = 64;
pub const _TIF_SYSCALL_AUDIT: u32 = 128;
pub const _TIF_SECCOMP: u32 = 256;
pub const _TIF_NOTIFY_SIGNAL: u32 = 512;
pub const _TIF_UPROBE: u32 = 1024;
pub const _TIF_WORK_MASK: u32 = 1550;
pub const _TIF_SYSCALL_WORK: u32 = 449;
pub const PREEMPT_ENABLED: u32 = 0;
pub const PREEMPT_DISABLE_OFFSET: u32 = 1;
pub const PREEMPT_LOCK_OFFSET: u32 = 1;
pub const SOFTIRQ_LOCK_OFFSET: u32 = 513;
pub const STATIC_CALL_SITE_TAIL: u32 = 1;
pub const STATIC_CALL_SITE_INIT: u32 = 2;
pub const STATIC_CALL_SITE_FLAGS: u32 = 3;
pub const STACK_MAGIC: u32 = 3735928559;
pub const READ: u32 = 0;
pub const WRITE: u32 = 1;
pub const BITMAP_MEM_ALIGNMENT: u32 = 8;
pub const BITMAP_MEM_MASK: u32 = 7;
pub const RISCV_ACQUIRE_BARRIER: &'static [u8; 15usize] = b"\tfence r , rw\n\0";
pub const RISCV_RELEASE_BARRIER: &'static [u8; 15usize] = b"\tfence rw,  w\n\0";
pub const ___GFP_DMA: u32 = 1;
pub const ___GFP_HIGHMEM: u32 = 2;
pub const ___GFP_DMA32: u32 = 4;
pub const ___GFP_MOVABLE: u32 = 8;
pub const ___GFP_RECLAIMABLE: u32 = 16;
pub const ___GFP_HIGH: u32 = 32;
pub const ___GFP_IO: u32 = 64;
pub const ___GFP_FS: u32 = 128;
pub const ___GFP_ZERO: u32 = 256;
pub const ___GFP_ATOMIC: u32 = 512;
pub const ___GFP_DIRECT_RECLAIM: u32 = 1024;
pub const ___GFP_KSWAPD_RECLAIM: u32 = 2048;
pub const ___GFP_WRITE: u32 = 4096;
pub const ___GFP_NOWARN: u32 = 8192;
pub const ___GFP_RETRY_MAYFAIL: u32 = 16384;
pub const ___GFP_NOFAIL: u32 = 32768;
pub const ___GFP_NORETRY: u32 = 65536;
pub const ___GFP_MEMALLOC: u32 = 131072;
pub const ___GFP_COMP: u32 = 262144;
pub const ___GFP_NOMEMALLOC: u32 = 524288;
pub const ___GFP_HARDWALL: u32 = 1048576;
pub const ___GFP_THISNODE: u32 = 2097152;
pub const ___GFP_ACCOUNT: u32 = 4194304;
pub const ___GFP_ZEROTAGS: u32 = 8388608;
pub const ___GFP_SKIP_ZERO: u32 = 0;
pub const ___GFP_SKIP_KASAN_UNPOISON: u32 = 0;
pub const ___GFP_SKIP_KASAN_POISON: u32 = 0;
pub const ___GFP_NOLOCKDEP: u32 = 0;
pub const NODES_SHIFT: u32 = 0;
pub const MAX_NUMNODES: u32 = 1;
pub const NUMA_NO_NODE: i32 = -1;
pub const INVALID_HARTID: i32 = -1;
pub const force_read_lock_recursive: u32 = 0;
pub const SINGLE_DEPTH_NESTING: u32 = 1;
pub const LOCK_SECTION_NAME: &'static [u8; 13usize] = b".text..lock.\0";
pub const LOCK_SECTION_END: &'static [u8; 12usize] = b".previous\n\t\0";
pub const RWLOCK_MAGIC: u32 = 3736018669;
pub const _QW_WAITING: u32 = 256;
pub const _QW_LOCKED: u32 = 255;
pub const _QW_WMASK: u32 = 511;
pub const _QR_SHIFT: u32 = 9;
pub const _QR_BIAS: u32 = 512;
pub const STAT_HAVE_NSEC: u32 = 1;
pub const S_IFMT: u32 = 61440;
pub const S_IFSOCK: u32 = 49152;
pub const S_IFLNK: u32 = 40960;
pub const S_IFREG: u32 = 32768;
pub const S_IFBLK: u32 = 24576;
pub const S_IFDIR: u32 = 16384;
pub const S_IFCHR: u32 = 8192;
pub const S_IFIFO: u32 = 4096;
pub const S_ISUID: u32 = 2048;
pub const S_ISGID: u32 = 1024;
pub const S_ISVTX: u32 = 512;
pub const S_IRWXU: u32 = 448;
pub const S_IRUSR: u32 = 256;
pub const S_IWUSR: u32 = 128;
pub const S_IXUSR: u32 = 64;
pub const S_IRWXG: u32 = 56;
pub const S_IRGRP: u32 = 32;
pub const S_IWGRP: u32 = 16;
pub const S_IXGRP: u32 = 8;
pub const S_IRWXO: u32 = 7;
pub const S_IROTH: u32 = 4;
pub const S_IWOTH: u32 = 2;
pub const S_IXOTH: u32 = 1;
pub const STATX_TYPE: u32 = 1;
pub const STATX_MODE: u32 = 2;
pub const STATX_NLINK: u32 = 4;
pub const STATX_UID: u32 = 8;
pub const STATX_GID: u32 = 16;
pub const STATX_ATIME: u32 = 32;
pub const STATX_MTIME: u32 = 64;
pub const STATX_CTIME: u32 = 128;
pub const STATX_INO: u32 = 256;
pub const STATX_SIZE: u32 = 512;
pub const STATX_BLOCKS: u32 = 1024;
pub const STATX_BASIC_STATS: u32 = 2047;
pub const STATX_BTIME: u32 = 2048;
pub const STATX_MNT_ID: u32 = 4096;
pub const STATX_DIOALIGN: u32 = 8192;
pub const STATX__RESERVED: u32 = 2147483648;
pub const STATX_ATTR_COMPRESSED: u32 = 4;
pub const STATX_ATTR_IMMUTABLE: u32 = 16;
pub const STATX_ATTR_APPEND: u32 = 32;
pub const STATX_ATTR_NODUMP: u32 = 64;
pub const STATX_ATTR_ENCRYPTED: u32 = 2048;
pub const STATX_ATTR_AUTOMOUNT: u32 = 4096;
pub const STATX_ATTR_MOUNT_ROOT: u32 = 8192;
pub const STATX_ATTR_VERITY: u32 = 1048576;
pub const STATX_ATTR_DAX: u32 = 2097152;
pub const S_IRWXUGO: u32 = 511;
pub const S_IALLUGO: u32 = 4095;
pub const S_IRUGO: u32 = 292;
pub const S_IWUGO: u32 = 146;
pub const S_IXUGO: u32 = 73;
pub const UTIME_NOW: u32 = 1073741823;
pub const UTIME_OMIT: u32 = 1073741822;
pub const L1_CACHE_SHIFT: u32 = 6;
pub const L1_CACHE_BYTES: u32 = 64;
pub const SMP_CACHE_BYTES: u32 = 64;
pub const INTERNODE_CACHE_SHIFT: u32 = 6;
pub const NTP_API: u32 = 4;
pub const ADJ_OFFSET: u32 = 1;
pub const ADJ_FREQUENCY: u32 = 2;
pub const ADJ_MAXERROR: u32 = 4;
pub const ADJ_ESTERROR: u32 = 8;
pub const ADJ_STATUS: u32 = 16;
pub const ADJ_TIMECONST: u32 = 32;
pub const ADJ_TAI: u32 = 128;
pub const ADJ_SETOFFSET: u32 = 256;
pub const ADJ_MICRO: u32 = 4096;
pub const ADJ_NANO: u32 = 8192;
pub const ADJ_TICK: u32 = 16384;
pub const MOD_OFFSET: u32 = 1;
pub const MOD_FREQUENCY: u32 = 2;
pub const MOD_MAXERROR: u32 = 4;
pub const MOD_ESTERROR: u32 = 8;
pub const MOD_STATUS: u32 = 16;
pub const MOD_TIMECONST: u32 = 32;
pub const MOD_TAI: u32 = 128;
pub const MOD_MICRO: u32 = 4096;
pub const MOD_NANO: u32 = 8192;
pub const STA_PLL: u32 = 1;
pub const STA_PPSFREQ: u32 = 2;
pub const STA_PPSTIME: u32 = 4;
pub const STA_FLL: u32 = 8;
pub const STA_INS: u32 = 16;
pub const STA_DEL: u32 = 32;
pub const STA_UNSYNC: u32 = 64;
pub const STA_FREQHOLD: u32 = 128;
pub const STA_PPSSIGNAL: u32 = 256;
pub const STA_PPSJITTER: u32 = 512;
pub const STA_PPSWANDER: u32 = 1024;
pub const STA_PPSERROR: u32 = 2048;
pub const STA_CLOCKERR: u32 = 4096;
pub const STA_NANO: u32 = 8192;
pub const STA_MODE: u32 = 16384;
pub const STA_CLK: u32 = 32768;
pub const STA_RONLY: u32 = 65280;
pub const TIME_OK: u32 = 0;
pub const TIME_INS: u32 = 1;
pub const TIME_DEL: u32 = 2;
pub const TIME_OOP: u32 = 3;
pub const TIME_WAIT: u32 = 4;
pub const TIME_ERROR: u32 = 5;
pub const TIME_BAD: u32 = 5;
pub const ADJ_ADJTIME: u32 = 32768;
pub const ADJ_OFFSET_SINGLESHOT: u32 = 1;
pub const ADJ_OFFSET_READONLY: u32 = 8192;
pub const SHIFT_PLL: u32 = 2;
pub const SHIFT_FLL: u32 = 2;
pub const MAXTC: u32 = 10;
pub const SHIFT_USEC: u32 = 16;
pub const PPM_SCALE_INV_SHIFT: u32 = 19;
pub const MAXPHASE: u32 = 500000000;
pub const MAXFREQ: u32 = 500000;
pub const MINSEC: u32 = 256;
pub const MAXSEC: u32 = 2048;
pub const NTP_PHASE_LIMIT: u32 = 16000000;
pub const NTP_SCALE_SHIFT: u32 = 32;
pub const NTP_INTERVAL_FREQ: u32 = 250;
pub const NTP_INTERVAL_LENGTH: u32 = 4000000;
pub const PIT_TICK_RATE: u32 = 1193182;
pub const DEFAULT_OVERFLOWUID: u32 = 65534;
pub const DEFAULT_OVERFLOWGID: u32 = 65534;
pub const DEFAULT_FS_OVERFLOWUID: u32 = 65534;
pub const DEFAULT_FS_OVERFLOWGID: u32 = 65534;
pub const KSTAT_ATTR_FS_IOC_FLAGS: u32 = 1050740;
pub const KSTAT_ATTR_VFS_FLAGS: u32 = 48;
pub const AT_SYSINFO_EHDR: u32 = 33;
pub const AT_L1I_CACHESIZE: u32 = 40;
pub const AT_L1I_CACHEGEOMETRY: u32 = 41;
pub const AT_L1D_CACHESIZE: u32 = 42;
pub const AT_L1D_CACHEGEOMETRY: u32 = 43;
pub const AT_L2_CACHESIZE: u32 = 44;
pub const AT_L2_CACHEGEOMETRY: u32 = 45;
pub const AT_L3_CACHESIZE: u32 = 46;
pub const AT_L3_CACHEGEOMETRY: u32 = 47;
pub const AT_VECTOR_SIZE_ARCH: u32 = 9;
pub const AT_NULL: u32 = 0;
pub const AT_IGNORE: u32 = 1;
pub const AT_EXECFD: u32 = 2;
pub const AT_PHDR: u32 = 3;
pub const AT_PHENT: u32 = 4;
pub const AT_PHNUM: u32 = 5;
pub const AT_PAGESZ: u32 = 6;
pub const AT_BASE: u32 = 7;
pub const AT_FLAGS: u32 = 8;
pub const AT_ENTRY: u32 = 9;
pub const AT_NOTELF: u32 = 10;
pub const AT_UID: u32 = 11;
pub const AT_EUID: u32 = 12;
pub const AT_GID: u32 = 13;
pub const AT_EGID: u32 = 14;
pub const AT_PLATFORM: u32 = 15;
pub const AT_HWCAP: u32 = 16;
pub const AT_CLKTCK: u32 = 17;
pub const AT_SECURE: u32 = 23;
pub const AT_BASE_PLATFORM: u32 = 24;
pub const AT_RANDOM: u32 = 25;
pub const AT_HWCAP2: u32 = 26;
pub const AT_EXECFN: u32 = 31;
pub const AT_MINSIGSTKSZ: u32 = 51;
pub const AT_VECTOR_SIZE_BASE: u32 = 20;
pub const NUM_ACTIVE_RCU_POLL_OLDSTATE: u32 = 2;
pub const TRC_NEED_QS: u32 = 1;
pub const TRC_NEED_QS_CHECKED: u32 = 2;
pub const NUM_ACTIVE_RCU_POLL_FULL_OLDSTATE: u32 = 4;
pub const MAPLE_NODE_SLOTS: u32 = 31;
pub const MAPLE_RANGE64_SLOTS: u32 = 16;
pub const MAPLE_ARANGE64_SLOTS: u32 = 10;
pub const MAPLE_ARANGE64_META_MAX: u32 = 15;
pub const MAPLE_ALLOC_SLOTS: u32 = 30;
pub const MAPLE_NODE_MASK: u32 = 255;
pub const MT_FLAGS_ALLOC_RANGE: u32 = 1;
pub const MT_FLAGS_USE_RCU: u32 = 2;
pub const MT_FLAGS_HEIGHT_OFFSET: u32 = 2;
pub const MT_FLAGS_HEIGHT_MASK: u32 = 124;
pub const MT_FLAGS_LOCK_MASK: u32 = 768;
pub const MT_FLAGS_LOCK_IRQ: u32 = 256;
pub const MT_FLAGS_LOCK_BH: u32 = 512;
pub const MT_FLAGS_LOCK_EXTERN: u32 = 768;
pub const MAPLE_HEIGHT_MAX: u32 = 31;
pub const MAPLE_NODE_TYPE_MASK: u32 = 15;
pub const MAPLE_NODE_TYPE_SHIFT: u32 = 3;
pub const MAPLE_RESERVED_RANGE: u32 = 4096;
pub const OSQ_UNLOCKED_VAL: u32 = 0;
pub const RWSEM_UNLOCKED_VALUE: u32 = 0;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const P_ALL: u32 = 0;
pub const P_PID: u32 = 1;
pub const P_PGID: u32 = 2;
pub const P_PIDFD: u32 = 3;
pub const WQ_FLAG_EXCLUSIVE: u32 = 1;
pub const WQ_FLAG_WOKEN: u32 = 2;
pub const WQ_FLAG_BOOKMARK: u32 = 4;
pub const WQ_FLAG_CUSTOM: u32 = 8;
pub const WQ_FLAG_DONE: u32 = 16;
pub const WQ_FLAG_PRIORITY: u32 = 32;
pub const UPROBE_HANDLER_REMOVE: u32 = 1;
pub const UPROBE_HANDLER_MASK: u32 = 1;
pub const MAX_URETPROBE_DEPTH: u32 = 64;
pub const NR_PAGEFLAGS: u32 = 23;
pub const MAX_NR_ZONES: u32 = 3;
pub const NR_CPUS_BITS: u32 = 6;
pub const SPINLOCK_SIZE: u32 = 24;
pub const LRU_GEN_WIDTH: u32 = 0;
pub const __LRU_REFS_WIDTH: u32 = 0;
pub const ZONES_SHIFT: u32 = 2;
pub const ZONES_WIDTH: u32 = 2;
pub const SECTIONS_SHIFT: u32 = 0;
pub const SECTIONS_WIDTH: u32 = 0;
pub const NODES_WIDTH: u32 = 0;
pub const KASAN_TAG_WIDTH: u32 = 0;
pub const LAST_CPUPID_SHIFT: u32 = 0;
pub const LAST_CPUPID_WIDTH: u32 = 0;
pub const TICK_NSEC: u32 = 4000000;
pub const HZ_TO_MSEC_SHR32: u32 = 29;
pub const MSEC_TO_HZ_SHR32: u32 = 33;
pub const HZ_TO_MSEC_NUM: u32 = 4;
pub const HZ_TO_MSEC_DEN: u32 = 1;
pub const MSEC_TO_HZ_NUM: u32 = 1;
pub const MSEC_TO_HZ_DEN: u32 = 4;
pub const HZ_TO_USEC_SHR32: u32 = 20;
pub const USEC_TO_HZ_SHR32: u32 = 43;
pub const HZ_TO_USEC_NUM: u32 = 4000;
pub const HZ_TO_USEC_DEN: u32 = 1;
pub const USEC_TO_HZ_NUM: u32 = 1;
pub const USEC_TO_HZ_DEN: u32 = 4000;
pub const HZ_TO_NSEC_NUM: u32 = 4000000;
pub const HZ_TO_NSEC_DEN: u32 = 1;
pub const NSEC_TO_HZ_NUM: u32 = 1;
pub const NSEC_TO_HZ_DEN: u32 = 4000000;
pub const SHIFT_HZ: u32 = 8;
pub const TICK_USEC: u32 = 4000;
pub const USER_TICK_USEC: u32 = 10000;
pub const SEC_JIFFIE_SC: u32 = 23;
pub const NSEC_JIFFIE_SC: u32 = 53;
pub const TIMESTAMP_SIZE: u32 = 30;
pub const LOW_RES_NSEC: u32 = 4000000;
pub const KTIME_LOW_RES: u32 = 4000000;
pub const TIMER_CPUMASK: u32 = 262143;
pub const TIMER_MIGRATING: u32 = 262144;
pub const TIMER_BASEMASK: u32 = 524287;
pub const TIMER_DEFERRABLE: u32 = 524288;
pub const TIMER_PINNED: u32 = 1048576;
pub const TIMER_IRQSAFE: u32 = 2097152;
pub const TIMER_INIT_FLAGS: u32 = 3670016;
pub const TIMER_ARRAYSHIFT: u32 = 22;
pub const TIMER_ARRAYMASK: u32 = 4290772992;
pub const TIMER_TRACE_FLAGMASK: u32 = 3932160;
pub const NEXT_TIMER_MAX_DELTA: u32 = 1073741823;
pub const KCSAN_SEQLOCK_REGION_MAX: u32 = 1000;
pub const AT_VECTOR_SIZE: u32 = 60;
pub const INIT_PASID: u32 = 0;
pub const MM_MT_FLAGS: u32 = 769;
pub const BUILD_ID_SIZE_MAX: u32 = 20;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const GRND_NONBLOCK: u32 = 1;
pub const GRND_RANDOM: u32 = 2;
pub const GRND_INSECURE: u32 = 4;
pub const CANARY_MASK: i32 = -256;
pub const LINUX_MM_DEBUG_H: u32 = 1;
pub const PERCPU_MODULE_RESERVE: u32 = 8192;
pub const PCPU_MIN_ALLOC_SHIFT: u32 = 2;
pub const PCPU_MIN_ALLOC_SIZE: u32 = 4;
pub const PERCPU_DYNAMIC_EARLY_SLOTS: u32 = 128;
pub const PERCPU_DYNAMIC_EARLY_SIZE: u32 = 12288;
pub const PERCPU_DYNAMIC_RESERVE: u32 = 28672;
pub const first_online_node: u32 = 0;
pub const first_memory_node: u32 = 0;
pub const nr_node_ids: u32 = 1;
pub const nr_online_nodes: u32 = 1;
pub const PB_migratetype_bits: u32 = 3;
pub const PAGEFLAGS_MASK: u32 = 8388607;
pub const PAGE_POISON_PATTERN: i32 = -1;
pub const FOLIO_PF_ANY: u32 = 0;
pub const FOLIO_PF_HEAD: u32 = 0;
pub const FOLIO_PF_ONLY_HEAD: u32 = 0;
pub const FOLIO_PF_NO_TAIL: u32 = 0;
pub const FOLIO_PF_NO_COMPOUND: u32 = 0;
pub const FOLIO_PF_SECOND: u32 = 1;
pub const __PG_HWPOISON: u32 = 0;
pub const PAGE_MAPPING_ANON: u32 = 1;
pub const PAGE_MAPPING_MOVABLE: u32 = 2;
pub const PAGE_MAPPING_KSM: u32 = 3;
pub const PAGE_MAPPING_FLAGS: u32 = 3;
pub const PAGE_MAPPING_DAX_COW: u32 = 1;
pub const PAGE_TYPE_BASE: u32 = 4026531840;
pub const PAGE_MAPCOUNT_RESERVE: i32 = -128;
pub const PG_buddy: u32 = 128;
pub const PG_offline: u32 = 256;
pub const PG_table: u32 = 512;
pub const PG_guard: u32 = 1024;
pub const MAX_ORDER: u32 = 11;
pub const MAX_ORDER_NR_PAGES: u32 = 1024;
pub const PAGE_ALLOC_COSTLY_ORDER: u32 = 3;
pub const MIGRATETYPE_MASK: u32 = 7;
pub const NR_VM_NUMA_EVENT_ITEMS: u32 = 0;
pub const LRU_BASE: u32 = 0;
pub const LRU_ACTIVE: u32 = 1;
pub const LRU_FILE: u32 = 2;
pub const WORKINGSET_ANON: u32 = 0;
pub const WORKINGSET_FILE: u32 = 1;
pub const ANON_AND_FILE: u32 = 2;
pub const MIN_NR_GENS: u32 = 2;
pub const MAX_NR_GENS: u32 = 4;
pub const MAX_NR_TIERS: u32 = 4;
pub const NR_PCP_THP: u32 = 0;
pub const ASYNC_AND_SYNC: u32 = 2;
pub const ZONEID_SHIFT: u32 = 2;
pub const ZONES_MASK: u32 = 3;
pub const NODES_MASK: u32 = 0;
pub const SECTIONS_MASK: u32 = 0;
pub const LAST_CPUPID_MASK: u32 = 0;
pub const KASAN_TAG_MASK: u32 = 0;
pub const ZONEID_MASK: u32 = 3;
pub const DEF_PRIORITY: u32 = 12;
pub const MAX_ZONES_PER_ZONELIST: u32 = 3;
pub const RCU_DONE_TAIL: u32 = 0;
pub const RCU_WAIT_TAIL: u32 = 1;
pub const RCU_NEXT_READY_TAIL: u32 = 2;
pub const RCU_NEXT_TAIL: u32 = 3;
pub const RCU_CBLIST_NSEGS: u32 = 4;
pub const RCU_FANOUT: u32 = 64;
pub const RCU_FANOUT_LEAF: u32 = 16;
pub const RCU_FANOUT_1: u32 = 16;
pub const RCU_FANOUT_2: u32 = 1024;
pub const RCU_FANOUT_3: u32 = 65536;
pub const RCU_FANOUT_4: u32 = 4194304;
pub const RCU_NUM_LVLS: u32 = 2;
pub const NUM_RCU_LVL_0: u32 = 1;
pub const SRCU_SIZE_SMALL: u32 = 0;
pub const SRCU_SIZE_ALLOC: u32 = 1;
pub const SRCU_SIZE_WAIT_BARRIER: u32 = 2;
pub const SRCU_SIZE_WAIT_CALL: u32 = 3;
pub const SRCU_SIZE_WAIT_CBS1: u32 = 4;
pub const SRCU_SIZE_WAIT_CBS2: u32 = 5;
pub const SRCU_SIZE_WAIT_CBS3: u32 = 6;
pub const SRCU_SIZE_WAIT_CBS4: u32 = 7;
pub const SRCU_SIZE_BIG: u32 = 8;
pub const SRCU_STATE_IDLE: u32 = 0;
pub const SRCU_STATE_SCAN1: u32 = 1;
pub const SRCU_STATE_SCAN2: u32 = 2;
pub const NOTIFY_DONE: u32 = 0;
pub const NOTIFY_OK: u32 = 1;
pub const NOTIFY_STOP_MASK: u32 = 32768;
pub const NOTIFY_BAD: u32 = 32770;
pub const NOTIFY_STOP: u32 = 32769;
pub const NETLINK_URELEASE: u32 = 1;
pub const KBD_KEYCODE: u32 = 1;
pub const KBD_UNBOUND_KEYCODE: u32 = 2;
pub const KBD_UNICODE: u32 = 3;
pub const KBD_KEYSYM: u32 = 4;
pub const KBD_POST_KEYSYM: u32 = 5;
pub const NUMA_ZONELIST_ORDER_LEN: u32 = 16;
pub const LOCAL_DISTANCE: u32 = 10;
pub const REMOTE_DISTANCE: u32 = 20;
pub const DISTANCE_BITS: u32 = 8;
pub const RECLAIM_DISTANCE: u32 = 30;
pub const PENALTY_FOR_NODE_WITH_CPUS: u32 = 1;
pub const GFP_MOVABLE_SHIFT: u32 = 3;
pub const GFP_ZONES_SHIFT: u32 = 2;
pub const CTL_MAXNAME: u32 = 10;
pub const UMH_NO_WAIT: u32 = 0;
pub const UMH_WAIT_EXEC: u32 = 1;
pub const UMH_WAIT_PROC: u32 = 2;
pub const UMH_KILLABLE: u32 = 4;
pub const UMH_FREEZABLE: u32 = 8;
pub const KMOD_PATH_LEN: u32 = 256;
pub const EM_NONE: u32 = 0;
pub const EM_M32: u32 = 1;
pub const EM_SPARC: u32 = 2;
pub const EM_386: u32 = 3;
pub const EM_68K: u32 = 4;
pub const EM_88K: u32 = 5;
pub const EM_486: u32 = 6;
pub const EM_860: u32 = 7;
pub const EM_MIPS: u32 = 8;
pub const EM_MIPS_RS3_LE: u32 = 10;
pub const EM_MIPS_RS4_BE: u32 = 10;
pub const EM_PARISC: u32 = 15;
pub const EM_SPARC32PLUS: u32 = 18;
pub const EM_PPC: u32 = 20;
pub const EM_PPC64: u32 = 21;
pub const EM_SPU: u32 = 23;
pub const EM_ARM: u32 = 40;
pub const EM_SH: u32 = 42;
pub const EM_SPARCV9: u32 = 43;
pub const EM_H8_300: u32 = 46;
pub const EM_IA_64: u32 = 50;
pub const EM_X86_64: u32 = 62;
pub const EM_S390: u32 = 22;
pub const EM_CRIS: u32 = 76;
pub const EM_M32R: u32 = 88;
pub const EM_MN10300: u32 = 89;
pub const EM_OPENRISC: u32 = 92;
pub const EM_ARCOMPACT: u32 = 93;
pub const EM_XTENSA: u32 = 94;
pub const EM_BLACKFIN: u32 = 106;
pub const EM_UNICORE: u32 = 110;
pub const EM_ALTERA_NIOS2: u32 = 113;
pub const EM_TI_C6000: u32 = 140;
pub const EM_HEXAGON: u32 = 164;
pub const EM_NDS32: u32 = 167;
pub const EM_AARCH64: u32 = 183;
pub const EM_TILEPRO: u32 = 188;
pub const EM_MICROBLAZE: u32 = 189;
pub const EM_TILEGX: u32 = 191;
pub const EM_ARCV2: u32 = 195;
pub const EM_RISCV: u32 = 243;
pub const EM_BPF: u32 = 247;
pub const EM_CSKY: u32 = 252;
pub const EM_LOONGARCH: u32 = 258;
pub const EM_FRV: u32 = 21569;
pub const EM_ALPHA: u32 = 36902;
pub const EM_CYGNUS_M32R: u32 = 36929;
pub const EM_S390_OLD: u32 = 41872;
pub const EM_CYGNUS_MN10300: u32 = 48879;
pub const PT_NULL: u32 = 0;
pub const PT_LOAD: u32 = 1;
pub const PT_DYNAMIC: u32 = 2;
pub const PT_INTERP: u32 = 3;
pub const PT_NOTE: u32 = 4;
pub const PT_SHLIB: u32 = 5;
pub const PT_PHDR: u32 = 6;
pub const PT_TLS: u32 = 7;
pub const PT_LOOS: u32 = 1610612736;
pub const PT_HIOS: u32 = 1879048191;
pub const PT_LOPROC: u32 = 1879048192;
pub const PT_HIPROC: u32 = 2147483647;
pub const PT_GNU_EH_FRAME: u32 = 1685382480;
pub const PT_GNU_STACK: u32 = 1685382481;
pub const PT_GNU_RELRO: u32 = 1685382482;
pub const PT_GNU_PROPERTY: u32 = 1685382483;
pub const PT_AARCH64_MEMTAG_MTE: u32 = 1879048194;
pub const PN_XNUM: u32 = 65535;
pub const ET_NONE: u32 = 0;
pub const ET_REL: u32 = 1;
pub const ET_EXEC: u32 = 2;
pub const ET_DYN: u32 = 3;
pub const ET_CORE: u32 = 4;
pub const ET_LOPROC: u32 = 65280;
pub const ET_HIPROC: u32 = 65535;
pub const DT_NULL: u32 = 0;
pub const DT_NEEDED: u32 = 1;
pub const DT_PLTRELSZ: u32 = 2;
pub const DT_PLTGOT: u32 = 3;
pub const DT_HASH: u32 = 4;
pub const DT_STRTAB: u32 = 5;
pub const DT_SYMTAB: u32 = 6;
pub const DT_RELA: u32 = 7;
pub const DT_RELASZ: u32 = 8;
pub const DT_RELAENT: u32 = 9;
pub const DT_STRSZ: u32 = 10;
pub const DT_SYMENT: u32 = 11;
pub const DT_INIT: u32 = 12;
pub const DT_FINI: u32 = 13;
pub const DT_SONAME: u32 = 14;
pub const DT_RPATH: u32 = 15;
pub const DT_SYMBOLIC: u32 = 16;
pub const DT_REL: u32 = 17;
pub const DT_RELSZ: u32 = 18;
pub const DT_RELENT: u32 = 19;
pub const DT_PLTREL: u32 = 20;
pub const DT_DEBUG: u32 = 21;
pub const DT_TEXTREL: u32 = 22;
pub const DT_JMPREL: u32 = 23;
pub const DT_ENCODING: u32 = 32;
pub const OLD_DT_LOOS: u32 = 1610612736;
pub const DT_LOOS: u32 = 1610612749;
pub const DT_HIOS: u32 = 1879044096;
pub const DT_VALRNGLO: u32 = 1879047424;
pub const DT_VALRNGHI: u32 = 1879047679;
pub const DT_ADDRRNGLO: u32 = 1879047680;
pub const DT_ADDRRNGHI: u32 = 1879047935;
pub const DT_VERSYM: u32 = 1879048176;
pub const DT_RELACOUNT: u32 = 1879048185;
pub const DT_RELCOUNT: u32 = 1879048186;
pub const DT_FLAGS_1: u32 = 1879048187;
pub const DT_VERDEF: u32 = 1879048188;
pub const DT_VERDEFNUM: u32 = 1879048189;
pub const DT_VERNEED: u32 = 1879048190;
pub const DT_VERNEEDNUM: u32 = 1879048191;
pub const OLD_DT_HIOS: u32 = 1879048191;
pub const DT_LOPROC: u32 = 1879048192;
pub const DT_HIPROC: u32 = 2147483647;
pub const STB_LOCAL: u32 = 0;
pub const STB_GLOBAL: u32 = 1;
pub const STB_WEAK: u32 = 2;
pub const STT_NOTYPE: u32 = 0;
pub const STT_OBJECT: u32 = 1;
pub const STT_FUNC: u32 = 2;
pub const STT_SECTION: u32 = 3;
pub const STT_FILE: u32 = 4;
pub const STT_COMMON: u32 = 5;
pub const STT_TLS: u32 = 6;
pub const EI_NIDENT: u32 = 16;
pub const PF_R: u32 = 4;
pub const PF_W: u32 = 2;
pub const PF_X: u32 = 1;
pub const SHT_NULL: u32 = 0;
pub const SHT_PROGBITS: u32 = 1;
pub const SHT_SYMTAB: u32 = 2;
pub const SHT_STRTAB: u32 = 3;
pub const SHT_RELA: u32 = 4;
pub const SHT_HASH: u32 = 5;
pub const SHT_DYNAMIC: u32 = 6;
pub const SHT_NOTE: u32 = 7;
pub const SHT_NOBITS: u32 = 8;
pub const SHT_REL: u32 = 9;
pub const SHT_SHLIB: u32 = 10;
pub const SHT_DYNSYM: u32 = 11;
pub const SHT_NUM: u32 = 12;
pub const SHT_LOPROC: u32 = 1879048192;
pub const SHT_HIPROC: u32 = 2147483647;
pub const SHT_LOUSER: u32 = 2147483648;
pub const SHT_HIUSER: u32 = 4294967295;
pub const SHF_WRITE: u32 = 1;
pub const SHF_ALLOC: u32 = 2;
pub const SHF_EXECINSTR: u32 = 4;
pub const SHF_RELA_LIVEPATCH: u32 = 1048576;
pub const SHF_RO_AFTER_INIT: u32 = 2097152;
pub const SHF_MASKPROC: u32 = 4026531840;
pub const SHN_UNDEF: u32 = 0;
pub const SHN_LORESERVE: u32 = 65280;
pub const SHN_LOPROC: u32 = 65280;
pub const SHN_HIPROC: u32 = 65311;
pub const SHN_LIVEPATCH: u32 = 65312;
pub const SHN_ABS: u32 = 65521;
pub const SHN_COMMON: u32 = 65522;
pub const SHN_HIRESERVE: u32 = 65535;
pub const EI_MAG0: u32 = 0;
pub const EI_MAG1: u32 = 1;
pub const EI_MAG2: u32 = 2;
pub const EI_MAG3: u32 = 3;
pub const EI_CLASS: u32 = 4;
pub const EI_DATA: u32 = 5;
pub const EI_VERSION: u32 = 6;
pub const EI_OSABI: u32 = 7;
pub const EI_PAD: u32 = 8;
pub const ELFMAG0: u32 = 127;
pub const ELFMAG1: u8 = 69u8;
pub const ELFMAG2: u8 = 76u8;
pub const ELFMAG3: u8 = 70u8;
pub const ELFMAG: &'static [u8; 5usize] = b"\x7FELF\0";
pub const SELFMAG: u32 = 4;
pub const ELFCLASSNONE: u32 = 0;
pub const ELFCLASS32: u32 = 1;
pub const ELFCLASS64: u32 = 2;
pub const ELFCLASSNUM: u32 = 3;
pub const ELFDATANONE: u32 = 0;
pub const ELFDATA2LSB: u32 = 1;
pub const ELFDATA2MSB: u32 = 2;
pub const EV_NONE: u32 = 0;
pub const EV_CURRENT: u32 = 1;
pub const EV_NUM: u32 = 2;
pub const ELFOSABI_NONE: u32 = 0;
pub const ELFOSABI_LINUX: u32 = 3;
pub const ELF_OSABI: u32 = 0;
pub const NT_PRSTATUS: u32 = 1;
pub const NT_PRFPREG: u32 = 2;
pub const NT_PRPSINFO: u32 = 3;
pub const NT_TASKSTRUCT: u32 = 4;
pub const NT_AUXV: u32 = 6;
pub const NT_SIGINFO: u32 = 1397311305;
pub const NT_FILE: u32 = 1179208773;
pub const NT_PRXFPREG: u32 = 1189489535;
pub const NT_PPC_VMX: u32 = 256;
pub const NT_PPC_SPE: u32 = 257;
pub const NT_PPC_VSX: u32 = 258;
pub const NT_PPC_TAR: u32 = 259;
pub const NT_PPC_PPR: u32 = 260;
pub const NT_PPC_DSCR: u32 = 261;
pub const NT_PPC_EBB: u32 = 262;
pub const NT_PPC_PMU: u32 = 263;
pub const NT_PPC_TM_CGPR: u32 = 264;
pub const NT_PPC_TM_CFPR: u32 = 265;
pub const NT_PPC_TM_CVMX: u32 = 266;
pub const NT_PPC_TM_CVSX: u32 = 267;
pub const NT_PPC_TM_SPR: u32 = 268;
pub const NT_PPC_TM_CTAR: u32 = 269;
pub const NT_PPC_TM_CPPR: u32 = 270;
pub const NT_PPC_TM_CDSCR: u32 = 271;
pub const NT_PPC_PKEY: u32 = 272;
pub const NT_386_TLS: u32 = 512;
pub const NT_386_IOPERM: u32 = 513;
pub const NT_X86_XSTATE: u32 = 514;
pub const NT_S390_HIGH_GPRS: u32 = 768;
pub const NT_S390_TIMER: u32 = 769;
pub const NT_S390_TODCMP: u32 = 770;
pub const NT_S390_TODPREG: u32 = 771;
pub const NT_S390_CTRS: u32 = 772;
pub const NT_S390_PREFIX: u32 = 773;
pub const NT_S390_LAST_BREAK: u32 = 774;
pub const NT_S390_SYSTEM_CALL: u32 = 775;
pub const NT_S390_TDB: u32 = 776;
pub const NT_S390_VXRS_LOW: u32 = 777;
pub const NT_S390_VXRS_HIGH: u32 = 778;
pub const NT_S390_GS_CB: u32 = 779;
pub const NT_S390_GS_BC: u32 = 780;
pub const NT_S390_RI_CB: u32 = 781;
pub const NT_S390_PV_CPU_DATA: u32 = 782;
pub const NT_ARM_VFP: u32 = 1024;
pub const NT_ARM_TLS: u32 = 1025;
pub const NT_ARM_HW_BREAK: u32 = 1026;
pub const NT_ARM_HW_WATCH: u32 = 1027;
pub const NT_ARM_SYSTEM_CALL: u32 = 1028;
pub const NT_ARM_SVE: u32 = 1029;
pub const NT_ARM_PAC_MASK: u32 = 1030;
pub const NT_ARM_PACA_KEYS: u32 = 1031;
pub const NT_ARM_PACG_KEYS: u32 = 1032;
pub const NT_ARM_TAGGED_ADDR_CTRL: u32 = 1033;
pub const NT_ARM_PAC_ENABLED_KEYS: u32 = 1034;
pub const NT_ARM_SSVE: u32 = 1035;
pub const NT_ARM_ZA: u32 = 1036;
pub const NT_ARC_V2: u32 = 1536;
pub const NT_VMCOREDD: u32 = 1792;
pub const NT_MIPS_DSP: u32 = 2048;
pub const NT_MIPS_FP_MODE: u32 = 2049;
pub const NT_MIPS_MSA: u32 = 2050;
pub const NT_LOONGARCH_CPUCFG: u32 = 2560;
pub const NT_LOONGARCH_CSR: u32 = 2561;
pub const NT_LOONGARCH_LSX: u32 = 2562;
pub const NT_LOONGARCH_LASX: u32 = 2563;
pub const NT_LOONGARCH_LBT: u32 = 2564;
pub const NT_GNU_PROPERTY_TYPE_0: u32 = 5;
pub const GNU_PROPERTY_AARCH64_FEATURE_1_AND: u32 = 3221225472;
pub const GNU_PROPERTY_AARCH64_FEATURE_1_BTI: u32 = 1;
pub const IPC_CREAT: u32 = 512;
pub const IPC_EXCL: u32 = 1024;
pub const IPC_NOWAIT: u32 = 2048;
pub const IPC_DIPC: u32 = 4096;
pub const IPC_OWN: u32 = 8192;
pub const IPC_RMID: u32 = 0;
pub const IPC_SET: u32 = 1;
pub const IPC_STAT: u32 = 2;
pub const IPC_INFO: u32 = 3;
pub const IPC_OLD: u32 = 0;
pub const IPC_64: u32 = 256;
pub const SEMOP: u32 = 1;
pub const SEMGET: u32 = 2;
pub const SEMCTL: u32 = 3;
pub const SEMTIMEDOP: u32 = 4;
pub const MSGSND: u32 = 11;
pub const MSGRCV: u32 = 12;
pub const MSGGET: u32 = 13;
pub const MSGCTL: u32 = 14;
pub const SHMAT: u32 = 21;
pub const SHMDT: u32 = 22;
pub const SHMGET: u32 = 23;
pub const SHMCTL: u32 = 24;
pub const DIPC: u32 = 25;
pub const SEM_UNDO: u32 = 4096;
pub const GETPID: u32 = 11;
pub const GETVAL: u32 = 12;
pub const GETALL: u32 = 13;
pub const GETNCNT: u32 = 14;
pub const GETZCNT: u32 = 15;
pub const SETVAL: u32 = 16;
pub const SETALL: u32 = 17;
pub const SEM_STAT: u32 = 18;
pub const SEM_INFO: u32 = 19;
pub const SEM_STAT_ANY: u32 = 20;
pub const SEMMNI: u32 = 32000;
pub const SEMMSL: u32 = 32000;
pub const SEMMNS: u32 = 1024000000;
pub const SEMOPM: u32 = 500;
pub const SEMVMX: u32 = 32767;
pub const SEMAEM: u32 = 32767;
pub const SEMUME: u32 = 500;
pub const SEMMNU: u32 = 1024000000;
pub const SEMMAP: u32 = 1024000000;
pub const SEMUSZ: u32 = 20;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP_OLD: u32 = 35078;
pub const SIOCGSTAMPNS_OLD: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO_OLD: u32 = 20;
pub const SO_SNDTIMEO_OLD: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_MARK: u32 = 36;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const SO_ATTACH_REUSEPORT_CBPF: u32 = 51;
pub const SO_ATTACH_REUSEPORT_EBPF: u32 = 52;
pub const SO_CNX_ADVICE: u32 = 53;
pub const SCM_TIMESTAMPING_OPT_STATS: u32 = 54;
pub const SO_MEMINFO: u32 = 55;
pub const SO_INCOMING_NAPI_ID: u32 = 56;
pub const SO_COOKIE: u32 = 57;
pub const SCM_TIMESTAMPING_PKTINFO: u32 = 58;
pub const SO_PEERGROUPS: u32 = 59;
pub const SO_ZEROCOPY: u32 = 60;
pub const SO_TXTIME: u32 = 61;
pub const SCM_TXTIME: u32 = 61;
pub const SO_BINDTOIFINDEX: u32 = 62;
pub const SO_TIMESTAMP_OLD: u32 = 29;
pub const SO_TIMESTAMPNS_OLD: u32 = 35;
pub const SO_TIMESTAMPING_OLD: u32 = 37;
pub const SO_TIMESTAMP_NEW: u32 = 63;
pub const SO_TIMESTAMPNS_NEW: u32 = 64;
pub const SO_TIMESTAMPING_NEW: u32 = 65;
pub const SO_RCVTIMEO_NEW: u32 = 66;
pub const SO_SNDTIMEO_NEW: u32 = 67;
pub const SO_DETACH_REUSEPORT_BPF: u32 = 68;
pub const SO_PREFER_BUSY_POLL: u32 = 69;
pub const SO_BUSY_POLL_BUDGET: u32 = 70;
pub const SO_NETNS_COOKIE: u32 = 71;
pub const SO_BUF_LOCK: u32 = 72;
pub const SO_RESERVE_MEM: u32 = 73;
pub const SO_TXREHASH: u32 = 74;
pub const SO_RCVMARK: u32 = 75;
pub const SOCK_IOC_TYPE: u32 = 137;
pub const SIOCGSTAMP: u32 = 35078;
pub const SIOCGSTAMPNS: u32 = 35079;
pub const SIOCADDRT: u32 = 35083;
pub const SIOCDELRT: u32 = 35084;
pub const SIOCRTMSG: u32 = 35085;
pub const SIOCGIFNAME: u32 = 35088;
pub const SIOCSIFLINK: u32 = 35089;
pub const SIOCGIFCONF: u32 = 35090;
pub const SIOCGIFFLAGS: u32 = 35091;
pub const SIOCSIFFLAGS: u32 = 35092;
pub const SIOCGIFADDR: u32 = 35093;
pub const SIOCSIFADDR: u32 = 35094;
pub const SIOCGIFDSTADDR: u32 = 35095;
pub const SIOCSIFDSTADDR: u32 = 35096;
pub const SIOCGIFBRDADDR: u32 = 35097;
pub const SIOCSIFBRDADDR: u32 = 35098;
pub const SIOCGIFNETMASK: u32 = 35099;
pub const SIOCSIFNETMASK: u32 = 35100;
pub const SIOCGIFMETRIC: u32 = 35101;
pub const SIOCSIFMETRIC: u32 = 35102;
pub const SIOCGIFMEM: u32 = 35103;
pub const SIOCSIFMEM: u32 = 35104;
pub const SIOCGIFMTU: u32 = 35105;
pub const SIOCSIFMTU: u32 = 35106;
pub const SIOCSIFNAME: u32 = 35107;
pub const SIOCSIFHWADDR: u32 = 35108;
pub const SIOCGIFENCAP: u32 = 35109;
pub const SIOCSIFENCAP: u32 = 35110;
pub const SIOCGIFHWADDR: u32 = 35111;
pub const SIOCGIFSLAVE: u32 = 35113;
pub const SIOCSIFSLAVE: u32 = 35120;
pub const SIOCADDMULTI: u32 = 35121;
pub const SIOCDELMULTI: u32 = 35122;
pub const SIOCGIFINDEX: u32 = 35123;
pub const SIOGIFINDEX: u32 = 35123;
pub const SIOCSIFPFLAGS: u32 = 35124;
pub const SIOCGIFPFLAGS: u32 = 35125;
pub const SIOCDIFADDR: u32 = 35126;
pub const SIOCSIFHWBROADCAST: u32 = 35127;
pub const SIOCGIFCOUNT: u32 = 35128;
pub const SIOCGIFBR: u32 = 35136;
pub const SIOCSIFBR: u32 = 35137;
pub const SIOCGIFTXQLEN: u32 = 35138;
pub const SIOCSIFTXQLEN: u32 = 35139;
pub const SIOCETHTOOL: u32 = 35142;
pub const SIOCGMIIPHY: u32 = 35143;
pub const SIOCGMIIREG: u32 = 35144;
pub const SIOCSMIIREG: u32 = 35145;
pub const SIOCWANDEV: u32 = 35146;
pub const SIOCOUTQNSD: u32 = 35147;
pub const SIOCGSKNS: u32 = 35148;
pub const SIOCDARP: u32 = 35155;
pub const SIOCGARP: u32 = 35156;
pub const SIOCSARP: u32 = 35157;
pub const SIOCDRARP: u32 = 35168;
pub const SIOCGRARP: u32 = 35169;
pub const SIOCSRARP: u32 = 35170;
pub const SIOCGIFMAP: u32 = 35184;
pub const SIOCSIFMAP: u32 = 35185;
pub const SIOCADDDLCI: u32 = 35200;
pub const SIOCDELDLCI: u32 = 35201;
pub const SIOCGIFVLAN: u32 = 35202;
pub const SIOCSIFVLAN: u32 = 35203;
pub const SIOCBONDENSLAVE: u32 = 35216;
pub const SIOCBONDRELEASE: u32 = 35217;
pub const SIOCBONDSETHWADDR: u32 = 35218;
pub const SIOCBONDSLAVEINFOQUERY: u32 = 35219;
pub const SIOCBONDINFOQUERY: u32 = 35220;
pub const SIOCBONDCHANGEACTIVE: u32 = 35221;
pub const SIOCBRADDBR: u32 = 35232;
pub const SIOCBRDELBR: u32 = 35233;
pub const SIOCBRADDIF: u32 = 35234;
pub const SIOCBRDELIF: u32 = 35235;
pub const SIOCSHWTSTAMP: u32 = 35248;
pub const SIOCGHWTSTAMP: u32 = 35249;
pub const SIOCDEVPRIVATE: u32 = 35312;
pub const SIOCPROTOPRIVATE: u32 = 35296;
pub const UIO_FASTIOV: u32 = 8;
pub const UIO_MAXIOV: u32 = 1024;
pub const _K_SS_MAXSIZE: u32 = 128;
pub const SOCK_SNDBUF_LOCK: u32 = 1;
pub const SOCK_RCVBUF_LOCK: u32 = 2;
pub const SOCK_BUF_LOCK_MASK: u32 = 3;
pub const SOCK_TXREHASH_DEFAULT: u32 = 255;
pub const SOCK_TXREHASH_DISABLED: u32 = 0;
pub const SOCK_TXREHASH_ENABLED: u32 = 1;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_CREDENTIALS: u32 = 2;
pub const SCM_SECURITY: u32 = 3;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_KCM: u32 = 41;
pub const AF_QIPCRTR: u32 = 42;
pub const AF_SMC: u32 = 43;
pub const AF_XDP: u32 = 44;
pub const AF_MCTP: u32 = 45;
pub const AF_MAX: u32 = 46;
pub const PF_UNSPEC: u32 = 0;
pub const PF_UNIX: u32 = 1;
pub const PF_LOCAL: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_KCM: u32 = 41;
pub const PF_QIPCRTR: u32 = 42;
pub const PF_SMC: u32 = 43;
pub const PF_XDP: u32 = 44;
pub const PF_MCTP: u32 = 45;
pub const PF_MAX: u32 = 46;
pub const SOMAXCONN: u32 = 4096;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_TRYHARD: u32 = 4;
pub const MSG_CTRUNC: u32 = 8;
pub const MSG_PROBE: u32 = 16;
pub const MSG_TRUNC: u32 = 32;
pub const MSG_DONTWAIT: u32 = 64;
pub const MSG_EOR: u32 = 128;
pub const MSG_WAITALL: u32 = 256;
pub const MSG_FIN: u32 = 512;
pub const MSG_SYN: u32 = 1024;
pub const MSG_CONFIRM: u32 = 2048;
pub const MSG_RST: u32 = 4096;
pub const MSG_ERRQUEUE: u32 = 8192;
pub const MSG_NOSIGNAL: u32 = 16384;
pub const MSG_MORE: u32 = 32768;
pub const MSG_WAITFORONE: u32 = 65536;
pub const MSG_SENDPAGE_NOPOLICY: u32 = 65536;
pub const MSG_SENDPAGE_NOTLAST: u32 = 131072;
pub const MSG_BATCH: u32 = 262144;
pub const MSG_EOF: u32 = 512;
pub const MSG_NO_SHARED_FRAGS: u32 = 524288;
pub const MSG_SENDPAGE_DECRYPTED: u32 = 1048576;
pub const MSG_ZEROCOPY: u32 = 67108864;
pub const MSG_FASTOPEN: u32 = 536870912;
pub const MSG_CMSG_CLOEXEC: u32 = 1073741824;
pub const MSG_CMSG_COMPAT: u32 = 2147483648;
pub const SOL_IP: u32 = 0;
pub const SOL_TCP: u32 = 6;
pub const SOL_UDP: u32 = 17;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const SOL_SCTP: u32 = 132;
pub const SOL_UDPLITE: u32 = 136;
pub const SOL_RAW: u32 = 255;
pub const SOL_IPX: u32 = 256;
pub const SOL_AX25: u32 = 257;
pub const SOL_ATALK: u32 = 258;
pub const SOL_NETROM: u32 = 259;
pub const SOL_ROSE: u32 = 260;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOL_NETBEUI: u32 = 267;
pub const SOL_LLC: u32 = 268;
pub const SOL_DCCP: u32 = 269;
pub const SOL_NETLINK: u32 = 270;
pub const SOL_TIPC: u32 = 271;
pub const SOL_RXRPC: u32 = 272;
pub const SOL_PPPOL2TP: u32 = 273;
pub const SOL_BLUETOOTH: u32 = 274;
pub const SOL_PNPIPE: u32 = 275;
pub const SOL_RDS: u32 = 276;
pub const SOL_IUCV: u32 = 277;
pub const SOL_CAIF: u32 = 278;
pub const SOL_ALG: u32 = 279;
pub const SOL_NFC: u32 = 280;
pub const SOL_KCM: u32 = 281;
pub const SOL_TLS: u32 = 282;
pub const SOL_XDP: u32 = 283;
pub const SOL_MPTCP: u32 = 284;
pub const SOL_MCTP: u32 = 285;
pub const SOL_SMC: u32 = 286;
pub const IPX_TYPE: u32 = 1;
pub const __UAPI_DEF_IF_IFCONF: u32 = 1;
pub const __UAPI_DEF_IF_IFMAP: u32 = 1;
pub const __UAPI_DEF_IF_IFNAMSIZ: u32 = 1;
pub const __UAPI_DEF_IF_IFREQ: u32 = 1;
pub const __UAPI_DEF_IF_NET_DEVICE_FLAGS: u32 = 1;
pub const __UAPI_DEF_IF_NET_DEVICE_FLAGS_LOWER_UP_DORMANT_ECHO: u32 = 1;
pub const __UAPI_DEF_IN_ADDR: u32 = 1;
pub const __UAPI_DEF_IN_IPPROTO: u32 = 1;
pub const __UAPI_DEF_IN_PKTINFO: u32 = 1;
pub const __UAPI_DEF_IP_MREQ: u32 = 1;
pub const __UAPI_DEF_SOCKADDR_IN: u32 = 1;
pub const __UAPI_DEF_IN_CLASS: u32 = 1;
pub const __UAPI_DEF_IN6_ADDR: u32 = 1;
pub const __UAPI_DEF_IN6_ADDR_ALT: u32 = 1;
pub const __UAPI_DEF_SOCKADDR_IN6: u32 = 1;
pub const __UAPI_DEF_IPV6_MREQ: u32 = 1;
pub const __UAPI_DEF_IPPROTO_V6: u32 = 1;
pub const __UAPI_DEF_IPV6_OPTIONS: u32 = 1;
pub const __UAPI_DEF_IN6_PKTINFO: u32 = 1;
pub const __UAPI_DEF_IP6_MTUINFO: u32 = 1;
pub const __UAPI_DEF_SOCKADDR_IPX: u32 = 1;
pub const __UAPI_DEF_IPX_ROUTE_DEFINITION: u32 = 1;
pub const __UAPI_DEF_IPX_INTERFACE_DEFINITION: u32 = 1;
pub const __UAPI_DEF_IPX_CONFIG_DATA: u32 = 1;
pub const __UAPI_DEF_IPX_ROUTE_DEF: u32 = 1;
pub const __UAPI_DEF_XATTR: u32 = 1;
pub const IFNAMSIZ: u32 = 16;
pub const IFALIASZ: u32 = 256;
pub const ALTIFNAMSIZ: u32 = 128;
pub const GENERIC_HDLC_VERSION: u32 = 4;
pub const CLOCK_DEFAULT: u32 = 0;
pub const CLOCK_EXT: u32 = 1;
pub const CLOCK_INT: u32 = 2;
pub const CLOCK_TXINT: u32 = 3;
pub const CLOCK_TXFROMRX: u32 = 4;
pub const ENCODING_DEFAULT: u32 = 0;
pub const ENCODING_NRZ: u32 = 1;
pub const ENCODING_NRZI: u32 = 2;
pub const ENCODING_FM_MARK: u32 = 3;
pub const ENCODING_FM_SPACE: u32 = 4;
pub const ENCODING_MANCHESTER: u32 = 5;
pub const PARITY_DEFAULT: u32 = 0;
pub const PARITY_NONE: u32 = 1;
pub const PARITY_CRC16_PR0: u32 = 2;
pub const PARITY_CRC16_PR1: u32 = 3;
pub const PARITY_CRC16_PR0_CCITT: u32 = 4;
pub const PARITY_CRC16_PR1_CCITT: u32 = 5;
pub const PARITY_CRC32_PR0_CCITT: u32 = 6;
pub const PARITY_CRC32_PR1_CCITT: u32 = 7;
pub const LMI_DEFAULT: u32 = 0;
pub const LMI_NONE: u32 = 1;
pub const LMI_ANSI: u32 = 2;
pub const LMI_CCITT: u32 = 3;
pub const LMI_CISCO: u32 = 4;
pub const IF_GET_IFACE: u32 = 1;
pub const IF_GET_PROTO: u32 = 2;
pub const IF_IFACE_V35: u32 = 4096;
pub const IF_IFACE_V24: u32 = 4097;
pub const IF_IFACE_X21: u32 = 4098;
pub const IF_IFACE_T1: u32 = 4099;
pub const IF_IFACE_E1: u32 = 4100;
pub const IF_IFACE_SYNC_SERIAL: u32 = 4101;
pub const IF_IFACE_X21D: u32 = 4102;
pub const IF_PROTO_HDLC: u32 = 8192;
pub const IF_PROTO_PPP: u32 = 8193;
pub const IF_PROTO_CISCO: u32 = 8194;
pub const IF_PROTO_FR: u32 = 8195;
pub const IF_PROTO_FR_ADD_PVC: u32 = 8196;
pub const IF_PROTO_FR_DEL_PVC: u32 = 8197;
pub const IF_PROTO_X25: u32 = 8198;
pub const IF_PROTO_HDLC_ETH: u32 = 8199;
pub const IF_PROTO_FR_ADD_ETH_PVC: u32 = 8200;
pub const IF_PROTO_FR_DEL_ETH_PVC: u32 = 8201;
pub const IF_PROTO_FR_PVC: u32 = 8202;
pub const IF_PROTO_FR_ETH_PVC: u32 = 8203;
pub const IF_PROTO_RAW: u32 = 8204;
pub const IFHWADDRLEN: u32 = 6;
pub const MINORBITS: u32 = 20;
pub const MINORMASK: u32 = 1048575;
pub const LIST_BL_LOCKMASK: u32 = 1;
pub const GOLDEN_RATIO_32: u32 = 1640531527;
pub const GOLDEN_RATIO_64: u64 = 7046029254386353131;
pub const DNAME_INLINE_LEN: u32 = 32;
pub const DCACHE_OP_HASH: u32 = 1;
pub const DCACHE_OP_COMPARE: u32 = 2;
pub const DCACHE_OP_REVALIDATE: u32 = 4;
pub const DCACHE_OP_DELETE: u32 = 8;
pub const DCACHE_OP_PRUNE: u32 = 16;
pub const DCACHE_DISCONNECTED: u32 = 32;
pub const DCACHE_REFERENCED: u32 = 64;
pub const DCACHE_DONTCACHE: u32 = 128;
pub const DCACHE_CANT_MOUNT: u32 = 256;
pub const DCACHE_GENOCIDE: u32 = 512;
pub const DCACHE_SHRINK_LIST: u32 = 1024;
pub const DCACHE_OP_WEAK_REVALIDATE: u32 = 2048;
pub const DCACHE_NFSFS_RENAMED: u32 = 4096;
pub const DCACHE_COOKIE: u32 = 8192;
pub const DCACHE_FSNOTIFY_PARENT_WATCHED: u32 = 16384;
pub const DCACHE_DENTRY_KILLED: u32 = 32768;
pub const DCACHE_MOUNTED: u32 = 65536;
pub const DCACHE_NEED_AUTOMOUNT: u32 = 131072;
pub const DCACHE_MANAGE_TRANSIT: u32 = 262144;
pub const DCACHE_MANAGED_DENTRY: u32 = 458752;
pub const DCACHE_LRU_LIST: u32 = 524288;
pub const DCACHE_ENTRY_TYPE: u32 = 7340032;
pub const DCACHE_MISS_TYPE: u32 = 0;
pub const DCACHE_WHITEOUT_TYPE: u32 = 1048576;
pub const DCACHE_DIRECTORY_TYPE: u32 = 2097152;
pub const DCACHE_AUTODIR_TYPE: u32 = 3145728;
pub const DCACHE_REGULAR_TYPE: u32 = 4194304;
pub const DCACHE_SPECIAL_TYPE: u32 = 5242880;
pub const DCACHE_SYMLINK_TYPE: u32 = 6291456;
pub const DCACHE_MAY_FREE: u32 = 8388608;
pub const DCACHE_FALLTHRU: u32 = 16777216;
pub const DCACHE_NOKEY_NAME: u32 = 33554432;
pub const DCACHE_OP_REAL: u32 = 67108864;
pub const DCACHE_PAR_LOOKUP: u32 = 268435456;
pub const DCACHE_DENTRY_CURSOR: u32 = 536870912;
pub const DCACHE_NORCU: u32 = 1073741824;
pub const SHRINK_STOP: i32 = -1;
pub const SHRINK_EMPTY: i32 = -2;
pub const DEFAULT_SEEKS: u32 = 2;
pub const SHRINKER_REGISTERED: u32 = 1;
pub const SHRINKER_NUMA_AWARE: u32 = 2;
pub const SHRINKER_MEMCG_AWARE: u32 = 4;
pub const SHRINKER_NONSLAB: u32 = 8;
pub const CSIGNAL: u32 = 255;
pub const CLONE_VM: u32 = 256;
pub const CLONE_FS: u32 = 512;
pub const CLONE_FILES: u32 = 1024;
pub const CLONE_SIGHAND: u32 = 2048;
pub const CLONE_PIDFD: u32 = 4096;
pub const CLONE_PTRACE: u32 = 8192;
pub const CLONE_VFORK: u32 = 16384;
pub const CLONE_PARENT: u32 = 32768;
pub const CLONE_THREAD: u32 = 65536;
pub const CLONE_NEWNS: u32 = 131072;
pub const CLONE_SYSVSEM: u32 = 262144;
pub const CLONE_SETTLS: u32 = 524288;
pub const CLONE_PARENT_SETTID: u32 = 1048576;
pub const CLONE_CHILD_CLEARTID: u32 = 2097152;
pub const CLONE_DETACHED: u32 = 4194304;
pub const CLONE_UNTRACED: u32 = 8388608;
pub const CLONE_CHILD_SETTID: u32 = 16777216;
pub const CLONE_NEWCGROUP: u32 = 33554432;
pub const CLONE_NEWUTS: u32 = 67108864;
pub const CLONE_NEWIPC: u32 = 134217728;
pub const CLONE_NEWUSER: u32 = 268435456;
pub const CLONE_NEWPID: u32 = 536870912;
pub const CLONE_NEWNET: u32 = 1073741824;
pub const CLONE_IO: u32 = 2147483648;
pub const CLONE_CLEAR_SIGHAND: u64 = 4294967296;
pub const CLONE_INTO_CGROUP: u64 = 8589934592;
pub const CLONE_NEWTIME: u32 = 128;
pub const CLONE_ARGS_SIZE_VER0: u32 = 64;
pub const CLONE_ARGS_SIZE_VER1: u32 = 80;
pub const CLONE_ARGS_SIZE_VER2: u32 = 88;
pub const SCHED_NORMAL: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const SCHED_BATCH: u32 = 3;
pub const SCHED_IDLE: u32 = 5;
pub const SCHED_DEADLINE: u32 = 6;
pub const SCHED_RESET_ON_FORK: u32 = 1073741824;
pub const SCHED_FLAG_RESET_ON_FORK: u32 = 1;
pub const SCHED_FLAG_RECLAIM: u32 = 2;
pub const SCHED_FLAG_DL_OVERRUN: u32 = 4;
pub const SCHED_FLAG_KEEP_POLICY: u32 = 8;
pub const SCHED_FLAG_KEEP_PARAMS: u32 = 16;
pub const SCHED_FLAG_UTIL_CLAMP_MIN: u32 = 32;
pub const SCHED_FLAG_UTIL_CLAMP_MAX: u32 = 64;
pub const SCHED_FLAG_KEEP_ALL: u32 = 24;
pub const SCHED_FLAG_UTIL_CLAMP: u32 = 96;
pub const SCHED_FLAG_ALL: u32 = 127;
pub const HUGETLB_FLAG_ENCODE_SHIFT: u32 = 26;
pub const HUGETLB_FLAG_ENCODE_MASK: u32 = 63;
pub const HUGETLB_FLAG_ENCODE_16KB: u32 = 939524096;
pub const HUGETLB_FLAG_ENCODE_64KB: u32 = 1073741824;
pub const HUGETLB_FLAG_ENCODE_512KB: u32 = 1275068416;
pub const HUGETLB_FLAG_ENCODE_1MB: u32 = 1342177280;
pub const HUGETLB_FLAG_ENCODE_2MB: u32 = 1409286144;
pub const HUGETLB_FLAG_ENCODE_8MB: u32 = 1543503872;
pub const HUGETLB_FLAG_ENCODE_16MB: u32 = 1610612736;
pub const HUGETLB_FLAG_ENCODE_32MB: u32 = 1677721600;
pub const HUGETLB_FLAG_ENCODE_256MB: u32 = 1879048192;
pub const HUGETLB_FLAG_ENCODE_512MB: u32 = 1946157056;
pub const HUGETLB_FLAG_ENCODE_1GB: u32 = 2013265920;
pub const HUGETLB_FLAG_ENCODE_2GB: u32 = 2080374784;
pub const HUGETLB_FLAG_ENCODE_16GB: u32 = 2281701376;
pub const SHMMIN: u32 = 1;
pub const SHMMNI: u32 = 4096;
pub const SHMMAX: i32 = -16777217;
pub const SHMALL: i32 = -16777217;
pub const SHMSEG: u32 = 4096;
pub const SHM_R: u32 = 256;
pub const SHM_W: u32 = 128;
pub const SHM_HUGETLB: u32 = 2048;
pub const SHM_NORESERVE: u32 = 4096;
pub const SHM_HUGE_SHIFT: u32 = 26;
pub const SHM_HUGE_MASK: u32 = 63;
pub const SHM_HUGE_64KB: u32 = 1073741824;
pub const SHM_HUGE_512KB: u32 = 1275068416;
pub const SHM_HUGE_1MB: u32 = 1342177280;
pub const SHM_HUGE_2MB: u32 = 1409286144;
pub const SHM_HUGE_8MB: u32 = 1543503872;
pub const SHM_HUGE_16MB: u32 = 1610612736;
pub const SHM_HUGE_32MB: u32 = 1677721600;
pub const SHM_HUGE_256MB: u32 = 1879048192;
pub const SHM_HUGE_512MB: u32 = 1946157056;
pub const SHM_HUGE_1GB: u32 = 2013265920;
pub const SHM_HUGE_2GB: u32 = 2080374784;
pub const SHM_HUGE_16GB: u32 = 2281701376;
pub const SHM_RDONLY: u32 = 4096;
pub const SHM_RND: u32 = 8192;
pub const SHM_REMAP: u32 = 16384;
pub const SHM_EXEC: u32 = 32768;
pub const SHM_LOCK: u32 = 11;
pub const SHM_UNLOCK: u32 = 12;
pub const SHM_STAT: u32 = 13;
pub const SHM_INFO: u32 = 14;
pub const SHM_STAT_ANY: u32 = 15;
pub const KMSAN_RETVAL_SIZE: u32 = 800;
pub const KMSAN_PARAM_SIZE: u32 = 800;
pub const HIGH_RES_NSEC: u32 = 1;
pub const KTIME_HIGH_RES: u32 = 1;
pub const MONOTONIC_RES_NSEC: u32 = 1;
pub const KTIME_MONOTONIC_RES: u32 = 1;
pub const HRTIMER_STATE_INACTIVE: u32 = 0;
pub const HRTIMER_STATE_ENQUEUED: u32 = 1;
pub const SECCOMP_MODE_DISABLED: u32 = 0;
pub const SECCOMP_MODE_STRICT: u32 = 1;
pub const SECCOMP_MODE_FILTER: u32 = 2;
pub const SECCOMP_SET_MODE_STRICT: u32 = 0;
pub const SECCOMP_SET_MODE_FILTER: u32 = 1;
pub const SECCOMP_GET_ACTION_AVAIL: u32 = 2;
pub const SECCOMP_GET_NOTIF_SIZES: u32 = 3;
pub const SECCOMP_FILTER_FLAG_TSYNC: u32 = 1;
pub const SECCOMP_FILTER_FLAG_LOG: u32 = 2;
pub const SECCOMP_FILTER_FLAG_SPEC_ALLOW: u32 = 4;
pub const SECCOMP_FILTER_FLAG_NEW_LISTENER: u32 = 8;
pub const SECCOMP_FILTER_FLAG_TSYNC_ESRCH: u32 = 16;
pub const SECCOMP_FILTER_FLAG_WAIT_KILLABLE_RECV: u32 = 32;
pub const SECCOMP_RET_KILL_PROCESS: u32 = 2147483648;
pub const SECCOMP_RET_KILL_THREAD: u32 = 0;
pub const SECCOMP_RET_KILL: u32 = 0;
pub const SECCOMP_RET_TRAP: u32 = 196608;
pub const SECCOMP_RET_ERRNO: u32 = 327680;
pub const SECCOMP_RET_USER_NOTIF: u32 = 2143289344;
pub const SECCOMP_RET_TRACE: u32 = 2146435072;
pub const SECCOMP_RET_LOG: u32 = 2147221504;
pub const SECCOMP_RET_ALLOW: u32 = 2147418112;
pub const SECCOMP_RET_ACTION_FULL: u32 = 4294901760;
pub const SECCOMP_RET_ACTION: u32 = 2147418112;
pub const SECCOMP_RET_DATA: u32 = 65535;
pub const SECCOMP_USER_NOTIF_FLAG_CONTINUE: u32 = 1;
pub const SECCOMP_ADDFD_FLAG_SETFD: u32 = 1;
pub const SECCOMP_ADDFD_FLAG_SEND: u32 = 2;
pub const SECCOMP_IOC_MAGIC: u8 = 33u8;
pub const SECCOMP_FILTER_FLAG_MASK: u32 = 63;
pub const SECCOMP_NOTIFY_ADDFD_SIZE_VER0: u32 = 24;
pub const SECCOMP_NOTIFY_ADDFD_SIZE_LATEST: u32 = 24;
pub const __NR_io_setup: u32 = 0;
pub const __NR_io_destroy: u32 = 1;
pub const __NR_io_submit: u32 = 2;
pub const __NR_io_cancel: u32 = 3;
pub const __NR_io_getevents: u32 = 4;
pub const __NR_setxattr: u32 = 5;
pub const __NR_lsetxattr: u32 = 6;
pub const __NR_fsetxattr: u32 = 7;
pub const __NR_getxattr: u32 = 8;
pub const __NR_lgetxattr: u32 = 9;
pub const __NR_fgetxattr: u32 = 10;
pub const __NR_listxattr: u32 = 11;
pub const __NR_llistxattr: u32 = 12;
pub const __NR_flistxattr: u32 = 13;
pub const __NR_removexattr: u32 = 14;
pub const __NR_lremovexattr: u32 = 15;
pub const __NR_fremovexattr: u32 = 16;
pub const __NR_getcwd: u32 = 17;
pub const __NR_lookup_dcookie: u32 = 18;
pub const __NR_eventfd2: u32 = 19;
pub const __NR_epoll_create1: u32 = 20;
pub const __NR_epoll_ctl: u32 = 21;
pub const __NR_epoll_pwait: u32 = 22;
pub const __NR_dup: u32 = 23;
pub const __NR_dup3: u32 = 24;
pub const __NR3264_fcntl: u32 = 25;
pub const __NR_inotify_init1: u32 = 26;
pub const __NR_inotify_add_watch: u32 = 27;
pub const __NR_inotify_rm_watch: u32 = 28;
pub const __NR_ioctl: u32 = 29;
pub const __NR_ioprio_set: u32 = 30;
pub const __NR_ioprio_get: u32 = 31;
pub const __NR_flock: u32 = 32;
pub const __NR_mknodat: u32 = 33;
pub const __NR_mkdirat: u32 = 34;
pub const __NR_unlinkat: u32 = 35;
pub const __NR_symlinkat: u32 = 36;
pub const __NR_linkat: u32 = 37;
pub const __NR_umount2: u32 = 39;
pub const __NR_mount: u32 = 40;
pub const __NR_pivot_root: u32 = 41;
pub const __NR_nfsservctl: u32 = 42;
pub const __NR3264_statfs: u32 = 43;
pub const __NR3264_fstatfs: u32 = 44;
pub const __NR3264_truncate: u32 = 45;
pub const __NR3264_ftruncate: u32 = 46;
pub const __NR_fallocate: u32 = 47;
pub const __NR_faccessat: u32 = 48;
pub const __NR_chdir: u32 = 49;
pub const __NR_fchdir: u32 = 50;
pub const __NR_chroot: u32 = 51;
pub const __NR_fchmod: u32 = 52;
pub const __NR_fchmodat: u32 = 53;
pub const __NR_fchownat: u32 = 54;
pub const __NR_fchown: u32 = 55;
pub const __NR_openat: u32 = 56;
pub const __NR_close: u32 = 57;
pub const __NR_vhangup: u32 = 58;
pub const __NR_pipe2: u32 = 59;
pub const __NR_quotactl: u32 = 60;
pub const __NR_getdents64: u32 = 61;
pub const __NR3264_lseek: u32 = 62;
pub const __NR_read: u32 = 63;
pub const __NR_write: u32 = 64;
pub const __NR_readv: u32 = 65;
pub const __NR_writev: u32 = 66;
pub const __NR_pread64: u32 = 67;
pub const __NR_pwrite64: u32 = 68;
pub const __NR_preadv: u32 = 69;
pub const __NR_pwritev: u32 = 70;
pub const __NR3264_sendfile: u32 = 71;
pub const __NR_pselect6: u32 = 72;
pub const __NR_ppoll: u32 = 73;
pub const __NR_signalfd4: u32 = 74;
pub const __NR_vmsplice: u32 = 75;
pub const __NR_splice: u32 = 76;
pub const __NR_tee: u32 = 77;
pub const __NR_readlinkat: u32 = 78;
pub const __NR3264_fstatat: u32 = 79;
pub const __NR3264_fstat: u32 = 80;
pub const __NR_sync: u32 = 81;
pub const __NR_fsync: u32 = 82;
pub const __NR_fdatasync: u32 = 83;
pub const __NR_sync_file_range: u32 = 84;
pub const __NR_timerfd_create: u32 = 85;
pub const __NR_timerfd_settime: u32 = 86;
pub const __NR_timerfd_gettime: u32 = 87;
pub const __NR_utimensat: u32 = 88;
pub const __NR_acct: u32 = 89;
pub const __NR_capget: u32 = 90;
pub const __NR_capset: u32 = 91;
pub const __NR_personality: u32 = 92;
pub const __NR_exit: u32 = 93;
pub const __NR_exit_group: u32 = 94;
pub const __NR_waitid: u32 = 95;
pub const __NR_set_tid_address: u32 = 96;
pub const __NR_unshare: u32 = 97;
pub const __NR_futex: u32 = 98;
pub const __NR_set_robust_list: u32 = 99;
pub const __NR_get_robust_list: u32 = 100;
pub const __NR_nanosleep: u32 = 101;
pub const __NR_getitimer: u32 = 102;
pub const __NR_setitimer: u32 = 103;
pub const __NR_kexec_load: u32 = 104;
pub const __NR_init_module: u32 = 105;
pub const __NR_delete_module: u32 = 106;
pub const __NR_timer_create: u32 = 107;
pub const __NR_timer_gettime: u32 = 108;
pub const __NR_timer_getoverrun: u32 = 109;
pub const __NR_timer_settime: u32 = 110;
pub const __NR_timer_delete: u32 = 111;
pub const __NR_clock_settime: u32 = 112;
pub const __NR_clock_gettime: u32 = 113;
pub const __NR_clock_getres: u32 = 114;
pub const __NR_clock_nanosleep: u32 = 115;
pub const __NR_syslog: u32 = 116;
pub const __NR_ptrace: u32 = 117;
pub const __NR_sched_setparam: u32 = 118;
pub const __NR_sched_setscheduler: u32 = 119;
pub const __NR_sched_getscheduler: u32 = 120;
pub const __NR_sched_getparam: u32 = 121;
pub const __NR_sched_setaffinity: u32 = 122;
pub const __NR_sched_getaffinity: u32 = 123;
pub const __NR_sched_yield: u32 = 124;
pub const __NR_sched_get_priority_max: u32 = 125;
pub const __NR_sched_get_priority_min: u32 = 126;
pub const __NR_sched_rr_get_interval: u32 = 127;
pub const __NR_restart_syscall: u32 = 128;
pub const __NR_kill: u32 = 129;
pub const __NR_tkill: u32 = 130;
pub const __NR_tgkill: u32 = 131;
pub const __NR_sigaltstack: u32 = 132;
pub const __NR_rt_sigsuspend: u32 = 133;
pub const __NR_rt_sigaction: u32 = 134;
pub const __NR_rt_sigprocmask: u32 = 135;
pub const __NR_rt_sigpending: u32 = 136;
pub const __NR_rt_sigtimedwait: u32 = 137;
pub const __NR_rt_sigqueueinfo: u32 = 138;
pub const __NR_rt_sigreturn: u32 = 139;
pub const __NR_setpriority: u32 = 140;
pub const __NR_getpriority: u32 = 141;
pub const __NR_reboot: u32 = 142;
pub const __NR_setregid: u32 = 143;
pub const __NR_setgid: u32 = 144;
pub const __NR_setreuid: u32 = 145;
pub const __NR_setuid: u32 = 146;
pub const __NR_setresuid: u32 = 147;
pub const __NR_getresuid: u32 = 148;
pub const __NR_setresgid: u32 = 149;
pub const __NR_getresgid: u32 = 150;
pub const __NR_setfsuid: u32 = 151;
pub const __NR_setfsgid: u32 = 152;
pub const __NR_times: u32 = 153;
pub const __NR_setpgid: u32 = 154;
pub const __NR_getpgid: u32 = 155;
pub const __NR_getsid: u32 = 156;
pub const __NR_setsid: u32 = 157;
pub const __NR_getgroups: u32 = 158;
pub const __NR_setgroups: u32 = 159;
pub const __NR_uname: u32 = 160;
pub const __NR_sethostname: u32 = 161;
pub const __NR_setdomainname: u32 = 162;
pub const __NR_getrlimit: u32 = 163;
pub const __NR_setrlimit: u32 = 164;
pub const __NR_getrusage: u32 = 165;
pub const __NR_umask: u32 = 166;
pub const __NR_prctl: u32 = 167;
pub const __NR_getcpu: u32 = 168;
pub const __NR_gettimeofday: u32 = 169;
pub const __NR_settimeofday: u32 = 170;
pub const __NR_adjtimex: u32 = 171;
pub const __NR_getpid: u32 = 172;
pub const __NR_getppid: u32 = 173;
pub const __NR_getuid: u32 = 174;
pub const __NR_geteuid: u32 = 175;
pub const __NR_getgid: u32 = 176;
pub const __NR_getegid: u32 = 177;
pub const __NR_gettid: u32 = 178;
pub const __NR_sysinfo: u32 = 179;
pub const __NR_mq_open: u32 = 180;
pub const __NR_mq_unlink: u32 = 181;
pub const __NR_mq_timedsend: u32 = 182;
pub const __NR_mq_timedreceive: u32 = 183;
pub const __NR_mq_notify: u32 = 184;
pub const __NR_mq_getsetattr: u32 = 185;
pub const __NR_msgget: u32 = 186;
pub const __NR_msgctl: u32 = 187;
pub const __NR_msgrcv: u32 = 188;
pub const __NR_msgsnd: u32 = 189;
pub const __NR_semget: u32 = 190;
pub const __NR_semctl: u32 = 191;
pub const __NR_semtimedop: u32 = 192;
pub const __NR_semop: u32 = 193;
pub const __NR_shmget: u32 = 194;
pub const __NR_shmctl: u32 = 195;
pub const __NR_shmat: u32 = 196;
pub const __NR_shmdt: u32 = 197;
pub const __NR_socket: u32 = 198;
pub const __NR_socketpair: u32 = 199;
pub const __NR_bind: u32 = 200;
pub const __NR_listen: u32 = 201;
pub const __NR_accept: u32 = 202;
pub const __NR_connect: u32 = 203;
pub const __NR_getsockname: u32 = 204;
pub const __NR_getpeername: u32 = 205;
pub const __NR_sendto: u32 = 206;
pub const __NR_recvfrom: u32 = 207;
pub const __NR_setsockopt: u32 = 208;
pub const __NR_getsockopt: u32 = 209;
pub const __NR_shutdown: u32 = 210;
pub const __NR_sendmsg: u32 = 211;
pub const __NR_recvmsg: u32 = 212;
pub const __NR_readahead: u32 = 213;
pub const __NR_brk: u32 = 214;
pub const __NR_munmap: u32 = 215;
pub const __NR_mremap: u32 = 216;
pub const __NR_add_key: u32 = 217;
pub const __NR_request_key: u32 = 218;
pub const __NR_keyctl: u32 = 219;
pub const __NR_clone: u32 = 220;
pub const __NR_execve: u32 = 221;
pub const __NR3264_mmap: u32 = 222;
pub const __NR3264_fadvise64: u32 = 223;
pub const __NR_swapon: u32 = 224;
pub const __NR_swapoff: u32 = 225;
pub const __NR_mprotect: u32 = 226;
pub const __NR_msync: u32 = 227;
pub const __NR_mlock: u32 = 228;
pub const __NR_munlock: u32 = 229;
pub const __NR_mlockall: u32 = 230;
pub const __NR_munlockall: u32 = 231;
pub const __NR_mincore: u32 = 232;
pub const __NR_madvise: u32 = 233;
pub const __NR_remap_file_pages: u32 = 234;
pub const __NR_mbind: u32 = 235;
pub const __NR_get_mempolicy: u32 = 236;
pub const __NR_set_mempolicy: u32 = 237;
pub const __NR_migrate_pages: u32 = 238;
pub const __NR_move_pages: u32 = 239;
pub const __NR_rt_tgsigqueueinfo: u32 = 240;
pub const __NR_perf_event_open: u32 = 241;
pub const __NR_accept4: u32 = 242;
pub const __NR_recvmmsg: u32 = 243;
pub const __NR_arch_specific_syscall: u32 = 244;
pub const __NR_wait4: u32 = 260;
pub const __NR_prlimit64: u32 = 261;
pub const __NR_fanotify_init: u32 = 262;
pub const __NR_fanotify_mark: u32 = 263;
pub const __NR_name_to_handle_at: u32 = 264;
pub const __NR_open_by_handle_at: u32 = 265;
pub const __NR_clock_adjtime: u32 = 266;
pub const __NR_syncfs: u32 = 267;
pub const __NR_setns: u32 = 268;
pub const __NR_sendmmsg: u32 = 269;
pub const __NR_process_vm_readv: u32 = 270;
pub const __NR_process_vm_writev: u32 = 271;
pub const __NR_kcmp: u32 = 272;
pub const __NR_finit_module: u32 = 273;
pub const __NR_sched_setattr: u32 = 274;
pub const __NR_sched_getattr: u32 = 275;
pub const __NR_renameat2: u32 = 276;
pub const __NR_seccomp: u32 = 277;
pub const __NR_getrandom: u32 = 278;
pub const __NR_memfd_create: u32 = 279;
pub const __NR_bpf: u32 = 280;
pub const __NR_execveat: u32 = 281;
pub const __NR_userfaultfd: u32 = 282;
pub const __NR_membarrier: u32 = 283;
pub const __NR_mlock2: u32 = 284;
pub const __NR_copy_file_range: u32 = 285;
pub const __NR_preadv2: u32 = 286;
pub const __NR_pwritev2: u32 = 287;
pub const __NR_pkey_mprotect: u32 = 288;
pub const __NR_pkey_alloc: u32 = 289;
pub const __NR_pkey_free: u32 = 290;
pub const __NR_statx: u32 = 291;
pub const __NR_io_pgetevents: u32 = 292;
pub const __NR_rseq: u32 = 293;
pub const __NR_kexec_file_load: u32 = 294;
pub const __NR_pidfd_send_signal: u32 = 424;
pub const __NR_io_uring_setup: u32 = 425;
pub const __NR_io_uring_enter: u32 = 426;
pub const __NR_io_uring_register: u32 = 427;
pub const __NR_open_tree: u32 = 428;
pub const __NR_move_mount: u32 = 429;
pub const __NR_fsopen: u32 = 430;
pub const __NR_fsconfig: u32 = 431;
pub const __NR_fsmount: u32 = 432;
pub const __NR_fspick: u32 = 433;
pub const __NR_pidfd_open: u32 = 434;
pub const __NR_clone3: u32 = 435;
pub const __NR_close_range: u32 = 436;
pub const __NR_openat2: u32 = 437;
pub const __NR_pidfd_getfd: u32 = 438;
pub const __NR_faccessat2: u32 = 439;
pub const __NR_process_madvise: u32 = 440;
pub const __NR_epoll_pwait2: u32 = 441;
pub const __NR_mount_setattr: u32 = 442;
pub const __NR_quotactl_fd: u32 = 443;
pub const __NR_landlock_create_ruleset: u32 = 444;
pub const __NR_landlock_add_rule: u32 = 445;
pub const __NR_landlock_restrict_self: u32 = 446;
pub const __NR_memfd_secret: u32 = 447;
pub const __NR_process_mrelease: u32 = 448;
pub const __NR_futex_waitv: u32 = 449;
pub const __NR_set_mempolicy_home_node: u32 = 450;
pub const __NR_syscalls: u32 = 451;
pub const __NR_fcntl: u32 = 25;
pub const __NR_statfs: u32 = 43;
pub const __NR_fstatfs: u32 = 44;
pub const __NR_truncate: u32 = 45;
pub const __NR_ftruncate: u32 = 46;
pub const __NR_lseek: u32 = 62;
pub const __NR_sendfile: u32 = 71;
pub const __NR_newfstatat: u32 = 79;
pub const __NR_fstat: u32 = 80;
pub const __NR_mmap: u32 = 222;
pub const __NR_fadvise64: u32 = 223;
pub const __NR_riscv_flush_icache: u32 = 259;
pub const NR_syscalls: u32 = 451;
pub const __NR_seccomp_read_32: u32 = 63;
pub const __NR_seccomp_write_32: u32 = 64;
pub const __NR_seccomp_exit_32: u32 = 93;
pub const __NR_seccomp_sigreturn_32: u32 = 139;
pub const __NR_seccomp_read: u32 = 63;
pub const __NR_seccomp_write: u32 = 64;
pub const __NR_seccomp_exit: u32 = 93;
pub const __NR_seccomp_sigreturn: u32 = 139;
pub const SECCOMP_ARCH_NATIVE_NR: u32 = 451;
pub const SECCOMP_ARCH_NATIVE_NAME: &'static [u8; 8usize] = b"riscv64\0";
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_BOTH: i32 = -2;
pub const RUSAGE_THREAD: u32 = 1;
pub const RLIM64_INFINITY: i32 = -1;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const _STK_LIM: u32 = 8388608;
pub const MLOCK_LIMIT: u32 = 8388608;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_NPROC: u32 = 6;
pub const RLIMIT_NOFILE: u32 = 7;
pub const RLIMIT_MEMLOCK: u32 = 8;
pub const RLIMIT_AS: u32 = 9;
pub const RLIMIT_LOCKS: u32 = 10;
pub const RLIMIT_SIGPENDING: u32 = 11;
pub const RLIMIT_MSGQUEUE: u32 = 12;
pub const RLIMIT_NICE: u32 = 13;
pub const RLIMIT_RTPRIO: u32 = 14;
pub const RLIMIT_RTTIME: u32 = 15;
pub const RLIM_NLIMITS: u32 = 16;
pub const RLIM_INFINITY: i32 = -1;
pub const MAX_NICE: u32 = 19;
pub const MIN_NICE: i32 = -20;
pub const NICE_WIDTH: u32 = 40;
pub const MAX_RT_PRIO: u32 = 100;
pub const MAX_PRIO: u32 = 140;
pub const DEFAULT_PRIO: u32 = 120;
pub const _NSIG: u32 = 64;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPOLL: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const SIGRTMIN: u32 = 32;
pub const SIGRTMAX: u32 = 64;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_UNSUPPORTED: u32 = 1024;
pub const SA_EXPOSE_TAGBITS: u32 = 2048;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const SI_MAX_SIZE: u32 = 128;
pub const SI_USER: u32 = 0;
pub const SI_KERNEL: u32 = 128;
pub const SI_QUEUE: i32 = -1;
pub const SI_TIMER: i32 = -2;
pub const SI_MESGQ: i32 = -3;
pub const SI_ASYNCIO: i32 = -4;
pub const SI_SIGIO: i32 = -5;
pub const SI_TKILL: i32 = -6;
pub const SI_DETHREAD: i32 = -7;
pub const SI_ASYNCNL: i32 = -60;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLOPN: u32 = 2;
pub const ILL_ILLADR: u32 = 3;
pub const ILL_ILLTRP: u32 = 4;
pub const ILL_PRVOPC: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const ILL_BADIADDR: u32 = 9;
pub const __ILL_BREAK: u32 = 10;
pub const __ILL_BNDMOD: u32 = 11;
pub const NSIGILL: u32 = 11;
pub const FPE_INTDIV: u32 = 1;
pub const FPE_INTOVF: u32 = 2;
pub const FPE_FLTDIV: u32 = 3;
pub const FPE_FLTOVF: u32 = 4;
pub const FPE_FLTUND: u32 = 5;
pub const FPE_FLTRES: u32 = 6;
pub const FPE_FLTINV: u32 = 7;
pub const FPE_FLTSUB: u32 = 8;
pub const __FPE_DECOVF: u32 = 9;
pub const __FPE_DECDIV: u32 = 10;
pub const __FPE_DECERR: u32 = 11;
pub const __FPE_INVASC: u32 = 12;
pub const __FPE_INVDEC: u32 = 13;
pub const FPE_FLTUNK: u32 = 14;
pub const FPE_CONDTRAP: u32 = 15;
pub const NSIGFPE: u32 = 15;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const SEGV_BNDERR: u32 = 3;
pub const SEGV_PKUERR: u32 = 4;
pub const SEGV_ACCADI: u32 = 5;
pub const SEGV_ADIDERR: u32 = 6;
pub const SEGV_ADIPERR: u32 = 7;
pub const SEGV_MTEAERR: u32 = 8;
pub const SEGV_MTESERR: u32 = 9;
pub const NSIGSEGV: u32 = 9;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const BUS_MCEERR_AR: u32 = 4;
pub const BUS_MCEERR_AO: u32 = 5;
pub const NSIGBUS: u32 = 5;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const TRAP_BRANCH: u32 = 3;
pub const TRAP_HWBKPT: u32 = 4;
pub const TRAP_UNK: u32 = 5;
pub const TRAP_PERF: u32 = 6;
pub const NSIGTRAP: u32 = 6;
pub const TRAP_PERF_FLAG_ASYNC: u32 = 1;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const NSIGCHLD: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const NSIGPOLL: u32 = 6;
pub const SYS_SECCOMP: u32 = 1;
pub const SYS_USER_DISPATCH: u32 = 2;
pub const NSIGSYS: u32 = 2;
pub const EMT_TAGOVF: u32 = 1;
pub const NSIGEMT: u32 = 1;
pub const SIGEV_SIGNAL: u32 = 0;
pub const SIGEV_NONE: u32 = 1;
pub const SIGEV_THREAD: u32 = 2;
pub const SIGEV_THREAD_ID: u32 = 4;
pub const SIGEV_MAX_SIZE: u32 = 64;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 2;
pub const SS_AUTODISARM: u32 = 2147483648;
pub const SS_FLAG_BITS: u32 = 2147483648;
pub const SIGQUEUE_PREALLOC: u32 = 1;
pub const SA_IMMUTABLE: u32 = 8388608;
pub const __ARCH_UAPI_SA_FLAGS: u32 = 0;
pub const UAPI_SA_FLAGS: u32 = 3623880711;
pub const ALARMTIMER_STATE_INACTIVE: u32 = 0;
pub const ALARMTIMER_STATE_ENQUEUED: u32 = 1;
pub const CPUCLOCK_PERTHREAD_MASK: u32 = 4;
pub const CPUCLOCK_CLOCK_MASK: u32 = 3;
pub const CPUCLOCK_PROF: u32 = 0;
pub const CPUCLOCK_VIRT: u32 = 1;
pub const CPUCLOCK_SCHED: u32 = 2;
pub const CPUCLOCK_MAX: u32 = 3;
pub const CLOCKFD: u32 = 3;
pub const CLOCKFD_MASK: u32 = 7;
pub const REQUEUE_PENDING: u32 = 1;
pub const MAX_DA_NAME_LEN: u32 = 24;
pub const KM_MAX_IDX: u32 = 16;
pub const TASK_RUNNING: u32 = 0;
pub const TASK_INTERRUPTIBLE: u32 = 1;
pub const TASK_UNINTERRUPTIBLE: u32 = 2;
pub const __TASK_STOPPED: u32 = 4;
pub const __TASK_TRACED: u32 = 8;
pub const EXIT_DEAD: u32 = 16;
pub const EXIT_ZOMBIE: u32 = 32;
pub const EXIT_TRACE: u32 = 48;
pub const TASK_PARKED: u32 = 64;
pub const TASK_DEAD: u32 = 128;
pub const TASK_WAKEKILL: u32 = 256;
pub const TASK_WAKING: u32 = 512;
pub const TASK_NOLOAD: u32 = 1024;
pub const TASK_NEW: u32 = 2048;
pub const TASK_RTLOCK_WAIT: u32 = 4096;
pub const TASK_FREEZABLE: u32 = 8192;
pub const TASK_FROZEN: u32 = 32768;
pub const TASK_STATE_MAX: u32 = 65536;
pub const TASK_ANY: u32 = 65535;
pub const TASK_KILLABLE: u32 = 258;
pub const TASK_STOPPED: u32 = 260;
pub const TASK_TRACED: u32 = 8;
pub const TASK_IDLE: u32 = 1026;
pub const TASK_NORMAL: u32 = 3;
pub const TASK_REPORT: u32 = 127;
pub const SCHED_FIXEDPOINT_SHIFT: u32 = 10;
pub const SCHED_FIXEDPOINT_SCALE: u32 = 1024;
pub const SCHED_CAPACITY_SHIFT: u32 = 10;
pub const SCHED_CAPACITY_SCALE: u32 = 1024;
pub const UTIL_EST_WEIGHT_SHIFT: u32 = 2;
pub const UTIL_AVG_UNCHANGED: u32 = 2147483648;
pub const TASK_REPORT_IDLE: u32 = 128;
pub const TASK_REPORT_MAX: u32 = 256;
pub const PF_VCPU: u32 = 1;
pub const PF_IDLE: u32 = 2;
pub const PF_EXITING: u32 = 4;
pub const PF_POSTCOREDUMP: u32 = 8;
pub const PF_IO_WORKER: u32 = 16;
pub const PF_WQ_WORKER: u32 = 32;
pub const PF_FORKNOEXEC: u32 = 64;
pub const PF_MCE_PROCESS: u32 = 128;
pub const PF_SUPERPRIV: u32 = 256;
pub const PF_DUMPCORE: u32 = 512;
pub const PF_SIGNALED: u32 = 1024;
pub const PF_MEMALLOC: u32 = 2048;
pub const PF_NPROC_EXCEEDED: u32 = 4096;
pub const PF_USED_MATH: u32 = 8192;
pub const PF__HOLE__00004000: u32 = 16384;
pub const PF_NOFREEZE: u32 = 32768;
pub const PF__HOLE__00010000: u32 = 65536;
pub const PF_KSWAPD: u32 = 131072;
pub const PF_MEMALLOC_NOFS: u32 = 262144;
pub const PF_MEMALLOC_NOIO: u32 = 524288;
pub const PF_LOCAL_THROTTLE: u32 = 1048576;
pub const PF_KTHREAD: u32 = 2097152;
pub const PF_RANDOMIZE: u32 = 4194304;
pub const PF__HOLE__00800000: u32 = 8388608;
pub const PF__HOLE__01000000: u32 = 16777216;
pub const PF__HOLE__02000000: u32 = 33554432;
pub const PF_NO_SETAFFINITY: u32 = 67108864;
pub const PF_MCE_EARLY: u32 = 134217728;
pub const PF_MEMALLOC_PIN: u32 = 268435456;
pub const PF__HOLE__20000000: u32 = 536870912;
pub const PF__HOLE__40000000: u32 = 1073741824;
pub const PF_SUSPEND_TASK: u32 = 2147483648;
pub const PFA_NO_NEW_PRIVS: u32 = 0;
pub const PFA_SPREAD_PAGE: u32 = 1;
pub const PFA_SPREAD_SLAB: u32 = 2;
pub const PFA_SPEC_SSB_DISABLE: u32 = 3;
pub const PFA_SPEC_SSB_FORCE_DISABLE: u32 = 4;
pub const PFA_SPEC_IB_DISABLE: u32 = 5;
pub const PFA_SPEC_IB_FORCE_DISABLE: u32 = 6;
pub const PFA_SPEC_SSB_NOEXEC: u32 = 7;
pub const MIGHT_RESCHED_RCU_SHIFT: u32 = 8;
pub const MIGHT_RESCHED_PREEMPT_MASK: u32 = 255;
pub const PREEMPT_LOCK_RESCHED_OFFSETS: u32 = 1;
pub const BITS_PER_XA_VALUE: u32 = 63;
pub const XA_MAX_MARKS: u32 = 3;
pub const RADIX_TREE_ENTRY_MASK: u32 = 3;
pub const RADIX_TREE_INTERNAL_NODE: u32 = 2;
pub const RADIX_TREE_MAX_TAGS: u32 = 3;
pub const _LINUX_CAPABILITY_VERSION_1: u32 = 429392688;
pub const _LINUX_CAPABILITY_U32S_1: u32 = 1;
pub const _LINUX_CAPABILITY_VERSION_2: u32 = 537333798;
pub const _LINUX_CAPABILITY_U32S_2: u32 = 2;
pub const _LINUX_CAPABILITY_VERSION_3: u32 = 537396514;
pub const _LINUX_CAPABILITY_U32S_3: u32 = 2;
pub const VFS_CAP_REVISION_MASK: u32 = 4278190080;
pub const VFS_CAP_REVISION_SHIFT: u32 = 24;
pub const VFS_CAP_FLAGS_MASK: i64 = -4278190081;
pub const VFS_CAP_FLAGS_EFFECTIVE: u32 = 1;
pub const VFS_CAP_REVISION_1: u32 = 16777216;
pub const VFS_CAP_U32_1: u32 = 1;
pub const VFS_CAP_REVISION_2: u32 = 33554432;
pub const VFS_CAP_U32_2: u32 = 2;
pub const VFS_CAP_REVISION_3: u32 = 50331648;
pub const VFS_CAP_U32_3: u32 = 2;
pub const VFS_CAP_U32: u32 = 2;
pub const VFS_CAP_REVISION: u32 = 50331648;
pub const CAP_CHOWN: u32 = 0;
pub const CAP_DAC_OVERRIDE: u32 = 1;
pub const CAP_DAC_READ_SEARCH: u32 = 2;
pub const CAP_FOWNER: u32 = 3;
pub const CAP_FSETID: u32 = 4;
pub const CAP_KILL: u32 = 5;
pub const CAP_SETGID: u32 = 6;
pub const CAP_SETUID: u32 = 7;
pub const CAP_SETPCAP: u32 = 8;
pub const CAP_LINUX_IMMUTABLE: u32 = 9;
pub const CAP_NET_BIND_SERVICE: u32 = 10;
pub const CAP_NET_BROADCAST: u32 = 11;
pub const CAP_NET_ADMIN: u32 = 12;
pub const CAP_NET_RAW: u32 = 13;
pub const CAP_IPC_LOCK: u32 = 14;
pub const CAP_IPC_OWNER: u32 = 15;
pub const CAP_SYS_MODULE: u32 = 16;
pub const CAP_SYS_RAWIO: u32 = 17;
pub const CAP_SYS_CHROOT: u32 = 18;
pub const CAP_SYS_PTRACE: u32 = 19;
pub const CAP_SYS_PACCT: u32 = 20;
pub const CAP_SYS_ADMIN: u32 = 21;
pub const CAP_SYS_BOOT: u32 = 22;
pub const CAP_SYS_NICE: u32 = 23;
pub const CAP_SYS_RESOURCE: u32 = 24;
pub const CAP_SYS_TIME: u32 = 25;
pub const CAP_SYS_TTY_CONFIG: u32 = 26;
pub const CAP_MKNOD: u32 = 27;
pub const CAP_LEASE: u32 = 28;
pub const CAP_AUDIT_WRITE: u32 = 29;
pub const CAP_AUDIT_CONTROL: u32 = 30;
pub const CAP_SETFCAP: u32 = 31;
pub const CAP_MAC_OVERRIDE: u32 = 32;
pub const CAP_MAC_ADMIN: u32 = 33;
pub const CAP_SYSLOG: u32 = 34;
pub const CAP_WAKE_ALARM: u32 = 35;
pub const CAP_BLOCK_SUSPEND: u32 = 36;
pub const CAP_AUDIT_READ: u32 = 37;
pub const CAP_PERFMON: u32 = 38;
pub const CAP_BPF: u32 = 39;
pub const CAP_CHECKPOINT_RESTORE: u32 = 40;
pub const CAP_LAST_CAP: u32 = 40;
pub const _KERNEL_CAPABILITY_VERSION: u32 = 537396514;
pub const _KERNEL_CAPABILITY_U32S: u32 = 2;
pub const CAP_LAST_U32: u32 = 1;
pub const O_ACCMODE: u32 = 3;
pub const O_RDONLY: u32 = 0;
pub const O_WRONLY: u32 = 1;
pub const O_RDWR: u32 = 2;
pub const O_CREAT: u32 = 64;
pub const O_EXCL: u32 = 128;
pub const O_NOCTTY: u32 = 256;
pub const O_TRUNC: u32 = 512;
pub const O_APPEND: u32 = 1024;
pub const O_NONBLOCK: u32 = 2048;
pub const O_DSYNC: u32 = 4096;
pub const FASYNC: u32 = 8192;
pub const O_DIRECT: u32 = 16384;
pub const O_LARGEFILE: u32 = 32768;
pub const O_DIRECTORY: u32 = 65536;
pub const O_NOFOLLOW: u32 = 131072;
pub const O_NOATIME: u32 = 262144;
pub const O_CLOEXEC: u32 = 524288;
pub const __O_SYNC: u32 = 1048576;
pub const O_SYNC: u32 = 1052672;
pub const O_PATH: u32 = 2097152;
pub const __O_TMPFILE: u32 = 4194304;
pub const O_TMPFILE: u32 = 4259840;
pub const O_TMPFILE_MASK: u32 = 4259904;
pub const O_NDELAY: u32 = 2048;
pub const F_DUPFD: u32 = 0;
pub const F_GETFD: u32 = 1;
pub const F_SETFD: u32 = 2;
pub const F_GETFL: u32 = 3;
pub const F_SETFL: u32 = 4;
pub const F_GETLK: u32 = 5;
pub const F_SETLK: u32 = 6;
pub const F_SETLKW: u32 = 7;
pub const F_SETOWN: u32 = 8;
pub const F_GETOWN: u32 = 9;
pub const F_SETSIG: u32 = 10;
pub const F_GETSIG: u32 = 11;
pub const F_GETLK64: u32 = 12;
pub const F_SETLK64: u32 = 13;
pub const F_SETLKW64: u32 = 14;
pub const F_SETOWN_EX: u32 = 15;
pub const F_GETOWN_EX: u32 = 16;
pub const F_GETOWNER_UIDS: u32 = 17;
pub const F_OFD_GETLK: u32 = 36;
pub const F_OFD_SETLK: u32 = 37;
pub const F_OFD_SETLKW: u32 = 38;
pub const F_OWNER_TID: u32 = 0;
pub const F_OWNER_PID: u32 = 1;
pub const F_OWNER_PGRP: u32 = 2;
pub const FD_CLOEXEC: u32 = 1;
pub const F_RDLCK: u32 = 0;
pub const F_WRLCK: u32 = 1;
pub const F_UNLCK: u32 = 2;
pub const F_EXLCK: u32 = 4;
pub const F_SHLCK: u32 = 8;
pub const LOCK_SH: u32 = 1;
pub const LOCK_EX: u32 = 2;
pub const LOCK_NB: u32 = 4;
pub const LOCK_UN: u32 = 8;
pub const LOCK_MAND: u32 = 32;
pub const LOCK_READ: u32 = 64;
pub const LOCK_WRITE: u32 = 128;
pub const LOCK_RW: u32 = 192;
pub const F_LINUX_SPECIFIC_BASE: u32 = 1024;
pub const RESOLVE_NO_XDEV: u32 = 1;
pub const RESOLVE_NO_MAGICLINKS: u32 = 2;
pub const RESOLVE_NO_SYMLINKS: u32 = 4;
pub const RESOLVE_BENEATH: u32 = 8;
pub const RESOLVE_IN_ROOT: u32 = 16;
pub const RESOLVE_CACHED: u32 = 32;
pub const F_SETLEASE: u32 = 1024;
pub const F_GETLEASE: u32 = 1025;
pub const F_CANCELLK: u32 = 1029;
pub const F_DUPFD_CLOEXEC: u32 = 1030;
pub const F_NOTIFY: u32 = 1026;
pub const F_SETPIPE_SZ: u32 = 1031;
pub const F_GETPIPE_SZ: u32 = 1032;
pub const F_ADD_SEALS: u32 = 1033;
pub const F_GET_SEALS: u32 = 1034;
pub const F_SEAL_SEAL: u32 = 1;
pub const F_SEAL_SHRINK: u32 = 2;
pub const F_SEAL_GROW: u32 = 4;
pub const F_SEAL_WRITE: u32 = 8;
pub const F_SEAL_FUTURE_WRITE: u32 = 16;
pub const F_GET_RW_HINT: u32 = 1035;
pub const F_SET_RW_HINT: u32 = 1036;
pub const F_GET_FILE_RW_HINT: u32 = 1037;
pub const F_SET_FILE_RW_HINT: u32 = 1038;
pub const RWH_WRITE_LIFE_NOT_SET: u32 = 0;
pub const RWH_WRITE_LIFE_NONE: u32 = 1;
pub const RWH_WRITE_LIFE_SHORT: u32 = 2;
pub const RWH_WRITE_LIFE_MEDIUM: u32 = 3;
pub const RWH_WRITE_LIFE_LONG: u32 = 4;
pub const RWH_WRITE_LIFE_EXTREME: u32 = 5;
pub const RWF_WRITE_LIFE_NOT_SET: u32 = 0;
pub const DN_ACCESS: u32 = 1;
pub const DN_MODIFY: u32 = 2;
pub const DN_CREATE: u32 = 4;
pub const DN_DELETE: u32 = 8;
pub const DN_RENAME: u32 = 16;
pub const DN_ATTRIB: u32 = 32;
pub const DN_MULTISHOT: u32 = 2147483648;
pub const AT_FDCWD: i32 = -100;
pub const AT_SYMLINK_NOFOLLOW: u32 = 256;
pub const AT_EACCESS: u32 = 512;
pub const AT_REMOVEDIR: u32 = 512;
pub const AT_SYMLINK_FOLLOW: u32 = 1024;
pub const AT_NO_AUTOMOUNT: u32 = 2048;
pub const AT_EMPTY_PATH: u32 = 4096;
pub const AT_STATX_SYNC_TYPE: u32 = 24576;
pub const AT_STATX_SYNC_AS_STAT: u32 = 0;
pub const AT_STATX_FORCE_SYNC: u32 = 8192;
pub const AT_STATX_DONT_SYNC: u32 = 16384;
pub const AT_RECURSIVE: u32 = 32768;
pub const VALID_OPEN_FLAGS: u32 = 8388547;
pub const VALID_RESOLVE_FLAGS: u32 = 63;
pub const OPEN_HOW_SIZE_VER0: u32 = 24;
pub const OPEN_HOW_SIZE_LATEST: u32 = 24;
pub const SIGEMT_MASK: u32 = 0;
pub const JOBCTL_STOP_SIGMASK: u32 = 65535;
pub const JOBCTL_STOP_DEQUEUED_BIT: u32 = 16;
pub const JOBCTL_STOP_PENDING_BIT: u32 = 17;
pub const JOBCTL_STOP_CONSUME_BIT: u32 = 18;
pub const JOBCTL_TRAP_STOP_BIT: u32 = 19;
pub const JOBCTL_TRAP_NOTIFY_BIT: u32 = 20;
pub const JOBCTL_TRAPPING_BIT: u32 = 21;
pub const JOBCTL_LISTENING_BIT: u32 = 22;
pub const JOBCTL_TRAP_FREEZE_BIT: u32 = 23;
pub const JOBCTL_PTRACE_FROZEN_BIT: u32 = 24;
pub const JOBCTL_STOPPED_BIT: u32 = 26;
pub const JOBCTL_TRACED_BIT: u32 = 27;
pub const JOBCTL_STOP_DEQUEUED: u32 = 65536;
pub const JOBCTL_STOP_PENDING: u32 = 131072;
pub const JOBCTL_STOP_CONSUME: u32 = 262144;
pub const JOBCTL_TRAP_STOP: u32 = 524288;
pub const JOBCTL_TRAP_NOTIFY: u32 = 1048576;
pub const JOBCTL_TRAPPING: u32 = 2097152;
pub const JOBCTL_LISTENING: u32 = 4194304;
pub const JOBCTL_TRAP_FREEZE: u32 = 8388608;
pub const JOBCTL_PTRACE_FROZEN: u32 = 16777216;
pub const JOBCTL_STOPPED: u32 = 67108864;
pub const JOBCTL_TRACED: u32 = 134217728;
pub const JOBCTL_TRAP_MASK: u32 = 1572864;
pub const JOBCTL_PENDING_MASK: u32 = 1703936;
pub const EX_TYPE_NONE: u32 = 0;
pub const EX_TYPE_FIXUP: u32 = 1;
pub const EX_TYPE_BPF: u32 = 2;
pub const EX_TYPE_UACCESS_ERR_ZERO: u32 = 3;
pub const EX_DATA_REG_ERR_SHIFT: u32 = 0;
pub const EX_DATA_REG_ZERO_SHIFT: u32 = 5;
pub const SZ_1: u32 = 1;
pub const SZ_2: u32 = 2;
pub const SZ_4: u32 = 4;
pub const SZ_8: u32 = 8;
pub const SZ_16: u32 = 16;
pub const SZ_32: u32 = 32;
pub const SZ_64: u32 = 64;
pub const SZ_128: u32 = 128;
pub const SZ_256: u32 = 256;
pub const SZ_512: u32 = 512;
pub const SZ_1K: u32 = 1024;
pub const SZ_2K: u32 = 2048;
pub const SZ_4K: u32 = 4096;
pub const SZ_8K: u32 = 8192;
pub const SZ_16K: u32 = 16384;
pub const SZ_32K: u32 = 32768;
pub const SZ_64K: u32 = 65536;
pub const SZ_128K: u32 = 131072;
pub const SZ_256K: u32 = 262144;
pub const SZ_512K: u32 = 524288;
pub const SZ_1M: u32 = 1048576;
pub const SZ_2M: u32 = 2097152;
pub const SZ_4M: u32 = 4194304;
pub const SZ_8M: u32 = 8388608;
pub const SZ_16M: u32 = 16777216;
pub const SZ_32M: u32 = 33554432;
pub const SZ_64M: u32 = 67108864;
pub const SZ_128M: u32 = 134217728;
pub const SZ_256M: u32 = 268435456;
pub const SZ_512M: u32 = 536870912;
pub const SZ_1G: u32 = 1073741824;
pub const SZ_2G: u32 = 2147483648;
pub const _PAGE_ACCESSED_OFFSET: u32 = 6;
pub const _PAGE_PRESENT: u32 = 1;
pub const _PAGE_READ: u32 = 2;
pub const _PAGE_WRITE: u32 = 4;
pub const _PAGE_EXEC: u32 = 8;
pub const _PAGE_USER: u32 = 16;
pub const _PAGE_GLOBAL: u32 = 32;
pub const _PAGE_ACCESSED: u32 = 64;
pub const _PAGE_DIRTY: u32 = 128;
pub const _PAGE_SOFT: u32 = 256;
pub const _PAGE_SPECIAL: u32 = 256;
pub const _PAGE_TABLE: u32 = 1;
pub const _PAGE_PROT_NONE: u32 = 32;
pub const _PAGE_PFN_SHIFT: u32 = 10;
pub const _PAGE_LEAF: u32 = 14;
pub const BPF_JIT_REGION_SIZE: u32 = 134217728;
pub const PCI_IO_SIZE: u32 = 16777216;
pub const XIP_OFFSET: u32 = 0;
pub const ERRATA_STRING_LENGTH_MAX: u32 = 32;
pub const RISCV_ALTERNATIVES_BOOT: u32 = 0;
pub const RISCV_ALTERNATIVES_MODULE: u32 = 1;
pub const RISCV_ALTERNATIVES_EARLY_BOOT: u32 = 2;
pub const SIFIVE_VENDOR_ID: u32 = 1161;
pub const THEAD_VENDOR_ID: u32 = 1463;
pub const ERRATA_SIFIVE_CIP_453: u32 = 0;
pub const ERRATA_SIFIVE_CIP_1200: u32 = 1;
pub const ERRATA_SIFIVE_NUMBER: u32 = 2;
pub const CPUFEATURE_SVPBMT: u32 = 0;
pub const CPUFEATURE_ZICBOM: u32 = 1;
pub const CPUFEATURE_NUMBER: u32 = 2;
pub const ALT_SVPBMT_SHIFT: u32 = 61;
pub const ALT_THEAD_PBMT_SHIFT: u32 = 59;
pub const THEAD_inval_A0: &'static [u8; 17usize] = b".long 0x0265000b\0";
pub const THEAD_clean_A0: &'static [u8; 17usize] = b".long 0x0245000b\0";
pub const THEAD_flush_A0: &'static [u8; 17usize] = b".long 0x0275000b\0";
pub const THEAD_SYNC_S: &'static [u8; 17usize] = b".long 0x0190000b\0";
pub const PGDIR_SHIFT_L3: u32 = 30;
pub const PGDIR_SHIFT_L4: u32 = 39;
pub const PGDIR_SHIFT_L5: u32 = 48;
pub const P4D_SHIFT: u32 = 39;
pub const PUD_SHIFT: u32 = 30;
pub const PMD_SHIFT: u32 = 21;
pub const _PAGE_NOCACHE_SVPBMT: u64 = 2305843009213693952;
pub const _PAGE_IO_SVPBMT: u64 = 4611686018427387904;
pub const _PAGE_MTMASK_SVPBMT: u64 = 6917529027641081856;
pub const _PAGE_PMA_THEAD: u64 = 8070450532247928832;
pub const _PAGE_NOCACHE_THEAD: u32 = 0;
pub const _PAGE_IO_THEAD: i64 = -9223372036854775808;
pub const _PAGE_MTMASK_THEAD: i64 = -576460752303423488;
pub const _PAGE_BASE: u32 = 81;
pub const _PAGE_KERNEL: u32 = 231;
pub const __SWP_TYPE_SHIFT: u32 = 6;
pub const __SWP_TYPE_BITS: u32 = 5;
pub const __SWP_TYPE_MASK: u32 = 31;
pub const __SWP_OFFSET_SHIFT: u32 = 11;
pub const __LSW: u32 = 0;
pub const __MSW: u32 = 1;
pub const CLONE_LEGACY_FLAGS: u32 = 4294967295;
pub const ASSOC_ARRAY_KEY_CHUNK_SIZE: u32 = 64;
pub const KEY_POS_VIEW: u32 = 16777216;
pub const KEY_POS_READ: u32 = 33554432;
pub const KEY_POS_WRITE: u32 = 67108864;
pub const KEY_POS_SEARCH: u32 = 134217728;
pub const KEY_POS_LINK: u32 = 268435456;
pub const KEY_POS_SETATTR: u32 = 536870912;
pub const KEY_POS_ALL: u32 = 1056964608;
pub const KEY_USR_VIEW: u32 = 65536;
pub const KEY_USR_READ: u32 = 131072;
pub const KEY_USR_WRITE: u32 = 262144;
pub const KEY_USR_SEARCH: u32 = 524288;
pub const KEY_USR_LINK: u32 = 1048576;
pub const KEY_USR_SETATTR: u32 = 2097152;
pub const KEY_USR_ALL: u32 = 4128768;
pub const KEY_GRP_VIEW: u32 = 256;
pub const KEY_GRP_READ: u32 = 512;
pub const KEY_GRP_WRITE: u32 = 1024;
pub const KEY_GRP_SEARCH: u32 = 2048;
pub const KEY_GRP_LINK: u32 = 4096;
pub const KEY_GRP_SETATTR: u32 = 8192;
pub const KEY_GRP_ALL: u32 = 16128;
pub const KEY_OTH_VIEW: u32 = 1;
pub const KEY_OTH_READ: u32 = 2;
pub const KEY_OTH_WRITE: u32 = 4;
pub const KEY_OTH_SEARCH: u32 = 8;
pub const KEY_OTH_LINK: u32 = 16;
pub const KEY_OTH_SETATTR: u32 = 32;
pub const KEY_OTH_ALL: u32 = 63;
pub const KEY_PERM_UNDEF: u32 = 4294967295;
pub const KEY_FLAG_DEAD: u32 = 0;
pub const KEY_FLAG_REVOKED: u32 = 1;
pub const KEY_FLAG_IN_QUOTA: u32 = 2;
pub const KEY_FLAG_USER_CONSTRUCT: u32 = 3;
pub const KEY_FLAG_ROOT_CAN_CLEAR: u32 = 4;
pub const KEY_FLAG_INVALIDATED: u32 = 5;
pub const KEY_FLAG_BUILTIN: u32 = 6;
pub const KEY_FLAG_ROOT_CAN_INVAL: u32 = 7;
pub const KEY_FLAG_KEEP: u32 = 8;
pub const KEY_FLAG_UID_KEYRING: u32 = 9;
pub const KEY_ALLOC_IN_QUOTA: u32 = 0;
pub const KEY_ALLOC_QUOTA_OVERRUN: u32 = 1;
pub const KEY_ALLOC_NOT_IN_QUOTA: u32 = 2;
pub const KEY_ALLOC_BUILT_IN: u32 = 4;
pub const KEY_ALLOC_BYPASS_RESTRICTION: u32 = 8;
pub const KEY_ALLOC_UID_KEYRING: u32 = 16;
pub const KEY_ALLOC_SET_KEEP: u32 = 32;
pub const SIGNAL_STOP_STOPPED: u32 = 1;
pub const SIGNAL_STOP_CONTINUED: u32 = 2;
pub const SIGNAL_GROUP_EXIT: u32 = 4;
pub const SIGNAL_CLD_STOPPED: u32 = 16;
pub const SIGNAL_CLD_CONTINUED: u32 = 32;
pub const SIGNAL_CLD_MASK: u32 = 48;
pub const SIGNAL_UNKILLABLE: u32 = 64;
pub const SIGNAL_STOP_MASK: u32 = 51;
pub const UUID_SIZE: u32 = 16;
pub const UUID_STRING_LEN: u32 = 36;
pub const RR_TIMESLICE: u32 = 25;
pub const IOPRIO_CLASS_SHIFT: u32 = 13;
pub const IOPRIO_CLASS_MASK: u32 = 7;
pub const IOPRIO_PRIO_MASK: u32 = 8191;
pub const IOPRIO_NR_LEVELS: u32 = 8;
pub const IOPRIO_BE_NR: u32 = 8;
pub const IOPRIO_NORM: u32 = 4;
pub const IOPRIO_BE_NORM: u32 = 4;
pub const S_DT_SHIFT: u32 = 12;
pub const S_DT_MASK: u32 = 15;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_FIFO: u32 = 1;
pub const DT_CHR: u32 = 2;
pub const DT_DIR: u32 = 4;
pub const DT_BLK: u32 = 6;
pub const DT_REG: u32 = 8;
pub const DT_LNK: u32 = 10;
pub const DT_SOCK: u32 = 12;
pub const DT_WHT: u32 = 14;
pub const DT_MAX: u32 = 16;
pub const FT_UNKNOWN: u32 = 0;
pub const FT_REG_FILE: u32 = 1;
pub const FT_DIR: u32 = 2;
pub const FT_CHRDEV: u32 = 3;
pub const FT_BLKDEV: u32 = 4;
pub const FT_FIFO: u32 = 5;
pub const FT_SOCK: u32 = 6;
pub const FT_SYMLINK: u32 = 7;
pub const FT_MAX: u32 = 8;
pub const MNT_NOSUID: u32 = 1;
pub const MNT_NODEV: u32 = 2;
pub const MNT_NOEXEC: u32 = 4;
pub const MNT_NOATIME: u32 = 8;
pub const MNT_NODIRATIME: u32 = 16;
pub const MNT_RELATIME: u32 = 32;
pub const MNT_READONLY: u32 = 64;
pub const MNT_NOSYMFOLLOW: u32 = 128;
pub const MNT_SHRINKABLE: u32 = 256;
pub const MNT_WRITE_HOLD: u32 = 512;
pub const MNT_SHARED: u32 = 4096;
pub const MNT_UNBINDABLE: u32 = 8192;
pub const MNT_SHARED_MASK: u32 = 8192;
pub const MNT_USER_SETTABLE_MASK: u32 = 255;
pub const MNT_ATIME_MASK: u32 = 56;
pub const MNT_INTERNAL: u32 = 16384;
pub const MNT_LOCK_ATIME: u32 = 262144;
pub const MNT_LOCK_NOEXEC: u32 = 524288;
pub const MNT_LOCK_NOSUID: u32 = 1048576;
pub const MNT_LOCK_NODEV: u32 = 2097152;
pub const MNT_LOCK_READONLY: u32 = 4194304;
pub const MNT_LOCKED: u32 = 8388608;
pub const MNT_DOOMED: u32 = 16777216;
pub const MNT_SYNC_UMOUNT: u32 = 33554432;
pub const MNT_MARKED: u32 = 67108864;
pub const MNT_UMOUNT: u32 = 134217728;
pub const MNT_CURSOR: u32 = 268435456;
pub const SLAB_DEBUG_OBJECTS: u32 = 0;
pub const SLAB_FAILSLAB: u32 = 0;
pub const SLAB_KASAN: u32 = 0;
pub const SLAB_SKIP_KFENCE: u32 = 0;
pub const KMALLOC_SHIFT_HIGH: u32 = 13;
pub const KMALLOC_SHIFT_MAX: u32 = 22;
pub const KMALLOC_SHIFT_LOW: u32 = 3;
pub const KMALLOC_MAX_SIZE: u32 = 4194304;
pub const KMALLOC_MAX_CACHE_SIZE: u32 = 8192;
pub const KMALLOC_MAX_ORDER: u32 = 10;
pub const KMALLOC_MIN_SIZE: u32 = 8;
pub const INR_OPEN_CUR: u32 = 1024;
pub const INR_OPEN_MAX: u32 = 4096;
pub const BLOCK_SIZE_BITS: u32 = 10;
pub const BLOCK_SIZE: u32 = 1024;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const SEEK_MAX: u32 = 4;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const FILE_DEDUPE_RANGE_SAME: u32 = 0;
pub const FILE_DEDUPE_RANGE_DIFFERS: u32 = 1;
pub const NR_FILE: u32 = 8192;
pub const FS_XFLAG_REALTIME: u32 = 1;
pub const FS_XFLAG_PREALLOC: u32 = 2;
pub const FS_XFLAG_IMMUTABLE: u32 = 8;
pub const FS_XFLAG_APPEND: u32 = 16;
pub const FS_XFLAG_SYNC: u32 = 32;
pub const FS_XFLAG_NOATIME: u32 = 64;
pub const FS_XFLAG_NODUMP: u32 = 128;
pub const FS_XFLAG_RTINHERIT: u32 = 256;
pub const FS_XFLAG_PROJINHERIT: u32 = 512;
pub const FS_XFLAG_NOSYMLINKS: u32 = 1024;
pub const FS_XFLAG_EXTSIZE: u32 = 2048;
pub const FS_XFLAG_EXTSZINHERIT: u32 = 4096;
pub const FS_XFLAG_NODEFRAG: u32 = 8192;
pub const FS_XFLAG_FILESTREAM: u32 = 16384;
pub const FS_XFLAG_DAX: u32 = 32768;
pub const FS_XFLAG_COWEXTSIZE: u32 = 65536;
pub const FS_XFLAG_HASATTR: u32 = 2147483648;
pub const BMAP_IOCTL: u32 = 1;
pub const FSLABEL_MAX: u32 = 256;
pub const FS_SECRM_FL: u32 = 1;
pub const FS_UNRM_FL: u32 = 2;
pub const FS_COMPR_FL: u32 = 4;
pub const FS_SYNC_FL: u32 = 8;
pub const FS_IMMUTABLE_FL: u32 = 16;
pub const FS_APPEND_FL: u32 = 32;
pub const FS_NODUMP_FL: u32 = 64;
pub const FS_NOATIME_FL: u32 = 128;
pub const FS_DIRTY_FL: u32 = 256;
pub const FS_COMPRBLK_FL: u32 = 512;
pub const FS_NOCOMP_FL: u32 = 1024;
pub const FS_ENCRYPT_FL: u32 = 2048;
pub const FS_BTREE_FL: u32 = 4096;
pub const FS_INDEX_FL: u32 = 4096;
pub const FS_IMAGIC_FL: u32 = 8192;
pub const FS_JOURNAL_DATA_FL: u32 = 16384;
pub const FS_NOTAIL_FL: u32 = 32768;
pub const FS_DIRSYNC_FL: u32 = 65536;
pub const FS_TOPDIR_FL: u32 = 131072;
pub const FS_HUGE_FILE_FL: u32 = 262144;
pub const FS_EXTENT_FL: u32 = 524288;
pub const FS_VERITY_FL: u32 = 1048576;
pub const FS_EA_INODE_FL: u32 = 2097152;
pub const FS_EOFBLOCKS_FL: u32 = 4194304;
pub const FS_NOCOW_FL: u32 = 8388608;
pub const FS_DAX_FL: u32 = 33554432;
pub const FS_INLINE_DATA_FL: u32 = 268435456;
pub const FS_PROJINHERIT_FL: u32 = 536870912;
pub const FS_CASEFOLD_FL: u32 = 1073741824;
pub const FS_RESERVED_FL: u32 = 2147483648;
pub const FS_FL_USER_VISIBLE: u32 = 253951;
pub const FS_FL_USER_MODIFIABLE: u32 = 229631;
pub const SYNC_FILE_RANGE_WAIT_BEFORE: u32 = 1;
pub const SYNC_FILE_RANGE_WRITE: u32 = 2;
pub const SYNC_FILE_RANGE_WAIT_AFTER: u32 = 4;
pub const SYNC_FILE_RANGE_WRITE_AND_WAIT: u32 = 7;
pub const MAY_EXEC: u32 = 1;
pub const MAY_WRITE: u32 = 2;
pub const MAY_READ: u32 = 4;
pub const MAY_APPEND: u32 = 8;
pub const MAY_ACCESS: u32 = 16;
pub const MAY_OPEN: u32 = 32;
pub const MAY_CHDIR: u32 = 64;
pub const MAY_NOT_BLOCK: u32 = 128;
pub const ATTR_MODE: u32 = 1;
pub const ATTR_UID: u32 = 2;
pub const ATTR_GID: u32 = 4;
pub const ATTR_SIZE: u32 = 8;
pub const ATTR_ATIME: u32 = 16;
pub const ATTR_MTIME: u32 = 32;
pub const ATTR_CTIME: u32 = 64;
pub const ATTR_ATIME_SET: u32 = 128;
pub const ATTR_MTIME_SET: u32 = 256;
pub const ATTR_FORCE: u32 = 512;
pub const ATTR_KILL_SUID: u32 = 2048;
pub const ATTR_KILL_SGID: u32 = 4096;
pub const ATTR_FILE: u32 = 8192;
pub const ATTR_KILL_PRIV: u32 = 16384;
pub const ATTR_OPEN: u32 = 32768;
pub const ATTR_TIMES_SET: u32 = 65536;
pub const ATTR_TOUCH: u32 = 131072;
pub const WHITEOUT_MODE: u32 = 0;
pub const WHITEOUT_DEV: u32 = 0;
pub const XQM_USRQUOTA: u32 = 0;
pub const XQM_GRPQUOTA: u32 = 1;
pub const XQM_PRJQUOTA: u32 = 2;
pub const XQM_MAXQUOTAS: u32 = 3;
pub const FS_DQUOT_VERSION: u32 = 1;
pub const FS_DQ_ISOFT: u32 = 1;
pub const FS_DQ_IHARD: u32 = 2;
pub const FS_DQ_BSOFT: u32 = 4;
pub const FS_DQ_BHARD: u32 = 8;
pub const FS_DQ_RTBSOFT: u32 = 16;
pub const FS_DQ_RTBHARD: u32 = 32;
pub const FS_DQ_LIMIT_MASK: u32 = 63;
pub const FS_DQ_BTIMER: u32 = 64;
pub const FS_DQ_ITIMER: u32 = 128;
pub const FS_DQ_RTBTIMER: u32 = 256;
pub const FS_DQ_TIMER_MASK: u32 = 448;
pub const FS_DQ_BWARNS: u32 = 512;
pub const FS_DQ_IWARNS: u32 = 1024;
pub const FS_DQ_RTBWARNS: u32 = 2048;
pub const FS_DQ_WARNS_MASK: u32 = 3584;
pub const FS_DQ_BCOUNT: u32 = 4096;
pub const FS_DQ_ICOUNT: u32 = 8192;
pub const FS_DQ_RTBCOUNT: u32 = 16384;
pub const FS_DQ_ACCT_MASK: u32 = 28672;
pub const FS_DQ_BIGTIME: u32 = 32768;
pub const FS_QUOTA_UDQ_ACCT: u32 = 1;
pub const FS_QUOTA_UDQ_ENFD: u32 = 2;
pub const FS_QUOTA_GDQ_ACCT: u32 = 4;
pub const FS_QUOTA_GDQ_ENFD: u32 = 8;
pub const FS_QUOTA_PDQ_ACCT: u32 = 16;
pub const FS_QUOTA_PDQ_ENFD: u32 = 32;
pub const FS_USER_QUOTA: u32 = 1;
pub const FS_PROJ_QUOTA: u32 = 2;
pub const FS_GROUP_QUOTA: u32 = 4;
pub const FS_QSTAT_VERSION: u32 = 1;
pub const FS_QSTATV_VERSION1: u32 = 1;
pub const V1_INIT_ALLOC: u32 = 1;
pub const V1_INIT_REWRITE: u32 = 1;
pub const V1_DEL_ALLOC: u32 = 0;
pub const V1_DEL_REWRITE: u32 = 2;
pub const QTREE_INIT_ALLOC: u32 = 4;
pub const QTREE_INIT_REWRITE: u32 = 2;
pub const QTREE_DEL_ALLOC: u32 = 0;
pub const QTREE_DEL_REWRITE: u32 = 6;
pub const V2_INIT_ALLOC: u32 = 4;
pub const V2_INIT_REWRITE: u32 = 2;
pub const V2_DEL_ALLOC: u32 = 0;
pub const V2_DEL_REWRITE: u32 = 6;
pub const OVERFLOW_PROJID: u32 = 65534;
pub const __DQUOT_VERSION__: &'static [u8; 12usize] = b"dquot_6.6.0\0";
pub const MAXQUOTAS: u32 = 3;
pub const USRQUOTA: u32 = 0;
pub const GRPQUOTA: u32 = 1;
pub const PRJQUOTA: u32 = 2;
pub const SUBCMDMASK: u32 = 255;
pub const SUBCMDSHIFT: u32 = 8;
pub const Q_SYNC: u32 = 8388609;
pub const Q_QUOTAON: u32 = 8388610;
pub const Q_QUOTAOFF: u32 = 8388611;
pub const Q_GETFMT: u32 = 8388612;
pub const Q_GETINFO: u32 = 8388613;
pub const Q_SETINFO: u32 = 8388614;
pub const Q_GETQUOTA: u32 = 8388615;
pub const Q_SETQUOTA: u32 = 8388616;
pub const Q_GETNEXTQUOTA: u32 = 8388617;
pub const QFMT_VFS_OLD: u32 = 1;
pub const QFMT_VFS_V0: u32 = 2;
pub const QFMT_OCFS2: u32 = 3;
pub const QFMT_VFS_V1: u32 = 4;
pub const QIF_DQBLKSIZE_BITS: u32 = 10;
pub const QIF_DQBLKSIZE: u32 = 1024;
pub const IIF_BGRACE: u32 = 1;
pub const IIF_IGRACE: u32 = 2;
pub const IIF_FLAGS: u32 = 4;
pub const IIF_ALL: u32 = 7;
pub const QUOTA_NL_NOWARN: u32 = 0;
pub const QUOTA_NL_IHARDWARN: u32 = 1;
pub const QUOTA_NL_ISOFTLONGWARN: u32 = 2;
pub const QUOTA_NL_ISOFTWARN: u32 = 3;
pub const QUOTA_NL_BHARDWARN: u32 = 4;
pub const QUOTA_NL_BSOFTLONGWARN: u32 = 5;
pub const QUOTA_NL_BSOFTWARN: u32 = 6;
pub const QUOTA_NL_IHARDBELOW: u32 = 7;
pub const QUOTA_NL_ISOFTBELOW: u32 = 8;
pub const QUOTA_NL_BHARDBELOW: u32 = 9;
pub const QUOTA_NL_BSOFTBELOW: u32 = 10;
pub const QTYPE_MASK_USR: u32 = 1;
pub const QTYPE_MASK_GRP: u32 = 2;
pub const QTYPE_MASK_PRJ: u32 = 4;
pub const DQ_MOD_B: u32 = 0;
pub const DQ_BLKS_B: u32 = 1;
pub const DQ_INODES_B: u32 = 2;
pub const DQ_FAKE_B: u32 = 3;
pub const DQ_READ_B: u32 = 4;
pub const DQ_ACTIVE_B: u32 = 5;
pub const DQ_LASTSET_B: u32 = 6;
pub const QC_INO_SOFT: u32 = 1;
pub const QC_INO_HARD: u32 = 2;
pub const QC_SPC_SOFT: u32 = 4;
pub const QC_SPC_HARD: u32 = 8;
pub const QC_RT_SPC_SOFT: u32 = 16;
pub const QC_RT_SPC_HARD: u32 = 32;
pub const QC_LIMIT_MASK: u32 = 63;
pub const QC_SPC_TIMER: u32 = 64;
pub const QC_INO_TIMER: u32 = 128;
pub const QC_RT_SPC_TIMER: u32 = 256;
pub const QC_TIMER_MASK: u32 = 448;
pub const QC_SPC_WARNS: u32 = 512;
pub const QC_INO_WARNS: u32 = 1024;
pub const QC_RT_SPC_WARNS: u32 = 2048;
pub const QC_WARNS_MASK: u32 = 3584;
pub const QC_SPACE: u32 = 4096;
pub const QC_INO_COUNT: u32 = 8192;
pub const QC_RT_SPACE: u32 = 16384;
pub const QC_ACCT_MASK: u32 = 28672;
pub const QC_FLAGS: u32 = 32768;
pub const QCI_SYSFILE: u32 = 1;
pub const QCI_ROOT_SQUASH: u32 = 2;
pub const QCI_ACCT_ENABLED: u32 = 4;
pub const QCI_LIMITS_ENFORCED: u32 = 8;
pub const FILESYSTEM_MAX_STACK_DEPTH: u32 = 2;
pub const IOCB_EVENTFD: u32 = 65536;
pub const IOCB_DIRECT: u32 = 131072;
pub const IOCB_WRITE: u32 = 262144;
pub const IOCB_WAITQ: u32 = 524288;
pub const IOCB_NOIO: u32 = 1048576;
pub const IOCB_ALLOC_CACHE: u32 = 2097152;
pub const IOP_FASTPERM: u32 = 1;
pub const IOP_LOOKUP: u32 = 2;
pub const IOP_NOFOLLOW: u32 = 4;
pub const IOP_XATTR: u32 = 8;
pub const IOP_DEFAULT_READLINK: u32 = 16;
pub const MAX_NON_LFS: u32 = 2147483647;
pub const FL_POSIX: u32 = 1;
pub const FL_FLOCK: u32 = 2;
pub const FL_DELEG: u32 = 4;
pub const FL_ACCESS: u32 = 8;
pub const FL_EXISTS: u32 = 16;
pub const FL_LEASE: u32 = 32;
pub const FL_CLOSE: u32 = 64;
pub const FL_SLEEP: u32 = 128;
pub const FL_DOWNGRADE_PENDING: u32 = 256;
pub const FL_UNLOCK_PENDING: u32 = 512;
pub const FL_OFDLCK: u32 = 1024;
pub const FL_LAYOUT: u32 = 2048;
pub const FL_RECLAIM: u32 = 4096;
pub const FL_CLOSE_POSIX: u32 = 65;
pub const FILE_LOCK_DEFERRED: u32 = 1;
pub const FASYNC_MAGIC: u32 = 17921;
pub const SB_RDONLY: u32 = 1;
pub const SB_NOSUID: u32 = 2;
pub const SB_NODEV: u32 = 4;
pub const SB_NOEXEC: u32 = 8;
pub const SB_SYNCHRONOUS: u32 = 16;
pub const SB_MANDLOCK: u32 = 64;
pub const SB_DIRSYNC: u32 = 128;
pub const SB_NOATIME: u32 = 1024;
pub const SB_NODIRATIME: u32 = 2048;
pub const SB_SILENT: u32 = 32768;
pub const SB_POSIXACL: u32 = 65536;
pub const SB_INLINECRYPT: u32 = 131072;
pub const SB_KERNMOUNT: u32 = 4194304;
pub const SB_I_VERSION: u32 = 8388608;
pub const SB_LAZYTIME: u32 = 33554432;
pub const SB_SUBMOUNT: u32 = 67108864;
pub const SB_FORCE: u32 = 134217728;
pub const SB_NOSEC: u32 = 268435456;
pub const SB_BORN: u32 = 536870912;
pub const SB_ACTIVE: u32 = 1073741824;
pub const SB_NOUSER: u32 = 2147483648;
pub const SB_ENC_STRICT_MODE_FL: u32 = 1;
pub const MNT_FORCE: u32 = 1;
pub const MNT_DETACH: u32 = 2;
pub const MNT_EXPIRE: u32 = 4;
pub const UMOUNT_NOFOLLOW: u32 = 8;
pub const UMOUNT_UNUSED: u32 = 2147483648;
pub const SB_I_CGROUPWB: u32 = 1;
pub const SB_I_NOEXEC: u32 = 2;
pub const SB_I_NODEV: u32 = 4;
pub const SB_I_STABLE_WRITES: u32 = 8;
pub const SB_I_USERNS_VISIBLE: u32 = 16;
pub const SB_I_IMA_UNVERIFIABLE_SIGNATURE: u32 = 32;
pub const SB_I_UNTRUSTED_MOUNTER: u32 = 64;
pub const SB_I_SKIP_SYNC: u32 = 256;
pub const SB_I_PERSB_BDI: u32 = 512;
pub const SB_I_TS_EXPIRY_WARNED: u32 = 1024;
pub const SB_I_RETIRED: u32 = 2048;
pub const NOMMU_MAP_COPY: u32 = 1;
pub const NOMMU_MAP_DIRECT: u32 = 8;
pub const REMAP_FILE_DEDUP: u32 = 1;
pub const REMAP_FILE_CAN_SHORTEN: u32 = 2;
pub const REMAP_FILE_ADVISORY: u32 = 2;
pub const S_SYNC: u32 = 1;
pub const S_NOATIME: u32 = 2;
pub const S_APPEND: u32 = 4;
pub const S_IMMUTABLE: u32 = 8;
pub const S_DEAD: u32 = 16;
pub const S_NOQUOTA: u32 = 32;
pub const S_DIRSYNC: u32 = 64;
pub const S_NOCMTIME: u32 = 128;
pub const S_SWAPFILE: u32 = 256;
pub const S_PRIVATE: u32 = 512;
pub const S_IMA: u32 = 1024;
pub const S_AUTOMOUNT: u32 = 2048;
pub const S_NOSEC: u32 = 4096;
pub const S_DAX: u32 = 0;
pub const S_ENCRYPTED: u32 = 16384;
pub const S_CASEFOLD: u32 = 32768;
pub const S_VERITY: u32 = 65536;
pub const S_KERNEL_FILE: u32 = 131072;
pub const I_DIRTY_SYNC: u32 = 1;
pub const I_DIRTY_DATASYNC: u32 = 2;
pub const I_DIRTY_PAGES: u32 = 4;
pub const __I_NEW: u32 = 3;
pub const I_NEW: u32 = 8;
pub const I_WILL_FREE: u32 = 16;
pub const I_FREEING: u32 = 32;
pub const I_CLEAR: u32 = 64;
pub const __I_SYNC: u32 = 7;
pub const I_SYNC: u32 = 128;
pub const I_REFERENCED: u32 = 256;
pub const __I_DIO_WAKEUP: u32 = 9;
pub const I_DIO_WAKEUP: u32 = 512;
pub const I_LINKABLE: u32 = 1024;
pub const I_DIRTY_TIME: u32 = 2048;
pub const I_WB_SWITCH: u32 = 8192;
pub const I_OVL_INUSE: u32 = 16384;
pub const I_CREATING: u32 = 32768;
pub const I_DONTCACHE: u32 = 65536;
pub const I_SYNC_QUEUED: u32 = 131072;
pub const I_PINNING_FSCACHE_WB: u32 = 262144;
pub const I_DIRTY_INODE: u32 = 3;
pub const I_DIRTY: u32 = 7;
pub const I_DIRTY_ALL: u32 = 2055;
pub const FS_REQUIRES_DEV: u32 = 1;
pub const FS_BINARY_MOUNTDATA: u32 = 2;
pub const FS_HAS_SUBTYPE: u32 = 4;
pub const FS_USERNS_MOUNT: u32 = 8;
pub const FS_DISALLOW_NOTIFY_PERM: u32 = 16;
pub const FS_ALLOW_IDMAP: u32 = 32;
pub const FS_RENAME_DOES_D_MOVE: u32 = 32768;
pub const CHRDEV_MAJOR_MAX: u32 = 512;
pub const CHRDEV_MAJOR_DYN_END: u32 = 234;
pub const CHRDEV_MAJOR_DYN_EXT_START: u32 = 511;
pub const CHRDEV_MAJOR_DYN_EXT_END: u32 = 384;
pub const IOCB_FLAG_RESFD: u32 = 1;
pub const IOCB_FLAG_IOPRIO: u32 = 2;
pub const COMPAT_UTS_MACHINE: &'static [u8; 8usize] = b"riscv\0\0\0";
pub const ADFS_SUPER_MAGIC: u32 = 44533;
pub const AFFS_SUPER_MAGIC: u32 = 44543;
pub const AFS_SUPER_MAGIC: u32 = 1397113167;
pub const AUTOFS_SUPER_MAGIC: u32 = 391;
pub const CEPH_SUPER_MAGIC: u32 = 12805120;
pub const CODA_SUPER_MAGIC: u32 = 1937076805;
pub const CRAMFS_MAGIC: u32 = 684539205;
pub const CRAMFS_MAGIC_WEND: u32 = 1161678120;
pub const DEBUGFS_MAGIC: u32 = 1684170528;
pub const SECURITYFS_MAGIC: u32 = 1935894131;
pub const SELINUX_MAGIC: u32 = 4185718668;
pub const SMACK_MAGIC: u32 = 1128357203;
pub const RAMFS_MAGIC: u32 = 2240043254;
pub const TMPFS_MAGIC: u32 = 16914836;
pub const HUGETLBFS_MAGIC: u32 = 2508478710;
pub const SQUASHFS_MAGIC: u32 = 1936814952;
pub const ECRYPTFS_SUPER_MAGIC: u32 = 61791;
pub const EFS_SUPER_MAGIC: u32 = 4278867;
pub const EROFS_SUPER_MAGIC_V1: u32 = 3774210530;
pub const EXT2_SUPER_MAGIC: u32 = 61267;
pub const EXT3_SUPER_MAGIC: u32 = 61267;
pub const XENFS_SUPER_MAGIC: u32 = 2881100148;
pub const EXT4_SUPER_MAGIC: u32 = 61267;
pub const BTRFS_SUPER_MAGIC: u32 = 2435016766;
pub const NILFS_SUPER_MAGIC: u32 = 13364;
pub const F2FS_SUPER_MAGIC: u32 = 4076150800;
pub const HPFS_SUPER_MAGIC: u32 = 4187351113;
pub const ISOFS_SUPER_MAGIC: u32 = 38496;
pub const JFFS2_SUPER_MAGIC: u32 = 29366;
pub const XFS_SUPER_MAGIC: u32 = 1481003842;
pub const PSTOREFS_MAGIC: u32 = 1634035564;
pub const EFIVARFS_MAGIC: u32 = 3730735588;
pub const HOSTFS_SUPER_MAGIC: u32 = 12648430;
pub const OVERLAYFS_SUPER_MAGIC: u32 = 2035054128;
pub const FUSE_SUPER_MAGIC: u32 = 1702057286;
pub const MINIX_SUPER_MAGIC: u32 = 4991;
pub const MINIX_SUPER_MAGIC2: u32 = 5007;
pub const MINIX2_SUPER_MAGIC: u32 = 9320;
pub const MINIX2_SUPER_MAGIC2: u32 = 9336;
pub const MINIX3_SUPER_MAGIC: u32 = 19802;
pub const MSDOS_SUPER_MAGIC: u32 = 19780;
pub const EXFAT_SUPER_MAGIC: u32 = 538032816;
pub const NCP_SUPER_MAGIC: u32 = 22092;
pub const NFS_SUPER_MAGIC: u32 = 26985;
pub const OCFS2_SUPER_MAGIC: u32 = 1952539503;
pub const OPENPROM_SUPER_MAGIC: u32 = 40865;
pub const QNX4_SUPER_MAGIC: u32 = 47;
pub const QNX6_SUPER_MAGIC: u32 = 1746473250;
pub const AFS_FS_MAGIC: u32 = 1799439955;
pub const REISERFS_SUPER_MAGIC: u32 = 1382369651;
pub const REISERFS_SUPER_MAGIC_STRING: &'static [u8; 9usize] = b"ReIsErFs\0";
pub const REISER2FS_SUPER_MAGIC_STRING: &'static [u8; 10usize] = b"ReIsEr2Fs\0";
pub const REISER2FS_JR_SUPER_MAGIC_STRING: &'static [u8; 10usize] = b"ReIsEr3Fs\0";
pub const SMB_SUPER_MAGIC: u32 = 20859;
pub const CIFS_SUPER_MAGIC: u32 = 4283649346;
pub const SMB2_SUPER_MAGIC: u32 = 4266872130;
pub const CGROUP_SUPER_MAGIC: u32 = 2613483;
pub const CGROUP2_SUPER_MAGIC: u32 = 1667723888;
pub const RDTGROUP_SUPER_MAGIC: u32 = 124082209;
pub const STACK_END_MAGIC: u32 = 1470918301;
pub const TRACEFS_MAGIC: u32 = 1953653091;
pub const V9FS_MAGIC: u32 = 16914839;
pub const BDEVFS_MAGIC: u32 = 1650746742;
pub const DAXFS_MAGIC: u32 = 1684300152;
pub const BINFMTFS_MAGIC: u32 = 1112100429;
pub const DEVPTS_SUPER_MAGIC: u32 = 7377;
pub const BINDERFS_SUPER_MAGIC: u32 = 1819242352;
pub const FUTEXFS_SUPER_MAGIC: u32 = 195894762;
pub const PIPEFS_MAGIC: u32 = 1346981957;
pub const PROC_SUPER_MAGIC: u32 = 40864;
pub const SOCKFS_MAGIC: u32 = 1397703499;
pub const SYSFS_MAGIC: u32 = 1650812274;
pub const USBDEVICE_SUPER_MAGIC: u32 = 40866;
pub const MTD_INODE_FS_MAGIC: u32 = 288389204;
pub const ANON_INODE_FS_MAGIC: u32 = 151263540;
pub const BTRFS_TEST_MAGIC: u32 = 1936880249;
pub const NSFS_MAGIC: u32 = 1853056627;
pub const BPF_FS_MAGIC: u32 = 3405662737;
pub const AAFS_MAGIC: u32 = 1513908720;
pub const ZONEFS_MAGIC: u32 = 1515144787;
pub const UDF_SUPER_MAGIC: u32 = 352400198;
pub const DMA_BUF_MAGIC: u32 = 1145913666;
pub const DEVMEM_MAGIC: u32 = 1162691661;
pub const SECRETMEM_MAGIC: u32 = 1397048141;
pub const COMPAT_USER_HZ: u32 = 100;
pub const COMPAT_RLIM_INFINITY: u32 = 4294967295;
pub const COMPAT_OFF_T_MAX: u32 = 2147483647;
pub const _COMPAT_NSIG: u32 = 64;
pub const _COMPAT_NSIG_BPW: u32 = 32;
pub const COMPAT_USE_64BIT_TIME: u32 = 0;
pub const COMPAT_MINSIGSTKSZ: u32 = 2048;
pub const _COMPAT_NSIG_WORDS: u32 = 2;
pub const R_RISCV_NONE: u32 = 0;
pub const R_RISCV_32: u32 = 1;
pub const R_RISCV_64: u32 = 2;
pub const R_RISCV_RELATIVE: u32 = 3;
pub const R_RISCV_COPY: u32 = 4;
pub const R_RISCV_JUMP_SLOT: u32 = 5;
pub const R_RISCV_TLS_DTPMOD32: u32 = 6;
pub const R_RISCV_TLS_DTPMOD64: u32 = 7;
pub const R_RISCV_TLS_DTPREL32: u32 = 8;
pub const R_RISCV_TLS_DTPREL64: u32 = 9;
pub const R_RISCV_TLS_TPREL32: u32 = 10;
pub const R_RISCV_TLS_TPREL64: u32 = 11;
pub const R_RISCV_BRANCH: u32 = 16;
pub const R_RISCV_JAL: u32 = 17;
pub const R_RISCV_CALL: u32 = 18;
pub const R_RISCV_CALL_PLT: u32 = 19;
pub const R_RISCV_GOT_HI20: u32 = 20;
pub const R_RISCV_TLS_GOT_HI20: u32 = 21;
pub const R_RISCV_TLS_GD_HI20: u32 = 22;
pub const R_RISCV_PCREL_HI20: u32 = 23;
pub const R_RISCV_PCREL_LO12_I: u32 = 24;
pub const R_RISCV_PCREL_LO12_S: u32 = 25;
pub const R_RISCV_HI20: u32 = 26;
pub const R_RISCV_LO12_I: u32 = 27;
pub const R_RISCV_LO12_S: u32 = 28;
pub const R_RISCV_TPREL_HI20: u32 = 29;
pub const R_RISCV_TPREL_LO12_I: u32 = 30;
pub const R_RISCV_TPREL_LO12_S: u32 = 31;
pub const R_RISCV_TPREL_ADD: u32 = 32;
pub const R_RISCV_ADD8: u32 = 33;
pub const R_RISCV_ADD16: u32 = 34;
pub const R_RISCV_ADD32: u32 = 35;
pub const R_RISCV_ADD64: u32 = 36;
pub const R_RISCV_SUB8: u32 = 37;
pub const R_RISCV_SUB16: u32 = 38;
pub const R_RISCV_SUB32: u32 = 39;
pub const R_RISCV_SUB64: u32 = 40;
pub const R_RISCV_GNU_VTINHERIT: u32 = 41;
pub const R_RISCV_GNU_VTENTRY: u32 = 42;
pub const R_RISCV_ALIGN: u32 = 43;
pub const R_RISCV_RVC_BRANCH: u32 = 44;
pub const R_RISCV_RVC_JUMP: u32 = 45;
pub const R_RISCV_LUI: u32 = 46;
pub const R_RISCV_GPREL_I: u32 = 47;
pub const R_RISCV_GPREL_S: u32 = 48;
pub const R_RISCV_TPREL_I: u32 = 49;
pub const R_RISCV_TPREL_S: u32 = 50;
pub const R_RISCV_RELAX: u32 = 51;
pub const R_RISCV_SUB6: u32 = 52;
pub const R_RISCV_SET6: u32 = 53;
pub const R_RISCV_SET8: u32 = 54;
pub const R_RISCV_SET16: u32 = 55;
pub const R_RISCV_SET32: u32 = 56;
pub const R_RISCV_32_PCREL: u32 = 57;
pub const ELF_ARCH: u32 = 243;
pub const ELF_CLASS: u32 = 2;
pub const ELF_DATA: u32 = 1;
pub const ELF32_GNU_PROPERTY_ALIGN: u32 = 4;
pub const ELF64_GNU_PROPERTY_ALIGN: u32 = 8;
pub const ELF_GNU_PROPERTY_ALIGN: u32 = 8;
pub const IDR_FREE: u32 = 0;
pub const IDA_CHUNK_SIZE: u32 = 128;
pub const KERNFS_TYPE_MASK: u32 = 15;
pub const KERNFS_FLAG_MASK: i32 = -16;
pub const KERNFS_MAX_USER_XATTRS: u32 = 128;
pub const KERNFS_USER_XATTR_SIZE_LIMIT: u32 = 131072;
pub const SYSFS_PREALLOC: u32 = 4096;
pub const UEVENT_HELPER_PATH_LEN: u32 = 256;
pub const UEVENT_NUM_ENVP: u32 = 64;
pub const UEVENT_BUFFER_SIZE: u32 = 2048;
pub const TRACEPOINT_DEFS_H: u32 = 1;
pub const OPC_AUIPC: u32 = 23;
pub const OPC_LD: u32 = 12291;
pub const OPC_JALR: u32 = 103;
pub const REG_T0: u32 = 5;
pub const REG_T1: u32 = 6;
pub const KUNIT_LOG_SIZE: u32 = 512;
pub const KUNIT_PARAM_DESC_SIZE: u32 = 128;
pub const KUNIT_STATUS_COMMENT_SIZE: u32 = 256;
pub const KUNIT_SUBTEST_INDENT: &'static [u8; 5usize] = b"    \0";
pub const KUNIT_SUBSUBTEST_INDENT: &'static [u8; 9usize] = b"        \0";
pub const PRINTK_INFO_SUBSYSTEM_LEN: u32 = 16;
pub const PRINTK_INFO_DEVICE_LEN: u32 = 48;
pub const SCHED_CPUFREQ_IOWAIT: u32 = 1;
pub const SDF_SHARED_CHILD: u32 = 1;
pub const SDF_SHARED_PARENT: u32 = 2;
pub const SDF_NEEDS_GROUPS: u32 = 4;
pub const SDTL_OVERLAP: u32 = 1;
pub const IORESOURCE_BITS: u32 = 255;
pub const IORESOURCE_TYPE_BITS: u32 = 7936;
pub const IORESOURCE_IO: u32 = 256;
pub const IORESOURCE_MEM: u32 = 512;
pub const IORESOURCE_REG: u32 = 768;
pub const IORESOURCE_IRQ: u32 = 1024;
pub const IORESOURCE_DMA: u32 = 2048;
pub const IORESOURCE_BUS: u32 = 4096;
pub const IORESOURCE_PREFETCH: u32 = 8192;
pub const IORESOURCE_READONLY: u32 = 16384;
pub const IORESOURCE_CACHEABLE: u32 = 32768;
pub const IORESOURCE_RANGELENGTH: u32 = 65536;
pub const IORESOURCE_SHADOWABLE: u32 = 131072;
pub const IORESOURCE_SIZEALIGN: u32 = 262144;
pub const IORESOURCE_STARTALIGN: u32 = 524288;
pub const IORESOURCE_MEM_64: u32 = 1048576;
pub const IORESOURCE_WINDOW: u32 = 2097152;
pub const IORESOURCE_MUXED: u32 = 4194304;
pub const IORESOURCE_EXT_TYPE_BITS: u32 = 16777216;
pub const IORESOURCE_SYSRAM: u32 = 16777216;
pub const IORESOURCE_SYSRAM_DRIVER_MANAGED: u32 = 33554432;
pub const IORESOURCE_SYSRAM_MERGEABLE: u32 = 67108864;
pub const IORESOURCE_EXCLUSIVE: u32 = 134217728;
pub const IORESOURCE_DISABLED: u32 = 268435456;
pub const IORESOURCE_UNSET: u32 = 536870912;
pub const IORESOURCE_AUTO: u32 = 1073741824;
pub const IORESOURCE_BUSY: u32 = 2147483648;
pub const IORESOURCE_SYSTEM_RAM: u32 = 16777728;
pub const IORESOURCE_IRQ_HIGHEDGE: u32 = 1;
pub const IORESOURCE_IRQ_LOWEDGE: u32 = 2;
pub const IORESOURCE_IRQ_HIGHLEVEL: u32 = 4;
pub const IORESOURCE_IRQ_LOWLEVEL: u32 = 8;
pub const IORESOURCE_IRQ_SHAREABLE: u32 = 16;
pub const IORESOURCE_IRQ_OPTIONAL: u32 = 32;
pub const IORESOURCE_IRQ_WAKECAPABLE: u32 = 64;
pub const IORESOURCE_DMA_TYPE_MASK: u32 = 3;
pub const IORESOURCE_DMA_8BIT: u32 = 0;
pub const IORESOURCE_DMA_8AND16BIT: u32 = 1;
pub const IORESOURCE_DMA_16BIT: u32 = 2;
pub const IORESOURCE_DMA_MASTER: u32 = 4;
pub const IORESOURCE_DMA_BYTE: u32 = 8;
pub const IORESOURCE_DMA_WORD: u32 = 16;
pub const IORESOURCE_DMA_SPEED_MASK: u32 = 192;
pub const IORESOURCE_DMA_COMPATIBLE: u32 = 0;
pub const IORESOURCE_DMA_TYPEA: u32 = 64;
pub const IORESOURCE_DMA_TYPEB: u32 = 128;
pub const IORESOURCE_DMA_TYPEF: u32 = 192;
pub const IORESOURCE_MEM_WRITEABLE: u32 = 1;
pub const IORESOURCE_MEM_CACHEABLE: u32 = 2;
pub const IORESOURCE_MEM_RANGELENGTH: u32 = 4;
pub const IORESOURCE_MEM_TYPE_MASK: u32 = 24;
pub const IORESOURCE_MEM_8BIT: u32 = 0;
pub const IORESOURCE_MEM_16BIT: u32 = 8;
pub const IORESOURCE_MEM_8AND16BIT: u32 = 16;
pub const IORESOURCE_MEM_32BIT: u32 = 24;
pub const IORESOURCE_MEM_SHADOWABLE: u32 = 32;
pub const IORESOURCE_MEM_EXPANSIONROM: u32 = 64;
pub const IORESOURCE_MEM_NONPOSTED: u32 = 128;
pub const IORESOURCE_IO_16BIT_ADDR: u32 = 1;
pub const IORESOURCE_IO_FIXED: u32 = 2;
pub const IORESOURCE_IO_SPARSE: u32 = 4;
pub const IORESOURCE_ROM_ENABLE: u32 = 1;
pub const IORESOURCE_ROM_SHADOW: u32 = 2;
pub const IORESOURCE_PCI_FIXED: u32 = 16;
pub const IORESOURCE_PCI_EA_BEI: u32 = 32;
pub const PM_EVENT_INVALID: i32 = -1;
pub const PM_EVENT_ON: u32 = 0;
pub const PM_EVENT_FREEZE: u32 = 1;
pub const PM_EVENT_SUSPEND: u32 = 2;
pub const PM_EVENT_HIBERNATE: u32 = 4;
pub const PM_EVENT_QUIESCE: u32 = 8;
pub const PM_EVENT_RESUME: u32 = 16;
pub const PM_EVENT_THAW: u32 = 32;
pub const PM_EVENT_RESTORE: u32 = 64;
pub const PM_EVENT_RECOVER: u32 = 128;
pub const PM_EVENT_USER: u32 = 256;
pub const PM_EVENT_REMOTE: u32 = 512;
pub const PM_EVENT_AUTO: u32 = 1024;
pub const PM_EVENT_SLEEP: u32 = 6;
pub const PM_EVENT_USER_SUSPEND: u32 = 258;
pub const PM_EVENT_USER_RESUME: u32 = 272;
pub const PM_EVENT_REMOTE_RESUME: u32 = 528;
pub const PM_EVENT_AUTO_SUSPEND: u32 = 1026;
pub const PM_EVENT_AUTO_RESUME: u32 = 1040;
pub const PM_EVENT_PRETHAW: u32 = 8;
pub const BUS_NOTIFY_ADD_DEVICE: u32 = 1;
pub const BUS_NOTIFY_DEL_DEVICE: u32 = 2;
pub const BUS_NOTIFY_REMOVED_DEVICE: u32 = 3;
pub const BUS_NOTIFY_BIND_DRIVER: u32 = 4;
pub const BUS_NOTIFY_BOUND_DRIVER: u32 = 5;
pub const BUS_NOTIFY_UNBIND_DRIVER: u32 = 6;
pub const BUS_NOTIFY_UNBOUND_DRIVER: u32 = 7;
pub const BUS_NOTIFY_DRIVER_NOT_BOUND: u32 = 8;
pub const sysfs_deprecated: u32 = 0;
pub const PCI_ANY_ID: i32 = -1;
pub const IEEE1394_MATCH_VENDOR_ID: u32 = 1;
pub const IEEE1394_MATCH_MODEL_ID: u32 = 2;
pub const IEEE1394_MATCH_SPECIFIER_ID: u32 = 4;
pub const IEEE1394_MATCH_VERSION: u32 = 8;
pub const USB_DEVICE_ID_MATCH_VENDOR: u32 = 1;
pub const USB_DEVICE_ID_MATCH_PRODUCT: u32 = 2;
pub const USB_DEVICE_ID_MATCH_DEV_LO: u32 = 4;
pub const USB_DEVICE_ID_MATCH_DEV_HI: u32 = 8;
pub const USB_DEVICE_ID_MATCH_DEV_CLASS: u32 = 16;
pub const USB_DEVICE_ID_MATCH_DEV_SUBCLASS: u32 = 32;
pub const USB_DEVICE_ID_MATCH_DEV_PROTOCOL: u32 = 64;
pub const USB_DEVICE_ID_MATCH_INT_CLASS: u32 = 128;
pub const USB_DEVICE_ID_MATCH_INT_SUBCLASS: u32 = 256;
pub const USB_DEVICE_ID_MATCH_INT_PROTOCOL: u32 = 512;
pub const USB_DEVICE_ID_MATCH_INT_NUMBER: u32 = 1024;
pub const HID_ANY_ID: i32 = -1;
pub const HID_BUS_ANY: u32 = 65535;
pub const HID_GROUP_ANY: u32 = 0;
pub const CCW_DEVICE_ID_MATCH_CU_TYPE: u32 = 1;
pub const CCW_DEVICE_ID_MATCH_CU_MODEL: u32 = 2;
pub const CCW_DEVICE_ID_MATCH_DEVICE_TYPE: u32 = 4;
pub const CCW_DEVICE_ID_MATCH_DEVICE_MODEL: u32 = 8;
pub const AP_DEVICE_ID_MATCH_CARD_TYPE: u32 = 1;
pub const AP_DEVICE_ID_MATCH_QUEUE_TYPE: u32 = 2;
pub const ACPI_ID_LEN: u32 = 16;
pub const PNP_ID_LEN: u32 = 8;
pub const PNP_MAX_DEVICES: u32 = 8;
pub const SERIO_ANY: u32 = 255;
pub const PCMCIA_DEV_ID_MATCH_MANF_ID: u32 = 1;
pub const PCMCIA_DEV_ID_MATCH_CARD_ID: u32 = 2;
pub const PCMCIA_DEV_ID_MATCH_FUNC_ID: u32 = 4;
pub const PCMCIA_DEV_ID_MATCH_FUNCTION: u32 = 8;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID1: u32 = 16;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID2: u32 = 32;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID3: u32 = 64;
pub const PCMCIA_DEV_ID_MATCH_PROD_ID4: u32 = 128;
pub const PCMCIA_DEV_ID_MATCH_DEVICE_NO: u32 = 256;
pub const PCMCIA_DEV_ID_MATCH_FAKE_CIS: u32 = 512;
pub const PCMCIA_DEV_ID_MATCH_ANONYMOUS: u32 = 1024;
pub const INPUT_DEVICE_ID_EV_MAX: u32 = 31;
pub const INPUT_DEVICE_ID_KEY_MIN_INTERESTING: u32 = 113;
pub const INPUT_DEVICE_ID_KEY_MAX: u32 = 767;
pub const INPUT_DEVICE_ID_REL_MAX: u32 = 15;
pub const INPUT_DEVICE_ID_ABS_MAX: u32 = 63;
pub const INPUT_DEVICE_ID_MSC_MAX: u32 = 7;
pub const INPUT_DEVICE_ID_LED_MAX: u32 = 15;
pub const INPUT_DEVICE_ID_SND_MAX: u32 = 7;
pub const INPUT_DEVICE_ID_FF_MAX: u32 = 127;
pub const INPUT_DEVICE_ID_SW_MAX: u32 = 16;
pub const INPUT_DEVICE_ID_PROP_MAX: u32 = 31;
pub const INPUT_DEVICE_ID_MATCH_BUS: u32 = 1;
pub const INPUT_DEVICE_ID_MATCH_VENDOR: u32 = 2;
pub const INPUT_DEVICE_ID_MATCH_PRODUCT: u32 = 4;
pub const INPUT_DEVICE_ID_MATCH_VERSION: u32 = 8;
pub const INPUT_DEVICE_ID_MATCH_EVBIT: u32 = 16;
pub const INPUT_DEVICE_ID_MATCH_KEYBIT: u32 = 32;
pub const INPUT_DEVICE_ID_MATCH_RELBIT: u32 = 64;
pub const INPUT_DEVICE_ID_MATCH_ABSBIT: u32 = 128;
pub const INPUT_DEVICE_ID_MATCH_MSCIT: u32 = 256;
pub const INPUT_DEVICE_ID_MATCH_LEDBIT: u32 = 512;
pub const INPUT_DEVICE_ID_MATCH_SNDBIT: u32 = 1024;
pub const INPUT_DEVICE_ID_MATCH_FFBIT: u32 = 2048;
pub const INPUT_DEVICE_ID_MATCH_SWBIT: u32 = 4096;
pub const INPUT_DEVICE_ID_MATCH_PROPBIT: u32 = 8192;
pub const EISA_SIG_LEN: u32 = 8;
pub const EISA_DEVICE_MODALIAS_FMT: &'static [u8; 9usize] = b"eisa:s%s\0";
pub const PA_HWTYPE_ANY_ID: u32 = 255;
pub const PA_HVERSION_REV_ANY_ID: u32 = 255;
pub const PA_HVERSION_ANY_ID: u32 = 65535;
pub const PA_SVERSION_ANY_ID: u32 = 4294967295;
pub const SDIO_ANY_ID: i32 = -1;
pub const SSB_ANY_VENDOR: u32 = 65535;
pub const SSB_ANY_ID: u32 = 65535;
pub const SSB_ANY_REV: u32 = 255;
pub const BCMA_ANY_MANUF: u32 = 65535;
pub const BCMA_ANY_ID: u32 = 65535;
pub const BCMA_ANY_REV: u32 = 255;
pub const BCMA_ANY_CLASS: u32 = 255;
pub const VIRTIO_DEV_ANY_ID: u32 = 4294967295;
pub const RPMSG_NAME_SIZE: u32 = 32;
pub const RPMSG_DEVICE_MODALIAS_FMT: &'static [u8; 9usize] = b"rpmsg:%s\0";
pub const I2C_NAME_SIZE: u32 = 20;
pub const I2C_MODULE_PREFIX: &'static [u8; 5usize] = b"i2c:\0";
pub const PCI_EPF_NAME_SIZE: u32 = 20;
pub const PCI_EPF_MODULE_PREFIX: &'static [u8; 9usize] = b"pci_epf:\0";
pub const I3C_MATCH_DCR: u32 = 1;
pub const I3C_MATCH_MANUF: u32 = 2;
pub const I3C_MATCH_PART: u32 = 4;
pub const I3C_MATCH_EXTRA_INFO: u32 = 8;
pub const SPI_NAME_SIZE: u32 = 32;
pub const SPI_MODULE_PREFIX: &'static [u8; 5usize] = b"spi:\0";
pub const SLIMBUS_NAME_SIZE: u32 = 32;
pub const SLIMBUS_MODULE_PREFIX: &'static [u8; 6usize] = b"slim:\0";
pub const APR_NAME_SIZE: u32 = 32;
pub const APR_MODULE_PREFIX: &'static [u8; 5usize] = b"apr:\0";
pub const SPMI_NAME_SIZE: u32 = 32;
pub const SPMI_MODULE_PREFIX: &'static [u8; 6usize] = b"spmi:\0";
pub const PLATFORM_NAME_SIZE: u32 = 20;
pub const PLATFORM_MODULE_PREFIX: &'static [u8; 10usize] = b"platform:\0";
pub const MDIO_NAME_SIZE: u32 = 32;
pub const MDIO_MODULE_PREFIX: &'static [u8; 6usize] = b"mdio:\0";
pub const MDIO_ID_FMT: &'static [u8; 65usize] =
    b"%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u%u\0";
pub const ZORRO_WILDCARD: u32 = 4294967295;
pub const ZORRO_DEVICE_MODALIAS_FMT: &'static [u8; 12usize] = b"zorro:i%08X\0";
pub const ISAPNP_ANY_ID: u32 = 65535;
pub const X86_VENDOR_ANY: u32 = 65535;
pub const X86_FAMILY_ANY: u32 = 0;
pub const X86_MODEL_ANY: u32 = 0;
pub const X86_STEPPING_ANY: u32 = 0;
pub const X86_FEATURE_ANY: u32 = 0;
pub const IPACK_ANY_FORMAT: u32 = 255;
pub const IPACK_ANY_ID: i32 = -1;
pub const MEI_CL_MODULE_PREFIX: &'static [u8; 5usize] = b"mei:\0";
pub const MEI_CL_NAME_SIZE: u32 = 32;
pub const MEI_CL_VERSION_ANY: u32 = 255;
pub const RIO_ANY_ID: u32 = 65535;
pub const TBSVC_MATCH_PROTOCOL_KEY: u32 = 1;
pub const TBSVC_MATCH_PROTOCOL_ID: u32 = 2;
pub const TBSVC_MATCH_PROTOCOL_VERSION: u32 = 4;
pub const TBSVC_MATCH_PROTOCOL_REVISION: u32 = 8;
pub const TYPEC_ANY_MODE: u32 = 7;
pub const WMI_MODULE_PREFIX: &'static [u8; 5usize] = b"wmi:\0";
pub const MHI_DEVICE_MODALIAS_FMT: &'static [u8; 7usize] = b"mhi:%s\0";
pub const MHI_NAME_SIZE: u32 = 32;
pub const MHI_EP_DEVICE_MODALIAS_FMT: &'static [u8; 10usize] = b"mhi_ep:%s\0";
pub const AUXILIARY_NAME_SIZE: u32 = 32;
pub const AUXILIARY_MODULE_PREFIX: &'static [u8; 11usize] = b"auxiliary:\0";
pub const SSAM_MATCH_TARGET: u32 = 1;
pub const SSAM_MATCH_INSTANCE: u32 = 2;
pub const SSAM_MATCH_FUNCTION: u32 = 4;
pub const ISHTP_MODULE_PREFIX: &'static [u8; 7usize] = b"ishtp:\0";
pub const TASKSTATS_VERSION: u32 = 13;
pub const TS_COMM_LEN: u32 = 32;
pub const TASKSTATS_GENL_NAME: &'static [u8; 10usize] = b"TASKSTATS\0";
pub const TASKSTATS_GENL_VERSION: u32 = 1;
pub const _U: u32 = 1;
pub const _L: u32 = 2;
pub const _D: u32 = 4;
pub const _C: u32 = 8;
pub const _P: u32 = 16;
pub const _S: u32 = 32;
pub const _X: u32 = 64;
pub const _SP: u32 = 128;
pub const SEQ_SKIP: u32 = 1;
pub const UID_GID_MAP_MAX_BASE_EXTENTS: u32 = 5;
pub const UID_GID_MAP_MAX_EXTENTS: u32 = 340;
pub const USERNS_SETGROUPS_ALLOWED: u32 = 1;
pub const USERNS_INIT_FLAGS: u32 = 1;
pub const USER_PGTABLES_CEILING: u32 = 0;
pub const FIRST_USER_ADDRESS: u32 = 0;
pub const __PGTBL_PGD_MODIFIED: u32 = 0;
pub const __PGTBL_P4D_MODIFIED: u32 = 1;
pub const __PGTBL_PUD_MODIFIED: u32 = 2;
pub const __PGTBL_PMD_MODIFIED: u32 = 3;
pub const __PGTBL_PTE_MODIFIED: u32 = 4;
pub const IO_SPACE_LIMIT: u32 = 16777215;
pub const SWNODE_GRAPH_PORT_NAME_FMT: &'static [u8; 8usize] = b"port@%u\0";
pub const SWNODE_GRAPH_ENDPOINT_NAME_FMT: &'static [u8; 12usize] = b"endpoint@%u\0";
pub const NR_FWNODE_REFERENCE_ARGS: u32 = 8;
pub const PIO_INDIRECT_SIZE: u32 = 0;
pub const MMIO_UPPER_LIMIT: u32 = 16777215;
pub const VM_IOREMAP: u32 = 1;
pub const VM_ALLOC: u32 = 2;
pub const VM_MAP: u32 = 4;
pub const VM_USERMAP: u32 = 8;
pub const VM_DMA_COHERENT: u32 = 16;
pub const VM_UNINITIALIZED: u32 = 32;
pub const VM_NO_GUARD: u32 = 64;
pub const VM_KASAN: u32 = 128;
pub const VM_FLUSH_RESET_PERMS: u32 = 256;
pub const VM_MAP_PUT_PAGES: u32 = 512;
pub const VM_ALLOW_HUGE_VMAP: u32 = 1024;
pub const VM_DEFER_KMEMLEAK: u32 = 0;
pub const IOREMAP_MAX_ORDER: u32 = 19;
pub const ARCH_PAGE_TABLE_SYNC_MASK: u32 = 0;
pub const NR_IRQS: u32 = 64;
pub const NR_IRQS_LEGACY: u32 = 0;
pub const ARCH_IRQ_INIT_FLAGS: u32 = 0;
pub const IRQ_DEFAULT_INIT_FLAGS: u32 = 0;
pub const INVALID_HWIRQ: i32 = -1;
pub const STACK_DEPOT_EXTRA_BITS: u32 = 5;
pub const PGMAP_ALTMAP_VALID: u32 = 1;
pub const MAPCOUNT_ELF_CORE_MARGIN: u32 = 5;
pub const VM_NONE: u32 = 0;
pub const VM_READ: u32 = 1;
pub const VM_WRITE: u32 = 2;
pub const VM_EXEC: u32 = 4;
pub const VM_SHARED: u32 = 8;
pub const VM_MAYREAD: u32 = 16;
pub const VM_MAYWRITE: u32 = 32;
pub const VM_MAYEXEC: u32 = 64;
pub const VM_MAYSHARE: u32 = 128;
pub const VM_GROWSDOWN: u32 = 256;
pub const VM_UFFD_MISSING: u32 = 512;
pub const VM_PFNMAP: u32 = 1024;
pub const VM_UFFD_WP: u32 = 4096;
pub const VM_LOCKED: u32 = 8192;
pub const VM_IO: u32 = 16384;
pub const VM_SEQ_READ: u32 = 32768;
pub const VM_RAND_READ: u32 = 65536;
pub const VM_DONTCOPY: u32 = 131072;
pub const VM_DONTEXPAND: u32 = 262144;
pub const VM_LOCKONFAULT: u32 = 524288;
pub const VM_ACCOUNT: u32 = 1048576;
pub const VM_NORESERVE: u32 = 2097152;
pub const VM_HUGETLB: u32 = 4194304;
pub const VM_SYNC: u32 = 8388608;
pub const VM_ARCH_1: u32 = 16777216;
pub const VM_WIPEONFORK: u32 = 33554432;
pub const VM_DONTDUMP: u32 = 67108864;
pub const VM_SOFTDIRTY: u32 = 0;
pub const VM_MIXEDMAP: u32 = 268435456;
pub const VM_HUGEPAGE: u32 = 536870912;
pub const VM_NOHUGEPAGE: u32 = 1073741824;
pub const VM_MERGEABLE: u32 = 2147483648;
pub const VM_MTE: u32 = 0;
pub const VM_MTE_ALLOWED: u32 = 0;
pub const VM_GROWSUP: u32 = 0;
pub const VM_UFFD_MINOR: u32 = 0;
pub const VM_STACK_INCOMPLETE_SETUP: u32 = 98304;
pub const VM_DATA_FLAGS_NON_EXEC: u32 = 115;
pub const VM_DATA_FLAGS_EXEC: u32 = 119;
pub const VM_STACK: u32 = 256;
pub const VM_ACCESS_FLAGS: u32 = 7;
pub const VM_SPECIAL: u32 = 268715008;
pub const VM_NO_KHUGEPAGED: u32 = 272909312;
pub const VM_INIT_DEF_MASK: u32 = 1073741824;
pub const VM_LOCKED_CLEAR_MASK: i32 = -532481;
pub const VM_ARCH_CLEAR: u32 = 0;
pub const SUID_DUMP_DISABLE: u32 = 0;
pub const SUID_DUMP_USER: u32 = 1;
pub const SUID_DUMP_ROOT: u32 = 2;
pub const MMF_DUMPABLE_BITS: u32 = 2;
pub const MMF_DUMPABLE_MASK: u32 = 3;
pub const MMF_DUMP_ANON_PRIVATE: u32 = 2;
pub const MMF_DUMP_ANON_SHARED: u32 = 3;
pub const MMF_DUMP_MAPPED_PRIVATE: u32 = 4;
pub const MMF_DUMP_MAPPED_SHARED: u32 = 5;
pub const MMF_DUMP_ELF_HEADERS: u32 = 6;
pub const MMF_DUMP_HUGETLB_PRIVATE: u32 = 7;
pub const MMF_DUMP_HUGETLB_SHARED: u32 = 8;
pub const MMF_DUMP_DAX_PRIVATE: u32 = 9;
pub const MMF_DUMP_DAX_SHARED: u32 = 10;
pub const MMF_DUMP_FILTER_SHIFT: u32 = 2;
pub const MMF_DUMP_FILTER_BITS: u32 = 9;
pub const MMF_DUMP_FILTER_MASK: u32 = 2044;
pub const MMF_DUMP_MASK_DEFAULT_ELF: u32 = 64;
pub const MMF_VM_MERGEABLE: u32 = 16;
pub const MMF_VM_HUGEPAGE: u32 = 17;
pub const MMF_HAS_UPROBES: u32 = 19;
pub const MMF_RECALC_UPROBES: u32 = 20;
pub const MMF_OOM_SKIP: u32 = 21;
pub const MMF_UNSTABLE: u32 = 22;
pub const MMF_HUGE_ZERO_PAGE: u32 = 23;
pub const MMF_DISABLE_THP: u32 = 24;
pub const MMF_OOM_REAP_QUEUED: u32 = 25;
pub const MMF_MULTIPROCESS: u32 = 26;
pub const MMF_HAS_PINNED: u32 = 27;
pub const MMF_DISABLE_THP_MASK: u32 = 16777216;
pub const MMF_INIT_MASK: u32 = 16779263;
pub const transparent_hugepage_flags: u32 = 0;
pub const GUP_PIN_COUNTING_BIAS: u32 = 1024;
pub const SHOW_MEM_FILTER_NODES: u32 = 1;
pub const MM_CP_TRY_CHANGE_WRITABLE: u32 = 1;
pub const MM_CP_PROT_NUMA: u32 = 2;
pub const MM_CP_UFFD_WP: u32 = 4;
pub const MM_CP_UFFD_WP_RESOLVE: u32 = 8;
pub const MM_CP_UFFD_WP_ALL: u32 = 12;
pub const VM_UNMAPPED_AREA_TOPDOWN: u32 = 1;
pub const FOLL_WRITE: u32 = 1;
pub const FOLL_TOUCH: u32 = 2;
pub const FOLL_GET: u32 = 4;
pub const FOLL_DUMP: u32 = 8;
pub const FOLL_FORCE: u32 = 16;
pub const FOLL_NOWAIT: u32 = 32;
pub const FOLL_NOFAULT: u32 = 128;
pub const FOLL_HWPOISON: u32 = 256;
pub const FOLL_MIGRATION: u32 = 1024;
pub const FOLL_TRIED: u32 = 2048;
pub const FOLL_REMOTE: u32 = 8192;
pub const FOLL_ANON: u32 = 32768;
pub const FOLL_LONGTERM: u32 = 65536;
pub const FOLL_SPLIT_PMD: u32 = 131072;
pub const FOLL_PIN: u32 = 262144;
pub const FOLL_FAST_ONLY: u32 = 524288;
pub const IRQF_TRIGGER_NONE: u32 = 0;
pub const IRQF_TRIGGER_RISING: u32 = 1;
pub const IRQF_TRIGGER_FALLING: u32 = 2;
pub const IRQF_TRIGGER_HIGH: u32 = 4;
pub const IRQF_TRIGGER_LOW: u32 = 8;
pub const IRQF_TRIGGER_MASK: u32 = 15;
pub const IRQF_TRIGGER_PROBE: u32 = 16;
pub const IRQF_SHARED: u32 = 128;
pub const IRQF_PROBE_SHARED: u32 = 256;
pub const __IRQF_TIMER: u32 = 512;
pub const IRQF_PERCPU: u32 = 1024;
pub const IRQF_NOBALANCING: u32 = 2048;
pub const IRQF_IRQPOLL: u32 = 4096;
pub const IRQF_ONESHOT: u32 = 8192;
pub const IRQF_NO_SUSPEND: u32 = 16384;
pub const IRQF_FORCE_RESUME: u32 = 32768;
pub const IRQF_NO_THREAD: u32 = 65536;
pub const IRQF_EARLY_RESUME: u32 = 131072;
pub const IRQF_COND_SUSPEND: u32 = 262144;
pub const IRQF_NO_AUTOEN: u32 = 524288;
pub const IRQF_NO_DEBUG: u32 = 1048576;
pub const IRQF_TIMER: u32 = 82432;
pub const IRQ_NOTCONNECTED: u32 = 2147483648;
pub const IRQ_AFFINITY_MAX_SETS: u32 = 4;
pub const CGROUP_LSM_NUM: u32 = 0;
pub const NR_PSI_RESOURCES: u32 = 0;
pub const MAX_CGROUP_TYPE_NAMELEN: u32 = 32;
pub const MAX_CGROUP_ROOT_NAMELEN: u32 = 64;
pub const MAX_CFTYPE_NAME: u32 = 64;
pub const CGROUP_WEIGHT_MIN: u32 = 1;
pub const CGROUP_WEIGHT_DFL: u32 = 100;
pub const CGROUP_WEIGHT_MAX: u32 = 10000;
pub const CSS_TASK_ITER_PROCS: u32 = 1;
pub const CSS_TASK_ITER_THREADED: u32 = 2;
pub const CSS_TASK_ITER_SKIPPED: u32 = 65536;
pub const EFD_SEMAPHORE: u32 = 1;
pub const EFD_CLOEXEC: u32 = 524288;
pub const EFD_NONBLOCK: u32 = 2048;
pub const EFD_SHARED_FCNTL_FLAGS: u32 = 526336;
pub const EFD_FLAGS_SET: u32 = 526337;
pub const FPROP_FRAC_SHIFT: u32 = 10;
pub const FPROP_FRAC_BASE: u32 = 1024;
pub const ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE: u32 = 1;
pub const SYS_RISCV_FLUSH_ICACHE_LOCAL: u32 = 1;
pub const SYS_RISCV_FLUSH_ICACHE_ALL: u32 = 1;
pub const SECTOR_SHIFT: u32 = 9;
pub const SECTOR_SIZE: u32 = 512;
pub const PAGE_SECTORS_SHIFT: u32 = 3;
pub const PAGE_SECTORS: u32 = 8;
pub const SECTOR_MASK: u32 = 7;
pub const BLK_STS_OK: u32 = 0;
pub const BIO_ISSUE_RES_BITS: u32 = 1;
pub const BIO_ISSUE_SIZE_BITS: u32 = 12;
pub const BIO_ISSUE_RES_SHIFT: u32 = 63;
pub const BIO_ISSUE_SIZE_SHIFT: u32 = 51;
pub const BIO_ISSUE_TIME_MASK: u64 = 2251799813685247;
pub const BIO_ISSUE_SIZE_MASK: u64 = 9221120237041090560;
pub const BIO_ISSUE_RES_MASK: i64 = -9223372036854775808;
pub const BIO_ISSUE_THROTL_SKIP_LATENCY: i64 = -9223372036854775808;
pub const BLK_QC_T_NONE: i32 = -1;
pub const BIO_MAX_SECTORS: i32 = -1;
pub const REQ_OP_BITS: u32 = 8;
pub const REQ_FLAG_BITS: u32 = 24;
pub const DIRTY_SCOPE: u32 = 8;
pub const BDP_ASYNC: u32 = 1;
pub const MEM_CGROUP_ID_SHIFT: u32 = 16;
pub const MEMCG_CGWB_FRN_CNT: u32 = 4;
pub const MEMCG_CHARGE_BATCH: u32 = 64;
pub const FGP_ACCESSED: u32 = 1;
pub const FGP_LOCK: u32 = 2;
pub const FGP_CREAT: u32 = 4;
pub const FGP_WRITE: u32 = 8;
pub const FGP_NOFS: u32 = 16;
pub const FGP_NOWAIT: u32 = 32;
pub const FGP_FOR_MMAP: u32 = 64;
pub const FGP_HEAD: u32 = 128;
pub const FGP_ENTRY: u32 = 256;
pub const FGP_STABLE: u32 = 512;
pub const MPOL_F_STATIC_NODES: u32 = 32768;
pub const MPOL_F_RELATIVE_NODES: u32 = 16384;
pub const MPOL_F_NUMA_BALANCING: u32 = 8192;
pub const MPOL_MODE_FLAGS: u32 = 57344;
pub const MPOL_F_NODE: u32 = 1;
pub const MPOL_F_ADDR: u32 = 2;
pub const MPOL_F_MEMS_ALLOWED: u32 = 4;
pub const MPOL_MF_STRICT: u32 = 1;
pub const MPOL_MF_MOVE: u32 = 2;
pub const MPOL_MF_MOVE_ALL: u32 = 4;
pub const MPOL_MF_LAZY: u32 = 8;
pub const MPOL_MF_INTERNAL: u32 = 16;
pub const MPOL_MF_VALID: u32 = 7;
pub const MPOL_F_SHARED: u32 = 1;
pub const MPOL_F_MOF: u32 = 8;
pub const MPOL_F_MORON: u32 = 16;
pub const RECLAIM_ZONE: u32 = 1;
pub const RECLAIM_WRITE: u32 = 2;
pub const RECLAIM_UNMAP: u32 = 4;
pub const SWAP_FLAG_PREFER: u32 = 32768;
pub const SWAP_FLAG_PRIO_MASK: u32 = 32767;
pub const SWAP_FLAG_PRIO_SHIFT: u32 = 0;
pub const SWAP_FLAG_DISCARD: u32 = 65536;
pub const SWAP_FLAG_DISCARD_ONCE: u32 = 131072;
pub const SWAP_FLAG_DISCARD_PAGES: u32 = 262144;
pub const SWAP_FLAGS_VALID: u32 = 524287;
pub const SWAP_BATCH: u32 = 64;
pub const MAX_SWAPFILES_SHIFT: u32 = 5;
pub const SWP_SWAPIN_ERROR_NUM: u32 = 1;
pub const SWP_PTE_MARKER_NUM: u32 = 0;
pub const SWP_DEVICE_NUM: u32 = 0;
pub const SWP_MIGRATION_NUM: u32 = 3;
pub const SWP_HWPOISON_NUM: u32 = 0;
pub const MAX_SWAPFILES: u32 = 28;
pub const SWAP_CLUSTER_MAX: u32 = 32;
pub const COMPACT_CLUSTER_MAX: u32 = 32;
pub const SWAP_HAS_CACHE: u32 = 64;
pub const COUNT_CONTINUED: u32 = 128;
pub const SWAP_MAP_MAX: u32 = 62;
pub const SWAP_MAP_BAD: u32 = 63;
pub const SWAP_MAP_SHMEM: u32 = 191;
pub const SWAP_CONT_MAX: u32 = 127;
pub const CLUSTER_FLAG_FREE: u32 = 1;
pub const CLUSTER_FLAG_NEXT_NULL: u32 = 2;
pub const CLUSTER_FLAG_HUGE: u32 = 4;
pub const SWAP_RA_ORDER_CEILING: u32 = 5;
pub const MEMCG_RECLAIM_MAY_SWAP: u32 = 2;
pub const MEMCG_RECLAIM_PROACTIVE: u32 = 4;
pub const node_reclaim_mode: u32 = 0;
pub const REC_FAILED_NUM: u32 = 2;
pub const PM_HIBERNATION_PREPARE: u32 = 1;
pub const PM_POST_HIBERNATION: u32 = 2;
pub const PM_SUSPEND_PREPARE: u32 = 3;
pub const PM_POST_SUSPEND: u32 = 4;
pub const PM_RESTORE_PREPARE: u32 = 5;
pub const PM_POST_RESTORE: u32 = 6;
pub const REGULATOR_MODE_INVALID: u32 = 0;
pub const REGULATOR_MODE_FAST: u32 = 1;
pub const REGULATOR_MODE_NORMAL: u32 = 2;
pub const REGULATOR_MODE_IDLE: u32 = 4;
pub const REGULATOR_MODE_STANDBY: u32 = 8;
pub const REGULATOR_EVENT_UNDER_VOLTAGE: u32 = 1;
pub const REGULATOR_EVENT_OVER_CURRENT: u32 = 2;
pub const REGULATOR_EVENT_REGULATION_OUT: u32 = 4;
pub const REGULATOR_EVENT_FAIL: u32 = 8;
pub const REGULATOR_EVENT_OVER_TEMP: u32 = 16;
pub const REGULATOR_EVENT_FORCE_DISABLE: u32 = 32;
pub const REGULATOR_EVENT_VOLTAGE_CHANGE: u32 = 64;
pub const REGULATOR_EVENT_DISABLE: u32 = 128;
pub const REGULATOR_EVENT_PRE_VOLTAGE_CHANGE: u32 = 256;
pub const REGULATOR_EVENT_ABORT_VOLTAGE_CHANGE: u32 = 512;
pub const REGULATOR_EVENT_PRE_DISABLE: u32 = 1024;
pub const REGULATOR_EVENT_ABORT_DISABLE: u32 = 2048;
pub const REGULATOR_EVENT_ENABLE: u32 = 4096;
pub const REGULATOR_EVENT_UNDER_VOLTAGE_WARN: u32 = 8192;
pub const REGULATOR_EVENT_OVER_CURRENT_WARN: u32 = 16384;
pub const REGULATOR_EVENT_OVER_VOLTAGE_WARN: u32 = 32768;
pub const REGULATOR_EVENT_OVER_TEMP_WARN: u32 = 65536;
pub const REGULATOR_EVENT_WARN_MASK: u32 = 122880;
pub const AMBA_NR_IRQS: u32 = 9;
pub const AMBA_CID: u32 = 2969956365;
pub const CORESIGHT_CID: u32 = 2969931789;
pub const UCI_REG_DEVTYPE_OFFSET: u32 = 4044;
pub const UCI_REG_DEVARCH_OFFSET: u32 = 4028;
pub const FDPUT_FPUT: u32 = 1;
pub const FDPUT_POS_UNLOCK: u32 = 2;
pub const CAP_OPT_NONE: u32 = 0;
pub const SECURITY_LSM_NATIVE_LABELS: u32 = 1;
pub const LSM_SETID_ID: u32 = 1;
pub const LSM_SETID_RE: u32 = 2;
pub const LSM_SETID_RES: u32 = 4;
pub const LSM_SETID_FS: u32 = 8;
pub const LSM_PRLIMIT_READ: u32 = 1;
pub const LSM_PRLIMIT_WRITE: u32 = 2;
pub const LSM_UNSAFE_SHARE: u32 = 1;
pub const LSM_UNSAFE_PTRACE: u32 = 2;
pub const LSM_UNSAFE_NO_NEW_PRIVS: u32 = 4;
pub const fs_param_neg_with_no: u32 = 2;
pub const fs_param_can_be_empty: u32 = 4;
pub const fs_param_deprecated: u32 = 8;
pub const MAX_PHANDLE_ARGS: u32 = 16;
pub const OF_DYNAMIC: u32 = 1;
pub const OF_DETACHED: u32 = 2;
pub const OF_POPULATED: u32 = 3;
pub const OF_POPULATED_BUS: u32 = 4;
pub const OF_OVERLAY: u32 = 5;
pub const OF_OVERLAY_FREE_CSET: u32 = 6;
pub const OF_RECONFIG_ATTACH_NODE: u32 = 1;
pub const OF_RECONFIG_DETACH_NODE: u32 = 2;
pub const OF_RECONFIG_ADD_PROPERTY: u32 = 3;
pub const OF_RECONFIG_REMOVE_PROPERTY: u32 = 4;
pub const OF_RECONFIG_UPDATE_PROPERTY: u32 = 5;
pub const IRQ_DOMAIN_IRQ_SPEC_PARAMS: u32 = 16;
pub const PINCTRL_STATE_DEFAULT: &'static [u8; 8usize] = b"default\0";
pub const PINCTRL_STATE_INIT: &'static [u8; 5usize] = b"init\0";
pub const PINCTRL_STATE_IDLE: &'static [u8; 5usize] = b"idle\0";
pub const PINCTRL_STATE_SLEEP: &'static [u8; 6usize] = b"sleep\0";
pub const NUM_MSI_ALLOC_SCRATCHPAD_REGS: u32 = 2;
pub const MSI_ALLOC_FLAGS_PROXY_DEVICE: u32 = 1;
pub const GENERIC_MSI_DOMAIN_OPS: u32 = 1;
pub const GPIO_LINE_DIRECTION_IN: u32 = 1;
pub const GPIO_LINE_DIRECTION_OUT: u32 = 0;
pub const UNNAMED_MAJOR: u32 = 0;
pub const MEM_MAJOR: u32 = 1;
pub const RAMDISK_MAJOR: u32 = 1;
pub const FLOPPY_MAJOR: u32 = 2;
pub const PTY_MASTER_MAJOR: u32 = 2;
pub const IDE0_MAJOR: u32 = 3;
pub const HD_MAJOR: u32 = 3;
pub const PTY_SLAVE_MAJOR: u32 = 3;
pub const TTY_MAJOR: u32 = 4;
pub const TTYAUX_MAJOR: u32 = 5;
pub const LP_MAJOR: u32 = 6;
pub const VCS_MAJOR: u32 = 7;
pub const LOOP_MAJOR: u32 = 7;
pub const SCSI_DISK0_MAJOR: u32 = 8;
pub const SCSI_TAPE_MAJOR: u32 = 9;
pub const MD_MAJOR: u32 = 9;
pub const MISC_MAJOR: u32 = 10;
pub const SCSI_CDROM_MAJOR: u32 = 11;
pub const MUX_MAJOR: u32 = 11;
pub const XT_DISK_MAJOR: u32 = 13;
pub const INPUT_MAJOR: u32 = 13;
pub const SOUND_MAJOR: u32 = 14;
pub const CDU31A_CDROM_MAJOR: u32 = 15;
pub const JOYSTICK_MAJOR: u32 = 15;
pub const GOLDSTAR_CDROM_MAJOR: u32 = 16;
pub const OPTICS_CDROM_MAJOR: u32 = 17;
pub const SANYO_CDROM_MAJOR: u32 = 18;
pub const MITSUMI_X_CDROM_MAJOR: u32 = 20;
pub const MFM_ACORN_MAJOR: u32 = 21;
pub const SCSI_GENERIC_MAJOR: u32 = 21;
pub const IDE1_MAJOR: u32 = 22;
pub const DIGICU_MAJOR: u32 = 22;
pub const DIGI_MAJOR: u32 = 23;
pub const MITSUMI_CDROM_MAJOR: u32 = 23;
pub const CDU535_CDROM_MAJOR: u32 = 24;
pub const STL_SERIALMAJOR: u32 = 24;
pub const MATSUSHITA_CDROM_MAJOR: u32 = 25;
pub const STL_CALLOUTMAJOR: u32 = 25;
pub const MATSUSHITA_CDROM2_MAJOR: u32 = 26;
pub const QIC117_TAPE_MAJOR: u32 = 27;
pub const MATSUSHITA_CDROM3_MAJOR: u32 = 27;
pub const MATSUSHITA_CDROM4_MAJOR: u32 = 28;
pub const STL_SIOMEMMAJOR: u32 = 28;
pub const ACSI_MAJOR: u32 = 28;
pub const AZTECH_CDROM_MAJOR: u32 = 29;
pub const FB_MAJOR: u32 = 29;
pub const MTD_BLOCK_MAJOR: u32 = 31;
pub const CM206_CDROM_MAJOR: u32 = 32;
pub const IDE2_MAJOR: u32 = 33;
pub const IDE3_MAJOR: u32 = 34;
pub const Z8530_MAJOR: u32 = 34;
pub const XPRAM_MAJOR: u32 = 35;
pub const NETLINK_MAJOR: u32 = 36;
pub const PS2ESDI_MAJOR: u32 = 36;
pub const IDETAPE_MAJOR: u32 = 37;
pub const Z2RAM_MAJOR: u32 = 37;
pub const APBLOCK_MAJOR: u32 = 38;
pub const DDV_MAJOR: u32 = 39;
pub const NBD_MAJOR: u32 = 43;
pub const RISCOM8_NORMAL_MAJOR: u32 = 48;
pub const DAC960_MAJOR: u32 = 48;
pub const RISCOM8_CALLOUT_MAJOR: u32 = 49;
pub const MKISS_MAJOR: u32 = 55;
pub const DSP56K_MAJOR: u32 = 55;
pub const IDE4_MAJOR: u32 = 56;
pub const IDE5_MAJOR: u32 = 57;
pub const SCSI_DISK1_MAJOR: u32 = 65;
pub const SCSI_DISK2_MAJOR: u32 = 66;
pub const SCSI_DISK3_MAJOR: u32 = 67;
pub const SCSI_DISK4_MAJOR: u32 = 68;
pub const SCSI_DISK5_MAJOR: u32 = 69;
pub const SCSI_DISK6_MAJOR: u32 = 70;
pub const SCSI_DISK7_MAJOR: u32 = 71;
pub const COMPAQ_SMART2_MAJOR: u32 = 72;
pub const COMPAQ_SMART2_MAJOR1: u32 = 73;
pub const COMPAQ_SMART2_MAJOR2: u32 = 74;
pub const COMPAQ_SMART2_MAJOR3: u32 = 75;
pub const COMPAQ_SMART2_MAJOR4: u32 = 76;
pub const COMPAQ_SMART2_MAJOR5: u32 = 77;
pub const COMPAQ_SMART2_MAJOR6: u32 = 78;
pub const COMPAQ_SMART2_MAJOR7: u32 = 79;
pub const SPECIALIX_NORMAL_MAJOR: u32 = 75;
pub const SPECIALIX_CALLOUT_MAJOR: u32 = 76;
pub const AURORA_MAJOR: u32 = 79;
pub const I2O_MAJOR: u32 = 80;
pub const SHMIQ_MAJOR: u32 = 85;
pub const SCSI_CHANGER_MAJOR: u32 = 86;
pub const IDE6_MAJOR: u32 = 88;
pub const IDE7_MAJOR: u32 = 89;
pub const IDE8_MAJOR: u32 = 90;
pub const MTD_CHAR_MAJOR: u32 = 90;
pub const IDE9_MAJOR: u32 = 91;
pub const DASD_MAJOR: u32 = 94;
pub const MDISK_MAJOR: u32 = 95;
pub const UBD_MAJOR: u32 = 98;
pub const PP_MAJOR: u32 = 99;
pub const JSFD_MAJOR: u32 = 99;
pub const PHONE_MAJOR: u32 = 100;
pub const COMPAQ_CISS_MAJOR: u32 = 104;
pub const COMPAQ_CISS_MAJOR1: u32 = 105;
pub const COMPAQ_CISS_MAJOR2: u32 = 106;
pub const COMPAQ_CISS_MAJOR3: u32 = 107;
pub const COMPAQ_CISS_MAJOR4: u32 = 108;
pub const COMPAQ_CISS_MAJOR5: u32 = 109;
pub const COMPAQ_CISS_MAJOR6: u32 = 110;
pub const COMPAQ_CISS_MAJOR7: u32 = 111;
pub const VIODASD_MAJOR: u32 = 112;
pub const VIOCD_MAJOR: u32 = 113;
pub const ATARAID_MAJOR: u32 = 114;
pub const SCSI_DISK8_MAJOR: u32 = 128;
pub const SCSI_DISK9_MAJOR: u32 = 129;
pub const SCSI_DISK10_MAJOR: u32 = 130;
pub const SCSI_DISK11_MAJOR: u32 = 131;
pub const SCSI_DISK12_MAJOR: u32 = 132;
pub const SCSI_DISK13_MAJOR: u32 = 133;
pub const SCSI_DISK14_MAJOR: u32 = 134;
pub const SCSI_DISK15_MAJOR: u32 = 135;
pub const UNIX98_PTY_MASTER_MAJOR: u32 = 128;
pub const UNIX98_PTY_MAJOR_COUNT: u32 = 8;
pub const UNIX98_PTY_SLAVE_MAJOR: u32 = 136;
pub const DRBD_MAJOR: u32 = 147;
pub const RTF_MAJOR: u32 = 150;
pub const RAW_MAJOR: u32 = 162;
pub const USB_ACM_MAJOR: u32 = 166;
pub const USB_ACM_AUX_MAJOR: u32 = 167;
pub const USB_CHAR_MAJOR: u32 = 180;
pub const MMC_BLOCK_MAJOR: u32 = 179;
pub const VXVM_MAJOR: u32 = 199;
pub const VXSPEC_MAJOR: u32 = 200;
pub const VXDMP_MAJOR: u32 = 201;
pub const XENVBD_MAJOR: u32 = 202;
pub const MSR_MAJOR: u32 = 202;
pub const CPUID_MAJOR: u32 = 203;
pub const OSST_MAJOR: u32 = 206;
pub const IBM_TTY3270_MAJOR: u32 = 227;
pub const IBM_FS3270_MAJOR: u32 = 228;
pub const VIOTAPE_MAJOR: u32 = 230;
pub const BLOCK_EXT_MAJOR: u32 = 259;
pub const SCSI_OSD_MAJOR: u32 = 260;
pub const PSMOUSE_MINOR: u32 = 1;
pub const MS_BUSMOUSE_MINOR: u32 = 2;
pub const ATIXL_BUSMOUSE_MINOR: u32 = 3;
pub const ATARIMOUSE_MINOR: u32 = 5;
pub const SUN_MOUSE_MINOR: u32 = 6;
pub const APOLLO_MOUSE_MINOR: u32 = 7;
pub const PC110PAD_MINOR: u32 = 9;
pub const WATCHDOG_MINOR: u32 = 130;
pub const TEMP_MINOR: u32 = 131;
pub const APM_MINOR_DEV: u32 = 134;
pub const RTC_MINOR: u32 = 135;
pub const VHCI_MINOR: u32 = 137;
pub const SUN_OPENPROM_MINOR: u32 = 139;
pub const DMAPI_MINOR: u32 = 140;
pub const NVRAM_MINOR: u32 = 144;
pub const SBUS_FLASH_MINOR: u32 = 152;
pub const SGI_MMTIMER: u32 = 153;
pub const PMU_MINOR: u32 = 154;
pub const STORE_QUEUE_MINOR: u32 = 155;
pub const LCD_MINOR: u32 = 156;
pub const AC_MINOR: u32 = 157;
pub const BUTTON_MINOR: u32 = 158;
pub const NWFLASH_MINOR: u32 = 160;
pub const ENVCTRL_MINOR: u32 = 162;
pub const I2O_MINOR: u32 = 166;
pub const UCTRL_MINOR: u32 = 174;
pub const AGPGART_MINOR: u32 = 175;
pub const TOSH_MINOR_DEV: u32 = 181;
pub const HWRNG_MINOR: u32 = 183;
pub const KEYPAD_MINOR: u32 = 185;
pub const IRNET_MINOR: u32 = 187;
pub const D7S_MINOR: u32 = 193;
pub const VFIO_MINOR: u32 = 196;
pub const PXA3XX_GCU_MINOR: u32 = 197;
pub const TUN_MINOR: u32 = 200;
pub const CUSE_MINOR: u32 = 203;
pub const MWAVE_MINOR: u32 = 219;
pub const MPT_MINOR: u32 = 220;
pub const MPT2SAS_MINOR: u32 = 221;
pub const MPT3SAS_MINOR: u32 = 222;
pub const UINPUT_MINOR: u32 = 223;
pub const MISC_MCELOG_MINOR: u32 = 227;
pub const HPET_MINOR: u32 = 228;
pub const FUSE_MINOR: u32 = 229;
pub const SNAPSHOT_MINOR: u32 = 231;
pub const KVM_MINOR: u32 = 232;
pub const BTRFS_MINOR: u32 = 234;
pub const AUTOFS_MINOR: u32 = 235;
pub const MAPPER_CTRL_MINOR: u32 = 236;
pub const LOOP_CTRL_MINOR: u32 = 237;
pub const VHOST_NET_MINOR: u32 = 238;
pub const UHID_MINOR: u32 = 239;
pub const USERIO_MINOR: u32 = 240;
pub const VHOST_VSOCK_MINOR: u32 = 241;
pub const RFKILL_MINOR: u32 = 242;
pub const MISC_DYNAMIC_MINOR: u32 = 255;
pub const NPROTO: u32 = 46;
pub const SYS_SOCKET: u32 = 1;
pub const SYS_BIND: u32 = 2;
pub const SYS_CONNECT: u32 = 3;
pub const SYS_LISTEN: u32 = 4;
pub const SYS_ACCEPT: u32 = 5;
pub const SYS_GETSOCKNAME: u32 = 6;
pub const SYS_GETPEERNAME: u32 = 7;
pub const SYS_SOCKETPAIR: u32 = 8;
pub const SYS_SEND: u32 = 9;
pub const SYS_RECV: u32 = 10;
pub const SYS_SENDTO: u32 = 11;
pub const SYS_RECVFROM: u32 = 12;
pub const SYS_SHUTDOWN: u32 = 13;
pub const SYS_SETSOCKOPT: u32 = 14;
pub const SYS_GETSOCKOPT: u32 = 15;
pub const SYS_SENDMSG: u32 = 16;
pub const SYS_RECVMSG: u32 = 17;
pub const SYS_ACCEPT4: u32 = 18;
pub const SYS_RECVMMSG: u32 = 19;
pub const SYS_SENDMMSG: u32 = 20;
pub const __SO_ACCEPTCON: u32 = 65536;
pub const SOCKWQ_ASYNC_NOSPACE: u32 = 0;
pub const SOCKWQ_ASYNC_WAITDATA: u32 = 1;
pub const SOCK_NOSPACE: u32 = 2;
pub const SOCK_PASSCRED: u32 = 3;
pub const SOCK_PASSSEC: u32 = 4;
pub const SOCK_TYPE_MASK: u32 = 15;
pub const SOCK_CLOEXEC: u32 = 524288;
pub const SOCK_NONBLOCK: u32 = 2048;
pub const TS_AUTOLOAD: u32 = 1;
pub const TS_IGNORECASE: u32 = 2;
pub const TS_PRIV_ALIGNTO: u32 = 8;
pub const SG_CHAIN: u32 = 1;
pub const SG_END: u32 = 2;
pub const SG_PAGE_LINK_MASK: u32 = 3;
pub const SG_CHUNK_SIZE: u32 = 128;
pub const SG_MAX_SEGMENTS: u32 = 2048;
pub const SG_MITER_ATOMIC: u32 = 1;
pub const SG_MITER_TO_SG: u32 = 2;
pub const SG_MITER_FROM_SG: u32 = 4;
pub const DMA_ATTR_WEAK_ORDERING: u32 = 2;
pub const DMA_ATTR_WRITE_COMBINE: u32 = 4;
pub const DMA_ATTR_NO_KERNEL_MAPPING: u32 = 16;
pub const DMA_ATTR_SKIP_CPU_SYNC: u32 = 32;
pub const DMA_ATTR_FORCE_CONTIGUOUS: u32 = 64;
pub const DMA_ATTR_ALLOC_SINGLE_PAGES: u32 = 128;
pub const DMA_ATTR_NO_WARN: u32 = 256;
pub const DMA_ATTR_PRIVILEGED: u32 = 512;
pub const IPV6_FL_A_GET: u32 = 0;
pub const IPV6_FL_A_PUT: u32 = 1;
pub const IPV6_FL_A_RENEW: u32 = 2;
pub const IPV6_FL_F_CREATE: u32 = 1;
pub const IPV6_FL_F_EXCL: u32 = 2;
pub const IPV6_FL_F_REFLECT: u32 = 4;
pub const IPV6_FL_F_REMOTE: u32 = 8;
pub const IPV6_FL_S_NONE: u32 = 0;
pub const IPV6_FL_S_EXCL: u32 = 1;
pub const IPV6_FL_S_PROCESS: u32 = 2;
pub const IPV6_FL_S_USER: u32 = 3;
pub const IPV6_FL_S_ANY: u32 = 255;
pub const IPV6_FLOWINFO_FLOWLABEL: u32 = 1048575;
pub const IPV6_FLOWINFO_PRIORITY: u32 = 267386880;
pub const IPV6_PRIORITY_UNCHARACTERIZED: u32 = 0;
pub const IPV6_PRIORITY_FILLER: u32 = 256;
pub const IPV6_PRIORITY_UNATTENDED: u32 = 512;
pub const IPV6_PRIORITY_RESERVED1: u32 = 768;
pub const IPV6_PRIORITY_BULK: u32 = 1024;
pub const IPV6_PRIORITY_RESERVED2: u32 = 1280;
pub const IPV6_PRIORITY_INTERACTIVE: u32 = 1536;
pub const IPV6_PRIORITY_CONTROL: u32 = 1792;
pub const IPV6_PRIORITY_8: u32 = 2048;
pub const IPV6_PRIORITY_9: u32 = 2304;
pub const IPV6_PRIORITY_10: u32 = 2560;
pub const IPV6_PRIORITY_11: u32 = 2816;
pub const IPV6_PRIORITY_12: u32 = 3072;
pub const IPV6_PRIORITY_13: u32 = 3328;
pub const IPV6_PRIORITY_14: u32 = 3584;
pub const IPV6_PRIORITY_15: u32 = 3840;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_MH: u32 = 135;
pub const IPV6_TLV_PAD1: u32 = 0;
pub const IPV6_TLV_PADN: u32 = 1;
pub const IPV6_TLV_ROUTERALERT: u32 = 5;
pub const IPV6_TLV_CALIPSO: u32 = 7;
pub const IPV6_TLV_IOAM: u32 = 49;
pub const IPV6_TLV_JUMBO: u32 = 194;
pub const IPV6_TLV_HAO: u32 = 201;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_FLOWINFO: u32 = 11;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_MULTICAST_ALL: u32 = 29;
pub const IPV6_ROUTER_ALERT_ISOLATE: u32 = 30;
pub const IPV6_RECVERR_RFC4884: u32 = 31;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const IPV6_FLOWLABEL_MGR: u32 = 32;
pub const IPV6_FLOWINFO_SEND: u32 = 33;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_HDRINCL: u32 = 36;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_AUTOFLOWLABEL: u32 = 70;
pub const IPV6_ADDR_PREFERENCES: u32 = 72;
pub const IPV6_PREFER_SRC_TMP: u32 = 1;
pub const IPV6_PREFER_SRC_PUBLIC: u32 = 2;
pub const IPV6_PREFER_SRC_PUBTMP_DEFAULT: u32 = 256;
pub const IPV6_PREFER_SRC_COA: u32 = 4;
pub const IPV6_PREFER_SRC_HOME: u32 = 1024;
pub const IPV6_PREFER_SRC_CGA: u32 = 8;
pub const IPV6_PREFER_SRC_NONCGA: u32 = 2048;
pub const IPV6_MINHOPCOUNT: u32 = 73;
pub const IPV6_ORIGDSTADDR: u32 = 74;
pub const IPV6_RECVORIGDSTADDR: u32 = 74;
pub const IPV6_TRANSPARENT: u32 = 75;
pub const IPV6_UNICAST_IF: u32 = 76;
pub const IPV6_RECVFRAGSIZE: u32 = 77;
pub const IPV6_FREEBIND: u32 = 78;
pub const SIPHASH_CONST_0: u64 = 8317987319222330741;
pub const SIPHASH_CONST_1: u64 = 7237128888997146477;
pub const SIPHASH_CONST_2: u64 = 7816392313619706465;
pub const SIPHASH_CONST_3: u64 = 8387220255154660723;
pub const HSIPHASH_CONST_0: u32 = 0;
pub const HSIPHASH_CONST_1: u32 = 0;
pub const HSIPHASH_CONST_2: u32 = 1819895653;
pub const HSIPHASH_CONST_3: u32 = 1952801890;
pub const ETH_ALEN: u32 = 6;
pub const ETH_TLEN: u32 = 2;
pub const ETH_HLEN: u32 = 14;
pub const ETH_ZLEN: u32 = 60;
pub const ETH_DATA_LEN: u32 = 1500;
pub const ETH_FRAME_LEN: u32 = 1514;
pub const ETH_FCS_LEN: u32 = 4;
pub const ETH_MIN_MTU: u32 = 68;
pub const ETH_MAX_MTU: u32 = 65535;
pub const ETH_P_LOOP: u32 = 96;
pub const ETH_P_PUP: u32 = 512;
pub const ETH_P_PUPAT: u32 = 513;
pub const ETH_P_TSN: u32 = 8944;
pub const ETH_P_ERSPAN2: u32 = 8939;
pub const ETH_P_IP: u32 = 2048;
pub const ETH_P_X25: u32 = 2053;
pub const ETH_P_ARP: u32 = 2054;
pub const ETH_P_BPQ: u32 = 2303;
pub const ETH_P_IEEEPUP: u32 = 2560;
pub const ETH_P_IEEEPUPAT: u32 = 2561;
pub const ETH_P_BATMAN: u32 = 17157;
pub const ETH_P_DEC: u32 = 24576;
pub const ETH_P_DNA_DL: u32 = 24577;
pub const ETH_P_DNA_RC: u32 = 24578;
pub const ETH_P_DNA_RT: u32 = 24579;
pub const ETH_P_LAT: u32 = 24580;
pub const ETH_P_DIAG: u32 = 24581;
pub const ETH_P_CUST: u32 = 24582;
pub const ETH_P_SCA: u32 = 24583;
pub const ETH_P_TEB: u32 = 25944;
pub const ETH_P_RARP: u32 = 32821;
pub const ETH_P_ATALK: u32 = 32923;
pub const ETH_P_AARP: u32 = 33011;
pub const ETH_P_8021Q: u32 = 33024;
pub const ETH_P_ERSPAN: u32 = 35006;
pub const ETH_P_IPX: u32 = 33079;
pub const ETH_P_IPV6: u32 = 34525;
pub const ETH_P_PAUSE: u32 = 34824;
pub const ETH_P_SLOW: u32 = 34825;
pub const ETH_P_WCCP: u32 = 34878;
pub const ETH_P_MPLS_UC: u32 = 34887;
pub const ETH_P_MPLS_MC: u32 = 34888;
pub const ETH_P_ATMMPOA: u32 = 34892;
pub const ETH_P_PPP_DISC: u32 = 34915;
pub const ETH_P_PPP_SES: u32 = 34916;
pub const ETH_P_LINK_CTL: u32 = 34924;
pub const ETH_P_ATMFATE: u32 = 34948;
pub const ETH_P_PAE: u32 = 34958;
pub const ETH_P_PROFINET: u32 = 34962;
pub const ETH_P_REALTEK: u32 = 34969;
pub const ETH_P_AOE: u32 = 34978;
pub const ETH_P_ETHERCAT: u32 = 34980;
pub const ETH_P_8021AD: u32 = 34984;
pub const ETH_P_802_EX1: u32 = 34997;
pub const ETH_P_PREAUTH: u32 = 35015;
pub const ETH_P_TIPC: u32 = 35018;
pub const ETH_P_LLDP: u32 = 35020;
pub const ETH_P_MRP: u32 = 35043;
pub const ETH_P_MACSEC: u32 = 35045;
pub const ETH_P_8021AH: u32 = 35047;
pub const ETH_P_MVRP: u32 = 35061;
pub const ETH_P_1588: u32 = 35063;
pub const ETH_P_NCSI: u32 = 35064;
pub const ETH_P_PRP: u32 = 35067;
pub const ETH_P_CFM: u32 = 35074;
pub const ETH_P_FCOE: u32 = 35078;
pub const ETH_P_IBOE: u32 = 35093;
pub const ETH_P_TDLS: u32 = 35085;
pub const ETH_P_FIP: u32 = 35092;
pub const ETH_P_80221: u32 = 35095;
pub const ETH_P_HSR: u32 = 35119;
pub const ETH_P_NSH: u32 = 35151;
pub const ETH_P_LOOPBACK: u32 = 36864;
pub const ETH_P_QINQ1: u32 = 37120;
pub const ETH_P_QINQ2: u32 = 37376;
pub const ETH_P_QINQ3: u32 = 37632;
pub const ETH_P_EDSA: u32 = 56026;
pub const ETH_P_DSA_8021Q: u32 = 56027;
pub const ETH_P_DSA_A5PSW: u32 = 57345;
pub const ETH_P_IFE: u32 = 60734;
pub const ETH_P_AF_IUCV: u32 = 64507;
pub const ETH_P_802_3_MIN: u32 = 1536;
pub const ETH_P_802_3: u32 = 1;
pub const ETH_P_AX25: u32 = 2;
pub const ETH_P_ALL: u32 = 3;
pub const ETH_P_802_2: u32 = 4;
pub const ETH_P_SNAP: u32 = 5;
pub const ETH_P_DDCMP: u32 = 6;
pub const ETH_P_WAN_PPP: u32 = 7;
pub const ETH_P_PPP_MP: u32 = 8;
pub const ETH_P_LOCALTALK: u32 = 9;
pub const ETH_P_CAN: u32 = 12;
pub const ETH_P_CANFD: u32 = 13;
pub const ETH_P_CANXL: u32 = 14;
pub const ETH_P_PPPTALK: u32 = 16;
pub const ETH_P_TR_802_2: u32 = 17;
pub const ETH_P_MOBITEX: u32 = 21;
pub const ETH_P_CONTROL: u32 = 22;
pub const ETH_P_IRDA: u32 = 23;
pub const ETH_P_ECONET: u32 = 24;
pub const ETH_P_HDLC: u32 = 25;
pub const ETH_P_ARCNET: u32 = 26;
pub const ETH_P_DSA: u32 = 27;
pub const ETH_P_TRAILER: u32 = 28;
pub const ETH_P_PHONET: u32 = 245;
pub const ETH_P_IEEE802154: u32 = 246;
pub const ETH_P_CAIF: u32 = 247;
pub const ETH_P_XDSA: u32 = 248;
pub const ETH_P_MAP: u32 = 249;
pub const ETH_P_MCTP: u32 = 250;
pub const __UAPI_DEF_ETHHDR: u32 = 1;
pub const FLOW_DIS_MPLS_MAX: u32 = 7;
pub const FLOW_DIS_TUN_OPTS_MAX: u32 = 255;
pub const FLOW_KEYS_DIGEST_LEN: u32 = 16;
pub const PIPE_DEF_BUFFERS: u32 = 16;
pub const PIPE_BUF_FLAG_LRU: u32 = 1;
pub const PIPE_BUF_FLAG_ATOMIC: u32 = 2;
pub const PIPE_BUF_FLAG_GIFT: u32 = 4;
pub const PIPE_BUF_FLAG_PACKET: u32 = 8;
pub const PIPE_BUF_FLAG_CAN_MERGE: u32 = 16;
pub const PIPE_BUF_FLAG_WHOLE: u32 = 32;
pub const SPLICE_F_MOVE: u32 = 1;
pub const SPLICE_F_NONBLOCK: u32 = 2;
pub const SPLICE_F_MORE: u32 = 4;
pub const SPLICE_F_GIFT: u32 = 8;
pub const SPLICE_F_ALL: u32 = 15;
pub const PACKET_HOST: u32 = 0;
pub const PACKET_BROADCAST: u32 = 1;
pub const PACKET_MULTICAST: u32 = 2;
pub const PACKET_OTHERHOST: u32 = 3;
pub const PACKET_OUTGOING: u32 = 4;
pub const PACKET_LOOPBACK: u32 = 5;
pub const PACKET_USER: u32 = 6;
pub const PACKET_KERNEL: u32 = 7;
pub const PACKET_FASTROUTE: u32 = 6;
pub const PACKET_ADD_MEMBERSHIP: u32 = 1;
pub const PACKET_DROP_MEMBERSHIP: u32 = 2;
pub const PACKET_RECV_OUTPUT: u32 = 3;
pub const PACKET_RX_RING: u32 = 5;
pub const PACKET_STATISTICS: u32 = 6;
pub const PACKET_COPY_THRESH: u32 = 7;
pub const PACKET_AUXDATA: u32 = 8;
pub const PACKET_ORIGDEV: u32 = 9;
pub const PACKET_VERSION: u32 = 10;
pub const PACKET_HDRLEN: u32 = 11;
pub const PACKET_RESERVE: u32 = 12;
pub const PACKET_TX_RING: u32 = 13;
pub const PACKET_LOSS: u32 = 14;
pub const PACKET_VNET_HDR: u32 = 15;
pub const PACKET_TX_TIMESTAMP: u32 = 16;
pub const PACKET_TIMESTAMP: u32 = 17;
pub const PACKET_FANOUT: u32 = 18;
pub const PACKET_TX_HAS_OFF: u32 = 19;
pub const PACKET_QDISC_BYPASS: u32 = 20;
pub const PACKET_ROLLOVER_STATS: u32 = 21;
pub const PACKET_FANOUT_DATA: u32 = 22;
pub const PACKET_IGNORE_OUTGOING: u32 = 23;
pub const PACKET_FANOUT_HASH: u32 = 0;
pub const PACKET_FANOUT_LB: u32 = 1;
pub const PACKET_FANOUT_CPU: u32 = 2;
pub const PACKET_FANOUT_ROLLOVER: u32 = 3;
pub const PACKET_FANOUT_RND: u32 = 4;
pub const PACKET_FANOUT_QM: u32 = 5;
pub const PACKET_FANOUT_CBPF: u32 = 6;
pub const PACKET_FANOUT_EBPF: u32 = 7;
pub const PACKET_FANOUT_FLAG_ROLLOVER: u32 = 4096;
pub const PACKET_FANOUT_FLAG_UNIQUEID: u32 = 8192;
pub const PACKET_FANOUT_FLAG_DEFRAG: u32 = 32768;
pub const TP_STATUS_KERNEL: u32 = 0;
pub const TP_STATUS_USER: u32 = 1;
pub const TP_STATUS_COPY: u32 = 2;
pub const TP_STATUS_LOSING: u32 = 4;
pub const TP_STATUS_CSUMNOTREADY: u32 = 8;
pub const TP_STATUS_VLAN_VALID: u32 = 16;
pub const TP_STATUS_BLK_TMO: u32 = 32;
pub const TP_STATUS_VLAN_TPID_VALID: u32 = 64;
pub const TP_STATUS_CSUM_VALID: u32 = 128;
pub const TP_STATUS_AVAILABLE: u32 = 0;
pub const TP_STATUS_SEND_REQUEST: u32 = 1;
pub const TP_STATUS_SENDING: u32 = 2;
pub const TP_STATUS_WRONG_FORMAT: u32 = 4;
pub const TP_STATUS_TS_SOFTWARE: u32 = 536870912;
pub const TP_STATUS_TS_SYS_HARDWARE: u32 = 1073741824;
pub const TP_STATUS_TS_RAW_HARDWARE: u32 = 2147483648;
pub const TP_FT_REQ_FILL_RXHASH: u32 = 1;
pub const TPACKET_ALIGNMENT: u32 = 16;
pub const PACKET_MR_MULTICAST: u32 = 0;
pub const PACKET_MR_PROMISC: u32 = 1;
pub const PACKET_MR_ALLMULTI: u32 = 2;
pub const PACKET_MR_UNICAST: u32 = 3;
pub const LOOPBACK_IFINDEX: u32 = 1;
pub const FLOWI_FLAG_ANYSRC: u32 = 1;
pub const FLOWI_FLAG_KNOWN_NH: u32 = 2;
pub const _LINUX_PTR_RING_H: u32 = 1;
pub const PP_ALLOC_CACHE_SIZE: u32 = 128;
pub const PP_ALLOC_CACHE_REFILL: u32 = 64;
pub const NF_CT_STATE_INVALID_BIT: u32 = 1;
pub const NF_CT_STATE_UNTRACKED_BIT: u32 = 64;
pub const NF_CT_EXPECT_PERMANENT: u32 = 1;
pub const NF_CT_EXPECT_INACTIVE: u32 = 2;
pub const NF_CT_EXPECT_USERSPACE: u32 = 4;
pub const NFCT_INFOMASK: u32 = 7;
pub const NFCT_PTRMASK: i32 = -8;
pub const CHECKSUM_NONE: u32 = 0;
pub const CHECKSUM_UNNECESSARY: u32 = 1;
pub const CHECKSUM_COMPLETE: u32 = 2;
pub const CHECKSUM_PARTIAL: u32 = 3;
pub const SKB_MAX_CSUM_LEVEL: u32 = 3;
pub const GSO_BY_FRAGS: u32 = 65535;
pub const SKB_DATAREF_SHIFT: u32 = 16;
pub const SKB_DATAREF_MASK: u32 = 65535;
pub const NET_SKBUFF_DATA_USES_OFFSET: u32 = 1;
pub const CLONED_MASK: u32 = 1;
pub const PKT_TYPE_MAX: u32 = 7;
pub const PKT_VLAN_PRESENT_BIT: u32 = 0;
pub const TC_AT_INGRESS_MASK: u32 = 128;
pub const SKB_MONO_DELIVERY_TIME_MASK: u32 = 32;
pub const SKB_ALLOC_FCLONE: u32 = 1;
pub const SKB_ALLOC_RX: u32 = 2;
pub const SKB_ALLOC_NAPI: u32 = 4;
pub const SKB_DST_NOREF: u32 = 1;
pub const SKB_DST_PTRMASK: i32 = -2;
pub const ENCAP_TYPE_ETHER: u32 = 0;
pub const ENCAP_TYPE_IPPROTO: u32 = 1;
pub const NET_IP_ALIGN: u32 = 2;
pub const CHECKSUM_BREAK: u32 = 76;
pub const SKB_GSO_CB_OFFSET: u32 = 32;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_HDRINCL: u32 = 3;
pub const IP_OPTIONS: u32 = 4;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_RECVRETOPTS: u32 = 7;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_RECVFRAGSIZE: u32 = 25;
pub const IP_RECVERR_RFC4884: u32 = 26;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const __SOCK_SIZE__: u32 = 16;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_MULTICAST_NET: u32 = 3758096384;
pub const IN_CLASSE_NET: u32 = 4294967295;
pub const IN_CLASSE_NSHIFT: u32 = 0;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INADDR_LOOPBACK: u32 = 2130706433;
pub const INADDR_UNSPEC_GROUP: u32 = 3758096384;
pub const INADDR_ALLHOSTS_GROUP: u32 = 3758096385;
pub const INADDR_ALLRTRS_GROUP: u32 = 3758096386;
pub const INADDR_ALLSNOOPERS_GROUP: u32 = 3758096490;
pub const INADDR_MAX_LOCAL_GROUP: u32 = 3758096639;
pub const NF_DROP: u32 = 0;
pub const NF_ACCEPT: u32 = 1;
pub const NF_STOLEN: u32 = 2;
pub const NF_QUEUE: u32 = 3;
pub const NF_REPEAT: u32 = 4;
pub const NF_STOP: u32 = 5;
pub const NF_MAX_VERDICT: u32 = 5;
pub const NF_VERDICT_MASK: u32 = 255;
pub const NF_VERDICT_FLAG_QUEUE_BYPASS: u32 = 32768;
pub const NF_VERDICT_QMASK: u32 = 4294901760;
pub const NF_VERDICT_QBITS: u32 = 16;
pub const NF_ARP_NUMHOOKS: u32 = 3;
pub const MAX_UDELAY_MS: u32 = 5;
pub const PREFETCH_STRIDE: u32 = 256;
pub const DQL_MAX_OBJECT: u32 = 0;
pub const DQL_MAX_LIMIT: u32 = 0;
pub const __ICMPMSG_MIB_MAX: u32 = 512;
pub const __ICMP6MSG_MIB_MAX: u32 = 512;
pub const ICMPMSG_MIB_MAX: u32 = 512;
pub const ICMP6MSG_MIB_MAX: u32 = 512;
pub const IPFRAG_ECN_NOT_ECT: u32 = 1;
pub const IPFRAG_ECN_ECT_1: u32 = 2;
pub const IPFRAG_ECN_ECT_0: u32 = 4;
pub const IPFRAG_ECN_CE: u32 = 8;
pub const IPFRAG_OK: u32 = 0;
pub const IPFRAG_DUP: u32 = 1;
pub const IPFRAG_OVERLAP: u32 = 2;
pub const DST_PERCPU_COUNTER_BATCH: u32 = 32;
pub const ICMPV6_ROUTER_PREF_LOW: u32 = 3;
pub const ICMPV6_ROUTER_PREF_MEDIUM: u32 = 0;
pub const ICMPV6_ROUTER_PREF_HIGH: u32 = 1;
pub const ICMPV6_ROUTER_PREF_INVALID: u32 = 2;
pub const ICMPV6_DEST_UNREACH: u32 = 1;
pub const ICMPV6_PKT_TOOBIG: u32 = 2;
pub const ICMPV6_TIME_EXCEED: u32 = 3;
pub const ICMPV6_PARAMPROB: u32 = 4;
pub const ICMPV6_ERRMSG_MAX: u32 = 127;
pub const ICMPV6_INFOMSG_MASK: u32 = 128;
pub const ICMPV6_ECHO_REQUEST: u32 = 128;
pub const ICMPV6_ECHO_REPLY: u32 = 129;
pub const ICMPV6_MGM_QUERY: u32 = 130;
pub const ICMPV6_MGM_REPORT: u32 = 131;
pub const ICMPV6_MGM_REDUCTION: u32 = 132;
pub const ICMPV6_NI_QUERY: u32 = 139;
pub const ICMPV6_NI_REPLY: u32 = 140;
pub const ICMPV6_MLD2_REPORT: u32 = 143;
pub const ICMPV6_DHAAD_REQUEST: u32 = 144;
pub const ICMPV6_DHAAD_REPLY: u32 = 145;
pub const ICMPV6_MOBILE_PREFIX_SOL: u32 = 146;
pub const ICMPV6_MOBILE_PREFIX_ADV: u32 = 147;
pub const ICMPV6_MRDISC_ADV: u32 = 151;
pub const ICMPV6_MSG_MAX: u32 = 255;
pub const ICMPV6_NOROUTE: u32 = 0;
pub const ICMPV6_ADM_PROHIBITED: u32 = 1;
pub const ICMPV6_NOT_NEIGHBOUR: u32 = 2;
pub const ICMPV6_ADDR_UNREACH: u32 = 3;
pub const ICMPV6_PORT_UNREACH: u32 = 4;
pub const ICMPV6_POLICY_FAIL: u32 = 5;
pub const ICMPV6_REJECT_ROUTE: u32 = 6;
pub const ICMPV6_EXC_HOPLIMIT: u32 = 0;
pub const ICMPV6_EXC_FRAGTIME: u32 = 1;
pub const ICMPV6_HDR_FIELD: u32 = 0;
pub const ICMPV6_UNK_NEXTHDR: u32 = 1;
pub const ICMPV6_UNK_OPTION: u32 = 2;
pub const ICMPV6_HDR_INCOMP: u32 = 3;
pub const ICMPV6_EXT_ECHO_REQUEST: u32 = 160;
pub const ICMPV6_EXT_ECHO_REPLY: u32 = 161;
pub const ICMPV6_FILTER: u32 = 1;
pub const ICMPV6_FILTER_BLOCK: u32 = 1;
pub const ICMPV6_FILTER_PASS: u32 = 2;
pub const ICMPV6_FILTER_BLOCKOTHERS: u32 = 3;
pub const ICMPV6_FILTER_PASSONLY: u32 = 4;
pub const MLD2_MODE_IS_INCLUDE: u32 = 1;
pub const MLD2_MODE_IS_EXCLUDE: u32 = 2;
pub const MLD2_CHANGE_TO_INCLUDE: u32 = 3;
pub const MLD2_CHANGE_TO_EXCLUDE: u32 = 4;
pub const MLD2_ALLOW_NEW_SOURCES: u32 = 5;
pub const MLD2_BLOCK_OLD_SOURCES: u32 = 6;
pub const IP_CT_TCP_FLAG_WINDOW_SCALE: u32 = 1;
pub const IP_CT_TCP_FLAG_SACK_PERM: u32 = 2;
pub const IP_CT_TCP_FLAG_CLOSE_INIT: u32 = 4;
pub const IP_CT_TCP_FLAG_BE_LIBERAL: u32 = 8;
pub const IP_CT_TCP_FLAG_DATA_UNACKNOWLEDGED: u32 = 16;
pub const IP_CT_TCP_FLAG_MAXACK_SET: u32 = 32;
pub const IP_CT_EXP_CHALLENGE_ACK: u32 = 64;
pub const IP_CT_TCP_SIMULTANEOUS_OPEN: u32 = 128;
pub const XFRM_SC_DOI_RESERVED: u32 = 0;
pub const XFRM_SC_DOI_LSM: u32 = 1;
pub const XFRM_SC_ALG_RESERVED: u32 = 0;
pub const XFRM_SC_ALG_SELINUX: u32 = 1;
pub const XFRMA_REPLAY_ESN_MAX: u32 = 4096;
pub const XFRM_MODE_TRANSPORT: u32 = 0;
pub const XFRM_MODE_TUNNEL: u32 = 1;
pub const XFRM_MODE_ROUTEOPTIMIZATION: u32 = 2;
pub const XFRM_MODE_IN_TRIGGER: u32 = 3;
pub const XFRM_MODE_BEET: u32 = 4;
pub const XFRM_MODE_MAX: u32 = 5;
pub const XFRM_STATE_NOECN: u32 = 1;
pub const XFRM_STATE_DECAP_DSCP: u32 = 2;
pub const XFRM_STATE_NOPMTUDISC: u32 = 4;
pub const XFRM_STATE_WILDRECV: u32 = 8;
pub const XFRM_STATE_ICMP: u32 = 16;
pub const XFRM_STATE_AF_UNSPEC: u32 = 32;
pub const XFRM_STATE_ALIGN4: u32 = 64;
pub const XFRM_STATE_ESN: u32 = 128;
pub const XFRM_SA_XFLAG_DONT_ENCAP_DSCP: u32 = 1;
pub const XFRM_SA_XFLAG_OSEQ_MAY_WRAP: u32 = 2;
pub const XFRM_POLICY_ALLOW: u32 = 0;
pub const XFRM_POLICY_BLOCK: u32 = 1;
pub const XFRM_POLICY_LOCALOK: u32 = 1;
pub const XFRM_POLICY_ICMP: u32 = 2;
pub const XFRM_OFFLOAD_IPV6: u32 = 1;
pub const XFRM_OFFLOAD_INBOUND: u32 = 2;
pub const XFRM_USERPOLICY_UNSPEC: u32 = 0;
pub const XFRM_USERPOLICY_BLOCK: u32 = 1;
pub const XFRM_USERPOLICY_ACCEPT: u32 = 2;
pub const NETDEV_HASHBITS: u32 = 8;
pub const NETDEV_HASHENTRIES: u32 = 256;
pub const XDP_XMIT_FLUSH: u32 = 1;
pub const XDP_XMIT_FLAGS_MASK: u32 = 1;
pub const XDP_BULK_QUEUE_SIZE: u32 = 16;
pub const DEV_MAP_BULK_SIZE: u32 = 16;
pub const SCM_MAX_FD: u32 = 253;
pub const NETLINK_ROUTE: u32 = 0;
pub const NETLINK_UNUSED: u32 = 1;
pub const NETLINK_USERSOCK: u32 = 2;
pub const NETLINK_FIREWALL: u32 = 3;
pub const NETLINK_SOCK_DIAG: u32 = 4;
pub const NETLINK_NFLOG: u32 = 5;
pub const NETLINK_XFRM: u32 = 6;
pub const NETLINK_SELINUX: u32 = 7;
pub const NETLINK_ISCSI: u32 = 8;
pub const NETLINK_AUDIT: u32 = 9;
pub const NETLINK_FIB_LOOKUP: u32 = 10;
pub const NETLINK_CONNECTOR: u32 = 11;
pub const NETLINK_NETFILTER: u32 = 12;
pub const NETLINK_IP6_FW: u32 = 13;
pub const NETLINK_DNRTMSG: u32 = 14;
pub const NETLINK_KOBJECT_UEVENT: u32 = 15;
pub const NETLINK_GENERIC: u32 = 16;
pub const NETLINK_SCSITRANSPORT: u32 = 18;
pub const NETLINK_ECRYPTFS: u32 = 19;
pub const NETLINK_RDMA: u32 = 20;
pub const NETLINK_CRYPTO: u32 = 21;
pub const NETLINK_SMC: u32 = 22;
pub const NETLINK_INET_DIAG: u32 = 4;
pub const MAX_LINKS: u32 = 32;
pub const NLM_F_REQUEST: u32 = 1;
pub const NLM_F_MULTI: u32 = 2;
pub const NLM_F_ACK: u32 = 4;
pub const NLM_F_ECHO: u32 = 8;
pub const NLM_F_DUMP_INTR: u32 = 16;
pub const NLM_F_DUMP_FILTERED: u32 = 32;
pub const NLM_F_ROOT: u32 = 256;
pub const NLM_F_MATCH: u32 = 512;
pub const NLM_F_ATOMIC: u32 = 1024;
pub const NLM_F_DUMP: u32 = 768;
pub const NLM_F_REPLACE: u32 = 256;
pub const NLM_F_EXCL: u32 = 512;
pub const NLM_F_CREATE: u32 = 1024;
pub const NLM_F_APPEND: u32 = 2048;
pub const NLM_F_NONREC: u32 = 256;
pub const NLM_F_BULK: u32 = 512;
pub const NLM_F_CAPPED: u32 = 256;
pub const NLM_F_ACK_TLVS: u32 = 512;
pub const NLMSG_ALIGNTO: u32 = 4;
pub const NLMSG_NOOP: u32 = 1;
pub const NLMSG_ERROR: u32 = 2;
pub const NLMSG_DONE: u32 = 3;
pub const NLMSG_OVERRUN: u32 = 4;
pub const NLMSG_MIN_TYPE: u32 = 16;
pub const NETLINK_ADD_MEMBERSHIP: u32 = 1;
pub const NETLINK_DROP_MEMBERSHIP: u32 = 2;
pub const NETLINK_PKTINFO: u32 = 3;
pub const NETLINK_BROADCAST_ERROR: u32 = 4;
pub const NETLINK_NO_ENOBUFS: u32 = 5;
pub const NETLINK_LISTEN_ALL_NSID: u32 = 8;
pub const NETLINK_LIST_MEMBERSHIPS: u32 = 9;
pub const NETLINK_CAP_ACK: u32 = 10;
pub const NETLINK_EXT_ACK: u32 = 11;
pub const NETLINK_GET_STRICT_CHK: u32 = 12;
pub const NET_MAJOR: u32 = 36;
pub const NLA_F_NESTED: u32 = 32768;
pub const NLA_F_NET_BYTEORDER: u32 = 16384;
pub const NLA_TYPE_MASK: i32 = -49153;
pub const NLA_ALIGNTO: u32 = 4;
pub const NL_CFG_F_NONROOT_RECV: u32 = 1;
pub const NL_CFG_F_NONROOT_SEND: u32 = 2;
pub const NETLINK_MAX_COOKIE_LEN: u32 = 20;
pub const NTF_USE: u32 = 1;
pub const NTF_SELF: u32 = 2;
pub const NTF_MASTER: u32 = 4;
pub const NTF_PROXY: u32 = 8;
pub const NTF_EXT_LEARNED: u32 = 16;
pub const NTF_OFFLOADED: u32 = 32;
pub const NTF_STICKY: u32 = 64;
pub const NTF_ROUTER: u32 = 128;
pub const NTF_EXT_MANAGED: u32 = 1;
pub const NUD_INCOMPLETE: u32 = 1;
pub const NUD_REACHABLE: u32 = 2;
pub const NUD_STALE: u32 = 4;
pub const NUD_DELAY: u32 = 8;
pub const NUD_PROBE: u32 = 16;
pub const NUD_FAILED: u32 = 32;
pub const NUD_NOARP: u32 = 64;
pub const NUD_PERMANENT: u32 = 128;
pub const NUD_NONE: u32 = 0;
pub const MACVLAN_FLAG_NOPROMISC: u32 = 1;
pub const MACVLAN_FLAG_NODST: u32 = 2;
pub const IPVLAN_F_PRIVATE: u32 = 1;
pub const IPVLAN_F_VEPA: u32 = 2;
pub const TUNNEL_MSG_FLAG_STATS: u32 = 1;
pub const TUNNEL_MSG_VALID_USER_FLAGS: u32 = 1;
pub const MAX_VLAN_LIST_LEN: u32 = 1;
pub const PORT_PROFILE_MAX: u32 = 40;
pub const PORT_UUID_MAX: u32 = 16;
pub const PORT_SELF_VF: i32 = -1;
pub const XDP_FLAGS_UPDATE_IF_NOEXIST: u32 = 1;
pub const XDP_FLAGS_SKB_MODE: u32 = 2;
pub const XDP_FLAGS_DRV_MODE: u32 = 4;
pub const XDP_FLAGS_HW_MODE: u32 = 8;
pub const XDP_FLAGS_REPLACE: u32 = 16;
pub const XDP_FLAGS_MODES: u32 = 14;
pub const XDP_FLAGS_MASK: u32 = 31;
pub const RMNET_FLAGS_INGRESS_DEAGGREGATION: u32 = 1;
pub const RMNET_FLAGS_INGRESS_MAP_COMMANDS: u32 = 2;
pub const RMNET_FLAGS_INGRESS_MAP_CKSUMV4: u32 = 4;
pub const RMNET_FLAGS_EGRESS_MAP_CKSUMV4: u32 = 8;
pub const RMNET_FLAGS_INGRESS_MAP_CKSUMV5: u32 = 16;
pub const RMNET_FLAGS_EGRESS_MAP_CKSUMV5: u32 = 32;
pub const MAX_ADDR_LEN: u32 = 32;
pub const INIT_NETDEV_GROUP: u32 = 0;
pub const NET_NAME_UNKNOWN: u32 = 0;
pub const NET_NAME_ENUM: u32 = 1;
pub const NET_NAME_PREDICTABLE: u32 = 2;
pub const NET_NAME_USER: u32 = 3;
pub const NET_NAME_RENAMED: u32 = 4;
pub const NET_ADDR_PERM: u32 = 0;
pub const NET_ADDR_RANDOM: u32 = 1;
pub const NET_ADDR_STOLEN: u32 = 2;
pub const NET_ADDR_SET: u32 = 3;
pub const BOND_ABI_VERSION: u32 = 2;
pub const BOND_ENSLAVE_OLD: u32 = 35312;
pub const BOND_RELEASE_OLD: u32 = 35313;
pub const BOND_SETHWADDR_OLD: u32 = 35314;
pub const BOND_SLAVE_INFO_QUERY_OLD: u32 = 35323;
pub const BOND_INFO_QUERY_OLD: u32 = 35324;
pub const BOND_CHANGE_ACTIVE_OLD: u32 = 35325;
pub const BOND_CHECK_MII_STATUS: u32 = 35143;
pub const BOND_MODE_ROUNDROBIN: u32 = 0;
pub const BOND_MODE_ACTIVEBACKUP: u32 = 1;
pub const BOND_MODE_XOR: u32 = 2;
pub const BOND_MODE_BROADCAST: u32 = 3;
pub const BOND_MODE_8023AD: u32 = 4;
pub const BOND_MODE_TLB: u32 = 5;
pub const BOND_MODE_ALB: u32 = 6;
pub const BOND_LINK_UP: u32 = 0;
pub const BOND_LINK_FAIL: u32 = 1;
pub const BOND_LINK_DOWN: u32 = 2;
pub const BOND_LINK_BACK: u32 = 3;
pub const BOND_STATE_ACTIVE: u32 = 0;
pub const BOND_STATE_BACKUP: u32 = 1;
pub const BOND_DEFAULT_MAX_BONDS: u32 = 1;
pub const BOND_DEFAULT_TX_QUEUES: u32 = 16;
pub const BOND_DEFAULT_RESEND_IGMP: u32 = 1;
pub const BOND_XMIT_POLICY_LAYER2: u32 = 0;
pub const BOND_XMIT_POLICY_LAYER34: u32 = 1;
pub const BOND_XMIT_POLICY_LAYER23: u32 = 2;
pub const BOND_XMIT_POLICY_ENCAP23: u32 = 3;
pub const BOND_XMIT_POLICY_ENCAP34: u32 = 4;
pub const BOND_XMIT_POLICY_VLAN_SRCMAC: u32 = 5;
pub const LACP_STATE_LACP_ACTIVITY: u32 = 1;
pub const LACP_STATE_LACP_TIMEOUT: u32 = 2;
pub const LACP_STATE_AGGREGATION: u32 = 4;
pub const LACP_STATE_SYNCHRONIZATION: u32 = 8;
pub const LACP_STATE_COLLECTING: u32 = 16;
pub const LACP_STATE_DISTRIBUTING: u32 = 32;
pub const LACP_STATE_DEFAULTED: u32 = 64;
pub const LACP_STATE_EXPIRED: u32 = 128;
pub const TC_PRIO_BESTEFFORT: u32 = 0;
pub const TC_PRIO_FILLER: u32 = 1;
pub const TC_PRIO_BULK: u32 = 2;
pub const TC_PRIO_INTERACTIVE_BULK: u32 = 4;
pub const TC_PRIO_INTERACTIVE: u32 = 6;
pub const TC_PRIO_CONTROL: u32 = 7;
pub const TC_PRIO_MAX: u32 = 15;
pub const TC_H_MAJ_MASK: u32 = 4294901760;
pub const TC_H_MIN_MASK: u32 = 65535;
pub const TC_H_UNSPEC: u32 = 0;
pub const TC_H_ROOT: u32 = 4294967295;
pub const TC_H_INGRESS: u32 = 4294967281;
pub const TC_H_CLSACT: u32 = 4294967281;
pub const TC_H_MIN_PRIORITY: u32 = 65504;
pub const TC_H_MIN_INGRESS: u32 = 65522;
pub const TC_H_MIN_EGRESS: u32 = 65523;
pub const TC_LINKLAYER_MASK: u32 = 15;
pub const TC_RTAB_SIZE: u32 = 1024;
pub const SKBPRIO_MAX_PRIORITY: u32 = 64;
pub const TCQ_PRIO_BANDS: u32 = 16;
pub const TCQ_MIN_PRIO_BANDS: u32 = 2;
pub const TCQ_PLUG_BUFFER: u32 = 0;
pub const TCQ_PLUG_RELEASE_ONE: u32 = 1;
pub const TCQ_PLUG_RELEASE_INDEFINITE: u32 = 2;
pub const TCQ_PLUG_LIMIT: u32 = 3;
pub const TC_RED_ECN: u32 = 1;
pub const TC_RED_HARDDROP: u32 = 2;
pub const TC_RED_ADAPTATIVE: u32 = 4;
pub const TC_RED_NODROP: u32 = 8;
pub const TC_RED_HISTORIC_FLAGS: u32 = 7;
pub const MAX_DPs: u32 = 16;
pub const TC_HTB_NUMPRIO: u32 = 8;
pub const TC_HTB_MAXDEPTH: u32 = 8;
pub const TC_HTB_PROTOVER: u32 = 3;
pub const TC_CBQ_MAXPRIO: u32 = 8;
pub const TC_CBQ_MAXLEVEL: u32 = 8;
pub const TC_CBQ_DEF_EWMA: u32 = 5;
pub const TCF_CBQ_LSS_BOUNDED: u32 = 1;
pub const TCF_CBQ_LSS_ISOLATED: u32 = 2;
pub const TCF_CBQ_LSS_FLAGS: u32 = 1;
pub const TCF_CBQ_LSS_EWMA: u32 = 2;
pub const TCF_CBQ_LSS_MAXIDLE: u32 = 4;
pub const TCF_CBQ_LSS_MINIDLE: u32 = 8;
pub const TCF_CBQ_LSS_OFFTIME: u32 = 16;
pub const TCF_CBQ_LSS_AVPKT: u32 = 32;
pub const TC_CBQ_OVL_CLASSIC: u32 = 0;
pub const TC_CBQ_OVL_DELAY: u32 = 1;
pub const TC_CBQ_OVL_LOWPRIO: u32 = 2;
pub const TC_CBQ_OVL_DROP: u32 = 3;
pub const TC_CBQ_OVL_RCLASSIC: u32 = 4;
pub const NETEM_DIST_SCALE: u32 = 8192;
pub const NETEM_DIST_MAX: u32 = 16384;
pub const TC_QOPT_BITMASK: u32 = 15;
pub const TC_QOPT_MAX_QUEUE: u32 = 16;
pub const TC_MQPRIO_F_MODE: u32 = 1;
pub const TC_MQPRIO_F_SHAPER: u32 = 2;
pub const TC_MQPRIO_F_MIN_RATE: u32 = 4;
pub const TC_MQPRIO_F_MAX_RATE: u32 = 8;
pub const SFB_MAX_PROB: u32 = 65535;
pub const FQ_CODEL_QUANTUM_MAX: u32 = 1048576;
pub const TC_CAKE_MAX_TINS: u32 = 8;
pub const TCQ_ETS_MAX_BANDS: u32 = 16;
pub const TC_COOKIE_MAX_SIZE: u32 = 16;
pub const TCA_ACT_FLAGS_NO_PERCPU_STATS: u32 = 1;
pub const TCA_ACT_FLAGS_SKIP_HW: u32 = 2;
pub const TCA_ACT_FLAGS_SKIP_SW: u32 = 4;
pub const TCA_ACT_HW_STATS_IMMEDIATE: u32 = 1;
pub const TCA_ACT_HW_STATS_DELAYED: u32 = 2;
pub const TCA_ACT_MAX_PRIO: u32 = 32;
pub const TCA_ACT_BIND: u32 = 1;
pub const TCA_ACT_NOBIND: u32 = 0;
pub const TCA_ACT_UNBIND: u32 = 1;
pub const TCA_ACT_NOUNBIND: u32 = 0;
pub const TCA_ACT_REPLACE: u32 = 1;
pub const TCA_ACT_NOREPLACE: u32 = 0;
pub const TC_ACT_UNSPEC: i32 = -1;
pub const TC_ACT_OK: u32 = 0;
pub const TC_ACT_RECLASSIFY: u32 = 1;
pub const TC_ACT_SHOT: u32 = 2;
pub const TC_ACT_PIPE: u32 = 3;
pub const TC_ACT_STOLEN: u32 = 4;
pub const TC_ACT_QUEUED: u32 = 5;
pub const TC_ACT_REPEAT: u32 = 6;
pub const TC_ACT_REDIRECT: u32 = 7;
pub const TC_ACT_TRAP: u32 = 8;
pub const TC_ACT_VALUE_MAX: u32 = 8;
pub const __TC_ACT_EXT_SHIFT: u32 = 28;
pub const TC_ACT_EXT_VAL_MASK: u32 = 268435455;
pub const TCA_ACT_GACT: u32 = 5;
pub const TCA_ACT_IPT: u32 = 6;
pub const TCA_ACT_PEDIT: u32 = 7;
pub const TCA_ACT_MIRRED: u32 = 8;
pub const TCA_ACT_NAT: u32 = 9;
pub const TCA_ACT_XT: u32 = 10;
pub const TCA_ACT_SKBEDIT: u32 = 11;
pub const TCA_ACT_VLAN: u32 = 12;
pub const TCA_ACT_BPF: u32 = 13;
pub const TCA_ACT_CONNMARK: u32 = 14;
pub const TCA_ACT_SKBMOD: u32 = 15;
pub const TCA_ACT_CSUM: u32 = 16;
pub const TCA_ACT_TUNNEL_KEY: u32 = 17;
pub const TCA_ACT_SIMP: u32 = 22;
pub const TCA_ACT_IFE: u32 = 25;
pub const TCA_ACT_SAMPLE: u32 = 26;
pub const TC_POLICE_UNSPEC: i32 = -1;
pub const TC_POLICE_OK: u32 = 0;
pub const TC_POLICE_RECLASSIFY: u32 = 1;
pub const TC_POLICE_SHOT: u32 = 2;
pub const TC_POLICE_PIPE: u32 = 3;
pub const TCA_CLS_FLAGS_SKIP_HW: u32 = 1;
pub const TCA_CLS_FLAGS_SKIP_SW: u32 = 2;
pub const TCA_CLS_FLAGS_IN_HW: u32 = 4;
pub const TCA_CLS_FLAGS_NOT_IN_HW: u32 = 8;
pub const TCA_CLS_FLAGS_VERBOSE: u32 = 16;
pub const TC_U32_UNSPEC: u32 = 0;
pub const TC_U32_ROOT: u32 = 4293918720;
pub const TC_U32_TERMINAL: u32 = 1;
pub const TC_U32_OFFSET: u32 = 2;
pub const TC_U32_VAROFFSET: u32 = 4;
pub const TC_U32_EAT: u32 = 8;
pub const TC_U32_MAXDEPTH: u32 = 8;
pub const TCA_BPF_FLAG_ACT_DIRECT: u32 = 1;
pub const TCA_FLOWER_MASK_FLAGS_RANGE: u32 = 1;
pub const TCF_EM_REL_END: u32 = 0;
pub const TCF_EM_REL_AND: u32 = 1;
pub const TCF_EM_REL_OR: u32 = 2;
pub const TCF_EM_INVERT: u32 = 4;
pub const TCF_EM_SIMPLE: u32 = 8;
pub const TCF_EM_REL_MASK: u32 = 3;
pub const TCF_EM_CONTAINER: u32 = 0;
pub const TCF_EM_CMP: u32 = 1;
pub const TCF_EM_NBYTE: u32 = 2;
pub const TCF_EM_U32: u32 = 3;
pub const TCF_EM_META: u32 = 4;
pub const TCF_EM_TEXT: u32 = 5;
pub const TCF_EM_VLAN: u32 = 6;
pub const TCF_EM_CANID: u32 = 7;
pub const TCF_EM_IPSET: u32 = 8;
pub const TCF_EM_IPT: u32 = 9;
pub const TCF_EM_MAX: u32 = 9;
pub const NET_RX_SUCCESS: u32 = 0;
pub const NET_RX_DROP: u32 = 1;
pub const MAX_NEST_DEV: u32 = 8;
pub const NET_XMIT_SUCCESS: u32 = 0;
pub const NET_XMIT_DROP: u32 = 1;
pub const NET_XMIT_CN: u32 = 2;
pub const NET_XMIT_MASK: u32 = 15;
pub const NETDEV_TX_MASK: u32 = 240;
pub const LL_MAX_HEADER: u32 = 96;
pub const MAX_HEADER: u32 = 144;
pub const NETDEV_HW_ADDR_T_LAN: u32 = 1;
pub const NETDEV_HW_ADDR_T_SAN: u32 = 2;
pub const NETDEV_HW_ADDR_T_UNICAST: u32 = 3;
pub const NETDEV_HW_ADDR_T_MULTICAST: u32 = 4;
pub const HH_DATA_MOD: u32 = 16;
pub const GRO_HASH_BUCKETS: u32 = 8;
pub const RPS_NO_FILTER: u32 = 65535;
pub const RPS_NO_CPU: u32 = 65535;
pub const TC_MAX_QUEUE: u32 = 16;
pub const TC_BITMASK: u32 = 15;
pub const MAX_PHYS_ITEM_ID_LEN: u32 = 32;
pub const NET_DEVICE_PATH_STACK_MAX: u32 = 5;
pub const NET_DEVICE_PATH_VLAN_MAX: u32 = 2;
pub const XDP_WAKEUP_RX: u32 = 1;
pub const XDP_WAKEUP_TX: u32 = 2;
pub const GRO_LEGACY_MAX_SIZE: u32 = 65536;
pub const GRO_MAX_SIZE: u32 = 524280;
pub const GSO_MAX_SEGS: u32 = 65535;
pub const GSO_LEGACY_MAX_SIZE: u32 = 65536;
pub const GSO_MAX_SIZE: u32 = 524280;
pub const TSO_LEGACY_MAX_SIZE: u32 = 65536;
pub const TSO_MAX_SIZE: i32 = -1;
pub const NETDEV_ALIGN: u32 = 32;
pub const NAPI_POLL_WEIGHT: u32 = 64;
pub const XMIT_RECURSION_LIMIT: u32 = 8;
pub const NETDEV_RSS_KEY_LEN: u32 = 52;
pub const PTYPE_HASH_SIZE: u32 = 16;
pub const PTYPE_HASH_MASK: u32 = 15;
pub const NF_CT_DEFAULT_ZONE_ID: u32 = 0;
pub const NF_CT_FLAG_MARK: u32 = 1;
pub const NF_ARP: u32 = 0;
pub const NF_ARP_IN: u32 = 0;
pub const NF_ARP_OUT: u32 = 1;
pub const NF_ARP_FORWARD: u32 = 2;
pub const SO_ORIGINAL_DST: u32 = 80;
pub const FASTRETRANS_DEBUG: u32 = 1;
pub const POLLIN: u32 = 1;
pub const POLLPRI: u32 = 2;
pub const POLLOUT: u32 = 4;
pub const POLLERR: u32 = 8;
pub const POLLHUP: u32 = 16;
pub const POLLNVAL: u32 = 32;
pub const POLLRDNORM: u32 = 64;
pub const POLLRDBAND: u32 = 128;
pub const POLLWRNORM: u32 = 256;
pub const POLLWRBAND: u32 = 512;
pub const POLLMSG: u32 = 1024;
pub const POLLREMOVE: u32 = 4096;
pub const POLLRDHUP: u32 = 8192;
pub const EPOLL_CLOEXEC: u32 = 524288;
pub const EPOLL_CTL_ADD: u32 = 1;
pub const EPOLL_CTL_DEL: u32 = 2;
pub const EPOLL_CTL_MOD: u32 = 3;
pub const MAX_STACK_ALLOC: u32 = 768;
pub const FRONTEND_STACK_ALLOC: u32 = 256;
pub const SELECT_STACK_ALLOC: u32 = 256;
pub const POLL_STACK_ALLOC: u32 = 256;
pub const WQUEUES_STACK_ALLOC: u32 = 512;
pub const IFA_F_SECONDARY: u32 = 1;
pub const IFA_F_TEMPORARY: u32 = 1;
pub const IFA_F_NODAD: u32 = 2;
pub const IFA_F_OPTIMISTIC: u32 = 4;
pub const IFA_F_DADFAILED: u32 = 8;
pub const IFA_F_HOMEADDRESS: u32 = 16;
pub const IFA_F_DEPRECATED: u32 = 32;
pub const IFA_F_TENTATIVE: u32 = 64;
pub const IFA_F_PERMANENT: u32 = 128;
pub const IFA_F_MANAGETEMPADDR: u32 = 256;
pub const IFA_F_NOPREFIXROUTE: u32 = 512;
pub const IFA_F_MCAUTOJOIN: u32 = 1024;
pub const IFA_F_STABLE_PRIVACY: u32 = 2048;
pub const IFAPROT_UNSPEC: u32 = 0;
pub const IFAPROT_KERNEL_LO: u32 = 1;
pub const IFAPROT_KERNEL_RA: u32 = 2;
pub const IFAPROT_KERNEL_LL: u32 = 3;
pub const RTNL_FAMILY_IPMR: u32 = 128;
pub const RTNL_FAMILY_IP6MR: u32 = 129;
pub const RTNL_FAMILY_MAX: u32 = 129;
pub const RTA_ALIGNTO: u32 = 4;
pub const RTPROT_UNSPEC: u32 = 0;
pub const RTPROT_REDIRECT: u32 = 1;
pub const RTPROT_KERNEL: u32 = 2;
pub const RTPROT_BOOT: u32 = 3;
pub const RTPROT_STATIC: u32 = 4;
pub const RTPROT_GATED: u32 = 8;
pub const RTPROT_RA: u32 = 9;
pub const RTPROT_MRT: u32 = 10;
pub const RTPROT_ZEBRA: u32 = 11;
pub const RTPROT_BIRD: u32 = 12;
pub const RTPROT_DNROUTED: u32 = 13;
pub const RTPROT_XORP: u32 = 14;
pub const RTPROT_NTK: u32 = 15;
pub const RTPROT_DHCP: u32 = 16;
pub const RTPROT_MROUTED: u32 = 17;
pub const RTPROT_KEEPALIVED: u32 = 18;
pub const RTPROT_BABEL: u32 = 42;
pub const RTPROT_OPENR: u32 = 99;
pub const RTPROT_BGP: u32 = 186;
pub const RTPROT_ISIS: u32 = 187;
pub const RTPROT_OSPF: u32 = 188;
pub const RTPROT_RIP: u32 = 189;
pub const RTPROT_EIGRP: u32 = 192;
pub const RTM_F_NOTIFY: u32 = 256;
pub const RTM_F_CLONED: u32 = 512;
pub const RTM_F_EQUALIZE: u32 = 1024;
pub const RTM_F_PREFIX: u32 = 2048;
pub const RTM_F_LOOKUP_TABLE: u32 = 4096;
pub const RTM_F_FIB_MATCH: u32 = 8192;
pub const RTM_F_OFFLOAD: u32 = 16384;
pub const RTM_F_TRAP: u32 = 32768;
pub const RTM_F_OFFLOAD_FAILED: u32 = 536870912;
pub const RTNH_F_DEAD: u32 = 1;
pub const RTNH_F_PERVASIVE: u32 = 2;
pub const RTNH_F_ONLINK: u32 = 4;
pub const RTNH_F_OFFLOAD: u32 = 8;
pub const RTNH_F_LINKDOWN: u32 = 16;
pub const RTNH_F_UNRESOLVED: u32 = 32;
pub const RTNH_F_TRAP: u32 = 64;
pub const RTNH_COMPARE_MASK: u32 = 89;
pub const RTNH_ALIGNTO: u32 = 4;
pub const RTNETLINK_HAVE_PEERINFO: u32 = 1;
pub const RTAX_FEATURE_ECN: u32 = 1;
pub const RTAX_FEATURE_SACK: u32 = 2;
pub const RTAX_FEATURE_TIMESTAMP: u32 = 4;
pub const RTAX_FEATURE_ALLFRAG: u32 = 8;
pub const RTAX_FEATURE_MASK: u32 = 15;
pub const TCM_IFINDEX_MAGIC_BLOCK: u32 = 4294967295;
pub const TCA_DUMP_FLAGS_TERSE: u32 = 1;
pub const TCA_FLAG_LARGE_DUMP_ON: u32 = 1;
pub const TCA_ACT_FLAG_LARGE_DUMP_ON: u32 = 1;
pub const TCA_ACT_FLAG_TERSE_DUMP: u32 = 2;
pub const RTEXT_FILTER_VF: u32 = 1;
pub const RTEXT_FILTER_BRVLAN: u32 = 2;
pub const RTEXT_FILTER_BRVLAN_COMPRESSED: u32 = 4;
pub const RTEXT_FILTER_SKIP_STATS: u32 = 8;
pub const RTEXT_FILTER_MRP: u32 = 16;
pub const RTEXT_FILTER_CFM_CONFIG: u32 = 32;
pub const RTEXT_FILTER_CFM_STATUS: u32 = 64;
pub const RTEXT_FILTER_MST: u32 = 128;
pub const RTNL_KIND_MASK: u32 = 3;
pub const NUD_IN_TIMER: u32 = 27;
pub const NUD_VALID: u32 = 222;
pub const NUD_CONNECTED: u32 = 194;
pub const NEIGH_NUM_HASH_RND: u32 = 4;
pub const NTF_OLD_MASK: u32 = 255;
pub const NTF_EXT_SHIFT: u32 = 8;
pub const NTF_EXT_MASK: u32 = 1;
pub const NTF_MANAGED: u32 = 256;
pub const NEIGH_SEQ_NEIGH_ONLY: u32 = 1;
pub const NEIGH_SEQ_IS_PNEIGH: u32 = 2;
pub const NEIGH_SEQ_SKIP_NOARP: u32 = 4;
pub const LOCALLY_ENQUEUED: u32 = 1;
pub const DST_NOXFRM: u32 = 2;
pub const DST_NOPOLICY: u32 = 4;
pub const DST_NOCOUNT: u32 = 8;
pub const DST_FAKE_RTABLE: u32 = 16;
pub const DST_XFRM_TUNNEL: u32 = 32;
pub const DST_XFRM_QUEUE: u32 = 64;
pub const DST_METADATA: u32 = 128;
pub const DST_OBSOLETE_NONE: u32 = 0;
pub const DST_OBSOLETE_DEAD: u32 = 2;
pub const DST_OBSOLETE_FORCE_CHK: i32 = -1;
pub const DST_OBSOLETE_KILL: i32 = -2;
pub const DST_METRICS_READ_ONLY: u32 = 1;
pub const DST_METRICS_REFCOUNTED: u32 = 2;
pub const DST_METRICS_FLAGS: u32 = 3;
pub const DST_FEATURE_ECN_CA: u32 = 2147483648;
pub const DST_FEATURE_MASK: u32 = 2147483648;
pub const DST_FEATURE_ECN_MASK: u32 = 2147483649;
pub const TCP_STATE_MASK: u32 = 15;
pub const FIB_RULE_PERMANENT: u32 = 1;
pub const FIB_RULE_INVERT: u32 = 2;
pub const FIB_RULE_UNRESOLVED: u32 = 4;
pub const FIB_RULE_IIF_DETACHED: u32 = 8;
pub const FIB_RULE_DEV_DETACHED: u32 = 8;
pub const FIB_RULE_OIF_DETACHED: u32 = 16;
pub const FIB_RULE_FIND_SADDR: u32 = 65536;
pub const FIB_LOOKUP_NOREF: u32 = 1;
pub const FIB_LOOKUP_IGNORE_LINKSTATE: u32 = 2;
pub const SK_USER_DATA_NOCOPY: u32 = 1;
pub const SK_USER_DATA_BPF: u32 = 2;
pub const SK_USER_DATA_PSOCK: u32 = 4;
pub const SK_USER_DATA_PTRMASK: i32 = -8;
pub const SK_NO_REUSE: u32 = 0;
pub const SK_CAN_REUSE: u32 = 1;
pub const SK_FORCE_REUSE: u32 = 2;
pub const SK_MEMORY_PCPU_RESERVE: u32 = 256;
pub const SK_ALLOC_PERCPU_COUNTER_BATCH: u32 = 16;
pub const PROTO_INUSE_NR: u32 = 64;
pub const SOCK_DESTROY_TIME: u32 = 2500;
pub const PROT_SOCK: u32 = 1024;
pub const SHUTDOWN_MASK: u32 = 3;
pub const RCV_SHUTDOWN: u32 = 1;
pub const SEND_SHUTDOWN: u32 = 2;
pub const SOCK_BINDADDR_LOCK: u32 = 4;
pub const SOCK_BINDPORT_LOCK: u32 = 8;
pub const SK_MEM_SEND: u32 = 0;
pub const SK_MEM_RECV: u32 = 1;
pub const SK_DEFAULT_STAMP: i32 = -1000000000;
pub const _SK_MEM_PACKETS: u32 = 256;
pub const JHASH_INITVAL: u32 = 3735928559;
pub const IPCORK_OPT: u32 = 1;
pub const IPCORK_ALLFRAG: u32 = 2;
pub const ICSK_TIME_RETRANS: u32 = 1;
pub const ICSK_TIME_DACK: u32 = 2;
pub const ICSK_TIME_PROBE0: u32 = 3;
pub const ICSK_TIME_LOSS_PROBE: u32 = 5;
pub const ICSK_TIME_REO_TIMEOUT: u32 = 6;
pub const TCP_PINGPONG_THRESH: u32 = 1;
pub const TCP_MSS_DEFAULT: u32 = 536;
pub const TCP_MSS_DESIRED: u32 = 1220;
pub const TCP_NODELAY: u32 = 1;
pub const TCP_MAXSEG: u32 = 2;
pub const TCP_CORK: u32 = 3;
pub const TCP_KEEPIDLE: u32 = 4;
pub const TCP_KEEPINTVL: u32 = 5;
pub const TCP_KEEPCNT: u32 = 6;
pub const TCP_SYNCNT: u32 = 7;
pub const TCP_LINGER2: u32 = 8;
pub const TCP_DEFER_ACCEPT: u32 = 9;
pub const TCP_WINDOW_CLAMP: u32 = 10;
pub const TCP_INFO: u32 = 11;
pub const TCP_QUICKACK: u32 = 12;
pub const TCP_CONGESTION: u32 = 13;
pub const TCP_MD5SIG: u32 = 14;
pub const TCP_THIN_LINEAR_TIMEOUTS: u32 = 16;
pub const TCP_THIN_DUPACK: u32 = 17;
pub const TCP_USER_TIMEOUT: u32 = 18;
pub const TCP_REPAIR: u32 = 19;
pub const TCP_REPAIR_QUEUE: u32 = 20;
pub const TCP_QUEUE_SEQ: u32 = 21;
pub const TCP_REPAIR_OPTIONS: u32 = 22;
pub const TCP_FASTOPEN: u32 = 23;
pub const TCP_TIMESTAMP: u32 = 24;
pub const TCP_NOTSENT_LOWAT: u32 = 25;
pub const TCP_CC_INFO: u32 = 26;
pub const TCP_SAVE_SYN: u32 = 27;
pub const TCP_SAVED_SYN: u32 = 28;
pub const TCP_REPAIR_WINDOW: u32 = 29;
pub const TCP_FASTOPEN_CONNECT: u32 = 30;
pub const TCP_ULP: u32 = 31;
pub const TCP_MD5SIG_EXT: u32 = 32;
pub const TCP_FASTOPEN_KEY: u32 = 33;
pub const TCP_FASTOPEN_NO_COOKIE: u32 = 34;
pub const TCP_ZEROCOPY_RECEIVE: u32 = 35;
pub const TCP_INQ: u32 = 36;
pub const TCP_CM_INQ: u32 = 36;
pub const TCP_TX_DELAY: u32 = 37;
pub const TCP_REPAIR_ON: u32 = 1;
pub const TCP_REPAIR_OFF: u32 = 0;
pub const TCP_REPAIR_OFF_NO_WP: i32 = -1;
pub const TCPI_OPT_TIMESTAMPS: u32 = 1;
pub const TCPI_OPT_SACK: u32 = 2;
pub const TCPI_OPT_WSCALE: u32 = 4;
pub const TCPI_OPT_ECN: u32 = 8;
pub const TCPI_OPT_ECN_SEEN: u32 = 16;
pub const TCPI_OPT_SYN_DATA: u32 = 32;
pub const TCP_MD5SIG_MAXKEYLEN: u32 = 80;
pub const TCP_MD5SIG_FLAG_PREFIX: u32 = 1;
pub const TCP_MD5SIG_FLAG_IFINDEX: u32 = 2;
pub const TCP_RECEIVE_ZEROCOPY_FLAG_TLB_CLEAN_HINT: u32 = 1;
pub const TCP_FASTOPEN_COOKIE_MIN: u32 = 4;
pub const TCP_FASTOPEN_COOKIE_MAX: u32 = 16;
pub const TCP_FASTOPEN_COOKIE_SIZE: u32 = 8;
pub const TCP_SACK_SEEN: u32 = 1;
pub const TCP_DSACK_SEEN: u32 = 4;
pub const TCP_NUM_SACKS: u32 = 4;
pub const TCP_RACK_RECOVERY_THRESH: u32 = 16;
pub const IPTOS_TOS_MASK: u32 = 30;
pub const IPTOS_LOWDELAY: u32 = 16;
pub const IPTOS_THROUGHPUT: u32 = 8;
pub const IPTOS_RELIABILITY: u32 = 4;
pub const IPTOS_MINCOST: u32 = 2;
pub const IPTOS_PREC_MASK: u32 = 224;
pub const IPTOS_PREC_NETCONTROL: u32 = 224;
pub const IPTOS_PREC_INTERNETCONTROL: u32 = 192;
pub const IPTOS_PREC_CRITIC_ECP: u32 = 160;
pub const IPTOS_PREC_FLASHOVERRIDE: u32 = 128;
pub const IPTOS_PREC_FLASH: u32 = 96;
pub const IPTOS_PREC_IMMEDIATE: u32 = 64;
pub const IPTOS_PREC_PRIORITY: u32 = 32;
pub const IPTOS_PREC_ROUTINE: u32 = 0;
pub const IPOPT_COPY: u32 = 128;
pub const IPOPT_CLASS_MASK: u32 = 96;
pub const IPOPT_NUMBER_MASK: u32 = 31;
pub const IPOPT_CONTROL: u32 = 0;
pub const IPOPT_RESERVED1: u32 = 32;
pub const IPOPT_MEASUREMENT: u32 = 64;
pub const IPOPT_RESERVED2: u32 = 96;
pub const IPOPT_END: u32 = 0;
pub const IPOPT_NOOP: u32 = 1;
pub const IPOPT_SEC: u32 = 130;
pub const IPOPT_LSRR: u32 = 131;
pub const IPOPT_TIMESTAMP: u32 = 68;
pub const IPOPT_CIPSO: u32 = 134;
pub const IPOPT_RR: u32 = 7;
pub const IPOPT_SID: u32 = 136;
pub const IPOPT_SSRR: u32 = 137;
pub const IPOPT_RA: u32 = 148;
pub const IPVERSION: u32 = 4;
pub const MAXTTL: u32 = 255;
pub const IPDEFTTL: u32 = 64;
pub const IPOPT_OPTVAL: u32 = 0;
pub const IPOPT_OLEN: u32 = 1;
pub const IPOPT_OFFSET: u32 = 2;
pub const IPOPT_MINOFF: u32 = 4;
pub const MAX_IPOPTLEN: u32 = 40;
pub const IPOPT_NOP: u32 = 1;
pub const IPOPT_EOL: u32 = 0;
pub const IPOPT_TS: u32 = 68;
pub const IPOPT_TS_TSONLY: u32 = 0;
pub const IPOPT_TS_TSANDADDR: u32 = 1;
pub const IPOPT_TS_PRESPEC: u32 = 3;
pub const IPV4_BEET_PHMAXLEN: u32 = 8;
pub const IPV6_MIN_MTU: u32 = 1280;
pub const IPV6_SRCRT_STRICT: u32 = 1;
pub const IPV6_SRCRT_TYPE_0: u32 = 0;
pub const IPV6_SRCRT_TYPE_2: u32 = 2;
pub const IPV6_SRCRT_TYPE_3: u32 = 3;
pub const IPV6_SRCRT_TYPE_4: u32 = 4;
pub const IPV6_OPT_ROUTERALERT_MLD: u32 = 0;
pub const UDP_CORK: u32 = 1;
pub const UDP_ENCAP: u32 = 100;
pub const UDP_NO_CHECK6_TX: u32 = 101;
pub const UDP_NO_CHECK6_RX: u32 = 102;
pub const UDP_SEGMENT: u32 = 103;
pub const UDP_GRO: u32 = 104;
pub const UDP_ENCAP_ESPINUDP_NON_IKE: u32 = 1;
pub const UDP_ENCAP_ESPINUDP: u32 = 2;
pub const UDP_ENCAP_L2TPINUDP: u32 = 3;
pub const UDP_ENCAP_GTP0: u32 = 4;
pub const UDP_ENCAP_GTP1U: u32 = 5;
pub const UDP_ENCAP_RXRPC: u32 = 6;
pub const TCP_ENCAP_ESPINTCP: u32 = 7;
pub const UDPLITE_BIT: u32 = 1;
pub const UDPLITE_SEND_CC: u32 = 2;
pub const UDPLITE_RECV_CC: u32 = 4;
pub const UDP_MAX_SEGMENTS: u32 = 64;
pub const IP6SKB_XFRM_TRANSFORMED: u32 = 1;
pub const IP6SKB_FORWARDED: u32 = 2;
pub const IP6SKB_REROUTED: u32 = 4;
pub const IP6SKB_ROUTERALERT: u32 = 8;
pub const IP6SKB_FRAGMENTED: u32 = 16;
pub const IP6SKB_HOPBYHOP: u32 = 32;
pub const IP6SKB_L3SLAVE: u32 = 64;
pub const IP6SKB_JUMBOGRAM: u32 = 128;
pub const IP6SKB_SEG6: u32 = 256;
pub const IP6SKB_FAKEJUMBO: u32 = 512;
pub const IF_RA_OTHERCONF: u32 = 128;
pub const IF_RA_MANAGED: u32 = 64;
pub const IF_RA_RCVD: u32 = 32;
pub const IF_RS_SENT: u32 = 16;
pub const IF_READY: u32 = 2147483648;
pub const IF_PREFIX_ONLINK: u32 = 1;
pub const IF_PREFIX_AUTOCONF: u32 = 2;
pub const IP6_SFBLOCK: u32 = 10;
pub const MAF_TIMER_RUNNING: u32 = 1;
pub const MAF_LAST_REPORTER: u32 = 2;
pub const MAF_LOADED: u32 = 4;
pub const MAF_NOREPORT: u32 = 8;
pub const MAF_GSQUERY: u32 = 16;
pub const INET_DSCP_MASK: u32 = 252;
pub const SIN6_LEN_RFC2133: u32 = 24;
pub const IPV6_MAXPLEN: u32 = 65535;
pub const NEXTHDR_HOP: u32 = 0;
pub const NEXTHDR_IPV4: u32 = 4;
pub const NEXTHDR_TCP: u32 = 6;
pub const NEXTHDR_UDP: u32 = 17;
pub const NEXTHDR_IPV6: u32 = 41;
pub const NEXTHDR_ROUTING: u32 = 43;
pub const NEXTHDR_FRAGMENT: u32 = 44;
pub const NEXTHDR_GRE: u32 = 47;
pub const NEXTHDR_ESP: u32 = 50;
pub const NEXTHDR_AUTH: u32 = 51;
pub const NEXTHDR_ICMP: u32 = 58;
pub const NEXTHDR_NONE: u32 = 59;
pub const NEXTHDR_DEST: u32 = 60;
pub const NEXTHDR_SCTP: u32 = 132;
pub const NEXTHDR_MOBILITY: u32 = 135;
pub const NEXTHDR_MAX: u32 = 255;
pub const IPV6_DEFAULT_HOPLIMIT: u32 = 64;
pub const IPV6_DEFAULT_MCASTHOPS: u32 = 1;
pub const IP6_DEFAULT_MAX_DST_OPTS_CNT: u32 = 8;
pub const IP6_DEFAULT_MAX_HBH_OPTS_CNT: u32 = 8;
pub const IPV6_ADDR_ANY: u32 = 0;
pub const IPV6_ADDR_UNICAST: u32 = 1;
pub const IPV6_ADDR_MULTICAST: u32 = 2;
pub const IPV6_ADDR_LOOPBACK: u32 = 16;
pub const IPV6_ADDR_LINKLOCAL: u32 = 32;
pub const IPV6_ADDR_SITELOCAL: u32 = 64;
pub const IPV6_ADDR_COMPATv4: u32 = 128;
pub const IPV6_ADDR_SCOPE_MASK: u32 = 240;
pub const IPV6_ADDR_MAPPED: u32 = 4096;
pub const __IPV6_ADDR_SCOPE_INVALID: i32 = -1;
pub const IPV6_ADDR_SCOPE_NODELOCAL: u32 = 1;
pub const IPV6_ADDR_SCOPE_LINKLOCAL: u32 = 2;
pub const IPV6_ADDR_SCOPE_SITELOCAL: u32 = 5;
pub const IPV6_ADDR_SCOPE_ORGLOCAL: u32 = 8;
pub const IPV6_ADDR_SCOPE_GLOBAL: u32 = 14;
pub const IP6_MF: u32 = 1;
pub const IP6_OFFSET: u32 = 65528;
pub const IPV6_TCLASS_SHIFT: u32 = 20;
pub const IPV6_FRAG_HIGH_THRESH: u32 = 4194304;
pub const IPV6_FRAG_LOW_THRESH: u32 = 3145728;
pub const IPV6_FRAG_TIMEOUT: u32 = 15000;
pub const IP6_AUTO_FLOW_LABEL_OFF: u32 = 0;
pub const IP6_AUTO_FLOW_LABEL_OPTOUT: u32 = 1;
pub const IP6_AUTO_FLOW_LABEL_OPTIN: u32 = 2;
pub const IP6_AUTO_FLOW_LABEL_FORCED: u32 = 3;
pub const IP6_AUTO_FLOW_LABEL_MAX: u32 = 3;
pub const IP6_DEFAULT_AUTO_FLOW_LABELS: u32 = 1;
pub const FNHE_HASH_SHIFT: u32 = 11;
pub const FNHE_HASH_SIZE: u32 = 2048;
pub const FNHE_RECLAIM_DEPTH: u32 = 5;
pub const FIB_TABLE_HASHSZ: u32 = 2;
pub const ARPHRD_NETROM: u32 = 0;
pub const ARPHRD_ETHER: u32 = 1;
pub const ARPHRD_EETHER: u32 = 2;
pub const ARPHRD_AX25: u32 = 3;
pub const ARPHRD_PRONET: u32 = 4;
pub const ARPHRD_CHAOS: u32 = 5;
pub const ARPHRD_IEEE802: u32 = 6;
pub const ARPHRD_ARCNET: u32 = 7;
pub const ARPHRD_APPLETLK: u32 = 8;
pub const ARPHRD_DLCI: u32 = 15;
pub const ARPHRD_ATM: u32 = 19;
pub const ARPHRD_METRICOM: u32 = 23;
pub const ARPHRD_IEEE1394: u32 = 24;
pub const ARPHRD_EUI64: u32 = 27;
pub const ARPHRD_INFINIBAND: u32 = 32;
pub const ARPHRD_SLIP: u32 = 256;
pub const ARPHRD_CSLIP: u32 = 257;
pub const ARPHRD_SLIP6: u32 = 258;
pub const ARPHRD_CSLIP6: u32 = 259;
pub const ARPHRD_RSRVD: u32 = 260;
pub const ARPHRD_ADAPT: u32 = 264;
pub const ARPHRD_ROSE: u32 = 270;
pub const ARPHRD_X25: u32 = 271;
pub const ARPHRD_HWX25: u32 = 272;
pub const ARPHRD_CAN: u32 = 280;
pub const ARPHRD_MCTP: u32 = 290;
pub const ARPHRD_PPP: u32 = 512;
pub const ARPHRD_CISCO: u32 = 513;
pub const ARPHRD_HDLC: u32 = 513;
pub const ARPHRD_LAPB: u32 = 516;
pub const ARPHRD_DDCMP: u32 = 517;
pub const ARPHRD_RAWHDLC: u32 = 518;
pub const ARPHRD_RAWIP: u32 = 519;
pub const ARPHRD_TUNNEL: u32 = 768;
pub const ARPHRD_TUNNEL6: u32 = 769;
pub const ARPHRD_FRAD: u32 = 770;
pub const ARPHRD_SKIP: u32 = 771;
pub const ARPHRD_LOOPBACK: u32 = 772;
pub const ARPHRD_LOCALTLK: u32 = 773;
pub const ARPHRD_FDDI: u32 = 774;
pub const ARPHRD_BIF: u32 = 775;
pub const ARPHRD_SIT: u32 = 776;
pub const ARPHRD_IPDDP: u32 = 777;
pub const ARPHRD_IPGRE: u32 = 778;
pub const ARPHRD_PIMREG: u32 = 779;
pub const ARPHRD_HIPPI: u32 = 780;
pub const ARPHRD_ASH: u32 = 781;
pub const ARPHRD_ECONET: u32 = 782;
pub const ARPHRD_IRDA: u32 = 783;
pub const ARPHRD_FCPP: u32 = 784;
pub const ARPHRD_FCAL: u32 = 785;
pub const ARPHRD_FCPL: u32 = 786;
pub const ARPHRD_FCFABRIC: u32 = 787;
pub const ARPHRD_IEEE802_TR: u32 = 800;
pub const ARPHRD_IEEE80211: u32 = 801;
pub const ARPHRD_IEEE80211_PRISM: u32 = 802;
pub const ARPHRD_IEEE80211_RADIOTAP: u32 = 803;
pub const ARPHRD_IEEE802154: u32 = 804;
pub const ARPHRD_IEEE802154_MONITOR: u32 = 805;
pub const ARPHRD_PHONET: u32 = 820;
pub const ARPHRD_PHONET_PIPE: u32 = 821;
pub const ARPHRD_CAIF: u32 = 822;
pub const ARPHRD_IP6GRE: u32 = 823;
pub const ARPHRD_NETLINK: u32 = 824;
pub const ARPHRD_6LOWPAN: u32 = 825;
pub const ARPHRD_VSOCKMON: u32 = 826;
pub const ARPHRD_VOID: u32 = 65535;
pub const ARPHRD_NONE: u32 = 65534;
pub const ARPOP_REQUEST: u32 = 1;
pub const ARPOP_REPLY: u32 = 2;
pub const ARPOP_RREQUEST: u32 = 3;
pub const ARPOP_RREPLY: u32 = 4;
pub const ARPOP_InREQUEST: u32 = 8;
pub const ARPOP_InREPLY: u32 = 9;
pub const ARPOP_NAK: u32 = 10;
pub const ATF_COM: u32 = 2;
pub const ATF_PERM: u32 = 4;
pub const ATF_PUBL: u32 = 8;
pub const ATF_USETRAILERS: u32 = 16;
pub const ATF_NETMASK: u32 = 32;
pub const ATF_DONTPUB: u32 = 64;
pub const NDISC_ROUTER_SOLICITATION: u32 = 133;
pub const NDISC_ROUTER_ADVERTISEMENT: u32 = 134;
pub const NDISC_NEIGHBOUR_SOLICITATION: u32 = 135;
pub const NDISC_NEIGHBOUR_ADVERTISEMENT: u32 = 136;
pub const NDISC_REDIRECT: u32 = 137;
pub const NDISC_NODETYPE_UNSPEC: u32 = 0;
pub const NDISC_NODETYPE_HOST: u32 = 1;
pub const NDISC_NODETYPE_NODEFAULT: u32 = 2;
pub const NDISC_NODETYPE_DEFAULT: u32 = 3;
pub const MAX_RTR_SOLICITATION_DELAY: u32 = 250;
pub const ND_REACHABLE_TIME: u32 = 7500;
pub const ND_RETRANS_TIMER: u32 = 250;
pub const ND_DEBUG: u32 = 1;
pub const NDISC_OPS_REDIRECT_DATA_SPACE: u32 = 2;
pub const RTCF_DEAD: u32 = 1;
pub const RTCF_ONLINK: u32 = 4;
pub const RTCF_NOTIFY: u32 = 65536;
pub const RTCF_DIRECTDST: u32 = 131072;
pub const RTCF_REDIRECTED: u32 = 262144;
pub const RTCF_TPROXY: u32 = 524288;
pub const RTCF_FAST: u32 = 2097152;
pub const RTCF_MASQ: u32 = 4194304;
pub const RTCF_SNAT: u32 = 8388608;
pub const RTCF_DOREDIRECT: u32 = 16777216;
pub const RTCF_DIRECTSRC: u32 = 67108864;
pub const RTCF_DNAT: u32 = 134217728;
pub const RTCF_BROADCAST: u32 = 268435456;
pub const RTCF_MULTICAST: u32 = 536870912;
pub const RTCF_REJECT: u32 = 1073741824;
pub const RTCF_LOCAL: u32 = 2147483648;
pub const RTCF_NAT: u32 = 142606336;
pub const RTF_UP: u32 = 1;
pub const RTF_GATEWAY: u32 = 2;
pub const RTF_HOST: u32 = 4;
pub const RTF_REINSTATE: u32 = 8;
pub const RTF_DYNAMIC: u32 = 16;
pub const RTF_MODIFIED: u32 = 32;
pub const RTF_MTU: u32 = 64;
pub const RTF_MSS: u32 = 64;
pub const RTF_WINDOW: u32 = 128;
pub const RTF_IRTT: u32 = 256;
pub const RTF_REJECT: u32 = 512;
pub const IP_MAX_MTU: u32 = 65535;
pub const RTO_ONLINK: u32 = 1;
pub const IPTOS_RT_MASK: u32 = 28;
pub const __NET_LWTUNNEL_H: u32 = 1;
pub const LWT_BPF_MAX_HEADROOM: u32 = 256;
pub const LWTUNNEL_HASH_BITS: u32 = 7;
pub const LWTUNNEL_HASH_SIZE: u32 = 128;
pub const IPV4_MAX_PMTU: u32 = 65535;
pub const IPV4_MIN_MTU: u32 = 68;
pub const IP_CE: u32 = 32768;
pub const IP_DF: u32 = 16384;
pub const IP_MF: u32 = 8192;
pub const IP_OFFSET: u32 = 8191;
pub const IP_FRAG_TIME: u32 = 7500;
pub const IP_REPLY_ARG_NOSRCCHECK: u32 = 1;
pub const FASTREUSEPORT_ANY: u32 = 1;
pub const FASTREUSEPORT_STRICT: u32 = 2;
pub const LISTENING_NULLS_BASE: u32 = 536870912;
pub const INET_LHTABLE_SIZE: u32 = 32;
pub const _LINUX_BPF_H: u32 = 1;
pub const BPF_LD: u32 = 0;
pub const BPF_LDX: u32 = 1;
pub const BPF_ST: u32 = 2;
pub const BPF_STX: u32 = 3;
pub const BPF_ALU: u32 = 4;
pub const BPF_JMP: u32 = 5;
pub const BPF_RET: u32 = 6;
pub const BPF_MISC: u32 = 7;
pub const BPF_W: u32 = 0;
pub const BPF_H: u32 = 8;
pub const BPF_B: u32 = 16;
pub const BPF_IMM: u32 = 0;
pub const BPF_ABS: u32 = 32;
pub const BPF_IND: u32 = 64;
pub const BPF_MEM: u32 = 96;
pub const BPF_LEN: u32 = 128;
pub const BPF_MSH: u32 = 160;
pub const BPF_ADD: u32 = 0;
pub const BPF_SUB: u32 = 16;
pub const BPF_MUL: u32 = 32;
pub const BPF_DIV: u32 = 48;
pub const BPF_OR: u32 = 64;
pub const BPF_AND: u32 = 80;
pub const BPF_LSH: u32 = 96;
pub const BPF_RSH: u32 = 112;
pub const BPF_NEG: u32 = 128;
pub const BPF_MOD: u32 = 144;
pub const BPF_XOR: u32 = 160;
pub const BPF_JA: u32 = 0;
pub const BPF_JEQ: u32 = 16;
pub const BPF_JGT: u32 = 32;
pub const BPF_JGE: u32 = 48;
pub const BPF_JSET: u32 = 64;
pub const BPF_K: u32 = 0;
pub const BPF_X: u32 = 8;
pub const BPF_MAXINSNS: u32 = 4096;
pub const BPF_JMP32: u32 = 6;
pub const BPF_ALU64: u32 = 7;
pub const BPF_DW: u32 = 24;
pub const BPF_ATOMIC: u32 = 192;
pub const BPF_XADD: u32 = 192;
pub const BPF_MOV: u32 = 176;
pub const BPF_ARSH: u32 = 192;
pub const BPF_END: u32 = 208;
pub const BPF_TO_LE: u32 = 0;
pub const BPF_TO_BE: u32 = 8;
pub const BPF_FROM_LE: u32 = 0;
pub const BPF_FROM_BE: u32 = 8;
pub const BPF_JNE: u32 = 80;
pub const BPF_JLT: u32 = 160;
pub const BPF_JLE: u32 = 176;
pub const BPF_JSGT: u32 = 96;
pub const BPF_JSGE: u32 = 112;
pub const BPF_JSLT: u32 = 192;
pub const BPF_JSLE: u32 = 208;
pub const BPF_CALL: u32 = 128;
pub const BPF_EXIT: u32 = 144;
pub const BPF_FETCH: u32 = 1;
pub const BPF_XCHG: u32 = 225;
pub const BPF_CMPXCHG: u32 = 241;
pub const BPF_F_ALLOW_OVERRIDE: u32 = 1;
pub const BPF_F_ALLOW_MULTI: u32 = 2;
pub const BPF_F_REPLACE: u32 = 4;
pub const BPF_F_STRICT_ALIGNMENT: u32 = 1;
pub const BPF_F_ANY_ALIGNMENT: u32 = 2;
pub const BPF_F_TEST_RND_HI32: u32 = 4;
pub const BPF_F_TEST_STATE_FREQ: u32 = 8;
pub const BPF_F_SLEEPABLE: u32 = 16;
pub const BPF_F_XDP_HAS_FRAGS: u32 = 32;
pub const BPF_F_KPROBE_MULTI_RETURN: u32 = 1;
pub const BPF_PSEUDO_MAP_FD: u32 = 1;
pub const BPF_PSEUDO_MAP_IDX: u32 = 5;
pub const BPF_PSEUDO_MAP_VALUE: u32 = 2;
pub const BPF_PSEUDO_MAP_IDX_VALUE: u32 = 6;
pub const BPF_PSEUDO_BTF_ID: u32 = 3;
pub const BPF_PSEUDO_FUNC: u32 = 4;
pub const BPF_PSEUDO_CALL: u32 = 1;
pub const BPF_PSEUDO_KFUNC_CALL: u32 = 2;
pub const BPF_F_QUERY_EFFECTIVE: u32 = 1;
pub const BPF_F_TEST_RUN_ON_CPU: u32 = 1;
pub const BPF_F_TEST_XDP_LIVE_FRAMES: u32 = 2;
pub const BPF_BUILD_ID_SIZE: u32 = 20;
pub const BPF_OBJ_NAME_LEN: u32 = 16;
pub const XDP_PACKET_HEADROOM: u32 = 256;
pub const BPF_TAG_SIZE: u32 = 8;
pub const BPF_MAJOR_VERSION: u32 = 1;
pub const BPF_MINOR_VERSION: u32 = 1;
pub const BPF_A: u32 = 16;
pub const BPF_TAX: u32 = 0;
pub const BPF_TXA: u32 = 128;
pub const BPF_MEMWORDS: u32 = 16;
pub const SKF_AD_OFF: i32 = -4096;
pub const SKF_AD_PROTOCOL: u32 = 0;
pub const SKF_AD_PKTTYPE: u32 = 4;
pub const SKF_AD_IFINDEX: u32 = 8;
pub const SKF_AD_NLATTR: u32 = 12;
pub const SKF_AD_NLATTR_NEST: u32 = 16;
pub const SKF_AD_MARK: u32 = 20;
pub const SKF_AD_QUEUE: u32 = 24;
pub const SKF_AD_HATYPE: u32 = 28;
pub const SKF_AD_RXHASH: u32 = 32;
pub const SKF_AD_CPU: u32 = 36;
pub const SKF_AD_ALU_XOR_X: u32 = 40;
pub const SKF_AD_VLAN_TAG: u32 = 44;
pub const SKF_AD_VLAN_TAG_PRESENT: u32 = 48;
pub const SKF_AD_PAY_OFFSET: u32 = 52;
pub const SKF_AD_RANDOM: u32 = 56;
pub const SKF_AD_VLAN_TPID: u32 = 60;
pub const SKF_AD_MAX: u32 = 64;
pub const SKF_NET_OFF: i32 = -1048576;
pub const SKF_LL_OFF: i32 = -2097152;
pub const BPF_NET_OFF: i32 = -1048576;
pub const BPF_LL_OFF: i32 = -2097152;
pub const KSYM_NAME_LEN: u32 = 512;
pub const _LINUX_BTF_H: u32 = 1;
pub const BTF_MAGIC: u32 = 60319;
pub const BTF_VERSION: u32 = 1;
pub const BTF_MAX_TYPE: u32 = 1048575;
pub const BTF_MAX_NAME_OFFSET: u32 = 16777215;
pub const BTF_MAX_VLEN: u32 = 65535;
pub const BTF_INT_SIGNED: u32 = 1;
pub const BTF_INT_CHAR: u32 = 2;
pub const BTF_INT_BOOL: u32 = 4;
pub const KF_ACQUIRE: u32 = 1;
pub const KF_RELEASE: u32 = 2;
pub const KF_RET_NULL: u32 = 4;
pub const KF_KPTR_GET: u32 = 8;
pub const KF_TRUSTED_ARGS: u32 = 16;
pub const KF_SLEEPABLE: u32 = 32;
pub const KF_DESTRUCTIVE: u32 = 64;
pub const BTF_SHOW_UNSAFE: u32 = 16;
pub const BPF_BASE_TYPE_BITS: u32 = 8;
pub const BPF_BASE_TYPE_LIMIT: u32 = 256;
pub const MAX_BPF_FUNC_ARGS: u32 = 12;
pub const MAX_BPF_FUNC_REG_ARGS: u32 = 5;
pub const BPF_MAX_TRAMP_LINKS: u32 = 38;
pub const BPF_DISPATCHER_MAX: u32 = 48;
pub const BPF_STRUCT_OPS_MAX_NR_MEMBERS: u32 = 64;
pub const BPF_COMPLEXITY_LIMIT_INSNS: u32 = 1000000;
pub const MAX_TAIL_CALL_CNT: u32 = 33;
pub const BPF_MAX_USER_RINGBUF_SAMPLES: u32 = 131072;
pub const BPF_RET_BIND_NO_CAP_NET_BIND_SERVICE: u32 = 1;
pub const BPF_RET_SET_CN: u32 = 1;
pub const BPF_ITER_FUNC_PREFIX: &'static [u8; 10usize] = b"bpf_iter_\0";
pub const BPF_ITER_CTX_ARG_MAX: u32 = 2;
pub const MAX_BPRINTF_VARARGS: u32 = 12;
pub const SECTION_ALIGN: u32 = 2097152;
pub const VLAN_HLEN: u32 = 4;
pub const VLAN_ETH_HLEN: u32 = 18;
pub const VLAN_ETH_ZLEN: u32 = 64;
pub const VLAN_ETH_DATA_LEN: u32 = 1500;
pub const VLAN_ETH_FRAME_LEN: u32 = 1518;
pub const VLAN_MAX_DEPTH: u32 = 8;
pub const VLAN_PRIO_MASK: u32 = 57344;
pub const VLAN_PRIO_SHIFT: u32 = 13;
pub const VLAN_CFI_MASK: u32 = 4096;
pub const VLAN_VID_MASK: u32 = 4095;
pub const VLAN_N_VID: u32 = 4096;
pub const SHA1_DIGEST_SIZE: u32 = 20;
pub const SHA1_BLOCK_SIZE: u32 = 64;
pub const SHA1_H0: u32 = 1732584193;
pub const SHA1_H1: u32 = 4023233417;
pub const SHA1_H2: u32 = 2562383102;
pub const SHA1_H3: u32 = 271733878;
pub const SHA1_H4: u32 = 3285377520;
pub const SHA1_DIGEST_WORDS: u32 = 5;
pub const SHA1_WORKSPACE_WORDS: u32 = 16;
pub const TCQ_F_BUILTIN: u32 = 1;
pub const TCQ_F_INGRESS: u32 = 2;
pub const TCQ_F_CAN_BYPASS: u32 = 4;
pub const TCQ_F_MQROOT: u32 = 8;
pub const TCQ_F_ONETXQUEUE: u32 = 16;
pub const TCQ_F_WARN_NONWC: u32 = 65536;
pub const TCQ_F_CPUSTATS: u32 = 32;
pub const TCQ_F_NOPARENT: u32 = 64;
pub const TCQ_F_INVISIBLE: u32 = 128;
pub const TCQ_F_NOLOCK: u32 = 256;
pub const TCQ_F_OFFLOADED: u32 = 512;
pub const QDISC_CB_PRIV_LEN: u32 = 20;
pub const BPF_TAIL_CALL: u32 = 240;
pub const BPF_PROBE_MEM: u32 = 32;
pub const BPF_CALL_ARGS: u32 = 224;
pub const BPF_NOSPEC: u32 = 192;
pub const BPF_SYM_ELF_TYPE: u8 = 116u8;
pub const MAX_BPF_STACK: u32 = 512;
pub const BPF_IMAGE_ALIGNMENT: u32 = 8;
pub const BPF_SKB_CB_LEN: u32 = 20;
pub const BPF_SOCKOPT_KERN_BUF_SIZE: u32 = 32;
pub const MPTCPOPT_HMAC_LEN: u32 = 20;
pub const MPTCP_RM_IDS_MAX: u32 = 8;
pub const MAX_TCP_OPTION_SPACE: u32 = 40;
pub const TCP_MIN_SND_MSS: u32 = 48;
pub const TCP_MIN_GSO_SIZE: u32 = 8;
pub const MAX_TCP_WINDOW: u32 = 32767;
pub const TCP_MIN_MSS: u32 = 88;
pub const TCP_BASE_MSS: u32 = 1024;
pub const TCP_PROBE_INTERVAL: u32 = 600;
pub const TCP_PROBE_THRESHOLD: u32 = 8;
pub const TCP_FASTRETRANS_THRESH: u32 = 3;
pub const TCP_MAX_QUICKACKS: u32 = 16;
pub const TCP_MAX_WSCALE: u32 = 14;
pub const TCP_URG_VALID: u32 = 256;
pub const TCP_URG_NOTYET: u32 = 512;
pub const TCP_URG_READ: u32 = 1024;
pub const TCP_RETR1: u32 = 3;
pub const TCP_RETR2: u32 = 15;
pub const TCP_SYN_RETRIES: u32 = 6;
pub const TCP_SYNACK_RETRIES: u32 = 5;
pub const TCP_TIMEWAIT_LEN: u32 = 15000;
pub const TCP_FIN_TIMEOUT: u32 = 15000;
pub const TCP_FIN_TIMEOUT_MAX: u32 = 30000;
pub const TCP_TIMEOUT_MIN: u32 = 2;
pub const TCP_KEEPALIVE_TIME: u32 = 1800000;
pub const TCP_KEEPALIVE_PROBES: u32 = 9;
pub const TCP_KEEPALIVE_INTVL: u32 = 18750;
pub const MAX_TCP_KEEPIDLE: u32 = 32767;
pub const MAX_TCP_KEEPINTVL: u32 = 32767;
pub const MAX_TCP_KEEPCNT: u32 = 127;
pub const MAX_TCP_SYNCNT: u32 = 127;
pub const TCP_SYNQ_INTERVAL: u32 = 50;
pub const TCP_PAWS_24DAYS: u32 = 2073600;
pub const TCP_PAWS_MSL: u32 = 60;
pub const TCP_PAWS_WINDOW: u32 = 1;
pub const TCPOPT_NOP: u32 = 1;
pub const TCPOPT_EOL: u32 = 0;
pub const TCPOPT_MSS: u32 = 2;
pub const TCPOPT_WINDOW: u32 = 3;
pub const TCPOPT_SACK_PERM: u32 = 4;
pub const TCPOPT_SACK: u32 = 5;
pub const TCPOPT_TIMESTAMP: u32 = 8;
pub const TCPOPT_MD5SIG: u32 = 19;
pub const TCPOPT_MPTCP: u32 = 30;
pub const TCPOPT_FASTOPEN: u32 = 34;
pub const TCPOPT_EXP: u32 = 254;
pub const TCPOPT_FASTOPEN_MAGIC: u32 = 63881;
pub const TCPOPT_SMC_MAGIC: u32 = 3805594585;
pub const TCPOLEN_MSS: u32 = 4;
pub const TCPOLEN_WINDOW: u32 = 3;
pub const TCPOLEN_SACK_PERM: u32 = 2;
pub const TCPOLEN_TIMESTAMP: u32 = 10;
pub const TCPOLEN_MD5SIG: u32 = 18;
pub const TCPOLEN_FASTOPEN_BASE: u32 = 2;
pub const TCPOLEN_EXP_FASTOPEN_BASE: u32 = 4;
pub const TCPOLEN_EXP_SMC_BASE: u32 = 6;
pub const TCPOLEN_TSTAMP_ALIGNED: u32 = 12;
pub const TCPOLEN_WSCALE_ALIGNED: u32 = 4;
pub const TCPOLEN_SACKPERM_ALIGNED: u32 = 4;
pub const TCPOLEN_SACK_BASE: u32 = 2;
pub const TCPOLEN_SACK_BASE_ALIGNED: u32 = 4;
pub const TCPOLEN_SACK_PERBLOCK: u32 = 8;
pub const TCPOLEN_MD5SIG_ALIGNED: u32 = 20;
pub const TCPOLEN_MSS_ALIGNED: u32 = 4;
pub const TCPOLEN_EXP_SMC_BASE_ALIGNED: u32 = 8;
pub const TCP_NAGLE_OFF: u32 = 1;
pub const TCP_NAGLE_CORK: u32 = 2;
pub const TCP_NAGLE_PUSH: u32 = 4;
pub const TCP_THIN_LINEAR_RETRIES: u32 = 6;
pub const TCP_INIT_CWND: u32 = 10;
pub const TFO_CLIENT_ENABLE: u32 = 1;
pub const TFO_SERVER_ENABLE: u32 = 2;
pub const TFO_CLIENT_NO_COOKIE: u32 = 4;
pub const TFO_SERVER_COOKIE_NOT_REQD: u32 = 512;
pub const TFO_SERVER_WO_SOCKOPT1: u32 = 1024;
pub const TCP_RACK_LOSS_DETECTION: u32 = 1;
pub const TCP_RACK_STATIC_REO_WND: u32 = 2;
pub const TCP_RACK_NO_DUPTHRESH: u32 = 4;
pub const TCP_ECN_OK: u32 = 1;
pub const TCP_ECN_QUEUE_CWR: u32 = 2;
pub const TCP_ECN_DEMAND_CWR: u32 = 4;
pub const TCP_ECN_SEEN: u32 = 8;
pub const TCP_TS_HZ: u32 = 1000;
pub const TCPHDR_FIN: u32 = 1;
pub const TCPHDR_SYN: u32 = 2;
pub const TCPHDR_RST: u32 = 4;
pub const TCPHDR_PSH: u32 = 8;
pub const TCPHDR_ACK: u32 = 16;
pub const TCPHDR_URG: u32 = 32;
pub const TCPHDR_ECE: u32 = 64;
pub const TCPHDR_CWR: u32 = 128;
pub const TCPHDR_SYN_ECN: u32 = 194;
pub const TCPCB_SACKED_ACKED: u32 = 1;
pub const TCPCB_SACKED_RETRANS: u32 = 2;
pub const TCPCB_LOST: u32 = 4;
pub const TCPCB_TAGBITS: u32 = 7;
pub const TCPCB_REPAIRED: u32 = 16;
pub const TCPCB_EVER_RETRANS: u32 = 128;
pub const TCPCB_RETRANS: u32 = 146;
pub const TCPCB_DELIVERED_CE_MASK: u32 = 1048575;
pub const TCP_CA_NAME_MAX: u32 = 16;
pub const TCP_CA_MAX: u32 = 128;
pub const TCP_CA_BUF_MAX: u32 = 2048;
pub const TCP_CA_UNSPEC: u32 = 0;
pub const TCP_CONG_NON_RESTRICTED: u32 = 1;
pub const TCP_CONG_NEEDS_ECN: u32 = 2;
pub const TCP_CONG_MASK: u32 = 3;
pub const TCP_INFINITE_SSTHRESH: u32 = 2147483647;
pub const TCP_FASTOPEN_KEY_MAX: u32 = 2;
pub const TCP_ULP_NAME_MAX: u32 = 16;
pub const TCP_ULP_MAX: u32 = 128;
pub const TCP_ULP_BUF_MAX: u32 = 2048;
pub const MAX_RTR_SOLICITATIONS: i32 = -1;
pub const RTR_SOLICITATION_INTERVAL: u32 = 1000;
pub const RTR_SOLICITATION_MAX_INTERVAL: u32 = 900000;
pub const MIN_VALID_LIFETIME: u32 = 7200;
pub const TEMP_VALID_LIFETIME: u32 = 604800;
pub const TEMP_PREFERRED_LIFETIME: u32 = 86400;
pub const REGEN_MAX_RETRY: u32 = 3;
pub const MAX_DESYNC_FACTOR: u32 = 600;
pub const ADDR_CHECK_FREQUENCY: u32 = 30000;
pub const IPV6_MAX_ADDRESSES: u32 = 16;
pub const ADDRCONF_TIMER_FUZZ: u32 = 62;
pub const ADDRCONF_TIMER_FUZZ_MAX: u32 = 250;
pub const ADDRCONF_NOTIFY_PRIORITY: u32 = 0;
pub const CPU_ONLINE: u32 = 2;
pub const CPU_UP_PREPARE: u32 = 3;
pub const CPU_DEAD: u32 = 7;
pub const CPU_DEAD_FROZEN: u32 = 8;
pub const CPU_POST_DEAD: u32 = 9;
pub const CPU_BROKEN: u32 = 11;
pub const PLATFORM_DEVID_NONE: i32 = -1;
pub const PLATFORM_DEVID_AUTO: i32 = -2;
pub const B_TYPE_LARGE: u32 = 133;
pub const BINDER_CURRENT_PROTOCOL_VERSION: u32 = 8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_branch_data {
    pub func: *const core::ffi::c_char,
    pub file: *const core::ffi::c_char,
    pub line: core::ffi::c_uint,
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ftrace_branch_data__bindgen_ty_1 {
    pub __bindgen_anon_1: ftrace_branch_data__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ftrace_branch_data__bindgen_ty_1__bindgen_ty_2,
    pub miss_hit: [core::ffi::c_ulong; 2usize],
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_1 {
    pub correct: core::ffi::c_ulong,
    pub incorrect: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ftrace_branch_data__bindgen_ty_1__bindgen_ty_2 {
    pub miss: core::ffi::c_ulong,
    pub hit: core::ffi::c_ulong,
}
impl Default for ftrace_branch_data__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for ftrace_branch_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_likely_data {
    pub data: ftrace_branch_data,
    pub constant: core::ffi::c_ulong,
}
impl Default for ftrace_likely_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type __s8 = core::ffi::c_schar;
pub type __u8 = core::ffi::c_uchar;
pub type __s16 = core::ffi::c_short;
pub type __u16 = core::ffi::c_ushort;
pub type __s32 = core::ffi::c_int;
pub type __u32 = core::ffi::c_uint;
pub type __s64 = core::ffi::c_longlong;
pub type __u64 = core::ffi::c_ulonglong;
pub type s8 = __s8;
pub type u8_ = __u8;
pub type s16 = __s16;
pub type u16_ = __u16;
pub type s32 = __s32;
pub type u32_ = __u32;
pub type s64 = __s64;
pub type u64_ = __u64;
pub const false_: core::ffi::c_uint = 0;
pub const true_: core::ffi::c_uint = 1;
pub type _bindgen_ty_1 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [core::ffi::c_ulong; 16usize],
}
pub type __kernel_sighandler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>;
pub type __kernel_key_t = core::ffi::c_int;
pub type __kernel_mqd_t = core::ffi::c_int;
pub type __kernel_long_t = core::ffi::c_long;
pub type __kernel_ulong_t = core::ffi::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = core::ffi::c_uint;
pub type __kernel_pid_t = core::ffi::c_int;
pub type __kernel_ipc_pid_t = core::ffi::c_int;
pub type __kernel_uid_t = core::ffi::c_uint;
pub type __kernel_gid_t = core::ffi::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = core::ffi::c_int;
pub type __kernel_uid32_t = core::ffi::c_uint;
pub type __kernel_gid32_t = core::ffi::c_uint;
pub type __kernel_old_uid_t = __kernel_uid_t;
pub type __kernel_old_gid_t = __kernel_gid_t;
pub type __kernel_old_dev_t = core::ffi::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [core::ffi::c_int; 2usize],
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = core::ffi::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time64_t = core::ffi::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = core::ffi::c_int;
pub type __kernel_clockid_t = core::ffi::c_int;
pub type __kernel_caddr_t = *mut core::ffi::c_char;
pub type __kernel_uid16_t = core::ffi::c_ushort;
pub type __kernel_gid16_t = core::ffi::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = core::ffi::c_uint;
pub type __kernel_dev_t = u32_;
pub type fd_set = __kernel_fd_set;
pub type dev_t = __kernel_dev_t;
pub type ino_t = __kernel_ulong_t;
pub type mode_t = __kernel_mode_t;
pub type umode_t = core::ffi::c_ushort;
pub type nlink_t = u32_;
pub type off_t = __kernel_off_t;
pub type pid_t = __kernel_pid_t;
pub type daddr_t = __kernel_daddr_t;
pub type key_t = __kernel_key_t;
pub type suseconds_t = __kernel_suseconds_t;
pub type timer_t = __kernel_timer_t;
pub type clockid_t = __kernel_clockid_t;
pub type mqd_t = __kernel_mqd_t;
pub type bool_ = bool;
pub type uid_t = __kernel_uid32_t;
pub type gid_t = __kernel_gid32_t;
pub type uid16_t = __kernel_uid16_t;
pub type gid16_t = __kernel_gid16_t;
pub type loff_t = __kernel_loff_t;
pub type clock_t = __kernel_clock_t;
pub type caddr_t = __kernel_caddr_t;
pub type u_char = core::ffi::c_uchar;
pub type u_short = core::ffi::c_ushort;
pub type u_int = core::ffi::c_uint;
pub type u_long = core::ffi::c_ulong;
pub type unchar = core::ffi::c_uchar;
pub type ushort = core::ffi::c_ushort;
pub type uint = core::ffi::c_uint;
pub type ulong = core::ffi::c_ulong;
pub type u_int8_t = u8_;
pub type u_int16_t = u16_;
pub type u_int32_t = u32_;
pub type u_int64_t = u64_;
pub type sector_t = u64_;
pub type blkcnt_t = u64_;
pub type dma_addr_t = u64_;
pub type gfp_t = core::ffi::c_uint;
pub type slab_flags_t = core::ffi::c_uint;
pub type fmode_t = core::ffi::c_uint;
pub type phys_addr_t = u64_;
pub type resource_size_t = phys_addr_t;
pub type irq_hw_number_t = core::ffi::c_ulong;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct atomic_t {
    pub counter: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct atomic64_t {
    pub counter: s64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_head {
    pub next: *mut list_head,
    pub prev: *mut list_head,
}
impl Default for list_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_head {
    pub first: *mut hlist_node,
}
impl Default for hlist_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_node {
    pub next: *mut hlist_node,
    pub pprev: *mut *mut hlist_node,
}
impl Default for hlist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ustat {
    pub f_tfree: __kernel_daddr_t,
    pub f_tinode: core::ffi::c_ulong,
    pub f_fname: [core::ffi::c_char; 6usize],
    pub f_fpack: [core::ffi::c_char; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct callback_head {
    pub next: *mut callback_head,
    pub func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
}
impl Default for callback_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rcu_callback_t = ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>;
pub type call_rcu_func_t =
    ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head, func: rcu_callback_t)>;
pub type swap_r_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *mut core::ffi::c_void,
        b: *mut core::ffi::c_void,
        size: core::ffi::c_int,
        priv_: *const core::ffi::c_void,
    ),
>;
pub type swap_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *mut core::ffi::c_void,
        b: *mut core::ffi::c_void,
        size: core::ffi::c_int,
    ),
>;
pub type cmp_r_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const core::ffi::c_void,
        b: *const core::ffi::c_void,
        priv_: *const core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
pub type cmp_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        a: *const core::ffi::c_void,
        b: *const core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kcsan_scoped_access {}
pub type va_list = __builtin_va_list;
pub type initcall_t = ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>;
pub type exitcall_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type initcall_entry_t = initcall_t;
extern "C" {
    pub static mut __con_initcall_start: [initcall_entry_t; 0usize];
}
extern "C" {
    pub static mut __con_initcall_end: [initcall_entry_t; 0usize];
}
pub type ctor_fn_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn do_one_initcall(fn_: initcall_t) -> core::ffi::c_int;
}
extern "C" {
    pub static mut boot_command_line: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut saved_command_line: *mut core::ffi::c_char;
}
extern "C" {
    pub static mut reset_devices: core::ffi::c_uint;
}
extern "C" {
    pub fn setup_arch(arg1: *mut *mut core::ffi::c_char);
}
extern "C" {
    pub fn prepare_namespace();
}
extern "C" {
    pub fn init_rootfs();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_system_type {
    pub name: *const core::ffi::c_char,
    pub fs_flags: core::ffi::c_int,
    pub init_fs_context:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fs_context) -> core::ffi::c_int>,
    pub parameters: *const fs_parameter_spec,
    pub mount: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_system_type,
            arg2: core::ffi::c_int,
            arg3: *const core::ffi::c_char,
            arg4: *mut core::ffi::c_void,
        ) -> *mut dentry,
    >,
    pub kill_sb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub owner: *mut module,
    pub next: *mut file_system_type,
    pub fs_supers: hlist_head,
    pub s_lock_key: lock_class_key,
    pub s_umount_key: lock_class_key,
    pub s_vfs_rename_key: lock_class_key,
    pub s_writers_key: [lock_class_key; 3usize],
    pub i_lock_key: lock_class_key,
    pub i_mutex_key: lock_class_key,
    pub invalidate_lock_key: lock_class_key,
    pub i_mutex_dir_key: lock_class_key,
}
impl Default for file_system_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut rootfs_fs_type: file_system_type;
}
extern "C" {
    pub static mut rodata_enabled: bool_;
}
extern "C" {
    pub fn mark_rodata_ro();
}
extern "C" {
    pub static mut late_time_init: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub static mut initcall_debug: bool_;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct module {
    pub state: module_state,
    pub list: list_head,
    pub name: [core::ffi::c_char; 56usize],
    pub mkobj: module_kobject,
    pub modinfo_attrs: *mut module_attribute,
    pub version: *const core::ffi::c_char,
    pub srcversion: *const core::ffi::c_char,
    pub holders_dir: *mut kobject,
    pub syms: *const kernel_symbol,
    pub crcs: *const s32,
    pub num_syms: core::ffi::c_uint,
    pub param_lock: mutex,
    pub kp: *mut kernel_param,
    pub num_kp: core::ffi::c_uint,
    pub num_gpl_syms: core::ffi::c_uint,
    pub gpl_syms: *const kernel_symbol,
    pub gpl_crcs: *const s32,
    pub using_gplonly_symbols: bool_,
    pub async_probe_requested: bool_,
    pub num_exentries: core::ffi::c_uint,
    pub extable: *mut exception_table_entry,
    pub init: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub __bindgen_padding_0: [u64; 4usize],
    pub core_layout: module_layout,
    pub init_layout: module_layout,
    pub arch: mod_arch_specific,
    pub taints: core::ffi::c_ulong,
    pub num_bugs: core::ffi::c_uint,
    pub bug_list: list_head,
    pub bug_table: *mut bug_entry,
    pub kallsyms: *mut mod_kallsyms,
    pub core_kallsyms: mod_kallsyms,
    pub sect_attrs: *mut module_sect_attrs,
    pub notes_attrs: *mut module_notes_attrs,
    pub args: *mut core::ffi::c_char,
    pub percpu: *mut core::ffi::c_void,
    pub percpu_size: core::ffi::c_uint,
    pub noinstr_text_start: *mut core::ffi::c_void,
    pub noinstr_text_size: core::ffi::c_uint,
    pub num_srcu_structs: core::ffi::c_uint,
    pub srcu_struct_ptrs: *mut *mut srcu_struct,
    pub jump_entries: *mut jump_entry,
    pub num_jump_entries: core::ffi::c_uint,
    pub source_list: list_head,
    pub target_list: list_head,
    pub exit: ::core::option::Option<unsafe extern "C" fn()>,
    pub refcnt: atomic_t,
    pub ctors: *mut ctor_fn_t,
    pub num_ctors: core::ffi::c_uint,
}
impl Default for module {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut __this_module: module;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_symbol {
    pub value: core::ffi::c_ulong,
    pub name: *const core::ffi::c_char,
    pub namespace: *const core::ffi::c_char,
}
impl Default for kernel_symbol {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type arch_spinlock_t = atomic_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qrwlock {
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1,
    pub wait_lock: arch_spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qrwlock__bindgen_ty_1 {
    pub cnts: atomic_t,
    pub __bindgen_anon_1: qrwlock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qrwlock__bindgen_ty_1__bindgen_ty_1 {
    pub wlocked: u8_,
    pub __lstate: [u8_; 3usize],
}
impl Default for qrwlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for qrwlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type arch_rwlock_t = qrwlock;
pub const lockdep_wait_type_LD_WAIT_INV: lockdep_wait_type = 0;
pub const lockdep_wait_type_LD_WAIT_FREE: lockdep_wait_type = 1;
pub const lockdep_wait_type_LD_WAIT_SPIN: lockdep_wait_type = 2;
pub const lockdep_wait_type_LD_WAIT_CONFIG: lockdep_wait_type = 2;
pub const lockdep_wait_type_LD_WAIT_SLEEP: lockdep_wait_type = 3;
pub const lockdep_wait_type_LD_WAIT_MAX: lockdep_wait_type = 4;
pub type lockdep_wait_type = core::ffi::c_uint;
pub const lockdep_lock_type_LD_LOCK_NORMAL: lockdep_lock_type = 0;
pub const lockdep_lock_type_LD_LOCK_PERCPU: lockdep_lock_type = 1;
pub const lockdep_lock_type_LD_LOCK_MAX: lockdep_lock_type = 2;
pub type lockdep_lock_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lock_class_key {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lockdep_map {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pin_cookie {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_spinlock {
    pub raw_lock: arch_spinlock_t,
    pub magic: core::ffi::c_uint,
    pub owner_cpu: core::ffi::c_uint,
    pub owner: *mut core::ffi::c_void,
}
impl Default for raw_spinlock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type raw_spinlock_t = raw_spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ratelimit_state {
    pub lock: raw_spinlock_t,
    pub interval: core::ffi::c_int,
    pub burst: core::ffi::c_int,
    pub printed: core::ffi::c_int,
    pub missed: core::ffi::c_int,
    pub begin: core::ffi::c_ulong,
    pub flags: core::ffi::c_ulong,
}
impl Default for ratelimit_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ___ratelimit(
        rs: *mut ratelimit_state,
        func: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut linux_banner: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut linux_proc_banner: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut oops_in_progress: core::ffi::c_int;
}
extern "C" {
    pub static mut console_printk: [core::ffi::c_int; 0usize];
}
extern "C" {
    pub fn console_verbose();
}
extern "C" {
    pub static mut devkmsg_log_str: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut suppress_printk: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct va_format {
    pub fmt: *const core::ffi::c_char,
    pub va: *mut va_list,
}
impl Default for va_format {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn vprintk_emit(
        facility: core::ffi::c_int,
        level: core::ffi::c_int,
        dev_info: *const dev_printk_info,
        fmt: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vprintk(fmt: *const core::ffi::c_char, args: va_list) -> core::ffi::c_int;
}
extern "C" {
    pub fn _printk(fmt: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    pub fn _printk_deferred(fmt: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    pub fn __printk_safe_enter();
}
extern "C" {
    pub fn __printk_safe_exit();
}
extern "C" {
    pub fn __printk_ratelimit(func: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn printk_timed_ratelimit(
        caller_jiffies: *mut core::ffi::c_ulong,
        interval_msec: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub static mut printk_delay_msec: core::ffi::c_int;
}
extern "C" {
    pub static mut dmesg_restrict: core::ffi::c_int;
}
extern "C" {
    pub fn wake_up_klogd();
}
extern "C" {
    pub fn log_buf_addr_get() -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn log_buf_len_get() -> u32_;
}
extern "C" {
    pub fn log_buf_vmcoreinfo_setup();
}
extern "C" {
    pub fn setup_log_buf(early: core::ffi::c_int);
}
extern "C" {
    pub fn dump_stack_set_arch_desc(fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn dump_stack_print_info(log_lvl: *const core::ffi::c_char);
}
extern "C" {
    pub fn show_regs_print_info(log_lvl: *const core::ffi::c_char);
}
extern "C" {
    pub fn dump_stack_lvl(log_lvl: *const core::ffi::c_char);
}
extern "C" {
    pub fn dump_stack();
}
extern "C" {
    pub fn printk_trigger_flush();
}
extern "C" {
    pub fn __printk_cpu_sync_try_get() -> core::ffi::c_int;
}
extern "C" {
    pub fn __printk_cpu_sync_wait();
}
extern "C" {
    pub fn __printk_cpu_sync_put();
}
extern "C" {
    pub static mut kptr_restrict: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_operations {
    pub owner: *mut module,
    pub llseek: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: loff_t, arg3: core::ffi::c_int) -> loff_t,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut core::ffi::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *const core::ffi::c_char,
            arg3: usize,
            arg4: *mut loff_t,
        ) -> isize,
    >,
    pub read_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub write_iter: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize,
    >,
    pub iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            kiocb: *mut kiocb,
            arg1: *mut io_comp_batch,
            flags: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub iterate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> core::ffi::c_int,
    >,
    pub iterate_shared: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut dir_context) -> core::ffi::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut poll_table_struct) -> __poll_t,
    >,
    pub unlocked_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_uint,
            arg3: core::ffi::c_ulong,
        ) -> core::ffi::c_long,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_uint,
            arg3: core::ffi::c_ulong,
        ) -> core::ffi::c_long,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut vm_area_struct) -> core::ffi::c_int,
    >,
    pub mmap_supported_flags: core::ffi::c_ulong,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int,
    >,
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, id: fl_owner_t) -> core::ffi::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int,
    >,
    pub fsync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            datasync: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub fasync: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: core::ffi::c_int,
            arg2: *mut file,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub lock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_int,
            arg3: *mut file_lock,
        ) -> core::ffi::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut page,
            arg3: core::ffi::c_int,
            arg4: usize,
            arg5: *mut loff_t,
            arg6: core::ffi::c_int,
        ) -> isize,
    >,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_ulong,
            arg3: core::ffi::c_ulong,
            arg4: core::ffi::c_ulong,
            arg5: core::ffi::c_ulong,
        ) -> core::ffi::c_ulong,
    >,
    pub check_flags:
        ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int) -> core::ffi::c_int>,
    pub flock: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_int,
            arg3: *mut file_lock,
        ) -> core::ffi::c_int,
    >,
    pub splice_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut file,
            arg3: *mut loff_t,
            arg4: usize,
            arg5: core::ffi::c_uint,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut loff_t,
            arg3: *mut pipe_inode_info,
            arg4: usize,
            arg5: core::ffi::c_uint,
        ) -> isize,
    >,
    pub setlease: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: core::ffi::c_long,
            arg3: *mut *mut file_lock,
            arg4: *mut *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub fallocate: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            mode: core::ffi::c_int,
            offset: loff_t,
            len: loff_t,
        ) -> core::ffi::c_long,
    >,
    pub show_fdinfo: ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, f: *mut file)>,
    pub copy_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: *mut file,
            arg4: loff_t,
            arg5: usize,
            arg6: core::ffi::c_uint,
        ) -> isize,
    >,
    pub remap_file_range: ::core::option::Option<
        unsafe extern "C" fn(
            file_in: *mut file,
            pos_in: loff_t,
            file_out: *mut file,
            pos_out: loff_t,
            len: loff_t,
            remap_flags: core::ffi::c_uint,
        ) -> loff_t,
    >,
    pub fadvise: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: loff_t,
            arg3: loff_t,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub uring_cmd: ::core::option::Option<
        unsafe extern "C" fn(
            ioucmd: *mut io_uring_cmd,
            issue_flags: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub uring_cmd_iopoll: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut io_uring_cmd,
            arg2: *mut io_comp_batch,
            poll_flags: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
}
impl Default for file_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static kmsg_fops: file_operations;
}
pub const DUMP_PREFIX_NONE: core::ffi::c_uint = 0;
pub const DUMP_PREFIX_ADDRESS: core::ffi::c_uint = 1;
pub const DUMP_PREFIX_OFFSET: core::ffi::c_uint = 2;
pub type _bindgen_ty_2 = core::ffi::c_uint;
extern "C" {
    pub fn hex_dump_to_buffer(
        buf: *const core::ffi::c_void,
        len: usize,
        rowsize: core::ffi::c_int,
        groupsize: core::ffi::c_int,
        linebuf: *mut core::ffi::c_char,
        linebuflen: usize,
        ascii: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn print_hex_dump(
        level: *const core::ffi::c_char,
        prefix_str: *const core::ffi::c_char,
        prefix_type: core::ffi::c_int,
        rowsize: core::ffi::c_int,
        groupsize: core::ffi::c_int,
        buf: *const core::ffi::c_void,
        len: usize,
        ascii: bool_,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct string_stream {
    _unused: [u8; 0],
}
pub const kunit_assert_type_KUNIT_ASSERTION: kunit_assert_type = 0;
pub const kunit_assert_type_KUNIT_EXPECTATION: kunit_assert_type = 1;
pub type kunit_assert_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_loc {
    pub line: core::ffi::c_int,
    pub file: *const core::ffi::c_char,
}
impl Default for kunit_loc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kunit_assert {}
pub type assert_format_t = ::core::option::Option<
    unsafe extern "C" fn(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    ),
>;
extern "C" {
    pub fn kunit_assert_prologue(
        loc: *const kunit_loc,
        type_: kunit_assert_type,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kunit_fail_assert {
    pub assert: kunit_assert,
}
extern "C" {
    pub fn kunit_fail_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_unary_assert {
    pub assert: kunit_assert,
    pub condition: *const core::ffi::c_char,
    pub expected_true: bool_,
}
impl Default for kunit_unary_assert {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kunit_unary_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_ptr_not_err_assert {
    pub assert: kunit_assert,
    pub text: *const core::ffi::c_char,
    pub value: *const core::ffi::c_void,
}
impl Default for kunit_ptr_not_err_assert {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kunit_ptr_not_err_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_assert_text {
    pub operation: *const core::ffi::c_char,
    pub left_text: *const core::ffi::c_char,
    pub right_text: *const core::ffi::c_char,
}
impl Default for kunit_binary_assert_text {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_assert {
    pub assert: kunit_assert,
    pub text: *const kunit_binary_assert_text,
    pub left_value: core::ffi::c_longlong,
    pub right_value: core::ffi::c_longlong,
}
impl Default for kunit_binary_assert {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kunit_binary_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_ptr_assert {
    pub assert: kunit_assert,
    pub text: *const kunit_binary_assert_text,
    pub left_value: *const core::ffi::c_void,
    pub right_value: *const core::ffi::c_void,
}
impl Default for kunit_binary_ptr_assert {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kunit_binary_ptr_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_binary_str_assert {
    pub assert: kunit_assert,
    pub text: *const kunit_binary_assert_text,
    pub left_value: *const core::ffi::c_char,
    pub right_value: *const core::ffi::c_char,
}
impl Default for kunit_binary_str_assert {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kunit_binary_str_assert_format(
        assert: *const kunit_assert,
        message: *const va_format,
        stream: *mut string_stream,
    );
}
pub type kunit_try_catch_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>;
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct kunit_try_catch {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
extern "C" {
    pub fn kunit_try_catch_run(try_catch: *mut kunit_try_catch, context: *mut core::ffi::c_void);
}
extern "C" {
    pub fn kunit_try_catch_throw(try_catch: *mut kunit_try_catch);
}
extern "C" {
    pub fn __list_add_valid(
        new: *mut list_head,
        prev: *mut list_head,
        next: *mut list_head,
    ) -> bool_;
}
extern "C" {
    pub fn __list_del_entry_valid(entry: *mut list_head) -> bool_;
}
pub type bug_insn_t = u32_;
extern "C" {
    pub static mut panic_blink:
        ::core::option::Option<unsafe extern "C" fn(state: core::ffi::c_int) -> core::ffi::c_long>;
}
extern "C" {
    pub fn panic(fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn nmi_panic(regs: *mut pt_regs, msg: *const core::ffi::c_char);
}
extern "C" {
    pub fn oops_enter();
}
extern "C" {
    pub fn oops_exit();
}
extern "C" {
    pub fn oops_may_print() -> bool_;
}
extern "C" {
    pub static mut panic_timeout: core::ffi::c_int;
}
extern "C" {
    pub static mut panic_print: core::ffi::c_ulong;
}
extern "C" {
    pub static mut panic_on_oops: core::ffi::c_int;
}
extern "C" {
    pub static mut panic_on_unrecovered_nmi: core::ffi::c_int;
}
extern "C" {
    pub static mut panic_on_io_nmi: core::ffi::c_int;
}
extern "C" {
    pub static mut panic_on_warn: core::ffi::c_int;
}
extern "C" {
    pub static mut panic_on_taint: core::ffi::c_ulong;
}
extern "C" {
    pub static mut panic_on_taint_nousertaint: bool_;
}
extern "C" {
    pub static mut sysctl_panic_on_rcu_stall: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_max_rcu_stall_to_panic: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_panic_on_stackoverflow: core::ffi::c_int;
}
extern "C" {
    pub static mut crash_kexec_post_notifiers: bool_;
}
extern "C" {
    pub static mut panic_cpu: atomic_t;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct taint_flag {
    pub c_true: core::ffi::c_char,
    pub c_false: core::ffi::c_char,
    pub module: bool_,
}
extern "C" {
    pub static taint_flags: [taint_flag; 19usize];
}
pub const lockdep_ok_LOCKDEP_STILL_OK: lockdep_ok = 0;
pub const lockdep_ok_LOCKDEP_NOW_UNRELIABLE: lockdep_ok = 1;
pub type lockdep_ok = core::ffi::c_uint;
extern "C" {
    pub fn print_tainted() -> *const core::ffi::c_char;
}
extern "C" {
    pub fn add_taint(flag: core::ffi::c_uint, arg1: lockdep_ok);
}
extern "C" {
    pub fn test_taint(flag: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_taint() -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct warn_args {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __warn(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        caller: *mut core::ffi::c_void,
        taint: core::ffi::c_uint,
        regs: *mut pt_regs,
        args: *mut warn_args,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bug_entry {
    pub bug_addr_disp: core::ffi::c_int,
    pub file_disp: core::ffi::c_int,
    pub line: core::ffi::c_ushort,
    pub flags: core::ffi::c_ushort,
}
extern "C" {
    pub fn __warn_printk(fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn __show_regs(regs: *mut pt_regs);
}
extern "C" {
    pub fn die(regs: *mut pt_regs, str_: *const core::ffi::c_char);
}
extern "C" {
    pub fn do_trap(
        regs: *mut pt_regs,
        signo: core::ffi::c_int,
        code: core::ffi::c_int,
        addr: core::ffi::c_ulong,
    );
}
pub const bug_trap_type_BUG_TRAP_TYPE_NONE: bug_trap_type = 0;
pub const bug_trap_type_BUG_TRAP_TYPE_WARN: bug_trap_type = 1;
pub const bug_trap_type_BUG_TRAP_TYPE_BUG: bug_trap_type = 2;
pub type bug_trap_type = core::ffi::c_uint;
extern "C" {
    pub fn bug_get_file_line(
        bug: *mut bug_entry,
        file: *mut *const core::ffi::c_char,
        line: *mut core::ffi::c_uint,
    );
}
extern "C" {
    pub fn find_bug(bugaddr: core::ffi::c_ulong) -> *mut bug_entry;
}
extern "C" {
    pub fn report_bug(bug_addr: core::ffi::c_ulong, regs: *mut pt_regs) -> bug_trap_type;
}
extern "C" {
    pub fn is_valid_bugaddr(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_bug_clear_once();
}
#[repr(C)]
#[derive(Default)]
pub struct sysinfo {
    pub uptime: __kernel_long_t,
    pub loads: [__kernel_ulong_t; 3usize],
    pub totalram: __kernel_ulong_t,
    pub freeram: __kernel_ulong_t,
    pub sharedram: __kernel_ulong_t,
    pub bufferram: __kernel_ulong_t,
    pub totalswap: __kernel_ulong_t,
    pub freeswap: __kernel_ulong_t,
    pub procs: __u16,
    pub pad: __u16,
    pub totalhigh: __kernel_ulong_t,
    pub freehigh: __kernel_ulong_t,
    pub mem_unit: __u32,
    pub _f: __IncompleteArrayField<core::ffi::c_char>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct s16_fract {
    pub numerator: __s16,
    pub denominator: __s16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u16_fract {
    pub numerator: __u16,
    pub denominator: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct s32_fract {
    pub numerator: __s32,
    pub denominator: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u32_fract {
    pub numerator: __u32,
    pub denominator: __u32,
}
extern "C" {
    pub fn int_pow(base: u64_, exp: core::ffi::c_uint) -> u64_;
}
extern "C" {
    pub fn int_sqrt(arg1: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn iter_div_u64_rem(dividend: u64_, divisor: u32_, remainder: *mut u64_) -> u32_;
}
extern "C" {
    pub fn mul_u64_u64_div_u64(a: u64_, mul: u64_, div: u64_) -> u64_;
}
pub type time64_t = __s64;
pub type timeu64_t = __u64;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_timespec {
    pub tv_sec: __kernel_time64_t,
    pub tv_nsec: core::ffi::c_longlong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_itimerspec {
    pub it_interval: __kernel_timespec,
    pub it_value: __kernel_timespec,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_old_timeval {
    pub tv_sec: __kernel_long_t,
    pub tv_usec: __kernel_long_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_old_timespec {
    pub tv_sec: __kernel_old_time_t,
    pub tv_nsec: core::ffi::c_long,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_old_itimerval {
    pub it_interval: __kernel_old_timeval,
    pub it_value: __kernel_old_timeval,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_sock_timeval {
    pub tv_sec: __s64,
    pub tv_usec: __s64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: core::ffi::c_int,
    pub tz_dsttime: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: time64_t,
    pub tv_nsec: core::ffi::c_long,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct itimerspec64 {
    pub it_interval: timespec64,
    pub it_value: timespec64,
}
extern "C" {
    pub fn set_normalized_timespec64(ts: *mut timespec64, sec: time64_t, nsec: s64);
}
extern "C" {
    pub fn ns_to_timespec64(nsec: s64) -> timespec64;
}
extern "C" {
    pub fn timespec64_add_safe(lhs: timespec64, rhs: timespec64) -> timespec64;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    _unused: [u8; 0],
}
pub const timespec_type_TT_NONE: timespec_type = 0;
pub const timespec_type_TT_NATIVE: timespec_type = 1;
pub const timespec_type_TT_COMPAT: timespec_type = 2;
pub type timespec_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block {
    pub arch_data: core::ffi::c_ulong,
    pub fn_:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut restart_block) -> core::ffi::c_long>,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1 {
    pub futex: restart_block__bindgen_ty_1__bindgen_ty_1,
    pub nanosleep: restart_block__bindgen_ty_1__bindgen_ty_2,
    pub poll: restart_block__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_1 {
    pub uaddr: *mut u32_,
    pub val: u32_,
    pub flags: u32_,
    pub bitset: u32_,
    pub time: u64_,
    pub uaddr2: *mut u32_,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_2 {
    pub clockid: clockid_t,
    pub type_: timespec_type,
    pub __bindgen_anon_1: restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub expires: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub rmtp: *mut __kernel_timespec,
    pub compat_rmtp: *mut old_timespec32,
    _bindgen_union_align: u64,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct restart_block__bindgen_ty_1__bindgen_ty_3 {
    pub ufds: *mut pollfd,
    pub nfds: core::ffi::c_int,
    pub has_timeout: core::ffi::c_int,
    pub tv_sec: core::ffi::c_ulong,
    pub tv_nsec: core::ffi::c_ulong,
}
impl Default for restart_block__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for restart_block__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for restart_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn do_no_restart_syscall(parm: *mut restart_block) -> core::ffi::c_long;
}
extern "C" {
    #[link_name = "\u{1}tp"]
    pub static mut riscv_current_is_tp: *mut task_struct;
}
extern "C" {
    #[link_name = "\u{1}sp"]
    pub static mut current_stack_pointer: core::ffi::c_ulong;
}
extern "C" {
    pub fn __sw_hweight8(w: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __sw_hweight16(w: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __sw_hweight32(w: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __sw_hweight64(w: __u64) -> core::ffi::c_ulong;
}
extern "C" {
    pub static mut static_key_initialized: bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key {
    pub enabled: atomic_t,
    pub __bindgen_anon_1: static_key__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union static_key__bindgen_ty_1 {
    pub type_: core::ffi::c_ulong,
    pub entries: *mut jump_entry,
    pub next: *mut static_key_mod,
    _bindgen_union_align: u64,
}
impl Default for static_key__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for static_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct jump_entry {
    pub code: s32,
    pub target: s32,
    pub key: core::ffi::c_long,
}
pub const jump_label_type_JUMP_LABEL_NOP: jump_label_type = 0;
pub const jump_label_type_JUMP_LABEL_JMP: jump_label_type = 1;
pub type jump_label_type = core::ffi::c_uint;
extern "C" {
    pub static mut __start___jump_table: [jump_entry; 0usize];
}
extern "C" {
    pub static mut __stop___jump_table: [jump_entry; 0usize];
}
extern "C" {
    pub fn jump_label_init();
}
extern "C" {
    pub fn jump_label_lock();
}
extern "C" {
    pub fn jump_label_unlock();
}
extern "C" {
    pub fn arch_jump_label_transform(entry: *mut jump_entry, type_: jump_label_type);
}
extern "C" {
    pub fn arch_jump_label_transform_queue(entry: *mut jump_entry, type_: jump_label_type)
        -> bool_;
}
extern "C" {
    pub fn arch_jump_label_transform_apply();
}
extern "C" {
    pub fn jump_label_text_reserved(
        start: *mut core::ffi::c_void,
        end: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn static_key_slow_inc(key: *mut static_key);
}
extern "C" {
    pub fn static_key_slow_dec(key: *mut static_key);
}
extern "C" {
    pub fn static_key_slow_inc_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn static_key_slow_dec_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn static_key_count(key: *mut static_key) -> core::ffi::c_int;
}
extern "C" {
    pub fn static_key_enable(key: *mut static_key);
}
extern "C" {
    pub fn static_key_disable(key: *mut static_key);
}
extern "C" {
    pub fn static_key_enable_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn static_key_disable_cpuslocked(key: *mut static_key);
}
extern "C" {
    pub fn jump_label_init_type(entry: *mut jump_entry) -> jump_label_type;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_true {
    pub key: static_key,
}
impl Default for static_key_true {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_false {
    pub key: static_key,
}
impl Default for static_key_false {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ____wrong_branch_error() -> bool_;
}
pub const CAP_HWCAP: core::ffi::c_uint = 1;
pub type _bindgen_ty_3 = core::ffi::c_uint;
extern "C" {
    pub static mut elf_hwcap: core::ffi::c_ulong;
}
pub const riscv_isa_ext_id_RISCV_ISA_EXT_SSCOFPMF: riscv_isa_ext_id = 26;
pub const riscv_isa_ext_id_RISCV_ISA_EXT_SVPBMT: riscv_isa_ext_id = 27;
pub const riscv_isa_ext_id_RISCV_ISA_EXT_ZICBOM: riscv_isa_ext_id = 28;
pub const riscv_isa_ext_id_RISCV_ISA_EXT_ZIHINTPAUSE: riscv_isa_ext_id = 29;
pub const riscv_isa_ext_id_RISCV_ISA_EXT_SSTC: riscv_isa_ext_id = 30;
pub const riscv_isa_ext_id_RISCV_ISA_EXT_SVINVAL: riscv_isa_ext_id = 31;
pub const riscv_isa_ext_id_RISCV_ISA_EXT_ID_MAX: riscv_isa_ext_id = 64;
pub type riscv_isa_ext_id = core::ffi::c_uint;
pub const riscv_isa_ext_key_RISCV_ISA_EXT_KEY_FPU: riscv_isa_ext_key = 0;
pub const riscv_isa_ext_key_RISCV_ISA_EXT_KEY_ZIHINTPAUSE: riscv_isa_ext_key = 1;
pub const riscv_isa_ext_key_RISCV_ISA_EXT_KEY_SVINVAL: riscv_isa_ext_key = 2;
pub const riscv_isa_ext_key_RISCV_ISA_EXT_KEY_MAX: riscv_isa_ext_key = 3;
pub type riscv_isa_ext_key = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct riscv_isa_ext_data {
    pub uprop: [core::ffi::c_char; 32usize],
    pub isa_ext_id: core::ffi::c_uint,
}
extern "C" {
    pub static mut riscv_isa_ext_keys: [static_key_false; 3usize];
}
extern "C" {
    pub fn riscv_isa_extension_base(isa_bitmap: *const core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __riscv_isa_extension_available(
        isa_bitmap: *const core::ffi::c_ulong,
        bit: core::ffi::c_int,
    ) -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct user_regs_struct {
    pub pc: core::ffi::c_ulong,
    pub ra: core::ffi::c_ulong,
    pub sp: core::ffi::c_ulong,
    pub gp: core::ffi::c_ulong,
    pub tp: core::ffi::c_ulong,
    pub t0: core::ffi::c_ulong,
    pub t1: core::ffi::c_ulong,
    pub t2: core::ffi::c_ulong,
    pub s0: core::ffi::c_ulong,
    pub s1: core::ffi::c_ulong,
    pub a0: core::ffi::c_ulong,
    pub a1: core::ffi::c_ulong,
    pub a2: core::ffi::c_ulong,
    pub a3: core::ffi::c_ulong,
    pub a4: core::ffi::c_ulong,
    pub a5: core::ffi::c_ulong,
    pub a6: core::ffi::c_ulong,
    pub a7: core::ffi::c_ulong,
    pub s2: core::ffi::c_ulong,
    pub s3: core::ffi::c_ulong,
    pub s4: core::ffi::c_ulong,
    pub s5: core::ffi::c_ulong,
    pub s6: core::ffi::c_ulong,
    pub s7: core::ffi::c_ulong,
    pub s8: core::ffi::c_ulong,
    pub s9: core::ffi::c_ulong,
    pub s10: core::ffi::c_ulong,
    pub s11: core::ffi::c_ulong,
    pub t3: core::ffi::c_ulong,
    pub t4: core::ffi::c_ulong,
    pub t5: core::ffi::c_ulong,
    pub t6: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __riscv_f_ext_state {
    pub f: [__u32; 32usize],
    pub fcsr: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __riscv_d_ext_state {
    pub f: [__u64; 32usize],
    pub fcsr: __u32,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct __riscv_q_ext_state {
    pub f: [__u64; 64usize],
    pub fcsr: __u32,
    pub reserved: [__u32; 3usize],
}
impl Default for __riscv_q_ext_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union __riscv_fp_state {
    pub f: __riscv_f_ext_state,
    pub d: __riscv_d_ext_state,
    pub q: __riscv_q_ext_state,
    _bindgen_union_align: [u128; 33usize],
}
impl Default for __riscv_fp_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pt_regs {
    pub epc: core::ffi::c_ulong,
    pub ra: core::ffi::c_ulong,
    pub sp: core::ffi::c_ulong,
    pub gp: core::ffi::c_ulong,
    pub tp: core::ffi::c_ulong,
    pub t0: core::ffi::c_ulong,
    pub t1: core::ffi::c_ulong,
    pub t2: core::ffi::c_ulong,
    pub s0: core::ffi::c_ulong,
    pub s1: core::ffi::c_ulong,
    pub a0: core::ffi::c_ulong,
    pub a1: core::ffi::c_ulong,
    pub a2: core::ffi::c_ulong,
    pub a3: core::ffi::c_ulong,
    pub a4: core::ffi::c_ulong,
    pub a5: core::ffi::c_ulong,
    pub a6: core::ffi::c_ulong,
    pub a7: core::ffi::c_ulong,
    pub s2: core::ffi::c_ulong,
    pub s3: core::ffi::c_ulong,
    pub s4: core::ffi::c_ulong,
    pub s5: core::ffi::c_ulong,
    pub s6: core::ffi::c_ulong,
    pub s7: core::ffi::c_ulong,
    pub s8: core::ffi::c_ulong,
    pub s9: core::ffi::c_ulong,
    pub s10: core::ffi::c_ulong,
    pub s11: core::ffi::c_ulong,
    pub t3: core::ffi::c_ulong,
    pub t4: core::ffi::c_ulong,
    pub t5: core::ffi::c_ulong,
    pub t6: core::ffi::c_ulong,
    pub status: core::ffi::c_ulong,
    pub badaddr: core::ffi::c_ulong,
    pub cause: core::ffi::c_ulong,
    pub orig_a0: core::ffi::c_ulong,
}
extern "C" {
    pub fn regs_query_register_offset(name: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn regs_get_kernel_stack_nth(
        regs: *mut pt_regs,
        n: core::ffi::c_uint,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn prepare_ftrace_return(
        parent: *mut core::ffi::c_ulong,
        self_addr: core::ffi::c_ulong,
        frame_pointer: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn do_syscall_trace_enter(regs: *mut pt_regs) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_syscall_trace_exit(regs: *mut pt_regs);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct thread_struct {
    pub ra: core::ffi::c_ulong,
    pub sp: core::ffi::c_ulong,
    pub s: [core::ffi::c_ulong; 12usize],
    pub fstate: __riscv_d_ext_state,
    pub bad_cause: core::ffi::c_ulong,
}
extern "C" {
    pub fn start_thread(regs: *mut pt_regs, pc: core::ffi::c_ulong, sp: core::ffi::c_ulong);
}
extern "C" {
    pub fn __get_wchan(p: *mut task_struct) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn riscv_of_processor_hartid(
        node: *mut device_node,
        hartid: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn riscv_of_parent_hartid(
        node: *mut device_node,
        hartid: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn riscv_fill_hwcap();
}
extern "C" {
    pub fn arch_dup_task_struct(dst: *mut task_struct, src: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bad_size_call_parameter();
}
extern "C" {
    pub static mut __per_cpu_offset: [core::ffi::c_ulong; 64usize];
}
pub const BAD_STACK: core::ffi::c_int = -1;
pub const NOT_STACK: core::ffi::c_int = 0;
pub const GOOD_FRAME: core::ffi::c_int = 1;
pub const GOOD_STACK: core::ffi::c_int = 2;
pub type _bindgen_ty_4 = core::ffi::c_int;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pfn_t {
    pub val: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pgd_t {
    pub pgd: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pte_t {
    pub pte: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pgprot_t {
    pub pgprot: core::ffi::c_ulong,
}
pub type pgtable_t = *mut page;
extern "C" {
    pub static mut riscv_pfn_base: core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_mapping {
    pub page_offset: core::ffi::c_ulong,
    pub virt_addr: core::ffi::c_ulong,
    pub phys_addr: usize,
    pub size: usize,
    pub va_pa_offset: core::ffi::c_ulong,
    pub va_kernel_pa_offset: core::ffi::c_ulong,
    pub va_kernel_xip_pa_offset: core::ffi::c_ulong,
}
extern "C" {
    pub static mut kernel_map: kernel_mapping;
}
extern "C" {
    pub static mut phys_ram_base: phys_addr_t;
}
extern "C" {
    pub static mut shadow_stack: [core::ffi::c_long; 128usize];
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct thread_info {
    pub flags: core::ffi::c_ulong,
    pub preempt_count: core::ffi::c_int,
    pub kernel_sp: core::ffi::c_long,
    pub user_sp: core::ffi::c_long,
    pub cpu: core::ffi::c_int,
}
extern "C" {
    pub fn __bad_copy_from();
}
extern "C" {
    pub fn __bad_copy_to();
}
extern "C" {
    pub fn __copy_overflow(size: core::ffi::c_int, count: core::ffi::c_ulong);
}
extern "C" {
    pub fn migrate_disable();
}
extern "C" {
    pub fn migrate_enable();
}
extern "C" {
    pub fn _local_bh_enable();
}
extern "C" {
    pub fn __local_bh_enable_ip(ip: core::ffi::c_ulong, cnt: core::ffi::c_uint);
}
extern "C" {
    pub fn _kstrtoul(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn _kstrtol(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_long,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoull(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoll(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_longlong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtouint(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoint(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtou16(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtos16(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut s16,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtou8(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut u8_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtos8(
        s: *const core::ffi::c_char,
        base: core::ffi::c_uint,
        res: *mut s8,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtobool(s: *const core::ffi::c_char, res: *mut bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoull_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_ulonglong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoll_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_longlong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoul_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtol_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_long,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtouint_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtoint_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtou16_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtos16_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut s16,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtou8_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut u8_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtos8_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        base: core::ffi::c_uint,
        res: *mut s8,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrtobool_from_user(
        s: *const core::ffi::c_char,
        count: usize,
        res: *mut bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_strtoul(
        arg1: *const core::ffi::c_char,
        arg2: *mut *mut core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn simple_strtol(
        arg1: *const core::ffi::c_char,
        arg2: *mut *mut core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn simple_strtoull(
        arg1: *const core::ffi::c_char,
        arg2: *mut *mut core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_ulonglong;
}
extern "C" {
    pub fn simple_strtoll(
        arg1: *const core::ffi::c_char,
        arg2: *mut *mut core::ffi::c_char,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_longlong;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct static_call_site {
    pub addr: s32,
    pub key: s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_call_key {
    pub func: *mut core::ffi::c_void,
}
impl Default for static_call_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __might_resched(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        offsets: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __might_sleep(file: *const core::ffi::c_char, line: core::ffi::c_int);
}
extern "C" {
    pub fn __cant_sleep(
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        preempt_offset: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __cant_migrate(file: *const core::ffi::c_char, line: core::ffi::c_int);
}
extern "C" {
    pub fn __might_fault(file: *const core::ffi::c_char, line: core::ffi::c_int);
}
extern "C" {
    pub fn do_exit(error_code: core::ffi::c_long);
}
extern "C" {
    pub fn num_to_str(
        buf: *mut core::ffi::c_char,
        size: core::ffi::c_int,
        num: core::ffi::c_ulonglong,
        width: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sprintf(
        buf: *mut core::ffi::c_char,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vsprintf(
        buf: *mut core::ffi::c_char,
        arg1: *const core::ffi::c_char,
        arg2: __builtin_va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn snprintf(
        buf: *mut core::ffi::c_char,
        size: core::ffi::c_ulong,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vsnprintf(
        buf: *mut core::ffi::c_char,
        size: core::ffi::c_ulong,
        fmt: *const core::ffi::c_char,
        args: __builtin_va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn scnprintf(
        buf: *mut core::ffi::c_char,
        size: usize,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vscnprintf(
        buf: *mut core::ffi::c_char,
        size: usize,
        fmt: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kasprintf(gfp: gfp_t, fmt: *const core::ffi::c_char, ...) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kvasprintf(
        gfp: gfp_t,
        fmt: *const core::ffi::c_char,
        args: va_list,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kvasprintf_const(
        gfp: gfp_t,
        fmt: *const core::ffi::c_char,
        args: va_list,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn sscanf(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: __builtin_va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn no_hash_pointers_enable(str_: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_option(
        str_: *mut *mut core::ffi::c_char,
        pint: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_options(
        str_: *const core::ffi::c_char,
        nints: core::ffi::c_int,
        ints: *mut core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn memparse(
        ptr: *const core::ffi::c_char,
        retptr: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_ulonglong;
}
extern "C" {
    pub fn parse_option_str(
        str_: *const core::ffi::c_char,
        option: *const core::ffi::c_char,
    ) -> bool_;
}
extern "C" {
    pub fn next_arg(
        args: *mut core::ffi::c_char,
        param: *mut *mut core::ffi::c_char,
        val: *mut *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn core_kernel_text(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn __kernel_text_address(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_text_address(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn func_ptr_is_kernel_text(ptr: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn bust_spinlocks(yes: core::ffi::c_int);
}
extern "C" {
    pub static mut root_mountflags: core::ffi::c_int;
}
extern "C" {
    pub static mut early_boot_irqs_disabled: bool_;
}
pub const system_states_SYSTEM_BOOTING: system_states = 0;
pub const system_states_SYSTEM_SCHEDULING: system_states = 1;
pub const system_states_SYSTEM_FREEING_INITMEM: system_states = 2;
pub const system_states_SYSTEM_RUNNING: system_states = 3;
pub const system_states_SYSTEM_HALT: system_states = 4;
pub const system_states_SYSTEM_POWER_OFF: system_states = 5;
pub const system_states_SYSTEM_RESTART: system_states = 6;
pub const system_states_SYSTEM_SUSPEND: system_states = 7;
pub type system_states = core::ffi::c_uint;
extern "C" {
    pub static mut system_state: system_states;
}
extern "C" {
    pub static mut hex_asc: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut hex_asc_upper: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub fn hex_to_bin(ch: core::ffi::c_uchar) -> core::ffi::c_int;
}
extern "C" {
    pub fn hex2bin(dst: *mut u8_, src: *const core::ffi::c_char, count: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn bin2hex(
        dst: *mut core::ffi::c_char,
        src: *const core::ffi::c_void,
        count: usize,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn mac_pton(s: *const core::ffi::c_char, mac: *mut u8_) -> bool_;
}
pub const ftrace_dump_mode_DUMP_NONE: ftrace_dump_mode = 0;
pub const ftrace_dump_mode_DUMP_ALL: ftrace_dump_mode = 1;
pub const ftrace_dump_mode_DUMP_ORIG: ftrace_dump_mode = 2;
pub type ftrace_dump_mode = core::ffi::c_uint;
extern "C" {
    pub fn _find_next_bit(
        addr1: *const core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_next_and_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_next_andnot_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_next_zero_bit(
        addr: *const core::ffi::c_ulong,
        nbits: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_first_bit(
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __find_nth_bit(
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __find_nth_and_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __find_nth_andnot_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_first_and_bit(
        addr1: *const core::ffi::c_ulong,
        addr2: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_first_zero_bit(
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _find_last_bit(
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn find_next_clump8(
        clump: *mut core::ffi::c_ulong,
        addr: *const core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        offset: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn strndup_user(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_long,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn memdup_user(arg1: *const core::ffi::c_void, arg2: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmemdup_user(arg1: *const core::ffi::c_void, arg2: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memdup_user_nul(arg1: *const core::ffi::c_void, arg2: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __memset(
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __memcpy(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __memmove(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strscpy(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    pub fn strscpy_pad(
        dest: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn strcat(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strncat(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: __kernel_size_t,
    ) -> usize;
}
extern "C" {
    pub fn strcmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strncmp(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strcasecmp(
        s1: *const core::ffi::c_char,
        s2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strncasecmp(
        s1: *const core::ffi::c_char,
        s2: *const core::ffi::c_char,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn strchr(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int)
        -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strchrnul(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strnchrnul(
        arg1: *const core::ffi::c_char,
        arg2: usize,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strnchr(
        arg1: *const core::ffi::c_char,
        arg2: usize,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn skip_spaces(arg1: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strim(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strstr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: usize,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const core::ffi::c_char) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn strnlen(arg1: *const core::ffi::c_char, arg2: __kernel_size_t) -> __kernel_size_t;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn strcspn(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn memset16(arg1: *mut u16, arg2: u16, arg3: __kernel_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memset32(arg1: *mut u32, arg2: u32, arg3: __kernel_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memset64(arg1: *mut u64, arg2: u64, arg3: __kernel_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __memcat_p(
        a: *mut *mut core::ffi::c_void,
        b: *mut *mut core::ffi::c_void,
    ) -> *mut *mut core::ffi::c_void;
}
extern "C" {
    pub fn memscan(
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: __kernel_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memchr(
        arg1: *const core::ffi::c_void,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memchr_inv(
        s: *const core::ffi::c_void,
        c: core::ffi::c_int,
        n: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn strreplace(
        s: *mut core::ffi::c_char,
        old: core::ffi::c_char,
        new: core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kfree_const(x: *const core::ffi::c_void);
}
extern "C" {
    pub fn kstrdup(s: *const core::ffi::c_char, gfp: gfp_t) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kstrdup_const(s: *const core::ffi::c_char, gfp: gfp_t) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn kstrndup(s: *const core::ffi::c_char, len: usize, gfp: gfp_t) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kmemdup(src: *const core::ffi::c_void, len: usize, gfp: gfp_t)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmemdup_nul(
        s: *const core::ffi::c_char,
        len: usize,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn argv_split(
        gfp: gfp_t,
        str_: *const core::ffi::c_char,
        argcp: *mut core::ffi::c_int,
    ) -> *mut *mut core::ffi::c_char;
}
extern "C" {
    pub fn argv_free(argv: *mut *mut core::ffi::c_char);
}
extern "C" {
    pub fn sysfs_streq(s1: *const core::ffi::c_char, s2: *const core::ffi::c_char) -> bool_;
}
extern "C" {
    pub fn match_string(
        array: *const *const core::ffi::c_char,
        n: usize,
        string: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sysfs_match_string(
        array: *const *const core::ffi::c_char,
        n: usize,
        s: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vbin_printf(
        bin_buf: *mut u32_,
        size: usize,
        fmt: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bstr_printf(
        buf: *mut core::ffi::c_char,
        size: usize,
        fmt: *const core::ffi::c_char,
        bin_buf: *const u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bprintf(
        bin_buf: *mut u32_,
        size: usize,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memory_read_from_buffer(
        to: *mut core::ffi::c_void,
        count: usize,
        ppos: *mut loff_t,
        from: *const core::ffi::c_void,
        available: usize,
    ) -> isize;
}
extern "C" {
    pub fn ptr_to_hashval(
        ptr: *const core::ffi::c_void,
        hashval_out: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memweight(ptr: *const core::ffi::c_void, bytes: usize) -> usize;
}
extern "C" {
    pub fn memcpy_and_pad(
        dest: *mut core::ffi::c_void,
        dest_len: usize,
        src: *const core::ffi::c_void,
        count: usize,
        pad: core::ffi::c_int,
    );
}
extern "C" {
    pub fn bitmap_alloc(nbits: core::ffi::c_uint, flags: gfp_t) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn bitmap_zalloc(nbits: core::ffi::c_uint, flags: gfp_t) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn bitmap_alloc_node(
        nbits: core::ffi::c_uint,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn bitmap_zalloc_node(
        nbits: core::ffi::c_uint,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn bitmap_free(bitmap: *const core::ffi::c_ulong);
}
extern "C" {
    pub fn devm_bitmap_alloc(
        dev: *mut device,
        nbits: core::ffi::c_uint,
        flags: gfp_t,
    ) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn devm_bitmap_zalloc(
        dev: *mut device,
        nbits: core::ffi::c_uint,
        flags: gfp_t,
    ) -> *mut core::ffi::c_ulong;
}
extern "C" {
    pub fn __bitmap_equal(
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_or_equal(
        src1: *const core::ffi::c_ulong,
        src2: *const core::ffi::c_ulong,
        src3: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_complement(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_shift_right(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        shift: core::ffi::c_uint,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_shift_left(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        shift: core::ffi::c_uint,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bitmap_cut(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        first: core::ffi::c_uint,
        cut: core::ffi::c_uint,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_and(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_or(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_xor(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_andnot(
        dst: *mut core::ffi::c_ulong,
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_replace(
        dst: *mut core::ffi::c_ulong,
        old: *const core::ffi::c_ulong,
        new: *const core::ffi::c_ulong,
        mask: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn __bitmap_intersects(
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_subset(
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn __bitmap_weight(
        bitmap: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __bitmap_weight_and(
        bitmap1: *const core::ffi::c_ulong,
        bitmap2: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __bitmap_set(
        map: *mut core::ffi::c_ulong,
        start: core::ffi::c_uint,
        len: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __bitmap_clear(
        map: *mut core::ffi::c_ulong,
        start: core::ffi::c_uint,
        len: core::ffi::c_int,
    );
}
extern "C" {
    pub fn bitmap_find_next_zero_area_off(
        map: *mut core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
        nr: core::ffi::c_uint,
        align_mask: core::ffi::c_ulong,
        align_offset: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn bitmap_parse(
        buf: *const core::ffi::c_char,
        buflen: core::ffi::c_uint,
        dst: *mut core::ffi::c_ulong,
        nbits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_parse_user(
        ubuf: *const core::ffi::c_char,
        ulen: core::ffi::c_uint,
        dst: *mut core::ffi::c_ulong,
        nbits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_parselist(
        buf: *const core::ffi::c_char,
        maskp: *mut core::ffi::c_ulong,
        nmaskbits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_parselist_user(
        ubuf: *const core::ffi::c_char,
        ulen: core::ffi::c_uint,
        dst: *mut core::ffi::c_ulong,
        nbits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_remap(
        dst: *mut core::ffi::c_ulong,
        src: *const core::ffi::c_ulong,
        old: *const core::ffi::c_ulong,
        new: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bitmap_bitremap(
        oldbit: core::ffi::c_int,
        old: *const core::ffi::c_ulong,
        new: *const core::ffi::c_ulong,
        bits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_onto(
        dst: *mut core::ffi::c_ulong,
        orig: *const core::ffi::c_ulong,
        relmap: *const core::ffi::c_ulong,
        bits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bitmap_fold(
        dst: *mut core::ffi::c_ulong,
        orig: *const core::ffi::c_ulong,
        sz: core::ffi::c_uint,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bitmap_find_free_region(
        bitmap: *mut core::ffi::c_ulong,
        bits: core::ffi::c_uint,
        order: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_release_region(
        bitmap: *mut core::ffi::c_ulong,
        pos: core::ffi::c_uint,
        order: core::ffi::c_int,
    );
}
extern "C" {
    pub fn bitmap_allocate_region(
        bitmap: *mut core::ffi::c_ulong,
        pos: core::ffi::c_uint,
        order: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_print_to_pagebuf(
        list: bool_,
        buf: *mut core::ffi::c_char,
        maskp: *const core::ffi::c_ulong,
        nmaskbits: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_print_bitmask_to_buf(
        buf: *mut core::ffi::c_char,
        maskp: *const core::ffi::c_ulong,
        nmaskbits: core::ffi::c_int,
        off: loff_t,
        count: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_print_list_to_buf(
        buf: *mut core::ffi::c_char,
        maskp: *const core::ffi::c_ulong,
        nmaskbits: core::ffi::c_int,
        off: loff_t,
        count: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bitmap_from_arr32(
        bitmap: *mut core::ffi::c_ulong,
        buf: *const u32_,
        nbits: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bitmap_to_arr32(
        buf: *mut u32_,
        bitmap: *const core::ffi::c_ulong,
        nbits: core::ffi::c_uint,
    );
}
pub type atomic_long_t = atomic64_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpumask {
    pub bits: [core::ffi::c_ulong; 1usize],
}
pub type cpumask_t = cpumask;
extern "C" {
    pub static mut nr_cpu_ids: core::ffi::c_uint;
}
extern "C" {
    pub static mut __cpu_possible_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_online_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_present_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_active_mask: cpumask;
}
extern "C" {
    pub static mut __cpu_dying_mask: cpumask;
}
extern "C" {
    pub static mut __num_online_cpus: atomic_t;
}
extern "C" {
    pub static mut cpus_booted_once_mask: cpumask_t;
}
extern "C" {
    pub fn cpumask_local_spread(i: core::ffi::c_uint, node: core::ffi::c_int) -> core::ffi::c_uint;
}
extern "C" {
    pub fn cpumask_any_and_distribute(
        src1p: *const cpumask,
        src2p: *const cpumask,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn cpumask_any_distribute(srcp: *const cpumask) -> core::ffi::c_uint;
}
extern "C" {
    pub fn cpumask_next_wrap(
        n: core::ffi::c_int,
        mask: *const cpumask,
        start: core::ffi::c_int,
        wrap: bool_,
    ) -> core::ffi::c_uint;
}
pub type cpumask_var_t = [cpumask; 1usize];
extern "C" {
    pub static cpu_all_bits: [core::ffi::c_ulong; 1usize];
}
extern "C" {
    pub fn init_cpu_present(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_possible(src: *const cpumask);
}
extern "C" {
    pub fn init_cpu_online(src: *const cpumask);
}
extern "C" {
    pub fn set_cpu_online(cpu: core::ffi::c_uint, online: bool_);
}
extern "C" {
    pub static mut cpu_bit_bitmap: [[core::ffi::c_ulong; 1usize]; 65usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llist_head {
    pub first: *mut llist_node,
}
impl Default for llist_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct llist_node {
    pub next: *mut llist_node,
}
impl Default for llist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn llist_add_batch(
        new_first: *mut llist_node,
        new_last: *mut llist_node,
        head: *mut llist_head,
    ) -> bool_;
}
extern "C" {
    pub fn llist_del_first(head: *mut llist_head) -> *mut llist_node;
}
extern "C" {
    pub fn llist_reverse_order(head: *mut llist_node) -> *mut llist_node;
}
pub const CSD_FLAG_LOCK: core::ffi::c_uint = 1;
pub const IRQ_WORK_PENDING: core::ffi::c_uint = 1;
pub const IRQ_WORK_BUSY: core::ffi::c_uint = 2;
pub const IRQ_WORK_LAZY: core::ffi::c_uint = 4;
pub const IRQ_WORK_HARD_IRQ: core::ffi::c_uint = 8;
pub const IRQ_WORK_CLAIMED: core::ffi::c_uint = 3;
pub const CSD_TYPE_ASYNC: core::ffi::c_uint = 0;
pub const CSD_TYPE_SYNC: core::ffi::c_uint = 16;
pub const CSD_TYPE_IRQ_WORK: core::ffi::c_uint = 32;
pub const CSD_TYPE_TTWU: core::ffi::c_uint = 48;
pub const CSD_FLAG_TYPE_MASK: core::ffi::c_uint = 240;
pub type _bindgen_ty_5 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_node {
    pub llist: llist_node,
    pub __bindgen_anon_1: __call_single_node__bindgen_ty_1,
    pub src: u16_,
    pub dst: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __call_single_node__bindgen_ty_1 {
    pub u_flags: core::ffi::c_uint,
    pub a_flags: atomic_t,
    _bindgen_union_align: u32,
}
impl Default for __call_single_node__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for __call_single_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type smp_call_func_t =
    ::core::option::Option<unsafe extern "C" fn(info: *mut core::ffi::c_void)>;
pub type smp_cond_func_t = ::core::option::Option<
    unsafe extern "C" fn(cpu: core::ffi::c_int, info: *mut core::ffi::c_void) -> bool_,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __call_single_data {
    pub node: __call_single_node,
    pub func: smp_call_func_t,
    pub info: *mut core::ffi::c_void,
}
impl Default for __call_single_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type call_single_data_t = __call_single_data;
extern "C" {
    pub fn __smp_call_single_queue(cpu: core::ffi::c_int, node: *mut llist_node);
}
extern "C" {
    pub static mut total_cpus: core::ffi::c_uint;
}
extern "C" {
    pub fn smp_call_function_single(
        cpuid: core::ffi::c_int,
        func: smp_call_func_t,
        info: *mut core::ffi::c_void,
        wait: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn on_each_cpu_cond_mask(
        cond_func: smp_cond_func_t,
        func: smp_call_func_t,
        info: *mut core::ffi::c_void,
        wait: bool_,
        mask: *const cpumask,
    );
}
extern "C" {
    pub fn smp_call_function_single_async(
        cpu: core::ffi::c_int,
        csd: *mut __call_single_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn panic_smp_self_stop();
}
extern "C" {
    pub fn nmi_panic_self_stop(regs: *mut pt_regs);
}
extern "C" {
    pub fn crash_smp_send_stop();
}
pub const irqreturn_IRQ_NONE: irqreturn = 0;
pub const irqreturn_IRQ_HANDLED: irqreturn = 1;
pub const irqreturn_IRQ_WAKE_THREAD: irqreturn = 2;
pub type irqreturn = core::ffi::c_uint;
pub use self::irqreturn as irqreturn_t;
extern "C" {
    pub static mut boot_cpu_hartid: core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct riscv_ipi_ops {
    pub ipi_inject: ::core::option::Option<unsafe extern "C" fn(target: *const cpumask)>,
    pub ipi_clear: ::core::option::Option<unsafe extern "C" fn()>,
}
extern "C" {
    pub static mut __cpuid_to_hartid_map: [core::ffi::c_ulong; 64usize];
}
extern "C" {
    pub fn show_ipi_stats(p: *mut seq_file, prec: core::ffi::c_int);
}
extern "C" {
    pub fn setup_smp();
}
extern "C" {
    pub fn handle_IPI(regs: *mut pt_regs);
}
extern "C" {
    pub fn arch_send_call_function_ipi_mask(mask: *mut cpumask);
}
extern "C" {
    pub fn arch_send_call_function_single_ipi(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn riscv_hartid_to_cpuid(hartid: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn riscv_set_ipi_ops(ops: *const riscv_ipi_ops);
}
extern "C" {
    pub fn riscv_clear_ipi();
}
extern "C" {
    pub fn smp_callin();
}
extern "C" {
    pub fn __cpu_disable() -> core::ffi::c_int;
}
extern "C" {
    pub fn __cpu_die(cpu: core::ffi::c_uint);
}
extern "C" {
    pub fn cpu_has_hotplug(cpu: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn smp_send_stop();
}
extern "C" {
    pub fn smp_send_reschedule(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn smp_prepare_cpus(max_cpus: core::ffi::c_uint);
}
extern "C" {
    pub fn __cpu_up(cpunum: core::ffi::c_uint, tidle: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn smp_cpus_done(max_cpus: core::ffi::c_uint);
}
extern "C" {
    pub fn smp_call_function(
        func: smp_call_func_t,
        info: *mut core::ffi::c_void,
        wait: core::ffi::c_int,
    );
}
extern "C" {
    pub fn smp_call_function_many(
        mask: *const cpumask,
        func: smp_call_func_t,
        info: *mut core::ffi::c_void,
        wait: bool_,
    );
}
extern "C" {
    pub fn smp_call_function_any(
        mask: *const cpumask,
        func: smp_call_func_t,
        info: *mut core::ffi::c_void,
        wait: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kick_all_cpus_sync();
}
extern "C" {
    pub fn wake_up_all_idle_cpus();
}
extern "C" {
    pub fn call_function_init();
}
extern "C" {
    pub fn generic_smp_call_function_single_interrupt();
}
extern "C" {
    pub fn smp_prepare_boot_cpu();
}
extern "C" {
    pub static mut setup_max_cpus: core::ffi::c_uint;
}
extern "C" {
    pub fn setup_nr_cpu_ids();
}
extern "C" {
    pub fn smp_init();
}
extern "C" {
    pub static mut __boot_cpu_id: core::ffi::c_int;
}
extern "C" {
    pub fn arch_disable_smp_support();
}
extern "C" {
    pub fn arch_thaw_secondary_cpus_begin();
}
extern "C" {
    pub fn arch_thaw_secondary_cpus_end();
}
extern "C" {
    pub fn smp_setup_processor_id();
}
extern "C" {
    pub fn smp_call_on_cpu(
        cpu: core::ffi::c_uint,
        func: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
        par: *mut core::ffi::c_void,
        phys: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn smpcfd_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn smpcfd_dead_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn smpcfd_dying_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn lock_is_held(arg1: *const core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn lockdep_is_held(arg1: *const core::ffi::c_void) -> core::ffi::c_int;
}
pub const xhlock_context_t_XHLOCK_HARD: xhlock_context_t = 0;
pub const xhlock_context_t_XHLOCK_SOFT: xhlock_context_t = 1;
pub const xhlock_context_t_XHLOCK_CTX_NR: xhlock_context_t = 2;
pub type xhlock_context_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mmiowb_state {
    pub nesting_count: u16_,
    pub mmiowb_pending: u16_,
}
extern "C" {
    pub static mut __mmiowb_state: mmiowb_state;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct spinlock {
    pub _bindgen_opaque_blob: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spinlock__bindgen_ty_1 {
    pub rlock: raw_spinlock,
    _bindgen_union_align: [u64; 3usize],
}
impl Default for spinlock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type spinlock_t = spinlock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rwlock_t {
    pub raw_lock: arch_rwlock_t,
    pub magic: core::ffi::c_uint,
    pub owner_cpu: core::ffi::c_uint,
    pub owner: *mut core::ffi::c_void,
}
impl Default for rwlock_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn queued_read_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn queued_write_lock_slowpath(lock: *mut qrwlock);
}
extern "C" {
    pub fn __raw_spin_lock_init(
        lock: *mut raw_spinlock_t,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
        inner: core::ffi::c_short,
    );
}
extern "C" {
    pub fn do_raw_spin_lock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn do_raw_spin_trylock(lock: *mut raw_spinlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_raw_spin_unlock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn __rwlock_init(
        lock: *mut rwlock_t,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn do_raw_read_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn do_raw_read_trylock(lock: *mut rwlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_raw_read_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn do_raw_write_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn do_raw_write_trylock(lock: *mut rwlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_raw_write_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn in_lock_functions(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn _raw_spin_lock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_nested(lock: *mut raw_spinlock_t, subclass: core::ffi::c_int);
}
extern "C" {
    pub fn _raw_spin_lock_nest_lock(lock: *mut raw_spinlock_t, map: *mut lockdep_map);
}
extern "C" {
    pub fn _raw_spin_lock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_lock_irqsave(lock: *mut raw_spinlock_t) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _raw_spin_lock_irqsave_nested(
        lock: *mut raw_spinlock_t,
        subclass: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _raw_spin_trylock(lock: *mut raw_spinlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn _raw_spin_trylock_bh(lock: *mut raw_spinlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn _raw_spin_unlock(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_bh(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irq(lock: *mut raw_spinlock_t);
}
extern "C" {
    pub fn _raw_spin_unlock_irqrestore(lock: *mut raw_spinlock_t, flags: core::ffi::c_ulong);
}
extern "C" {
    pub fn _raw_read_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_nested(lock: *mut rwlock_t, subclass: core::ffi::c_int);
}
extern "C" {
    pub fn _raw_read_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_lock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_lock_irqsave(lock: *mut rwlock_t) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _raw_write_lock_irqsave(lock: *mut rwlock_t) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _raw_read_trylock(lock: *mut rwlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn _raw_write_trylock(lock: *mut rwlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn _raw_read_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_bh(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_write_unlock_irq(lock: *mut rwlock_t);
}
extern "C" {
    pub fn _raw_read_unlock_irqrestore(lock: *mut rwlock_t, flags: core::ffi::c_ulong);
}
extern "C" {
    pub fn _raw_write_unlock_irqrestore(lock: *mut rwlock_t, flags: core::ffi::c_ulong);
}
extern "C" {
    pub fn _atomic_dec_and_lock(atomic: *mut atomic_t, lock: *mut spinlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn _atomic_dec_and_lock_irqsave(
        atomic: *mut atomic_t,
        lock: *mut spinlock_t,
        flags: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __alloc_bucket_spinlocks(
        locks: *mut *mut spinlock_t,
        lock_mask: *mut core::ffi::c_uint,
        max_size: usize,
        cpu_mult: core::ffi::c_uint,
        gfp: gfp_t,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn free_bucket_spinlocks(locks: *mut spinlock_t);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct refcount_struct {
    pub refs: atomic_t,
}
pub type refcount_t = refcount_struct;
pub const refcount_saturation_type_REFCOUNT_ADD_NOT_ZERO_OVF: refcount_saturation_type = 0;
pub const refcount_saturation_type_REFCOUNT_ADD_OVF: refcount_saturation_type = 1;
pub const refcount_saturation_type_REFCOUNT_ADD_UAF: refcount_saturation_type = 2;
pub const refcount_saturation_type_REFCOUNT_SUB_UAF: refcount_saturation_type = 3;
pub const refcount_saturation_type_REFCOUNT_DEC_LEAK: refcount_saturation_type = 4;
pub type refcount_saturation_type = core::ffi::c_uint;
extern "C" {
    pub fn refcount_warn_saturate(r: *mut refcount_t, t: refcount_saturation_type);
}
extern "C" {
    pub fn refcount_dec_if_one(r: *mut refcount_t) -> bool_;
}
extern "C" {
    pub fn refcount_dec_not_one(r: *mut refcount_t) -> bool_;
}
extern "C" {
    pub fn refcount_dec_and_mutex_lock(r: *mut refcount_t, lock: *mut mutex) -> bool_;
}
extern "C" {
    pub fn refcount_dec_and_lock(r: *mut refcount_t, lock: *mut spinlock_t) -> bool_;
}
extern "C" {
    pub fn refcount_dec_and_lock_irqsave(
        r: *mut refcount_t,
        lock: *mut spinlock_t,
        flags: *mut core::ffi::c_ulong,
    ) -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kref {
    pub refcount: refcount_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct stat {
    pub st_dev: core::ffi::c_ulong,
    pub st_ino: core::ffi::c_ulong,
    pub st_mode: core::ffi::c_uint,
    pub st_nlink: core::ffi::c_uint,
    pub st_uid: core::ffi::c_uint,
    pub st_gid: core::ffi::c_uint,
    pub st_rdev: core::ffi::c_ulong,
    pub __pad1: core::ffi::c_ulong,
    pub st_size: core::ffi::c_long,
    pub st_blksize: core::ffi::c_int,
    pub __pad2: core::ffi::c_int,
    pub st_blocks: core::ffi::c_long,
    pub st_atime: core::ffi::c_long,
    pub st_atime_nsec: core::ffi::c_ulong,
    pub st_mtime: core::ffi::c_long,
    pub st_mtime_nsec: core::ffi::c_ulong,
    pub st_ctime: core::ffi::c_long,
    pub st_ctime_nsec: core::ffi::c_ulong,
    pub __unused4: core::ffi::c_uint,
    pub __unused5: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct statx_timestamp {
    pub tv_sec: __s64,
    pub tv_nsec: __u32,
    pub __reserved: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct statx {
    pub stx_mask: __u32,
    pub stx_blksize: __u32,
    pub stx_attributes: __u64,
    pub stx_nlink: __u32,
    pub stx_uid: __u32,
    pub stx_gid: __u32,
    pub stx_mode: __u16,
    pub __spare0: [__u16; 1usize],
    pub stx_ino: __u64,
    pub stx_size: __u64,
    pub stx_blocks: __u64,
    pub stx_attributes_mask: __u64,
    pub stx_atime: statx_timestamp,
    pub stx_btime: statx_timestamp,
    pub stx_ctime: statx_timestamp,
    pub stx_mtime: statx_timestamp,
    pub stx_rdev_major: __u32,
    pub stx_rdev_minor: __u32,
    pub stx_dev_major: __u32,
    pub stx_dev_minor: __u32,
    pub stx_mnt_id: __u64,
    pub stx_dio_mem_align: __u32,
    pub stx_dio_offset_align: __u32,
    pub __spare3: [__u64; 12usize],
}
#[repr(C)]
#[repr(align(64))]
pub struct cacheline_padding {
    pub x: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for cacheline_padding {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut sys_tz: timezone;
}
extern "C" {
    pub fn get_timespec64(ts: *mut timespec64, uts: *const __kernel_timespec) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_timespec64(ts: *const timespec64, uts: *mut __kernel_timespec) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_itimerspec64(
        it: *mut itimerspec64,
        uit: *const __kernel_itimerspec,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_itimerspec64(
        it: *const itimerspec64,
        uit: *mut __kernel_itimerspec,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mktime64(
        year: core::ffi::c_uint,
        mon: core::ffi::c_uint,
        day: core::ffi::c_uint,
        hour: core::ffi::c_uint,
        min: core::ffi::c_uint,
        sec: core::ffi::c_uint,
    ) -> time64_t;
}
extern "C" {
    pub fn clear_itimer();
}
extern "C" {
    pub fn do_utimes(
        dfd: core::ffi::c_int,
        filename: *const core::ffi::c_char,
        times: *mut timespec64,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tm {
    pub tm_sec: core::ffi::c_int,
    pub tm_min: core::ffi::c_int,
    pub tm_hour: core::ffi::c_int,
    pub tm_mday: core::ffi::c_int,
    pub tm_mon: core::ffi::c_int,
    pub tm_year: core::ffi::c_long,
    pub tm_wday: core::ffi::c_int,
    pub tm_yday: core::ffi::c_int,
}
extern "C" {
    pub fn time64_to_tm(totalsecs: time64_t, offset: core::ffi::c_int, result: *mut tm);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __kernel_timex_timeval {
    pub tv_sec: __kernel_time64_t,
    pub tv_usec: core::ffi::c_longlong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_timex {
    pub modes: core::ffi::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub offset: core::ffi::c_longlong,
    pub freq: core::ffi::c_longlong,
    pub maxerror: core::ffi::c_longlong,
    pub esterror: core::ffi::c_longlong,
    pub status: core::ffi::c_int,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub constant: core::ffi::c_longlong,
    pub precision: core::ffi::c_longlong,
    pub tolerance: core::ffi::c_longlong,
    pub time: __kernel_timex_timeval,
    pub tick: core::ffi::c_longlong,
    pub ppsfreq: core::ffi::c_longlong,
    pub jitter: core::ffi::c_longlong,
    pub shift: core::ffi::c_int,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub stabil: core::ffi::c_longlong,
    pub jitcnt: core::ffi::c_longlong,
    pub calcnt: core::ffi::c_longlong,
    pub errcnt: core::ffi::c_longlong,
    pub stbcnt: core::ffi::c_longlong,
    pub tai: core::ffi::c_int,
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 44usize], u8>,
}
impl Default for __kernel_timex {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl __kernel_timex {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_2() -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn new_bitfield_3() -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn random_get_entropy_fallback() -> core::ffi::c_ulong;
}
pub type cycles_t = core::ffi::c_ulong;
extern "C" {
    pub fn time_init();
}
extern "C" {
    pub static mut tick_usec: core::ffi::c_ulong;
}
extern "C" {
    pub static mut tick_nsec: core::ffi::c_ulong;
}
extern "C" {
    pub fn do_adjtimex(arg1: *mut __kernel_timex) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_clock_adjtime(which_clock: clockid_t, ktx: *mut __kernel_timex) -> core::ffi::c_int;
}
extern "C" {
    pub fn hardpps(arg1: *const timespec64, arg2: *const timespec64);
}
pub type old_time32_t = s32;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_timespec32 {
    pub tv_sec: old_time32_t,
    pub tv_nsec: s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_timeval32 {
    pub tv_sec: old_time32_t,
    pub tv_usec: s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_itimerspec32 {
    pub it_interval: old_timespec32,
    pub it_value: old_timespec32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct old_utimbuf32 {
    pub actime: old_time32_t,
    pub modtime: old_time32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct old_timex32 {
    pub modes: u32_,
    pub offset: s32,
    pub freq: s32,
    pub maxerror: s32,
    pub esterror: s32,
    pub status: s32,
    pub constant: s32,
    pub precision: s32,
    pub tolerance: s32,
    pub time: old_timeval32,
    pub tick: s32,
    pub ppsfreq: s32,
    pub jitter: s32,
    pub shift: s32,
    pub stabil: s32,
    pub jitcnt: s32,
    pub calcnt: s32,
    pub errcnt: s32,
    pub stbcnt: s32,
    pub tai: s32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 44usize], u8>,
}
impl Default for old_timex32 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn get_old_timespec32(
        arg1: *mut timespec64,
        arg2: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_old_timespec32(
        arg1: *const timespec64,
        arg2: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_old_itimerspec32(
        its: *mut itimerspec64,
        uits: *const old_itimerspec32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_old_itimerspec32(
        its: *const itimerspec64,
        uits: *mut old_itimerspec32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_old_timex32(arg1: *mut __kernel_timex, arg2: *const old_timex32)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn put_old_timex32(arg1: *mut old_timex32, arg2: *const __kernel_timex)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn ns_to_kernel_old_timeval(nsec: s64) -> __kernel_old_timeval;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct timens_offset {
    pub sec: s64,
    pub nsec: u64_,
}
extern "C" {
    pub static mut overflowuid: core::ffi::c_int;
}
extern "C" {
    pub static mut overflowgid: core::ffi::c_int;
}
extern "C" {
    pub fn __bad_uid();
}
extern "C" {
    pub fn __bad_gid();
}
extern "C" {
    pub static mut fs_overflowuid: core::ffi::c_int;
}
extern "C" {
    pub static mut fs_overflowgid: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_namespace {
    pub uid_map: uid_gid_map,
    pub gid_map: uid_gid_map,
    pub projid_map: uid_gid_map,
    pub parent: *mut user_namespace,
    pub level: core::ffi::c_int,
    pub owner: kuid_t,
    pub group: kgid_t,
    pub ns: ns_common,
    pub flags: core::ffi::c_ulong,
    pub parent_could_setfcap: bool_,
    pub keyring_name_list: list_head,
    pub user_keyring_register: *mut key,
    pub keyring_sem: rw_semaphore,
    pub work: work_struct,
    pub set: ctl_table_set,
    pub sysctls: *mut ctl_table_header,
    pub ucounts: *mut ucounts,
    pub ucount_max: [core::ffi::c_long; 10usize],
    pub rlimit_max: [core::ffi::c_long; 4usize],
}
impl Default for user_namespace {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut init_user_ns: user_namespace;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kgid_t {
    pub val: gid_t,
}
extern "C" {
    pub fn make_kuid(from: *mut user_namespace, uid: uid_t) -> kuid_t;
}
extern "C" {
    pub fn make_kgid(from: *mut user_namespace, gid: gid_t) -> kgid_t;
}
extern "C" {
    pub fn from_kuid(to: *mut user_namespace, uid: kuid_t) -> uid_t;
}
extern "C" {
    pub fn from_kgid(to: *mut user_namespace, gid: kgid_t) -> gid_t;
}
extern "C" {
    pub fn from_kuid_munged(to: *mut user_namespace, uid: kuid_t) -> uid_t;
}
extern "C" {
    pub fn from_kgid_munged(to: *mut user_namespace, gid: kgid_t) -> gid_t;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kstat {
    pub result_mask: u32_,
    pub mode: umode_t,
    pub nlink: core::ffi::c_uint,
    pub blksize: u32,
    pub attributes: u64_,
    pub attributes_mask: u64_,
    pub ino: u64_,
    pub dev: dev_t,
    pub rdev: dev_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub size: loff_t,
    pub atime: timespec64,
    pub mtime: timespec64,
    pub ctime: timespec64,
    pub btime: timespec64,
    pub blocks: u64_,
    pub mnt_id: u64_,
    pub dio_mem_align: u32_,
    pub dio_offset_align: u32_,
}
pub const MM_FILEPAGES: core::ffi::c_uint = 0;
pub const MM_ANONPAGES: core::ffi::c_uint = 1;
pub const MM_SWAPENTS: core::ffi::c_uint = 2;
pub const MM_SHMEMPAGES: core::ffi::c_uint = 3;
pub const NR_MM_COUNTERS: core::ffi::c_uint = 4;
pub type _bindgen_ty_6 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct task_rss_stat {
    pub events: core::ffi::c_int,
    pub count: [core::ffi::c_int; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mm_rss_stat {
    pub count: [atomic_long_t; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_frag {
    pub page: *mut page,
    pub offset: __u32,
    pub size: __u32,
}
impl Default for page_frag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tlbflush_unmap_batch {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_node {
    pub __rb_parent_color: core::ffi::c_ulong,
    pub rb_right: *mut rb_node,
    pub rb_left: *mut rb_node,
}
impl Default for rb_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_root {
    pub rb_node: *mut rb_node,
}
impl Default for rb_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_root_cached {
    pub rb_root: rb_root,
    pub rb_leftmost: *mut rb_node,
}
impl Default for rb_root_cached {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ct_irq_enter();
}
extern "C" {
    pub fn ct_irq_exit();
}
extern "C" {
    pub fn ct_irq_enter_irqson();
}
extern "C" {
    pub fn ct_irq_exit_irqson();
}
extern "C" {
    pub fn ct_nmi_enter();
}
extern "C" {
    pub fn ct_nmi_exit();
}
extern "C" {
    pub fn call_rcu(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn rcu_barrier_tasks();
}
extern "C" {
    pub fn rcu_barrier_tasks_rude();
}
extern "C" {
    pub fn synchronize_rcu();
}
extern "C" {
    pub fn get_completed_synchronize_rcu() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn get_completed_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn rcu_read_unlock_strict();
}
extern "C" {
    pub fn rcu_init();
}
extern "C" {
    pub static mut rcu_scheduler_active: core::ffi::c_int;
}
extern "C" {
    pub fn rcu_sched_clock_irq(user: core::ffi::c_int);
}
extern "C" {
    pub fn rcu_report_dead(cpu: core::ffi::c_uint);
}
extern "C" {
    pub fn rcutree_migrate_callbacks(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn rcu_init_tasks_generic();
}
extern "C" {
    pub fn rcu_sysrq_start();
}
extern "C" {
    pub fn rcu_sysrq_end();
}
extern "C" {
    pub fn rcu_trc_cmpxchg_need_qs(t: *mut task_struct, old: u8_, new: u8_) -> u8_;
}
extern "C" {
    pub fn rcu_tasks_trace_qs_blkd(t: *mut task_struct);
}
extern "C" {
    pub fn exit_tasks_rcu_start();
}
extern "C" {
    pub fn exit_tasks_rcu_finish();
}
extern "C" {
    pub fn rcu_softirq_qs();
}
extern "C" {
    pub fn rcu_note_context_switch(preempt: bool_);
}
extern "C" {
    pub fn rcu_needs_cpu() -> core::ffi::c_int;
}
extern "C" {
    pub fn rcu_cpu_stall_reset();
}
extern "C" {
    pub fn synchronize_rcu_expedited();
}
extern "C" {
    pub fn kvfree_call_rcu(head: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn rcu_barrier();
}
extern "C" {
    pub fn rcu_eqs_special_set(cpu: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn rcu_momentary_dyntick_idle();
}
extern "C" {
    pub fn kfree_rcu_scheduler_running();
}
extern "C" {
    pub fn rcu_gp_might_be_stalled() -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rcu_gp_oldstate {
    pub rgos_norm: core::ffi::c_ulong,
    pub rgos_exp: core::ffi::c_ulong,
}
extern "C" {
    pub fn start_poll_synchronize_rcu_expedited() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn start_poll_synchronize_rcu_expedited_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn cond_synchronize_rcu_expedited(oldstate: core::ffi::c_ulong);
}
extern "C" {
    pub fn cond_synchronize_rcu_expedited_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn get_state_synchronize_rcu() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn get_state_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn start_poll_synchronize_rcu() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn start_poll_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn poll_state_synchronize_rcu(oldstate: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn poll_state_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate) -> bool_;
}
extern "C" {
    pub fn cond_synchronize_rcu(oldstate: core::ffi::c_ulong);
}
extern "C" {
    pub fn cond_synchronize_rcu_full(rgosp: *mut rcu_gp_oldstate);
}
extern "C" {
    pub fn rcu_is_idle_cpu(cpu: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn rcu_preempt_deferred_qs(t: *mut task_struct);
}
extern "C" {
    pub fn exit_rcu();
}
extern "C" {
    pub fn rcu_scheduler_starting();
}
extern "C" {
    pub fn rcu_end_inkernel_boot();
}
extern "C" {
    pub fn rcu_inkernel_boot_has_ended() -> bool_;
}
extern "C" {
    pub fn rcu_is_watching() -> bool_;
}
extern "C" {
    pub fn rcu_all_qs();
}
extern "C" {
    pub fn rcutree_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcutree_online_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcutree_offline_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcutree_dead_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcutree_dying_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn rcu_cpu_starting(cpu: core::ffi::c_uint);
}
extern "C" {
    pub static mut rcu_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_bh_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_sched_lock_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_callback_map: lockdep_map;
}
extern "C" {
    pub static mut rcu_expedited: core::ffi::c_int;
}
extern "C" {
    pub static mut rcu_normal: core::ffi::c_int;
}
extern "C" {
    pub fn rb_insert_color(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_erase(arg1: *mut rb_node, arg2: *mut rb_root);
}
extern "C" {
    pub fn rb_next(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_prev(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_first(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_last(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_first_postorder(arg1: *const rb_root) -> *mut rb_node;
}
extern "C" {
    pub fn rb_next_postorder(arg1: *const rb_node) -> *mut rb_node;
}
extern "C" {
    pub fn rb_replace_node(victim: *mut rb_node, new: *mut rb_node, root: *mut rb_root);
}
extern "C" {
    pub fn rb_replace_node_rcu(victim: *mut rb_node, new: *mut rb_node, root: *mut rb_root);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct maple_metadata {
    pub end: core::ffi::c_uchar,
    pub gap: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_range_64 {
    pub parent: *mut maple_pnode,
    pub pivot: [core::ffi::c_ulong; 15usize],
    pub __bindgen_anon_1: maple_range_64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_range_64__bindgen_ty_1 {
    pub slot: [*mut core::ffi::c_void; 16usize],
    pub __bindgen_anon_1: maple_range_64__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_range_64__bindgen_ty_1__bindgen_ty_1 {
    pub pad: [*mut core::ffi::c_void; 15usize],
    pub meta: maple_metadata,
}
impl Default for maple_range_64__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for maple_range_64__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for maple_range_64 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_arange_64 {
    pub parent: *mut maple_pnode,
    pub pivot: [core::ffi::c_ulong; 9usize],
    pub slot: [*mut core::ffi::c_void; 10usize],
    pub gap: [core::ffi::c_ulong; 10usize],
    pub meta: maple_metadata,
}
impl Default for maple_arange_64 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_alloc {
    pub total: core::ffi::c_ulong,
    pub node_count: core::ffi::c_uchar,
    pub request_count: core::ffi::c_uint,
    pub slot: [*mut maple_alloc; 30usize],
}
impl Default for maple_alloc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_topiary {
    pub parent: *mut maple_pnode,
    pub next: *mut maple_enode,
}
impl Default for maple_topiary {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const maple_type_maple_dense: maple_type = 0;
pub const maple_type_maple_leaf_64: maple_type = 1;
pub const maple_type_maple_range_64: maple_type = 2;
pub const maple_type_maple_arange_64: maple_type = 3;
pub type maple_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lockdep_map_p {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_tree {
    pub __bindgen_anon_1: maple_tree__bindgen_ty_1,
    pub ma_root: *mut core::ffi::c_void,
    pub ma_flags: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_tree__bindgen_ty_1 {
    pub ma_lock: spinlock_t,
    pub ma_external_lock: lockdep_map_p,
    _bindgen_union_align: [u64; 3usize],
}
impl Default for maple_tree__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for maple_tree {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_node {
    pub __bindgen_anon_1: maple_node__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union maple_node__bindgen_ty_1 {
    pub __bindgen_anon_1: maple_node__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: maple_node__bindgen_ty_1__bindgen_ty_2,
    pub mr64: maple_range_64,
    pub ma64: maple_arange_64,
    pub alloc: maple_alloc,
    _bindgen_union_align: [u64; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_node__bindgen_ty_1__bindgen_ty_1 {
    pub parent: *mut maple_pnode,
    pub slot: [*mut core::ffi::c_void; 31usize],
}
impl Default for maple_node__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct maple_node__bindgen_ty_1__bindgen_ty_2 {
    pub pad: *mut core::ffi::c_void,
    pub rcu: callback_head,
    pub piv_parent: *mut maple_enode,
    pub parent_slot: core::ffi::c_uchar,
    pub type_: maple_type,
    pub slot_len: core::ffi::c_uchar,
    pub ma_flags: core::ffi::c_uint,
}
impl Default for maple_node__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for maple_node__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for maple_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ma_topiary {
    pub head: *mut maple_enode,
    pub tail: *mut maple_enode,
    pub mtree: *mut maple_tree,
}
impl Default for ma_topiary {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mtree_load(mt: *mut maple_tree, index: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mtree_insert(
        mt: *mut maple_tree,
        index: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_insert_range(
        mt: *mut maple_tree,
        first: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_alloc_range(
        mt: *mut maple_tree,
        startp: *mut core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        size: core::ffi::c_ulong,
        min: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_alloc_rrange(
        mt: *mut maple_tree,
        startp: *mut core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        size: core::ffi::c_ulong,
        min: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_store_range(
        mt: *mut maple_tree,
        first: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_store(
        mt: *mut maple_tree,
        index: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mtree_erase(mt: *mut maple_tree, index: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mtree_destroy(mt: *mut maple_tree);
}
extern "C" {
    pub fn __mt_destroy(mt: *mut maple_tree);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ma_state {
    pub tree: *mut maple_tree,
    pub index: core::ffi::c_ulong,
    pub last: core::ffi::c_ulong,
    pub node: *mut maple_enode,
    pub min: core::ffi::c_ulong,
    pub max: core::ffi::c_ulong,
    pub alloc: *mut maple_alloc,
    pub depth: core::ffi::c_uchar,
    pub offset: core::ffi::c_uchar,
    pub mas_flags: core::ffi::c_uchar,
}
impl Default for ma_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ma_wr_state {
    pub mas: *mut ma_state,
    pub node: *mut maple_node,
    pub r_min: core::ffi::c_ulong,
    pub r_max: core::ffi::c_ulong,
    pub type_: maple_type,
    pub offset_end: core::ffi::c_uchar,
    pub node_end: core::ffi::c_uchar,
    pub pivots: *mut core::ffi::c_ulong,
    pub end_piv: core::ffi::c_ulong,
    pub slots: *mut *mut core::ffi::c_void,
    pub entry: *mut core::ffi::c_void,
    pub content: *mut core::ffi::c_void,
}
impl Default for ma_wr_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mas_walk(mas: *mut ma_state) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_store(mas: *mut ma_state, entry: *mut core::ffi::c_void) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_erase(mas: *mut ma_state) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_store_gfp(
        mas: *mut ma_state,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mas_store_prealloc(mas: *mut ma_state, entry: *mut core::ffi::c_void);
}
extern "C" {
    pub fn mas_find(mas: *mut ma_state, max: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_find_rev(mas: *mut ma_state, min: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_preallocate(
        mas: *mut ma_state,
        entry: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mas_is_err(mas: *mut ma_state) -> bool_;
}
extern "C" {
    pub fn mas_nomem(mas: *mut ma_state, gfp: gfp_t) -> bool_;
}
extern "C" {
    pub fn mas_pause(mas: *mut ma_state);
}
extern "C" {
    pub fn maple_tree_init();
}
extern "C" {
    pub fn mas_destroy(mas: *mut ma_state);
}
extern "C" {
    pub fn mas_expected_entries(
        mas: *mut ma_state,
        nr_entries: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mas_prev(mas: *mut ma_state, min: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_next(mas: *mut ma_state, max: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mas_empty_area(
        mas: *mut ma_state,
        min: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mas_dup_tree(oldmas: *mut ma_state, mas: *mut ma_state);
}
extern "C" {
    pub fn mas_dup_store(mas: *mut ma_state, entry: *mut core::ffi::c_void);
}
extern "C" {
    pub fn mas_empty_area_rev(
        mas: *mut ma_state,
        min: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mt_find(
        mt: *mut maple_tree,
        index: *mut core::ffi::c_ulong,
        max: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mt_find_after(
        mt: *mut maple_tree,
        index: *mut core::ffi::c_ulong,
        max: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mt_prev(
        mt: *mut maple_tree,
        index: core::ffi::c_ulong,
        min: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn mt_next(
        mt: *mut maple_tree,
        index: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct optimistic_spin_node {
    pub next: *mut optimistic_spin_node,
    pub prev: *mut optimistic_spin_node,
    pub locked: core::ffi::c_int,
    pub cpu: core::ffi::c_int,
}
impl Default for optimistic_spin_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct optimistic_spin_queue {
    pub tail: atomic_t,
}
extern "C" {
    pub fn osq_lock(lock: *mut optimistic_spin_queue) -> bool_;
}
extern "C" {
    pub fn osq_unlock(lock: *mut optimistic_spin_queue);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rw_semaphore {
    pub count: atomic_long_t,
    pub owner: atomic_long_t,
    pub osq: optimistic_spin_queue,
    pub wait_lock: raw_spinlock_t,
    pub wait_list: list_head,
    pub magic: *mut core::ffi::c_void,
}
impl Default for rw_semaphore {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __init_rwsem(
        sem: *mut rw_semaphore,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn down_read(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn down_read_interruptible(sem: *mut rw_semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_read_killable(sem: *mut rw_semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_read_trylock(sem: *mut rw_semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_write(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn down_write_killable(sem: *mut rw_semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_write_trylock(sem: *mut rw_semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn up_read(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn up_write(sem: *mut rw_semaphore);
}
extern "C" {
    pub fn downgrade_write(sem: *mut rw_semaphore);
}
pub type wait_queue_entry_t = wait_queue_entry;
pub type wait_queue_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        flags: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn default_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        flags: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_entry {
    pub flags: core::ffi::c_uint,
    pub private: *mut core::ffi::c_void,
    pub func: wait_queue_func_t,
    pub entry: list_head,
}
impl Default for wait_queue_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_queue_head {
    pub lock: spinlock_t,
    pub head: list_head,
}
impl Default for wait_queue_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type wait_queue_head_t = wait_queue_head;
extern "C" {
    pub fn __init_waitqueue_head(
        wq_head: *mut wait_queue_head,
        name: *const core::ffi::c_char,
        arg1: *mut lock_class_key,
    );
}
extern "C" {
    pub fn add_wait_queue(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn add_wait_queue_exclusive(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn add_wait_queue_priority(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn remove_wait_queue(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn __wake_up(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        nr: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked_key(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        key: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked_key_bookmark(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        key: *mut core::ffi::c_void,
        bookmark: *mut wait_queue_entry_t,
    );
}
extern "C" {
    pub fn __wake_up_sync_key(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        key: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked_sync_key(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        key: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __wake_up_locked(
        wq_head: *mut wait_queue_head,
        mode: core::ffi::c_uint,
        nr: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __wake_up_sync(wq_head: *mut wait_queue_head, mode: core::ffi::c_uint);
}
extern "C" {
    pub fn __wake_up_pollfree(wq_head: *mut wait_queue_head);
}
extern "C" {
    pub fn init_wait_entry(wq_entry: *mut wait_queue_entry, flags: core::ffi::c_int);
}
extern "C" {
    pub fn do_wait_intr(
        arg1: *mut wait_queue_head_t,
        arg2: *mut wait_queue_entry_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_wait_intr_irq(
        arg1: *mut wait_queue_head_t,
        arg2: *mut wait_queue_entry_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn prepare_to_wait(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: core::ffi::c_int,
    );
}
extern "C" {
    pub fn prepare_to_wait_exclusive(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn prepare_to_wait_event(
        wq_head: *mut wait_queue_head,
        wq_entry: *mut wait_queue_entry,
        state: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn finish_wait(wq_head: *mut wait_queue_head, wq_entry: *mut wait_queue_entry);
}
extern "C" {
    pub fn wait_woken(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        timeout: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn woken_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        sync: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn autoremove_wake_function(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        sync: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
pub type task_call_f = ::core::option::Option<
    unsafe extern "C" fn(p: *mut task_struct, arg: *mut core::ffi::c_void) -> core::ffi::c_int,
>;
extern "C" {
    pub fn task_call_func(
        p: *mut task_struct,
        func: task_call_f,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swait_queue_head {
    pub lock: raw_spinlock_t,
    pub task_list: list_head,
}
impl Default for swait_queue_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swait_queue {
    pub task: *mut task_struct,
    pub task_list: list_head,
}
impl Default for swait_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __init_swait_queue_head(
        q: *mut swait_queue_head,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn swake_up_one(q: *mut swait_queue_head);
}
extern "C" {
    pub fn swake_up_all(q: *mut swait_queue_head);
}
extern "C" {
    pub fn swake_up_locked(q: *mut swait_queue_head);
}
extern "C" {
    pub fn prepare_to_swait_exclusive(
        q: *mut swait_queue_head,
        wait: *mut swait_queue,
        state: core::ffi::c_int,
    );
}
extern "C" {
    pub fn prepare_to_swait_event(
        q: *mut swait_queue_head,
        wait: *mut swait_queue,
        state: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn __finish_swait(q: *mut swait_queue_head, wait: *mut swait_queue);
}
extern "C" {
    pub fn finish_swait(q: *mut swait_queue_head, wait: *mut swait_queue);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct completion {
    pub done: core::ffi::c_uint,
    pub wait: swait_queue_head,
}
impl Default for completion {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn wait_for_completion(arg1: *mut completion);
}
extern "C" {
    pub fn wait_for_completion_io(arg1: *mut completion);
}
extern "C" {
    pub fn wait_for_completion_interruptible(x: *mut completion) -> core::ffi::c_int;
}
extern "C" {
    pub fn wait_for_completion_killable(x: *mut completion) -> core::ffi::c_int;
}
extern "C" {
    pub fn wait_for_completion_state(
        x: *mut completion,
        state: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn wait_for_completion_timeout(
        x: *mut completion,
        timeout: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn wait_for_completion_io_timeout(
        x: *mut completion,
        timeout: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn wait_for_completion_interruptible_timeout(
        x: *mut completion,
        timeout: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn wait_for_completion_killable_timeout(
        x: *mut completion,
        timeout: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn try_wait_for_completion(x: *mut completion) -> bool_;
}
extern "C" {
    pub fn completion_done(x: *mut completion) -> bool_;
}
extern "C" {
    pub fn complete(arg1: *mut completion);
}
extern "C" {
    pub fn complete_all(arg1: *mut completion);
}
pub const uprobe_filter_ctx_UPROBE_FILTER_REGISTER: uprobe_filter_ctx = 0;
pub const uprobe_filter_ctx_UPROBE_FILTER_UNREGISTER: uprobe_filter_ctx = 1;
pub const uprobe_filter_ctx_UPROBE_FILTER_MMAP: uprobe_filter_ctx = 2;
pub type uprobe_filter_ctx = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uprobe_consumer {
    pub handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut uprobe_consumer, regs: *mut pt_regs) -> core::ffi::c_int,
    >,
    pub ret_handler: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut uprobe_consumer,
            func: core::ffi::c_ulong,
            regs: *mut pt_regs,
        ) -> core::ffi::c_int,
    >,
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut uprobe_consumer,
            ctx: uprobe_filter_ctx,
            mm: *mut mm_struct,
        ) -> bool_,
    >,
    pub next: *mut uprobe_consumer,
}
impl Default for uprobe_consumer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uprobes_state {}
extern "C" {
    pub fn register_refined_jiffies(clock_tick_rate: core::ffi::c_long) -> core::ffi::c_int;
}
extern "C" {
    pub static mut jiffies_64: u64_;
}
extern "C" {
    pub static mut jiffies: core::ffi::c_ulong;
}
extern "C" {
    pub static mut preset_lpj: core::ffi::c_ulong;
}
extern "C" {
    pub fn jiffies_to_msecs(j: core::ffi::c_ulong) -> core::ffi::c_uint;
}
extern "C" {
    pub fn jiffies_to_usecs(j: core::ffi::c_ulong) -> core::ffi::c_uint;
}
extern "C" {
    pub fn jiffies64_to_nsecs(j: u64_) -> u64_;
}
extern "C" {
    pub fn jiffies64_to_msecs(j: u64_) -> u64_;
}
extern "C" {
    pub fn __msecs_to_jiffies(m: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __usecs_to_jiffies(u: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn timespec64_to_jiffies(value: *const timespec64) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn jiffies_to_timespec64(jiffies: core::ffi::c_ulong, value: *mut timespec64);
}
extern "C" {
    pub fn jiffies_to_clock_t(x: core::ffi::c_ulong) -> clock_t;
}
extern "C" {
    pub fn clock_t_to_jiffies(x: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn jiffies_64_to_clock_t(x: u64_) -> u64_;
}
extern "C" {
    pub fn nsec_to_clock_t(x: u64_) -> u64_;
}
extern "C" {
    pub fn nsecs_to_jiffies64(n: u64_) -> u64_;
}
extern "C" {
    pub fn nsecs_to_jiffies(n: u64_) -> core::ffi::c_ulong;
}
pub type ktime_t = s64;
extern "C" {
    pub fn ktime_add_safe(lhs: ktime_t, rhs: ktime_t) -> ktime_t;
}
pub const clocksource_ids_CSID_GENERIC: clocksource_ids = 0;
pub const clocksource_ids_CSID_ARM_ARCH_COUNTER: clocksource_ids = 1;
pub const clocksource_ids_CSID_MAX: clocksource_ids = 2;
pub type clocksource_ids = core::ffi::c_uint;
extern "C" {
    pub fn timekeeping_init();
}
extern "C" {
    pub static mut timekeeping_suspended: core::ffi::c_int;
}
extern "C" {
    pub fn legacy_timer_tick(ticks: core::ffi::c_ulong);
}
extern "C" {
    pub fn do_settimeofday64(ts: *const timespec64) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_sys_settimeofday64(tv: *const timespec64, tz: *const timezone) -> core::ffi::c_int;
}
extern "C" {
    pub fn ktime_get_raw_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_real_ts64(tv: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_coarse_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_coarse_real_ts64(ts: *mut timespec64);
}
extern "C" {
    pub fn getboottime64(ts: *mut timespec64);
}
extern "C" {
    pub fn ktime_get_seconds() -> time64_t;
}
extern "C" {
    pub fn __ktime_get_real_seconds() -> time64_t;
}
extern "C" {
    pub fn ktime_get_real_seconds() -> time64_t;
}
pub const tk_offsets_TK_OFFS_REAL: tk_offsets = 0;
pub const tk_offsets_TK_OFFS_BOOT: tk_offsets = 1;
pub const tk_offsets_TK_OFFS_TAI: tk_offsets = 2;
pub const tk_offsets_TK_OFFS_MAX: tk_offsets = 3;
pub type tk_offsets = core::ffi::c_uint;
extern "C" {
    pub fn ktime_get() -> ktime_t;
}
extern "C" {
    pub fn ktime_get_with_offset(offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_get_coarse_with_offset(offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_mono_to_any(tmono: ktime_t, offs: tk_offsets) -> ktime_t;
}
extern "C" {
    pub fn ktime_get_raw() -> ktime_t;
}
extern "C" {
    pub fn ktime_get_resolution_ns() -> u32_;
}
extern "C" {
    pub fn ktime_get_mono_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_raw_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_boot_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_tai_fast_ns() -> u64_;
}
extern "C" {
    pub fn ktime_get_real_fast_ns() -> u64_;
}
extern "C" {
    pub fn timekeeping_rtc_skipsuspend() -> bool_;
}
extern "C" {
    pub fn timekeeping_rtc_skipresume() -> bool_;
}
extern "C" {
    pub fn timekeeping_inject_sleeptime64(delta: *const timespec64);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ktime_timestamps {
    pub mono: u64_,
    pub boot: u64_,
    pub real: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_time_snapshot {
    pub cycles: u64_,
    pub real: ktime_t,
    pub raw: ktime_t,
    pub cs_id: clocksource_ids,
    pub clock_was_set_seq: core::ffi::c_uint,
    pub cs_was_changed_seq: u8_,
}
impl Default for system_time_snapshot {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct system_device_crosststamp {
    pub device: ktime_t,
    pub sys_realtime: ktime_t,
    pub sys_monoraw: ktime_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct system_counterval_t {
    pub cycles: u64_,
    pub cs: *mut clocksource,
}
impl Default for system_counterval_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn get_device_system_crosststamp(
        get_time_fn: ::core::option::Option<
            unsafe extern "C" fn(
                device_time: *mut ktime_t,
                system_counterval: *mut system_counterval_t,
                ctx: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        ctx: *mut core::ffi::c_void,
        history: *mut system_time_snapshot,
        xtstamp: *mut system_device_crosststamp,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ktime_get_snapshot(systime_snapshot: *mut system_time_snapshot);
}
extern "C" {
    pub fn ktime_get_fast_timestamps(snap: *mut ktime_timestamps);
}
extern "C" {
    pub static mut persistent_clock_is_local: core::ffi::c_int;
}
extern "C" {
    pub fn read_persistent_clock64(ts: *mut timespec64);
}
extern "C" {
    pub fn read_persistent_wall_and_boot_offset(
        wall_clock: *mut timespec64,
        boot_offset: *mut timespec64,
    );
}
pub const debug_obj_state_ODEBUG_STATE_NONE: debug_obj_state = 0;
pub const debug_obj_state_ODEBUG_STATE_INIT: debug_obj_state = 1;
pub const debug_obj_state_ODEBUG_STATE_INACTIVE: debug_obj_state = 2;
pub const debug_obj_state_ODEBUG_STATE_ACTIVE: debug_obj_state = 3;
pub const debug_obj_state_ODEBUG_STATE_DESTROYED: debug_obj_state = 4;
pub const debug_obj_state_ODEBUG_STATE_NOTAVAILABLE: debug_obj_state = 5;
pub const debug_obj_state_ODEBUG_STATE_MAX: debug_obj_state = 6;
pub type debug_obj_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct debug_obj {
    pub node: hlist_node,
    pub state: debug_obj_state,
    pub astate: core::ffi::c_uint,
    pub object: *mut core::ffi::c_void,
    pub descr: *const debug_obj_descr,
}
impl Default for debug_obj {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct debug_obj_descr {
    pub name: *const core::ffi::c_char,
    pub debug_hint: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void) -> *mut core::ffi::c_void,
    >,
    pub is_static_object:
        ::core::option::Option<unsafe extern "C" fn(addr: *mut core::ffi::c_void) -> bool_>,
    pub fixup_init: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_activate: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_destroy: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_free: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void, state: debug_obj_state) -> bool_,
    >,
    pub fixup_assert_init: ::core::option::Option<
        unsafe extern "C" fn(addr: *mut core::ffi::c_void, state: debug_obj_state) -> bool_,
    >,
}
impl Default for debug_obj_descr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timer_list {
    pub entry: hlist_node,
    pub expires: core::ffi::c_ulong,
    pub function: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    pub flags: u32_,
}
impl Default for timer_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn init_timer_key(
        timer: *mut timer_list,
        func: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
        flags: core::ffi::c_uint,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn add_timer_on(timer: *mut timer_list, cpu: core::ffi::c_int);
}
extern "C" {
    pub fn del_timer(timer: *mut timer_list) -> core::ffi::c_int;
}
extern "C" {
    pub fn mod_timer(timer: *mut timer_list, expires: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn mod_timer_pending(
        timer: *mut timer_list,
        expires: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn timer_reduce(timer: *mut timer_list, expires: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn add_timer(timer: *mut timer_list);
}
extern "C" {
    pub fn try_to_del_timer_sync(timer: *mut timer_list) -> core::ffi::c_int;
}
extern "C" {
    pub fn del_timer_sync(timer: *mut timer_list) -> core::ffi::c_int;
}
extern "C" {
    pub fn init_timers();
}
extern "C" {
    pub fn it_real_fn(arg1: *mut hrtimer) -> hrtimer_restart;
}
extern "C" {
    pub fn __round_jiffies(j: core::ffi::c_ulong, cpu: core::ffi::c_int) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_relative(
        j: core::ffi::c_ulong,
        cpu: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn round_jiffies(j: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn round_jiffies_relative(j: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_up(j: core::ffi::c_ulong, cpu: core::ffi::c_int) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __round_jiffies_up_relative(
        j: core::ffi::c_ulong,
        cpu: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn round_jiffies_up(j: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn round_jiffies_up_relative(j: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn timers_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn timers_dead_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct workqueue_struct {
    _unused: [u8; 0],
}
pub type work_func_t = ::core::option::Option<unsafe extern "C" fn(work: *mut work_struct)>;
extern "C" {
    pub fn delayed_work_timer_fn(t: *mut timer_list);
}
pub const WORK_STRUCT_PENDING_BIT: core::ffi::c_long = 0;
pub const WORK_STRUCT_INACTIVE_BIT: core::ffi::c_long = 1;
pub const WORK_STRUCT_PWQ_BIT: core::ffi::c_long = 2;
pub const WORK_STRUCT_LINKED_BIT: core::ffi::c_long = 3;
pub const WORK_STRUCT_COLOR_SHIFT: core::ffi::c_long = 4;
pub const WORK_STRUCT_COLOR_BITS: core::ffi::c_long = 4;
pub const WORK_STRUCT_PENDING: core::ffi::c_long = 1;
pub const WORK_STRUCT_INACTIVE: core::ffi::c_long = 2;
pub const WORK_STRUCT_PWQ: core::ffi::c_long = 4;
pub const WORK_STRUCT_LINKED: core::ffi::c_long = 8;
pub const WORK_STRUCT_STATIC: core::ffi::c_long = 0;
pub const WORK_NR_COLORS: core::ffi::c_long = 16;
pub const WORK_CPU_UNBOUND: core::ffi::c_long = 64;
pub const WORK_STRUCT_FLAG_BITS: core::ffi::c_long = 8;
pub const WORK_OFFQ_FLAG_BASE: core::ffi::c_long = 4;
pub const __WORK_OFFQ_CANCELING: core::ffi::c_long = 4;
pub const WORK_OFFQ_CANCELING: core::ffi::c_long = 16;
pub const WORK_OFFQ_FLAG_BITS: core::ffi::c_long = 1;
pub const WORK_OFFQ_POOL_SHIFT: core::ffi::c_long = 5;
pub const WORK_OFFQ_LEFT: core::ffi::c_long = 59;
pub const WORK_OFFQ_POOL_BITS: core::ffi::c_long = 31;
pub const WORK_OFFQ_POOL_NONE: core::ffi::c_long = 2147483647;
pub const WORK_STRUCT_FLAG_MASK: core::ffi::c_long = 255;
pub const WORK_STRUCT_WQ_DATA_MASK: core::ffi::c_long = -256;
pub const WORK_STRUCT_NO_POOL: core::ffi::c_long = 68719476704;
pub const WORK_BUSY_PENDING: core::ffi::c_long = 1;
pub const WORK_BUSY_RUNNING: core::ffi::c_long = 2;
pub const WORKER_DESC_LEN: core::ffi::c_long = 24;
pub type _bindgen_ty_7 = core::ffi::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct work_struct {
    pub data: atomic_long_t,
    pub entry: list_head,
    pub func: work_func_t,
}
impl Default for work_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct delayed_work {
    pub work: work_struct,
    pub timer: timer_list,
    pub wq: *mut workqueue_struct,
    pub cpu: core::ffi::c_int,
}
impl Default for delayed_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_work {
    pub work: work_struct,
    pub rcu: callback_head,
    pub wq: *mut workqueue_struct,
}
impl Default for rcu_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct workqueue_attrs {
    pub nice: core::ffi::c_int,
    pub cpumask: cpumask_var_t,
    pub no_numa: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct execute_work {
    pub work: work_struct,
}
impl Default for execute_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const WQ_UNBOUND: core::ffi::c_uint = 2;
pub const WQ_FREEZABLE: core::ffi::c_uint = 4;
pub const WQ_MEM_RECLAIM: core::ffi::c_uint = 8;
pub const WQ_HIGHPRI: core::ffi::c_uint = 16;
pub const WQ_CPU_INTENSIVE: core::ffi::c_uint = 32;
pub const WQ_SYSFS: core::ffi::c_uint = 64;
pub const WQ_POWER_EFFICIENT: core::ffi::c_uint = 128;
pub const __WQ_DRAINING: core::ffi::c_uint = 65536;
pub const __WQ_ORDERED: core::ffi::c_uint = 131072;
pub const __WQ_LEGACY: core::ffi::c_uint = 262144;
pub const __WQ_ORDERED_EXPLICIT: core::ffi::c_uint = 524288;
pub const WQ_MAX_ACTIVE: core::ffi::c_uint = 512;
pub const WQ_MAX_UNBOUND_PER_CPU: core::ffi::c_uint = 4;
pub const WQ_DFL_ACTIVE: core::ffi::c_uint = 256;
pub type _bindgen_ty_8 = core::ffi::c_uint;
extern "C" {
    pub static mut system_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_highpri_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_long_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_unbound_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_freezable_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_power_efficient_wq: *mut workqueue_struct;
}
extern "C" {
    pub static mut system_freezable_power_efficient_wq: *mut workqueue_struct;
}
extern "C" {
    pub fn alloc_workqueue(
        fmt: *const core::ffi::c_char,
        flags: core::ffi::c_uint,
        max_active: core::ffi::c_int,
        ...
    ) -> *mut workqueue_struct;
}
extern "C" {
    pub fn destroy_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn alloc_workqueue_attrs() -> *mut workqueue_attrs;
}
extern "C" {
    pub fn free_workqueue_attrs(attrs: *mut workqueue_attrs);
}
extern "C" {
    pub fn apply_workqueue_attrs(
        wq: *mut workqueue_struct,
        attrs: *const workqueue_attrs,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn workqueue_set_unbound_cpumask(cpumask: *mut cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn queue_work_on(
        cpu: core::ffi::c_int,
        wq: *mut workqueue_struct,
        work: *mut work_struct,
    ) -> bool_;
}
extern "C" {
    pub fn queue_work_node(
        node: core::ffi::c_int,
        wq: *mut workqueue_struct,
        work: *mut work_struct,
    ) -> bool_;
}
extern "C" {
    pub fn queue_delayed_work_on(
        cpu: core::ffi::c_int,
        wq: *mut workqueue_struct,
        work: *mut delayed_work,
        delay: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn mod_delayed_work_on(
        cpu: core::ffi::c_int,
        wq: *mut workqueue_struct,
        dwork: *mut delayed_work,
        delay: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn queue_rcu_work(wq: *mut workqueue_struct, rwork: *mut rcu_work) -> bool_;
}
extern "C" {
    pub fn __flush_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn drain_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn schedule_on_each_cpu(func: work_func_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn execute_in_process_context(
        fn_: work_func_t,
        arg1: *mut execute_work,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn flush_work(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn cancel_work(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn cancel_work_sync(work: *mut work_struct) -> bool_;
}
extern "C" {
    pub fn flush_delayed_work(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn cancel_delayed_work(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn cancel_delayed_work_sync(dwork: *mut delayed_work) -> bool_;
}
extern "C" {
    pub fn flush_rcu_work(rwork: *mut rcu_work) -> bool_;
}
extern "C" {
    pub fn workqueue_set_max_active(wq: *mut workqueue_struct, max_active: core::ffi::c_int);
}
extern "C" {
    pub fn current_work() -> *mut work_struct;
}
extern "C" {
    pub fn current_is_workqueue_rescuer() -> bool_;
}
extern "C" {
    pub fn workqueue_congested(cpu: core::ffi::c_int, wq: *mut workqueue_struct) -> bool_;
}
extern "C" {
    pub fn work_busy(work: *mut work_struct) -> core::ffi::c_uint;
}
extern "C" {
    pub fn set_worker_desc(fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn print_worker_info(log_lvl: *const core::ffi::c_char, task: *mut task_struct);
}
extern "C" {
    pub fn show_all_workqueues();
}
extern "C" {
    pub fn show_one_workqueue(wq: *mut workqueue_struct);
}
extern "C" {
    pub fn wq_worker_comm(buf: *mut core::ffi::c_char, size: usize, task: *mut task_struct);
}
extern "C" {
    pub fn __warn_flushing_systemwide_wq();
}
extern "C" {
    pub fn work_on_cpu(
        cpu: core::ffi::c_int,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_long,
        >,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn work_on_cpu_safe(
        cpu: core::ffi::c_int,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_long,
        >,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn freeze_workqueues_begin();
}
extern "C" {
    pub fn freeze_workqueues_busy() -> bool_;
}
extern "C" {
    pub fn thaw_workqueues();
}
extern "C" {
    pub fn workqueue_sysfs_register(wq: *mut workqueue_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn wq_watchdog_touch(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn workqueue_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn workqueue_online_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn workqueue_offline_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn workqueue_init_early();
}
extern "C" {
    pub fn workqueue_init();
}
extern "C" {
    pub static mut debug_locks: core::ffi::c_int;
}
extern "C" {
    pub static mut debug_locks_silent: core::ffi::c_int;
}
extern "C" {
    pub fn debug_locks_off() -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mutex {
    pub owner: atomic_long_t,
    pub wait_lock: raw_spinlock_t,
    pub osq: optimistic_spin_queue,
    pub wait_list: list_head,
    pub magic: *mut core::ffi::c_void,
}
impl Default for mutex {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mutex_destroy(lock: *mut mutex);
}
extern "C" {
    pub fn __mutex_init(lock: *mut mutex, name: *const core::ffi::c_char, key: *mut lock_class_key);
}
extern "C" {
    pub fn mutex_is_locked(lock: *mut mutex) -> bool_;
}
extern "C" {
    pub fn mutex_lock(lock: *mut mutex);
}
extern "C" {
    pub fn mutex_lock_interruptible(lock: *mut mutex) -> core::ffi::c_int;
}
extern "C" {
    pub fn mutex_lock_killable(lock: *mut mutex) -> core::ffi::c_int;
}
extern "C" {
    pub fn mutex_lock_io(lock: *mut mutex);
}
extern "C" {
    pub fn mutex_trylock(lock: *mut mutex) -> core::ffi::c_int;
}
extern "C" {
    pub fn mutex_unlock(lock: *mut mutex);
}
extern "C" {
    pub fn atomic_dec_and_mutex_lock(cnt: *mut atomic_t, lock: *mut mutex) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount {
    pub sequence: core::ffi::c_uint,
}
pub type seqcount_t = seqcount;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_raw_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_raw_spinlock_t = seqcount_raw_spinlock;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_spinlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_spinlock_t = seqcount_spinlock;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_rwlock {
    pub seqcount: seqcount_t,
}
pub type seqcount_rwlock_t = seqcount_rwlock;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_mutex {
    pub seqcount: seqcount_t,
}
pub type seqcount_mutex_t = seqcount_mutex;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqcount_latch_t {
    pub seqcount: seqcount_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seqlock_t {
    pub seqcount: seqcount_spinlock_t,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_context_t {
    pub id: atomic_long_t,
    pub vdso: *mut core::ffi::c_void,
    pub icache_stale_mask: cpumask_t,
}
impl Default for mm_context_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn create_pgd_mapping(
        pgdp: *mut pgd_t,
        va: usize,
        pa: phys_addr_t,
        sz: phys_addr_t,
        prot: pgprot_t,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page {
    pub flags: core::ffi::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_2,
    pub _refcount: atomic_t,
    pub memcg_data: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: page__bindgen_ty_1__bindgen_ty_2,
    pub __bindgen_anon_3: page__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: page__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: page__bindgen_ty_1__bindgen_ty_5,
    pub __bindgen_anon_6: page__bindgen_ty_1__bindgen_ty_6,
    pub callback_head: callback_head,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1 {
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub index: core::ffi::c_ulong,
    pub private: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub buddy_list: list_head,
    pub pcp_list: list_head,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut core::ffi::c_void,
    pub mlock_count: core::ffi::c_uint,
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for page__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for page__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_2 {
    pub pp_magic: core::ffi::c_ulong,
    pub pp: *mut page_pool,
    pub _pp_mapping_pad: core::ffi::c_ulong,
    pub dma_addr: core::ffi::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub dma_addr_upper: core::ffi::c_ulong,
    pub pp_frag_count: atomic_long_t,
    _bindgen_union_align: u64,
}
impl Default for page__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for page__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_3 {
    pub compound_head: core::ffi::c_ulong,
    pub compound_dtor: core::ffi::c_uchar,
    pub compound_order: core::ffi::c_uchar,
    pub compound_mapcount: atomic_t,
    pub compound_pincount: atomic_t,
    pub compound_nr: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_4 {
    pub _compound_pad_1: core::ffi::c_ulong,
    pub _compound_pad_2: core::ffi::c_ulong,
    pub deferred_list: list_head,
}
impl Default for page__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_5 {
    pub _pt_pad_1: core::ffi::c_ulong,
    pub pmd_huge_pte: pgtable_t,
    pub _pt_pad_2: core::ffi::c_ulong,
    pub __bindgen_anon_1: page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
    pub ptl: *mut spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub pt_mm: *mut mm_struct,
    pub pt_frag_refcount: atomic_t,
    _bindgen_union_align: u64,
}
impl Default for page__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for page__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page__bindgen_ty_1__bindgen_ty_6 {
    pub pgmap: *mut dev_pagemap,
    pub zone_device_data: *mut core::ffi::c_void,
}
impl Default for page__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for page__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union page__bindgen_ty_2 {
    pub _mapcount: atomic_t,
    pub page_type: core::ffi::c_uint,
    _bindgen_union_align: u32,
}
impl Default for page__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for page {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio {
    pub __bindgen_anon_1: folio__bindgen_ty_1,
    pub _flags_1: core::ffi::c_ulong,
    pub __head: core::ffi::c_ulong,
    pub _folio_dtor: core::ffi::c_uchar,
    pub _folio_order: core::ffi::c_uchar,
    pub _total_mapcount: atomic_t,
    pub _pincount: atomic_t,
    pub _folio_nr_pages: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1 {
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1,
    pub page: page,
    _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1 {
    pub flags: core::ffi::c_ulong,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub mapping: *mut address_space,
    pub index: core::ffi::c_ulong,
    pub private: *mut core::ffi::c_void,
    pub _mapcount: atomic_t,
    pub _refcount: atomic_t,
    pub memcg_data: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub lru: list_head,
    pub __bindgen_anon_1: folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub __filler: *mut core::ffi::c_void,
    pub mlock_count: core::ffi::c_uint,
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for folio__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for folio__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for folio {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_frag_cache {
    pub va: *mut core::ffi::c_void,
    pub offset: __u16,
    pub size: __u16,
    pub pagecnt_bias: core::ffi::c_uint,
    pub pfmemalloc: bool_,
}
impl Default for page_frag_cache {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type vm_flags_t = core::ffi::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_region {
    pub vm_rb: rb_node,
    pub vm_flags: vm_flags_t,
    pub vm_start: core::ffi::c_ulong,
    pub vm_end: core::ffi::c_ulong,
    pub vm_top: core::ffi::c_ulong,
    pub vm_pgoff: core::ffi::c_ulong,
    pub vm_file: *mut file,
    pub vm_usage: core::ffi::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for vm_region {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl vm_region {
    #[inline]
    pub fn vm_icache_flushed(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vm_icache_flushed(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(vm_icache_flushed: bool_) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vm_icache_flushed: u8 = unsafe { ::core::mem::transmute(vm_icache_flushed) };
            vm_icache_flushed as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_userfaultfd_ctx {}
#[repr(C)]
#[derive(Default)]
pub struct anon_vma_name {
    pub kref: kref,
    pub name: __IncompleteArrayField<core::ffi::c_char>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_area_struct {
    pub vm_start: core::ffi::c_ulong,
    pub vm_end: core::ffi::c_ulong,
    pub vm_mm: *mut mm_struct,
    pub vm_page_prot: pgprot_t,
    pub vm_flags: core::ffi::c_ulong,
    pub __bindgen_anon_1: vm_area_struct__bindgen_ty_1,
    pub anon_vma_chain: list_head,
    pub anon_vma: *mut anon_vma,
    pub vm_ops: *const vm_operations_struct,
    pub vm_pgoff: core::ffi::c_ulong,
    pub vm_file: *mut file,
    pub vm_private_data: *mut core::ffi::c_void,
    pub swap_readahead_info: atomic_long_t,
    pub vm_userfaultfd_ctx: vm_userfaultfd_ctx,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_area_struct__bindgen_ty_1 {
    pub shared: vm_area_struct__bindgen_ty_1__bindgen_ty_1,
    pub anon_name: *mut anon_vma_name,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_area_struct__bindgen_ty_1__bindgen_ty_1 {
    pub rb: rb_node,
    pub rb_subtree_last: core::ffi::c_ulong,
}
impl Default for vm_area_struct__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for vm_area_struct__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for vm_area_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kioctx_table {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct mm_struct {
    pub __bindgen_anon_1: mm_struct__bindgen_ty_1,
    pub cpu_bitmap: __IncompleteArrayField<core::ffi::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mm_struct__bindgen_ty_1 {
    pub mm_mt: maple_tree,
    pub get_unmapped_area: ::core::option::Option<
        unsafe extern "C" fn(
            filp: *mut file,
            addr: core::ffi::c_ulong,
            len: core::ffi::c_ulong,
            pgoff: core::ffi::c_ulong,
            flags: core::ffi::c_ulong,
        ) -> core::ffi::c_ulong,
    >,
    pub mmap_base: core::ffi::c_ulong,
    pub mmap_legacy_base: core::ffi::c_ulong,
    pub task_size: core::ffi::c_ulong,
    pub pgd: *mut pgd_t,
    pub membarrier_state: atomic_t,
    pub mm_users: atomic_t,
    pub mm_count: atomic_t,
    pub pgtables_bytes: atomic_long_t,
    pub map_count: core::ffi::c_int,
    pub page_table_lock: spinlock_t,
    pub mmap_lock: rw_semaphore,
    pub mmlist: list_head,
    pub hiwater_rss: core::ffi::c_ulong,
    pub hiwater_vm: core::ffi::c_ulong,
    pub total_vm: core::ffi::c_ulong,
    pub locked_vm: core::ffi::c_ulong,
    pub pinned_vm: atomic64_t,
    pub data_vm: core::ffi::c_ulong,
    pub exec_vm: core::ffi::c_ulong,
    pub stack_vm: core::ffi::c_ulong,
    pub def_flags: core::ffi::c_ulong,
    pub write_protect_seq: seqcount_t,
    pub arg_lock: spinlock_t,
    pub start_code: core::ffi::c_ulong,
    pub end_code: core::ffi::c_ulong,
    pub start_data: core::ffi::c_ulong,
    pub end_data: core::ffi::c_ulong,
    pub start_brk: core::ffi::c_ulong,
    pub brk: core::ffi::c_ulong,
    pub start_stack: core::ffi::c_ulong,
    pub arg_start: core::ffi::c_ulong,
    pub arg_end: core::ffi::c_ulong,
    pub env_start: core::ffi::c_ulong,
    pub env_end: core::ffi::c_ulong,
    pub saved_auxv: [core::ffi::c_ulong; 60usize],
    pub rss_stat: mm_rss_stat,
    pub binfmt: *mut linux_binfmt,
    pub context: mm_context_t,
    pub flags: core::ffi::c_ulong,
    pub ioctx_lock: spinlock_t,
    pub ioctx_table: *mut kioctx_table,
    pub owner: *mut task_struct,
    pub user_ns: *mut user_namespace,
    pub exe_file: *mut file,
    pub tlb_flush_pending: atomic_t,
    pub uprobes_state: uprobes_state,
    pub hugetlb_usage: atomic_long_t,
    pub async_put_work: work_struct,
}
impl Default for mm_struct__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for mm_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut init_mm: mm_struct;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vma_iterator {
    pub mas: ma_state,
}
impl Default for vma_iterator {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_gather {
    _unused: [u8; 0],
}
extern "C" {
    pub fn tlb_gather_mmu(tlb: *mut mmu_gather, mm: *mut mm_struct);
}
extern "C" {
    pub fn tlb_gather_mmu_fullmm(tlb: *mut mmu_gather, mm: *mut mm_struct);
}
extern "C" {
    pub fn tlb_finish_mmu(tlb: *mut mmu_gather);
}
pub type vm_fault_t = core::ffi::c_uint;
pub const vm_fault_reason_VM_FAULT_OOM: vm_fault_reason = 1;
pub const vm_fault_reason_VM_FAULT_SIGBUS: vm_fault_reason = 2;
pub const vm_fault_reason_VM_FAULT_MAJOR: vm_fault_reason = 4;
pub const vm_fault_reason_VM_FAULT_WRITE: vm_fault_reason = 8;
pub const vm_fault_reason_VM_FAULT_HWPOISON: vm_fault_reason = 16;
pub const vm_fault_reason_VM_FAULT_HWPOISON_LARGE: vm_fault_reason = 32;
pub const vm_fault_reason_VM_FAULT_SIGSEGV: vm_fault_reason = 64;
pub const vm_fault_reason_VM_FAULT_NOPAGE: vm_fault_reason = 256;
pub const vm_fault_reason_VM_FAULT_LOCKED: vm_fault_reason = 512;
pub const vm_fault_reason_VM_FAULT_RETRY: vm_fault_reason = 1024;
pub const vm_fault_reason_VM_FAULT_FALLBACK: vm_fault_reason = 2048;
pub const vm_fault_reason_VM_FAULT_DONE_COW: vm_fault_reason = 4096;
pub const vm_fault_reason_VM_FAULT_NEEDDSYNC: vm_fault_reason = 8192;
pub const vm_fault_reason_VM_FAULT_COMPLETED: vm_fault_reason = 16384;
pub const vm_fault_reason_VM_FAULT_HINDEX_MASK: vm_fault_reason = 983040;
pub type vm_fault_reason = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_special_mapping {
    pub name: *const core::ffi::c_char,
    pub pages: *mut *mut page,
    pub fault: ::core::option::Option<
        unsafe extern "C" fn(
            sm: *const vm_special_mapping,
            vma: *mut vm_area_struct,
            vmf: *mut vm_fault,
        ) -> vm_fault_t,
    >,
    pub mremap: ::core::option::Option<
        unsafe extern "C" fn(
            sm: *const vm_special_mapping,
            new_vma: *mut vm_area_struct,
        ) -> core::ffi::c_int,
    >,
}
impl Default for vm_special_mapping {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const tlb_flush_reason_TLB_FLUSH_ON_TASK_SWITCH: tlb_flush_reason = 0;
pub const tlb_flush_reason_TLB_REMOTE_SHOOTDOWN: tlb_flush_reason = 1;
pub const tlb_flush_reason_TLB_LOCAL_SHOOTDOWN: tlb_flush_reason = 2;
pub const tlb_flush_reason_TLB_LOCAL_MM_SHOOTDOWN: tlb_flush_reason = 3;
pub const tlb_flush_reason_TLB_REMOTE_SEND_IPI: tlb_flush_reason = 4;
pub const tlb_flush_reason_NR_TLB_FLUSH_REASONS: tlb_flush_reason = 5;
pub type tlb_flush_reason = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct swp_entry_t {
    pub val: core::ffi::c_ulong,
}
pub const fault_flag_FAULT_FLAG_WRITE: fault_flag = 1;
pub const fault_flag_FAULT_FLAG_MKWRITE: fault_flag = 2;
pub const fault_flag_FAULT_FLAG_ALLOW_RETRY: fault_flag = 4;
pub const fault_flag_FAULT_FLAG_RETRY_NOWAIT: fault_flag = 8;
pub const fault_flag_FAULT_FLAG_KILLABLE: fault_flag = 16;
pub const fault_flag_FAULT_FLAG_TRIED: fault_flag = 32;
pub const fault_flag_FAULT_FLAG_USER: fault_flag = 64;
pub const fault_flag_FAULT_FLAG_REMOTE: fault_flag = 128;
pub const fault_flag_FAULT_FLAG_INSTRUCTION: fault_flag = 256;
pub const fault_flag_FAULT_FLAG_INTERRUPTIBLE: fault_flag = 512;
pub const fault_flag_FAULT_FLAG_UNSHARE: fault_flag = 1024;
pub const fault_flag_FAULT_FLAG_ORIG_PTE_VALID: fault_flag = 2048;
pub type fault_flag = core::ffi::c_uint;
pub type zap_flags_t = core::ffi::c_uint;
extern "C" {
    pub fn build_id_parse(
        vma: *mut vm_area_struct,
        build_id: *mut core::ffi::c_uchar,
        size: *mut __u32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn build_id_parse_buf(
        buf: *const core::ffi::c_void,
        build_id: *mut core::ffi::c_uchar,
        buf_size: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __do_once_start(done: *mut bool_, flags: *mut core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn __do_once_done(
        done: *mut bool_,
        once_key: *mut static_key_true,
        flags: *mut core::ffi::c_ulong,
        mod_: *mut module,
    );
}
extern "C" {
    pub fn __do_once_sleepable_start(done: *mut bool_) -> bool_;
}
extern "C" {
    pub fn __do_once_sleepable_done(
        done: *mut bool_,
        once_key: *mut static_key_true,
        mod_: *mut module,
    );
}
extern "C" {
    pub static mut __invalid_size_argument_for_IOC: core::ffi::c_uint;
}
extern "C" {
    pub static mut nr_irqs: core::ffi::c_int;
}
extern "C" {
    pub fn irq_to_desc(irq: core::ffi::c_uint) -> *mut irq_desc;
}
extern "C" {
    pub fn irq_get_next_irq(offset: core::ffi::c_uint) -> core::ffi::c_uint;
}
#[repr(C)]
#[derive(Default)]
pub struct rand_pool_info {
    pub entropy_count: core::ffi::c_int,
    pub buf_size: core::ffi::c_int,
    pub buf: __IncompleteArrayField<__u32>,
}
extern "C" {
    pub fn add_device_randomness(buf: *const core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn add_bootloader_randomness(buf: *const core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn add_input_randomness(
        type_: core::ffi::c_uint,
        code: core::ffi::c_uint,
        value: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn add_interrupt_randomness(irq: core::ffi::c_int);
}
extern "C" {
    pub fn add_hwgenerator_randomness(buf: *const core::ffi::c_void, len: usize, entropy: usize);
}
extern "C" {
    pub fn get_random_bytes(buf: *mut core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn get_random_u8() -> u8_;
}
extern "C" {
    pub fn get_random_u16() -> u16_;
}
extern "C" {
    pub fn get_random_u32() -> u32_;
}
extern "C" {
    pub fn get_random_u64() -> u64_;
}
extern "C" {
    pub fn random_init_early(command_line: *const core::ffi::c_char);
}
extern "C" {
    pub fn random_init();
}
extern "C" {
    pub fn rng_is_initialized() -> bool_;
}
extern "C" {
    pub fn wait_for_random_bytes() -> core::ffi::c_int;
}
extern "C" {
    pub fn dump_page(page: *mut page, reason: *const core::ffi::c_char);
}
extern "C" {
    pub fn dump_vma(vma: *const vm_area_struct);
}
extern "C" {
    pub fn dump_mm(mm: *const mm_struct);
}
extern "C" {
    pub static mut pcpu_base_addr: *mut core::ffi::c_void;
}
extern "C" {
    pub static mut pcpu_unit_offsets: *const core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcpu_group_info {
    pub nr_units: core::ffi::c_int,
    pub base_offset: core::ffi::c_ulong,
    pub cpu_map: *mut core::ffi::c_uint,
}
impl Default for pcpu_group_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct pcpu_alloc_info {
    pub static_size: usize,
    pub reserved_size: usize,
    pub dyn_size: usize,
    pub unit_size: usize,
    pub atom_size: usize,
    pub alloc_size: usize,
    pub __ai_size: usize,
    pub nr_groups: core::ffi::c_int,
    pub groups: __IncompleteArrayField<pcpu_group_info>,
}
impl Default for pcpu_alloc_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const pcpu_fc_PCPU_FC_AUTO: pcpu_fc = 0;
pub const pcpu_fc_PCPU_FC_EMBED: pcpu_fc = 1;
pub const pcpu_fc_PCPU_FC_PAGE: pcpu_fc = 2;
pub const pcpu_fc_PCPU_FC_NR: pcpu_fc = 3;
pub type pcpu_fc = core::ffi::c_uint;
extern "C" {
    pub static pcpu_fc_names: [*const core::ffi::c_char; 3usize];
}
extern "C" {
    pub static mut pcpu_chosen_fc: pcpu_fc;
}
pub type pcpu_fc_cpu_to_node_fn_t =
    ::core::option::Option<unsafe extern "C" fn(cpu: core::ffi::c_int) -> core::ffi::c_int>;
pub type pcpu_fc_cpu_distance_fn_t = ::core::option::Option<
    unsafe extern "C" fn(from: core::ffi::c_uint, to: core::ffi::c_uint) -> core::ffi::c_int,
>;
extern "C" {
    pub fn pcpu_alloc_alloc_info(
        nr_groups: core::ffi::c_int,
        nr_units: core::ffi::c_int,
    ) -> *mut pcpu_alloc_info;
}
extern "C" {
    pub fn pcpu_free_alloc_info(ai: *mut pcpu_alloc_info);
}
extern "C" {
    pub fn pcpu_setup_first_chunk(ai: *const pcpu_alloc_info, base_addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn __alloc_reserved_percpu(size: usize, align: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __is_kernel_percpu_address(
        addr: core::ffi::c_ulong,
        can_addr: *mut core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn is_kernel_percpu_address(addr: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn setup_per_cpu_areas();
}
extern "C" {
    pub fn __alloc_percpu_gfp(size: usize, align: usize, gfp: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __alloc_percpu(size: usize, align: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn free_percpu(__pdata: *mut core::ffi::c_void);
}
extern "C" {
    pub fn per_cpu_ptr_to_phys(addr: *mut core::ffi::c_void) -> phys_addr_t;
}
extern "C" {
    pub fn pcpu_nr_pages() -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rnd_state {
    pub s1: __u32,
    pub s2: __u32,
    pub s3: __u32,
    pub s4: __u32,
}
extern "C" {
    pub fn prandom_u32_state(state: *mut rnd_state) -> u32_;
}
extern "C" {
    pub fn prandom_bytes_state(state: *mut rnd_state, buf: *mut core::ffi::c_void, nbytes: usize);
}
extern "C" {
    pub fn prandom_seed_full_state(pcpu_state: *mut rnd_state);
}
extern "C" {
    pub fn random_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn random_online_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nodemask_t {
    pub bits: [core::ffi::c_ulong; 1usize],
}
extern "C" {
    pub static mut _unused_nodemask_arg_: nodemask_t;
}
pub const node_states_N_POSSIBLE: node_states = 0;
pub const node_states_N_ONLINE: node_states = 1;
pub const node_states_N_NORMAL_MEMORY: node_states = 2;
pub const node_states_N_HIGH_MEMORY: node_states = 2;
pub const node_states_N_MEMORY: node_states = 3;
pub const node_states_N_CPU: node_states = 4;
pub const node_states_N_GENERIC_INITIATOR: node_states = 5;
pub const node_states_NR_NODE_STATES: node_states = 6;
pub type node_states = core::ffi::c_uint;
extern "C" {
    pub static mut node_states: [nodemask_t; 6usize];
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nodemask_scratch {
    pub mask1: nodemask_t,
    pub mask2: nodemask_t,
}
pub const pageblock_bits_PB_migrate: pageblock_bits = 0;
pub const pageblock_bits_PB_migrate_end: pageblock_bits = 2;
pub const pageblock_bits_PB_migrate_skip: pageblock_bits = 3;
pub const pageblock_bits_NR_PAGEBLOCK_BITS: pageblock_bits = 4;
pub type pageblock_bits = core::ffi::c_uint;
extern "C" {
    pub fn get_pfnblock_flags_mask(
        page: *const page,
        pfn: core::ffi::c_ulong,
        mask: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn set_pfnblock_flags_mask(
        page: *mut page,
        flags: core::ffi::c_ulong,
        pfn: core::ffi::c_ulong,
        mask: core::ffi::c_ulong,
    );
}
pub const pageflags_PG_locked: pageflags = 0;
pub const pageflags_PG_referenced: pageflags = 1;
pub const pageflags_PG_uptodate: pageflags = 2;
pub const pageflags_PG_dirty: pageflags = 3;
pub const pageflags_PG_lru: pageflags = 4;
pub const pageflags_PG_active: pageflags = 5;
pub const pageflags_PG_workingset: pageflags = 6;
pub const pageflags_PG_waiters: pageflags = 7;
pub const pageflags_PG_error: pageflags = 8;
pub const pageflags_PG_slab: pageflags = 9;
pub const pageflags_PG_owner_priv_1: pageflags = 10;
pub const pageflags_PG_arch_1: pageflags = 11;
pub const pageflags_PG_reserved: pageflags = 12;
pub const pageflags_PG_private: pageflags = 13;
pub const pageflags_PG_private_2: pageflags = 14;
pub const pageflags_PG_writeback: pageflags = 15;
pub const pageflags_PG_head: pageflags = 16;
pub const pageflags_PG_mappedtodisk: pageflags = 17;
pub const pageflags_PG_reclaim: pageflags = 18;
pub const pageflags_PG_swapbacked: pageflags = 19;
pub const pageflags_PG_unevictable: pageflags = 20;
pub const pageflags_PG_mlocked: pageflags = 21;
pub const pageflags_PG_arch_2: pageflags = 22;
pub const pageflags___NR_PAGEFLAGS: pageflags = 23;
pub const pageflags_PG_readahead: pageflags = 18;
pub const pageflags_PG_anon_exclusive: pageflags = 17;
pub const pageflags_PG_checked: pageflags = 10;
pub const pageflags_PG_swapcache: pageflags = 10;
pub const pageflags_PG_fscache: pageflags = 14;
pub const pageflags_PG_pinned: pageflags = 10;
pub const pageflags_PG_savepinned: pageflags = 3;
pub const pageflags_PG_foreign: pageflags = 10;
pub const pageflags_PG_xen_remapped: pageflags = 10;
pub const pageflags_PG_slob_free: pageflags = 13;
pub const pageflags_PG_double_map: pageflags = 6;
pub const pageflags_PG_isolated: pageflags = 18;
pub const pageflags_PG_reported: pageflags = 2;
pub type pageflags = core::ffi::c_uint;
extern "C" {
    pub fn page_init_poison(page: *mut page, size: usize);
}
extern "C" {
    pub fn stable_page_flags(page: *mut page) -> u64_;
}
extern "C" {
    pub fn __folio_start_writeback(folio: *mut folio, keep_write: bool_) -> bool_;
}
extern "C" {
    pub fn set_page_writeback(page: *mut page) -> bool_;
}
extern "C" {
    pub fn PageHuge(page: *mut page) -> core::ffi::c_int;
}
extern "C" {
    pub fn PageHeadHuge(page: *mut page) -> core::ffi::c_int;
}
extern "C" {
    pub fn page_offline_freeze();
}
extern "C" {
    pub fn page_offline_thaw();
}
extern "C" {
    pub fn page_offline_begin();
}
extern "C" {
    pub fn page_offline_end();
}
extern "C" {
    pub fn is_free_buddy_page(page: *mut page) -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct local_lock_t {}
pub const migratetype_MIGRATE_UNMOVABLE: migratetype = 0;
pub const migratetype_MIGRATE_MOVABLE: migratetype = 1;
pub const migratetype_MIGRATE_RECLAIMABLE: migratetype = 2;
pub const migratetype_MIGRATE_PCPTYPES: migratetype = 3;
pub const migratetype_MIGRATE_HIGHATOMIC: migratetype = 3;
pub const migratetype_MIGRATE_TYPES: migratetype = 4;
pub type migratetype = core::ffi::c_uint;
extern "C" {
    pub static migratetype_names: [*const core::ffi::c_char; 4usize];
}
extern "C" {
    pub static mut page_group_by_mobility_disabled: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct free_area {
    pub free_list: [list_head; 4usize],
    pub nr_free: core::ffi::c_ulong,
}
impl Default for free_area {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const zone_stat_item_NR_FREE_PAGES: zone_stat_item = 0;
pub const zone_stat_item_NR_ZONE_LRU_BASE: zone_stat_item = 1;
pub const zone_stat_item_NR_ZONE_INACTIVE_ANON: zone_stat_item = 1;
pub const zone_stat_item_NR_ZONE_ACTIVE_ANON: zone_stat_item = 2;
pub const zone_stat_item_NR_ZONE_INACTIVE_FILE: zone_stat_item = 3;
pub const zone_stat_item_NR_ZONE_ACTIVE_FILE: zone_stat_item = 4;
pub const zone_stat_item_NR_ZONE_UNEVICTABLE: zone_stat_item = 5;
pub const zone_stat_item_NR_ZONE_WRITE_PENDING: zone_stat_item = 6;
pub const zone_stat_item_NR_MLOCK: zone_stat_item = 7;
pub const zone_stat_item_NR_BOUNCE: zone_stat_item = 8;
pub const zone_stat_item_NR_FREE_CMA_PAGES: zone_stat_item = 9;
pub const zone_stat_item_NR_VM_ZONE_STAT_ITEMS: zone_stat_item = 10;
pub type zone_stat_item = core::ffi::c_uint;
pub const node_stat_item_NR_LRU_BASE: node_stat_item = 0;
pub const node_stat_item_NR_INACTIVE_ANON: node_stat_item = 0;
pub const node_stat_item_NR_ACTIVE_ANON: node_stat_item = 1;
pub const node_stat_item_NR_INACTIVE_FILE: node_stat_item = 2;
pub const node_stat_item_NR_ACTIVE_FILE: node_stat_item = 3;
pub const node_stat_item_NR_UNEVICTABLE: node_stat_item = 4;
pub const node_stat_item_NR_SLAB_RECLAIMABLE_B: node_stat_item = 5;
pub const node_stat_item_NR_SLAB_UNRECLAIMABLE_B: node_stat_item = 6;
pub const node_stat_item_NR_ISOLATED_ANON: node_stat_item = 7;
pub const node_stat_item_NR_ISOLATED_FILE: node_stat_item = 8;
pub const node_stat_item_WORKINGSET_NODES: node_stat_item = 9;
pub const node_stat_item_WORKINGSET_REFAULT_BASE: node_stat_item = 10;
pub const node_stat_item_WORKINGSET_REFAULT_ANON: node_stat_item = 10;
pub const node_stat_item_WORKINGSET_REFAULT_FILE: node_stat_item = 11;
pub const node_stat_item_WORKINGSET_ACTIVATE_BASE: node_stat_item = 12;
pub const node_stat_item_WORKINGSET_ACTIVATE_ANON: node_stat_item = 12;
pub const node_stat_item_WORKINGSET_ACTIVATE_FILE: node_stat_item = 13;
pub const node_stat_item_WORKINGSET_RESTORE_BASE: node_stat_item = 14;
pub const node_stat_item_WORKINGSET_RESTORE_ANON: node_stat_item = 14;
pub const node_stat_item_WORKINGSET_RESTORE_FILE: node_stat_item = 15;
pub const node_stat_item_WORKINGSET_NODERECLAIM: node_stat_item = 16;
pub const node_stat_item_NR_ANON_MAPPED: node_stat_item = 17;
pub const node_stat_item_NR_FILE_MAPPED: node_stat_item = 18;
pub const node_stat_item_NR_FILE_PAGES: node_stat_item = 19;
pub const node_stat_item_NR_FILE_DIRTY: node_stat_item = 20;
pub const node_stat_item_NR_WRITEBACK: node_stat_item = 21;
pub const node_stat_item_NR_WRITEBACK_TEMP: node_stat_item = 22;
pub const node_stat_item_NR_SHMEM: node_stat_item = 23;
pub const node_stat_item_NR_SHMEM_THPS: node_stat_item = 24;
pub const node_stat_item_NR_SHMEM_PMDMAPPED: node_stat_item = 25;
pub const node_stat_item_NR_FILE_THPS: node_stat_item = 26;
pub const node_stat_item_NR_FILE_PMDMAPPED: node_stat_item = 27;
pub const node_stat_item_NR_ANON_THPS: node_stat_item = 28;
pub const node_stat_item_NR_VMSCAN_WRITE: node_stat_item = 29;
pub const node_stat_item_NR_VMSCAN_IMMEDIATE: node_stat_item = 30;
pub const node_stat_item_NR_DIRTIED: node_stat_item = 31;
pub const node_stat_item_NR_WRITTEN: node_stat_item = 32;
pub const node_stat_item_NR_THROTTLED_WRITTEN: node_stat_item = 33;
pub const node_stat_item_NR_KERNEL_MISC_RECLAIMABLE: node_stat_item = 34;
pub const node_stat_item_NR_FOLL_PIN_ACQUIRED: node_stat_item = 35;
pub const node_stat_item_NR_FOLL_PIN_RELEASED: node_stat_item = 36;
pub const node_stat_item_NR_KERNEL_STACK_KB: node_stat_item = 37;
pub const node_stat_item_NR_PAGETABLE: node_stat_item = 38;
pub const node_stat_item_NR_SECONDARY_PAGETABLE: node_stat_item = 39;
pub const node_stat_item_NR_SWAPCACHE: node_stat_item = 40;
pub const node_stat_item_NR_VM_NODE_STAT_ITEMS: node_stat_item = 41;
pub type node_stat_item = core::ffi::c_uint;
pub const lru_list_LRU_INACTIVE_ANON: lru_list = 0;
pub const lru_list_LRU_ACTIVE_ANON: lru_list = 1;
pub const lru_list_LRU_INACTIVE_FILE: lru_list = 2;
pub const lru_list_LRU_ACTIVE_FILE: lru_list = 3;
pub const lru_list_LRU_UNEVICTABLE: lru_list = 4;
pub const lru_list_NR_LRU_LISTS: lru_list = 5;
pub type lru_list = core::ffi::c_uint;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_WRITEBACK: vmscan_throttle_state = 0;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_ISOLATED: vmscan_throttle_state = 1;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_NOPROGRESS: vmscan_throttle_state = 2;
pub const vmscan_throttle_state_VMSCAN_THROTTLE_CONGESTED: vmscan_throttle_state = 3;
pub const vmscan_throttle_state_NR_VMSCAN_THROTTLE: vmscan_throttle_state = 4;
pub type vmscan_throttle_state = core::ffi::c_uint;
pub const lruvec_flags_LRUVEC_CONGESTED: lruvec_flags = 0;
pub type lruvec_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_vma_mapped_walk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec {
    pub lists: [list_head; 5usize],
    pub lru_lock: spinlock_t,
    pub anon_cost: core::ffi::c_ulong,
    pub file_cost: core::ffi::c_ulong,
    pub nonresident_age: atomic_long_t,
    pub refaults: [core::ffi::c_ulong; 2usize],
    pub flags: core::ffi::c_ulong,
    pub pgdat: *mut pglist_data,
}
impl Default for lruvec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type isolate_mode_t = core::ffi::c_uint;
pub const zone_watermarks_WMARK_MIN: zone_watermarks = 0;
pub const zone_watermarks_WMARK_LOW: zone_watermarks = 1;
pub const zone_watermarks_WMARK_HIGH: zone_watermarks = 2;
pub const zone_watermarks_WMARK_PROMO: zone_watermarks = 3;
pub const zone_watermarks_NR_WMARK: zone_watermarks = 4;
pub type zone_watermarks = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct per_cpu_pages {
    pub lock: spinlock_t,
    pub count: core::ffi::c_int,
    pub high: core::ffi::c_int,
    pub batch: core::ffi::c_int,
    pub free_factor: core::ffi::c_short,
    pub lists: [list_head; 12usize],
}
impl Default for per_cpu_pages {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct per_cpu_zonestat {
    pub vm_stat_diff: [s8; 10usize],
    pub stat_threshold: s8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct per_cpu_nodestat {
    pub stat_threshold: s8,
    pub vm_node_stat_diff: [s8; 41usize],
}
impl Default for per_cpu_nodestat {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const zone_type_ZONE_DMA32: zone_type = 0;
pub const zone_type_ZONE_NORMAL: zone_type = 1;
pub const zone_type_ZONE_MOVABLE: zone_type = 2;
pub const zone_type___MAX_NR_ZONES: zone_type = 3;
pub type zone_type = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
pub struct zone {
    pub _watermark: [core::ffi::c_ulong; 4usize],
    pub watermark_boost: core::ffi::c_ulong,
    pub nr_reserved_highatomic: core::ffi::c_ulong,
    pub lowmem_reserve: [core::ffi::c_long; 3usize],
    pub zone_pgdat: *mut pglist_data,
    pub per_cpu_pageset: *mut per_cpu_pages,
    pub per_cpu_zonestats: *mut per_cpu_zonestat,
    pub pageset_high: core::ffi::c_int,
    pub pageset_batch: core::ffi::c_int,
    pub pageblock_flags: *mut core::ffi::c_ulong,
    pub zone_start_pfn: core::ffi::c_ulong,
    pub managed_pages: atomic_long_t,
    pub spanned_pages: core::ffi::c_ulong,
    pub present_pages: core::ffi::c_ulong,
    pub name: *const core::ffi::c_char,
    pub initialized: core::ffi::c_int,
    pub __bindgen_padding_0: [u64; 4usize],
    pub _pad1_: cacheline_padding,
    pub free_area: [free_area; 11usize],
    pub flags: core::ffi::c_ulong,
    pub lock: spinlock_t,
    pub __bindgen_padding_1: u64,
    pub _pad2_: cacheline_padding,
    pub percpu_drift_mark: core::ffi::c_ulong,
    pub compact_cached_free_pfn: core::ffi::c_ulong,
    pub compact_cached_migrate_pfn: [core::ffi::c_ulong; 2usize],
    pub compact_init_migrate_pfn: core::ffi::c_ulong,
    pub compact_init_free_pfn: core::ffi::c_ulong,
    pub compact_considered: core::ffi::c_uint,
    pub compact_defer_shift: core::ffi::c_uint,
    pub compact_order_failed: core::ffi::c_int,
    pub compact_blockskip_flush: bool_,
    pub contiguous: bool_,
    pub __bindgen_padding_2: [u64; 0usize],
    pub _pad3_: cacheline_padding,
    pub vm_stat: [atomic_long_t; 10usize],
    pub vm_numa_event: __IncompleteArrayField<atomic_long_t>,
}
impl Default for zone {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const pgdat_flags_PGDAT_DIRTY: pgdat_flags = 0;
pub const pgdat_flags_PGDAT_WRITEBACK: pgdat_flags = 1;
pub const pgdat_flags_PGDAT_RECLAIM_LOCKED: pgdat_flags = 2;
pub type pgdat_flags = core::ffi::c_uint;
pub const zone_flags_ZONE_BOOSTED_WATERMARK: zone_flags = 0;
pub const zone_flags_ZONE_RECLAIM_ACTIVE: zone_flags = 1;
pub type zone_flags = core::ffi::c_uint;
pub const ZONELIST_FALLBACK: core::ffi::c_uint = 0;
pub const MAX_ZONELISTS: core::ffi::c_uint = 1;
pub type _bindgen_ty_9 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zoneref {
    pub zone: *mut zone,
    pub zone_idx: core::ffi::c_int,
}
impl Default for zoneref {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct zonelist {
    pub _zonerefs: [zoneref; 4usize],
}
impl Default for zonelist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut mem_map: *mut page;
}
#[repr(C)]
#[repr(align(64))]
pub struct pglist_data {
    pub node_zones: [zone; 3usize],
    pub node_zonelists: [zonelist; 1usize],
    pub nr_zones: core::ffi::c_int,
    pub node_mem_map: *mut page,
    pub node_start_pfn: core::ffi::c_ulong,
    pub node_present_pages: core::ffi::c_ulong,
    pub node_spanned_pages: core::ffi::c_ulong,
    pub node_id: core::ffi::c_int,
    pub kswapd_wait: wait_queue_head_t,
    pub pfmemalloc_wait: wait_queue_head_t,
    pub reclaim_wait: [wait_queue_head_t; 4usize],
    pub nr_writeback_throttled: atomic_t,
    pub nr_reclaim_start: core::ffi::c_ulong,
    pub kswapd: *mut task_struct,
    pub kswapd_order: core::ffi::c_int,
    pub kswapd_highest_zoneidx: zone_type,
    pub kswapd_failures: core::ffi::c_int,
    pub kcompactd_max_order: core::ffi::c_int,
    pub kcompactd_highest_zoneidx: zone_type,
    pub kcompactd_wait: wait_queue_head_t,
    pub kcompactd: *mut task_struct,
    pub proactive_compact_trigger: bool_,
    pub totalreserve_pages: core::ffi::c_ulong,
    pub __bindgen_padding_0: [u64; 6usize],
    pub _pad1_: cacheline_padding,
    pub __lruvec: lruvec,
    pub flags: core::ffi::c_ulong,
    pub __bindgen_padding_1: [u64; 3usize],
    pub _pad2_: cacheline_padding,
    pub per_cpu_nodestats: *mut per_cpu_nodestat,
    pub vm_stat: [atomic_long_t; 41usize],
}
impl Default for pglist_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type pg_data_t = pglist_data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_cblist {
    pub head: *mut callback_head,
    pub tail: *mut *mut callback_head,
    pub len: core::ffi::c_long,
}
impl Default for rcu_cblist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_segcblist {
    pub head: *mut callback_head,
    pub tails: [*mut *mut callback_head; 4usize],
    pub gp_seq: [core::ffi::c_ulong; 4usize],
    pub len: core::ffi::c_long,
    pub seglen: [core::ffi::c_long; 4usize],
    pub flags: u8_,
}
impl Default for rcu_segcblist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn init_srcu_struct(ssp: *mut srcu_struct) -> core::ffi::c_int;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct srcu_data {
    pub srcu_lock_count: [core::ffi::c_ulong; 2usize],
    pub srcu_unlock_count: [core::ffi::c_ulong; 2usize],
    pub __bindgen_padding_0: [u64; 4usize],
    pub lock: spinlock_t,
    pub srcu_cblist: rcu_segcblist,
    pub srcu_gp_seq_needed: core::ffi::c_ulong,
    pub srcu_gp_seq_needed_exp: core::ffi::c_ulong,
    pub srcu_cblist_invoking: bool_,
    pub delay_work: timer_list,
    pub work: work_struct,
    pub srcu_barrier_head: callback_head,
    pub mynode: *mut srcu_node,
    pub grpmask: core::ffi::c_ulong,
    pub cpu: core::ffi::c_int,
    pub ssp: *mut srcu_struct,
}
impl Default for srcu_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_node {
    pub lock: spinlock_t,
    pub srcu_have_cbs: [core::ffi::c_ulong; 4usize],
    pub srcu_data_have_cbs: [core::ffi::c_ulong; 4usize],
    pub srcu_gp_seq_needed_exp: core::ffi::c_ulong,
    pub srcu_parent: *mut srcu_node,
    pub grplo: core::ffi::c_int,
    pub grphi: core::ffi::c_int,
}
impl Default for srcu_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_struct {
    pub node: *mut srcu_node,
    pub level: [*mut srcu_node; 3usize],
    pub srcu_size_state: core::ffi::c_int,
    pub srcu_cb_mutex: mutex,
    pub lock: spinlock_t,
    pub srcu_gp_mutex: mutex,
    pub srcu_idx: core::ffi::c_uint,
    pub srcu_gp_seq: core::ffi::c_ulong,
    pub srcu_gp_seq_needed: core::ffi::c_ulong,
    pub srcu_gp_seq_needed_exp: core::ffi::c_ulong,
    pub srcu_gp_start: core::ffi::c_ulong,
    pub srcu_last_gp_end: core::ffi::c_ulong,
    pub srcu_size_jiffies: core::ffi::c_ulong,
    pub srcu_n_lock_retries: core::ffi::c_ulong,
    pub srcu_n_exp_nodelay: core::ffi::c_ulong,
    pub sda: *mut srcu_data,
    pub sda_is_static: bool_,
    pub srcu_barrier_seq: core::ffi::c_ulong,
    pub srcu_barrier_mutex: mutex,
    pub srcu_barrier_completion: completion,
    pub srcu_barrier_cpu_cnt: atomic_t,
    pub reschedule_jiffies: core::ffi::c_ulong,
    pub reschedule_count: core::ffi::c_ulong,
    pub work: delayed_work,
    pub dep_map: lockdep_map,
}
impl Default for srcu_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn synchronize_srcu_expedited(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn srcu_barrier(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn srcu_torture_stats_print(
        ssp: *mut srcu_struct,
        tt: *mut core::ffi::c_char,
        tf: *mut core::ffi::c_char,
    );
}
extern "C" {
    pub fn call_srcu(
        ssp: *mut srcu_struct,
        head: *mut callback_head,
        func: ::core::option::Option<unsafe extern "C" fn(head: *mut callback_head)>,
    );
}
extern "C" {
    pub fn cleanup_srcu_struct(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn __srcu_read_lock(ssp: *mut srcu_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn __srcu_read_unlock(ssp: *mut srcu_struct, idx: core::ffi::c_int);
}
extern "C" {
    pub fn synchronize_srcu(ssp: *mut srcu_struct);
}
extern "C" {
    pub fn get_state_synchronize_srcu(ssp: *mut srcu_struct) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn start_poll_synchronize_srcu(ssp: *mut srcu_struct) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn poll_state_synchronize_srcu(ssp: *mut srcu_struct, cookie: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn srcu_init();
}
pub type notifier_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        nb: *mut notifier_block,
        action: core::ffi::c_ulong,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct notifier_block {
    pub notifier_call: notifier_fn_t,
    pub next: *mut notifier_block,
    pub priority: core::ffi::c_int,
}
impl Default for notifier_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct atomic_notifier_head {
    pub lock: spinlock_t,
    pub head: *mut notifier_block,
}
impl Default for atomic_notifier_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blocking_notifier_head {
    pub rwsem: rw_semaphore,
    pub head: *mut notifier_block,
}
impl Default for blocking_notifier_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_notifier_head {
    pub head: *mut notifier_block,
}
impl Default for raw_notifier_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct srcu_notifier_head {
    pub mutex: mutex,
    pub srcu: srcu_struct,
    pub head: *mut notifier_block,
}
impl Default for srcu_notifier_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn srcu_init_notifier_head(nh: *mut srcu_notifier_head);
}
extern "C" {
    pub fn atomic_notifier_chain_register(
        nh: *mut atomic_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_register(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn raw_notifier_chain_register(
        nh: *mut raw_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn srcu_notifier_chain_register(
        nh: *mut srcu_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn atomic_notifier_chain_register_unique_prio(
        nh: *mut atomic_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_register_unique_prio(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn atomic_notifier_chain_unregister(
        nh: *mut atomic_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn blocking_notifier_chain_unregister(
        nh: *mut blocking_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn raw_notifier_chain_unregister(
        nh: *mut raw_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn srcu_notifier_chain_unregister(
        nh: *mut srcu_notifier_head,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn atomic_notifier_call_chain(
        nh: *mut atomic_notifier_head,
        val: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn blocking_notifier_call_chain(
        nh: *mut blocking_notifier_head,
        val: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn raw_notifier_call_chain(
        nh: *mut raw_notifier_head,
        val: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn srcu_notifier_call_chain(
        nh: *mut srcu_notifier_head,
        val: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn blocking_notifier_call_chain_robust(
        nh: *mut blocking_notifier_head,
        val_up: core::ffi::c_ulong,
        val_down: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn raw_notifier_call_chain_robust(
        nh: *mut raw_notifier_head,
        val_up: core::ffi::c_ulong,
        val_down: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn atomic_notifier_call_chain_is_empty(nh: *mut atomic_notifier_head) -> bool_;
}
extern "C" {
    pub static mut reboot_notifier_list: blocking_notifier_head;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_section {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memory_group {
    _unused: [u8; 0],
}
extern "C" {
    pub fn arch_get_mappable_range() -> range;
}
extern "C" {
    pub fn set_zone_contiguous(zone: *mut zone);
}
extern "C" {
    pub fn clear_zone_contiguous(zone: *mut zone);
}
extern "C" {
    pub fn build_all_zonelists(pgdat: *mut pg_data_t);
}
extern "C" {
    pub fn wakeup_kswapd(
        zone: *mut zone,
        gfp_mask: gfp_t,
        order: core::ffi::c_int,
        highest_zoneidx: zone_type,
    );
}
extern "C" {
    pub fn __zone_watermark_ok(
        z: *mut zone,
        order: core::ffi::c_uint,
        mark: core::ffi::c_ulong,
        highest_zoneidx: core::ffi::c_int,
        alloc_flags: core::ffi::c_uint,
        free_pages: core::ffi::c_long,
    ) -> bool_;
}
extern "C" {
    pub fn zone_watermark_ok(
        z: *mut zone,
        order: core::ffi::c_uint,
        mark: core::ffi::c_ulong,
        highest_zoneidx: core::ffi::c_int,
        alloc_flags: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn zone_watermark_ok_safe(
        z: *mut zone,
        order: core::ffi::c_uint,
        mark: core::ffi::c_ulong,
        highest_zoneidx: core::ffi::c_int,
    ) -> bool_;
}
pub const meminit_context_MEMINIT_EARLY: meminit_context = 0;
pub const meminit_context_MEMINIT_HOTPLUG: meminit_context = 1;
pub type meminit_context = core::ffi::c_uint;
extern "C" {
    pub fn init_currently_empty_zone(
        zone: *mut zone,
        start_pfn: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn lruvec_init(lruvec: *mut lruvec);
}
extern "C" {
    pub static mut movable_zone: core::ffi::c_int;
}
extern "C" {
    pub fn min_free_kbytes_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn watermark_scale_factor_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_lowmem_reserve_ratio: [core::ffi::c_int; 3usize];
}
extern "C" {
    pub fn lowmem_reserve_ratio_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn percpu_pagelist_high_fraction_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysctl_min_unmapped_ratio_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysctl_min_slab_ratio_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn numa_zonelist_order_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut percpu_pagelist_high_fraction: core::ffi::c_int;
}
extern "C" {
    pub static mut numa_zonelist_order: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut contig_page_data: pglist_data;
}
extern "C" {
    pub fn first_online_pgdat() -> *mut pglist_data;
}
extern "C" {
    pub fn next_online_pgdat(pgdat: *mut pglist_data) -> *mut pglist_data;
}
extern "C" {
    pub fn next_zone(zone: *mut zone) -> *mut zone;
}
extern "C" {
    pub fn __next_zones_zonelist(
        z: *mut zoneref,
        highest_zoneidx: zone_type,
        nodes: *mut nodemask_t,
    ) -> *mut zoneref;
}
extern "C" {
    pub fn topology_normalize_cpu_scale();
}
extern "C" {
    pub fn topology_update_cpu_topology() -> core::ffi::c_int;
}
extern "C" {
    pub fn topology_parse_cpu_capacity(cpu_node: *mut device_node, cpu: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub static mut cpu_scale: core::ffi::c_ulong;
}
extern "C" {
    pub fn topology_set_cpu_scale(cpu: core::ffi::c_uint, capacity: core::ffi::c_ulong);
}
extern "C" {
    pub static mut arch_freq_scale: core::ffi::c_ulong;
}
extern "C" {
    pub fn topology_set_freq_scale(
        cpus: *const cpumask,
        cur_freq: core::ffi::c_ulong,
        max_freq: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn topology_scale_freq_invariant() -> bool_;
}
pub const scale_freq_source_SCALE_FREQ_SOURCE_CPUFREQ: scale_freq_source = 0;
pub const scale_freq_source_SCALE_FREQ_SOURCE_ARCH: scale_freq_source = 1;
pub const scale_freq_source_SCALE_FREQ_SOURCE_CPPC: scale_freq_source = 2;
pub type scale_freq_source = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct scale_freq_data {
    pub source: scale_freq_source,
    pub set_freq_scale: ::core::option::Option<unsafe extern "C" fn()>,
}
impl Default for scale_freq_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn topology_scale_freq_tick();
}
extern "C" {
    pub fn topology_set_scale_freq_source(data: *mut scale_freq_data, cpus: *const cpumask);
}
extern "C" {
    pub fn topology_clear_scale_freq_source(source: scale_freq_source, cpus: *const cpumask);
}
extern "C" {
    pub static mut thermal_pressure: core::ffi::c_ulong;
}
extern "C" {
    pub fn topology_update_thermal_pressure(cpus: *const cpumask, capped_freq: core::ffi::c_ulong);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_topology {
    pub thread_id: core::ffi::c_int,
    pub core_id: core::ffi::c_int,
    pub cluster_id: core::ffi::c_int,
    pub package_id: core::ffi::c_int,
    pub thread_sibling: cpumask_t,
    pub core_sibling: cpumask_t,
    pub cluster_sibling: cpumask_t,
    pub llc_sibling: cpumask_t,
}
extern "C" {
    pub static mut cpu_topology: [cpu_topology; 64usize];
}
extern "C" {
    pub fn init_cpu_topology();
}
extern "C" {
    pub fn store_cpu_topology(cpuid: core::ffi::c_uint);
}
extern "C" {
    pub fn cpu_coregroup_mask(cpu: core::ffi::c_int) -> *const cpumask;
}
extern "C" {
    pub fn cpu_clustergroup_mask(cpu: core::ffi::c_int) -> *const cpumask;
}
extern "C" {
    pub fn update_siblings_masks(cpu: core::ffi::c_uint);
}
extern "C" {
    pub fn remove_cpu_topology(cpuid: core::ffi::c_uint);
}
extern "C" {
    pub fn reset_cpu_topology();
}
extern "C" {
    pub fn parse_acpi_topology() -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_update_cpu_topology() -> core::ffi::c_int;
}
extern "C" {
    pub static mut node_reclaim_distance: core::ffi::c_int;
}
extern "C" {
    pub fn __alloc_pages(
        gfp: gfp_t,
        order: core::ffi::c_uint,
        preferred_nid: core::ffi::c_int,
        nodemask: *mut nodemask_t,
    ) -> *mut page;
}
extern "C" {
    pub fn __folio_alloc(
        gfp: gfp_t,
        order: core::ffi::c_uint,
        preferred_nid: core::ffi::c_int,
        nodemask: *mut nodemask_t,
    ) -> *mut folio;
}
extern "C" {
    pub fn __alloc_pages_bulk(
        gfp: gfp_t,
        preferred_nid: core::ffi::c_int,
        nodemask: *mut nodemask_t,
        nr_pages: core::ffi::c_int,
        page_list: *mut list_head,
        page_array: *mut *mut page,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn alloc_pages_bulk_array_mempolicy(
        gfp: gfp_t,
        nr_pages: core::ffi::c_ulong,
        page_array: *mut *mut page,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __get_free_pages(gfp_mask: gfp_t, order: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn get_zeroed_page(gfp_mask: gfp_t) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn alloc_pages_exact(size: usize, gfp_mask: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn free_pages_exact(virt: *mut core::ffi::c_void, size: usize);
}
extern "C" {
    pub fn alloc_pages_exact_nid(
        nid: core::ffi::c_int,
        size: usize,
        gfp_mask: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __free_pages(page: *mut page, order: core::ffi::c_uint);
}
extern "C" {
    pub fn free_pages(addr: core::ffi::c_ulong, order: core::ffi::c_uint);
}
extern "C" {
    pub fn __page_frag_cache_drain(page: *mut page, count: core::ffi::c_uint);
}
extern "C" {
    pub fn page_frag_alloc_align(
        nc: *mut page_frag_cache,
        fragsz: core::ffi::c_uint,
        gfp_mask: gfp_t,
        align_mask: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn page_frag_free(addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn page_alloc_init();
}
extern "C" {
    pub fn drain_zone_pages(zone: *mut zone, pcp: *mut per_cpu_pages);
}
extern "C" {
    pub fn drain_all_pages(zone: *mut zone);
}
extern "C" {
    pub fn drain_local_pages(zone: *mut zone);
}
extern "C" {
    pub fn page_alloc_init_late();
}
extern "C" {
    pub static mut gfp_allowed_mask: gfp_t;
}
extern "C" {
    pub fn gfp_pfmemalloc_allowed(gfp_mask: gfp_t) -> bool_;
}
extern "C" {
    pub fn pm_restrict_gfp_mask();
}
extern "C" {
    pub fn pm_restore_gfp_mask();
}
extern "C" {
    pub fn vma_thp_gfp_mask(vma: *mut vm_area_struct) -> gfp_t;
}
extern "C" {
    pub fn free_contig_range(pfn: core::ffi::c_ulong, nr_pages: core::ffi::c_ulong);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sysctl_args {
    pub name: *mut core::ffi::c_int,
    pub nlen: core::ffi::c_int,
    pub oldval: *mut core::ffi::c_void,
    pub oldlenp: *mut usize,
    pub newval: *mut core::ffi::c_void,
    pub newlen: usize,
    pub __unused: [core::ffi::c_ulong; 4usize],
}
impl Default for __sysctl_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const CTL_KERN: core::ffi::c_uint = 1;
pub const CTL_VM: core::ffi::c_uint = 2;
pub const CTL_NET: core::ffi::c_uint = 3;
pub const CTL_PROC: core::ffi::c_uint = 4;
pub const CTL_FS: core::ffi::c_uint = 5;
pub const CTL_DEBUG: core::ffi::c_uint = 6;
pub const CTL_DEV: core::ffi::c_uint = 7;
pub const CTL_BUS: core::ffi::c_uint = 8;
pub const CTL_ABI: core::ffi::c_uint = 9;
pub const CTL_CPU: core::ffi::c_uint = 10;
pub const CTL_ARLAN: core::ffi::c_uint = 254;
pub const CTL_S390DBF: core::ffi::c_uint = 5677;
pub const CTL_SUNRPC: core::ffi::c_uint = 7249;
pub const CTL_PM: core::ffi::c_uint = 9899;
pub const CTL_FRV: core::ffi::c_uint = 9898;
pub type _bindgen_ty_10 = core::ffi::c_uint;
pub const CTL_BUS_ISA: core::ffi::c_uint = 1;
pub type _bindgen_ty_11 = core::ffi::c_uint;
pub const INOTIFY_MAX_USER_INSTANCES: core::ffi::c_uint = 1;
pub const INOTIFY_MAX_USER_WATCHES: core::ffi::c_uint = 2;
pub const INOTIFY_MAX_QUEUED_EVENTS: core::ffi::c_uint = 3;
pub type _bindgen_ty_12 = core::ffi::c_uint;
pub const KERN_OSTYPE: core::ffi::c_uint = 1;
pub const KERN_OSRELEASE: core::ffi::c_uint = 2;
pub const KERN_OSREV: core::ffi::c_uint = 3;
pub const KERN_VERSION: core::ffi::c_uint = 4;
pub const KERN_SECUREMASK: core::ffi::c_uint = 5;
pub const KERN_PROF: core::ffi::c_uint = 6;
pub const KERN_NODENAME: core::ffi::c_uint = 7;
pub const KERN_DOMAINNAME: core::ffi::c_uint = 8;
pub const KERN_PANIC: core::ffi::c_uint = 15;
pub const KERN_REALROOTDEV: core::ffi::c_uint = 16;
pub const KERN_SPARC_REBOOT: core::ffi::c_uint = 21;
pub const KERN_CTLALTDEL: core::ffi::c_uint = 22;
pub const KERN_PRINTK: core::ffi::c_uint = 23;
pub const KERN_NAMETRANS: core::ffi::c_uint = 24;
pub const KERN_PPC_HTABRECLAIM: core::ffi::c_uint = 25;
pub const KERN_PPC_ZEROPAGED: core::ffi::c_uint = 26;
pub const KERN_PPC_POWERSAVE_NAP: core::ffi::c_uint = 27;
pub const KERN_MODPROBE: core::ffi::c_uint = 28;
pub const KERN_SG_BIG_BUFF: core::ffi::c_uint = 29;
pub const KERN_ACCT: core::ffi::c_uint = 30;
pub const KERN_PPC_L2CR: core::ffi::c_uint = 31;
pub const KERN_RTSIGNR: core::ffi::c_uint = 32;
pub const KERN_RTSIGMAX: core::ffi::c_uint = 33;
pub const KERN_SHMMAX: core::ffi::c_uint = 34;
pub const KERN_MSGMAX: core::ffi::c_uint = 35;
pub const KERN_MSGMNB: core::ffi::c_uint = 36;
pub const KERN_MSGPOOL: core::ffi::c_uint = 37;
pub const KERN_SYSRQ: core::ffi::c_uint = 38;
pub const KERN_MAX_THREADS: core::ffi::c_uint = 39;
pub const KERN_RANDOM: core::ffi::c_uint = 40;
pub const KERN_SHMALL: core::ffi::c_uint = 41;
pub const KERN_MSGMNI: core::ffi::c_uint = 42;
pub const KERN_SEM: core::ffi::c_uint = 43;
pub const KERN_SPARC_STOP_A: core::ffi::c_uint = 44;
pub const KERN_SHMMNI: core::ffi::c_uint = 45;
pub const KERN_OVERFLOWUID: core::ffi::c_uint = 46;
pub const KERN_OVERFLOWGID: core::ffi::c_uint = 47;
pub const KERN_SHMPATH: core::ffi::c_uint = 48;
pub const KERN_HOTPLUG: core::ffi::c_uint = 49;
pub const KERN_IEEE_EMULATION_WARNINGS: core::ffi::c_uint = 50;
pub const KERN_S390_USER_DEBUG_LOGGING: core::ffi::c_uint = 51;
pub const KERN_CORE_USES_PID: core::ffi::c_uint = 52;
pub const KERN_TAINTED: core::ffi::c_uint = 53;
pub const KERN_CADPID: core::ffi::c_uint = 54;
pub const KERN_PIDMAX: core::ffi::c_uint = 55;
pub const KERN_CORE_PATTERN: core::ffi::c_uint = 56;
pub const KERN_PANIC_ON_OOPS: core::ffi::c_uint = 57;
pub const KERN_HPPA_PWRSW: core::ffi::c_uint = 58;
pub const KERN_HPPA_UNALIGNED: core::ffi::c_uint = 59;
pub const KERN_PRINTK_RATELIMIT: core::ffi::c_uint = 60;
pub const KERN_PRINTK_RATELIMIT_BURST: core::ffi::c_uint = 61;
pub const KERN_PTY: core::ffi::c_uint = 62;
pub const KERN_NGROUPS_MAX: core::ffi::c_uint = 63;
pub const KERN_SPARC_SCONS_PWROFF: core::ffi::c_uint = 64;
pub const KERN_HZ_TIMER: core::ffi::c_uint = 65;
pub const KERN_UNKNOWN_NMI_PANIC: core::ffi::c_uint = 66;
pub const KERN_BOOTLOADER_TYPE: core::ffi::c_uint = 67;
pub const KERN_RANDOMIZE: core::ffi::c_uint = 68;
pub const KERN_SETUID_DUMPABLE: core::ffi::c_uint = 69;
pub const KERN_SPIN_RETRY: core::ffi::c_uint = 70;
pub const KERN_ACPI_VIDEO_FLAGS: core::ffi::c_uint = 71;
pub const KERN_IA64_UNALIGNED: core::ffi::c_uint = 72;
pub const KERN_COMPAT_LOG: core::ffi::c_uint = 73;
pub const KERN_MAX_LOCK_DEPTH: core::ffi::c_uint = 74;
pub const KERN_NMI_WATCHDOG: core::ffi::c_uint = 75;
pub const KERN_PANIC_ON_NMI: core::ffi::c_uint = 76;
pub const KERN_PANIC_ON_WARN: core::ffi::c_uint = 77;
pub const KERN_PANIC_PRINT: core::ffi::c_uint = 78;
pub type _bindgen_ty_13 = core::ffi::c_uint;
pub const VM_UNUSED1: core::ffi::c_uint = 1;
pub const VM_UNUSED2: core::ffi::c_uint = 2;
pub const VM_UNUSED3: core::ffi::c_uint = 3;
pub const VM_UNUSED4: core::ffi::c_uint = 4;
pub const VM_OVERCOMMIT_MEMORY: core::ffi::c_uint = 5;
pub const VM_UNUSED5: core::ffi::c_uint = 6;
pub const VM_UNUSED7: core::ffi::c_uint = 7;
pub const VM_UNUSED8: core::ffi::c_uint = 8;
pub const VM_UNUSED9: core::ffi::c_uint = 9;
pub const VM_PAGE_CLUSTER: core::ffi::c_uint = 10;
pub const VM_DIRTY_BACKGROUND: core::ffi::c_uint = 11;
pub const VM_DIRTY_RATIO: core::ffi::c_uint = 12;
pub const VM_DIRTY_WB_CS: core::ffi::c_uint = 13;
pub const VM_DIRTY_EXPIRE_CS: core::ffi::c_uint = 14;
pub const VM_NR_PDFLUSH_THREADS: core::ffi::c_uint = 15;
pub const VM_OVERCOMMIT_RATIO: core::ffi::c_uint = 16;
pub const VM_PAGEBUF: core::ffi::c_uint = 17;
pub const VM_HUGETLB_PAGES: core::ffi::c_uint = 18;
pub const VM_SWAPPINESS: core::ffi::c_uint = 19;
pub const VM_LOWMEM_RESERVE_RATIO: core::ffi::c_uint = 20;
pub const VM_MIN_FREE_KBYTES: core::ffi::c_uint = 21;
pub const VM_MAX_MAP_COUNT: core::ffi::c_uint = 22;
pub const VM_LAPTOP_MODE: core::ffi::c_uint = 23;
pub const VM_BLOCK_DUMP: core::ffi::c_uint = 24;
pub const VM_HUGETLB_GROUP: core::ffi::c_uint = 25;
pub const VM_VFS_CACHE_PRESSURE: core::ffi::c_uint = 26;
pub const VM_LEGACY_VA_LAYOUT: core::ffi::c_uint = 27;
pub const VM_SWAP_TOKEN_TIMEOUT: core::ffi::c_uint = 28;
pub const VM_DROP_PAGECACHE: core::ffi::c_uint = 29;
pub const VM_PERCPU_PAGELIST_FRACTION: core::ffi::c_uint = 30;
pub const VM_ZONE_RECLAIM_MODE: core::ffi::c_uint = 31;
pub const VM_MIN_UNMAPPED: core::ffi::c_uint = 32;
pub const VM_PANIC_ON_OOM: core::ffi::c_uint = 33;
pub const VM_VDSO_ENABLED: core::ffi::c_uint = 34;
pub const VM_MIN_SLAB: core::ffi::c_uint = 35;
pub type _bindgen_ty_14 = core::ffi::c_uint;
pub const NET_CORE: core::ffi::c_uint = 1;
pub const NET_ETHER: core::ffi::c_uint = 2;
pub const NET_802: core::ffi::c_uint = 3;
pub const NET_UNIX: core::ffi::c_uint = 4;
pub const NET_IPV4: core::ffi::c_uint = 5;
pub const NET_IPX: core::ffi::c_uint = 6;
pub const NET_ATALK: core::ffi::c_uint = 7;
pub const NET_NETROM: core::ffi::c_uint = 8;
pub const NET_AX25: core::ffi::c_uint = 9;
pub const NET_BRIDGE: core::ffi::c_uint = 10;
pub const NET_ROSE: core::ffi::c_uint = 11;
pub const NET_IPV6: core::ffi::c_uint = 12;
pub const NET_X25: core::ffi::c_uint = 13;
pub const NET_TR: core::ffi::c_uint = 14;
pub const NET_DECNET: core::ffi::c_uint = 15;
pub const NET_ECONET: core::ffi::c_uint = 16;
pub const NET_SCTP: core::ffi::c_uint = 17;
pub const NET_LLC: core::ffi::c_uint = 18;
pub const NET_NETFILTER: core::ffi::c_uint = 19;
pub const NET_DCCP: core::ffi::c_uint = 20;
pub const NET_IRDA: core::ffi::c_uint = 412;
pub type _bindgen_ty_15 = core::ffi::c_uint;
pub const RANDOM_POOLSIZE: core::ffi::c_uint = 1;
pub const RANDOM_ENTROPY_COUNT: core::ffi::c_uint = 2;
pub const RANDOM_READ_THRESH: core::ffi::c_uint = 3;
pub const RANDOM_WRITE_THRESH: core::ffi::c_uint = 4;
pub const RANDOM_BOOT_ID: core::ffi::c_uint = 5;
pub const RANDOM_UUID: core::ffi::c_uint = 6;
pub type _bindgen_ty_16 = core::ffi::c_uint;
pub const PTY_MAX: core::ffi::c_uint = 1;
pub const PTY_NR: core::ffi::c_uint = 2;
pub type _bindgen_ty_17 = core::ffi::c_uint;
pub const BUS_ISA_MEM_BASE: core::ffi::c_uint = 1;
pub const BUS_ISA_PORT_BASE: core::ffi::c_uint = 2;
pub const BUS_ISA_PORT_SHIFT: core::ffi::c_uint = 3;
pub type _bindgen_ty_18 = core::ffi::c_uint;
pub const NET_CORE_WMEM_MAX: core::ffi::c_uint = 1;
pub const NET_CORE_RMEM_MAX: core::ffi::c_uint = 2;
pub const NET_CORE_WMEM_DEFAULT: core::ffi::c_uint = 3;
pub const NET_CORE_RMEM_DEFAULT: core::ffi::c_uint = 4;
pub const NET_CORE_MAX_BACKLOG: core::ffi::c_uint = 6;
pub const NET_CORE_FASTROUTE: core::ffi::c_uint = 7;
pub const NET_CORE_MSG_COST: core::ffi::c_uint = 8;
pub const NET_CORE_MSG_BURST: core::ffi::c_uint = 9;
pub const NET_CORE_OPTMEM_MAX: core::ffi::c_uint = 10;
pub const NET_CORE_HOT_LIST_LENGTH: core::ffi::c_uint = 11;
pub const NET_CORE_DIVERT_VERSION: core::ffi::c_uint = 12;
pub const NET_CORE_NO_CONG_THRESH: core::ffi::c_uint = 13;
pub const NET_CORE_NO_CONG: core::ffi::c_uint = 14;
pub const NET_CORE_LO_CONG: core::ffi::c_uint = 15;
pub const NET_CORE_MOD_CONG: core::ffi::c_uint = 16;
pub const NET_CORE_DEV_WEIGHT: core::ffi::c_uint = 17;
pub const NET_CORE_SOMAXCONN: core::ffi::c_uint = 18;
pub const NET_CORE_BUDGET: core::ffi::c_uint = 19;
pub const NET_CORE_AEVENT_ETIME: core::ffi::c_uint = 20;
pub const NET_CORE_AEVENT_RSEQTH: core::ffi::c_uint = 21;
pub const NET_CORE_WARNINGS: core::ffi::c_uint = 22;
pub type _bindgen_ty_19 = core::ffi::c_uint;
pub const NET_UNIX_DESTROY_DELAY: core::ffi::c_uint = 1;
pub const NET_UNIX_DELETE_DELAY: core::ffi::c_uint = 2;
pub const NET_UNIX_MAX_DGRAM_QLEN: core::ffi::c_uint = 3;
pub type _bindgen_ty_20 = core::ffi::c_uint;
pub const NET_NF_CONNTRACK_MAX: core::ffi::c_uint = 1;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT: core::ffi::c_uint = 2;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV: core::ffi::c_uint = 3;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED: core::ffi::c_uint = 4;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT: core::ffi::c_uint = 5;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT: core::ffi::c_uint = 6;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK: core::ffi::c_uint = 7;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT: core::ffi::c_uint = 8;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_CLOSE: core::ffi::c_uint = 9;
pub const NET_NF_CONNTRACK_UDP_TIMEOUT: core::ffi::c_uint = 10;
pub const NET_NF_CONNTRACK_UDP_TIMEOUT_STREAM: core::ffi::c_uint = 11;
pub const NET_NF_CONNTRACK_ICMP_TIMEOUT: core::ffi::c_uint = 12;
pub const NET_NF_CONNTRACK_GENERIC_TIMEOUT: core::ffi::c_uint = 13;
pub const NET_NF_CONNTRACK_BUCKETS: core::ffi::c_uint = 14;
pub const NET_NF_CONNTRACK_LOG_INVALID: core::ffi::c_uint = 15;
pub const NET_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS: core::ffi::c_uint = 16;
pub const NET_NF_CONNTRACK_TCP_LOOSE: core::ffi::c_uint = 17;
pub const NET_NF_CONNTRACK_TCP_BE_LIBERAL: core::ffi::c_uint = 18;
pub const NET_NF_CONNTRACK_TCP_MAX_RETRANS: core::ffi::c_uint = 19;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED: core::ffi::c_uint = 20;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT: core::ffi::c_uint = 21;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED: core::ffi::c_uint = 22;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED: core::ffi::c_uint = 23;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT: core::ffi::c_uint = 24;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD: core::ffi::c_uint = 25;
pub const NET_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT: core::ffi::c_uint = 26;
pub const NET_NF_CONNTRACK_COUNT: core::ffi::c_uint = 27;
pub const NET_NF_CONNTRACK_ICMPV6_TIMEOUT: core::ffi::c_uint = 28;
pub const NET_NF_CONNTRACK_FRAG6_TIMEOUT: core::ffi::c_uint = 29;
pub const NET_NF_CONNTRACK_FRAG6_LOW_THRESH: core::ffi::c_uint = 30;
pub const NET_NF_CONNTRACK_FRAG6_HIGH_THRESH: core::ffi::c_uint = 31;
pub const NET_NF_CONNTRACK_CHECKSUM: core::ffi::c_uint = 32;
pub type _bindgen_ty_21 = core::ffi::c_uint;
pub const NET_IPV4_FORWARD: core::ffi::c_uint = 8;
pub const NET_IPV4_DYNADDR: core::ffi::c_uint = 9;
pub const NET_IPV4_CONF: core::ffi::c_uint = 16;
pub const NET_IPV4_NEIGH: core::ffi::c_uint = 17;
pub const NET_IPV4_ROUTE: core::ffi::c_uint = 18;
pub const NET_IPV4_FIB_HASH: core::ffi::c_uint = 19;
pub const NET_IPV4_NETFILTER: core::ffi::c_uint = 20;
pub const NET_IPV4_TCP_TIMESTAMPS: core::ffi::c_uint = 33;
pub const NET_IPV4_TCP_WINDOW_SCALING: core::ffi::c_uint = 34;
pub const NET_IPV4_TCP_SACK: core::ffi::c_uint = 35;
pub const NET_IPV4_TCP_RETRANS_COLLAPSE: core::ffi::c_uint = 36;
pub const NET_IPV4_DEFAULT_TTL: core::ffi::c_uint = 37;
pub const NET_IPV4_AUTOCONFIG: core::ffi::c_uint = 38;
pub const NET_IPV4_NO_PMTU_DISC: core::ffi::c_uint = 39;
pub const NET_IPV4_TCP_SYN_RETRIES: core::ffi::c_uint = 40;
pub const NET_IPV4_IPFRAG_HIGH_THRESH: core::ffi::c_uint = 41;
pub const NET_IPV4_IPFRAG_LOW_THRESH: core::ffi::c_uint = 42;
pub const NET_IPV4_IPFRAG_TIME: core::ffi::c_uint = 43;
pub const NET_IPV4_TCP_MAX_KA_PROBES: core::ffi::c_uint = 44;
pub const NET_IPV4_TCP_KEEPALIVE_TIME: core::ffi::c_uint = 45;
pub const NET_IPV4_TCP_KEEPALIVE_PROBES: core::ffi::c_uint = 46;
pub const NET_IPV4_TCP_RETRIES1: core::ffi::c_uint = 47;
pub const NET_IPV4_TCP_RETRIES2: core::ffi::c_uint = 48;
pub const NET_IPV4_TCP_FIN_TIMEOUT: core::ffi::c_uint = 49;
pub const NET_IPV4_IP_MASQ_DEBUG: core::ffi::c_uint = 50;
pub const NET_TCP_SYNCOOKIES: core::ffi::c_uint = 51;
pub const NET_TCP_STDURG: core::ffi::c_uint = 52;
pub const NET_TCP_RFC1337: core::ffi::c_uint = 53;
pub const NET_TCP_SYN_TAILDROP: core::ffi::c_uint = 54;
pub const NET_TCP_MAX_SYN_BACKLOG: core::ffi::c_uint = 55;
pub const NET_IPV4_LOCAL_PORT_RANGE: core::ffi::c_uint = 56;
pub const NET_IPV4_ICMP_ECHO_IGNORE_ALL: core::ffi::c_uint = 57;
pub const NET_IPV4_ICMP_ECHO_IGNORE_BROADCASTS: core::ffi::c_uint = 58;
pub const NET_IPV4_ICMP_SOURCEQUENCH_RATE: core::ffi::c_uint = 59;
pub const NET_IPV4_ICMP_DESTUNREACH_RATE: core::ffi::c_uint = 60;
pub const NET_IPV4_ICMP_TIMEEXCEED_RATE: core::ffi::c_uint = 61;
pub const NET_IPV4_ICMP_PARAMPROB_RATE: core::ffi::c_uint = 62;
pub const NET_IPV4_ICMP_ECHOREPLY_RATE: core::ffi::c_uint = 63;
pub const NET_IPV4_ICMP_IGNORE_BOGUS_ERROR_RESPONSES: core::ffi::c_uint = 64;
pub const NET_IPV4_IGMP_MAX_MEMBERSHIPS: core::ffi::c_uint = 65;
pub const NET_TCP_TW_RECYCLE: core::ffi::c_uint = 66;
pub const NET_IPV4_ALWAYS_DEFRAG: core::ffi::c_uint = 67;
pub const NET_IPV4_TCP_KEEPALIVE_INTVL: core::ffi::c_uint = 68;
pub const NET_IPV4_INET_PEER_THRESHOLD: core::ffi::c_uint = 69;
pub const NET_IPV4_INET_PEER_MINTTL: core::ffi::c_uint = 70;
pub const NET_IPV4_INET_PEER_MAXTTL: core::ffi::c_uint = 71;
pub const NET_IPV4_INET_PEER_GC_MINTIME: core::ffi::c_uint = 72;
pub const NET_IPV4_INET_PEER_GC_MAXTIME: core::ffi::c_uint = 73;
pub const NET_TCP_ORPHAN_RETRIES: core::ffi::c_uint = 74;
pub const NET_TCP_ABORT_ON_OVERFLOW: core::ffi::c_uint = 75;
pub const NET_TCP_SYNACK_RETRIES: core::ffi::c_uint = 76;
pub const NET_TCP_MAX_ORPHANS: core::ffi::c_uint = 77;
pub const NET_TCP_MAX_TW_BUCKETS: core::ffi::c_uint = 78;
pub const NET_TCP_FACK: core::ffi::c_uint = 79;
pub const NET_TCP_REORDERING: core::ffi::c_uint = 80;
pub const NET_TCP_ECN: core::ffi::c_uint = 81;
pub const NET_TCP_DSACK: core::ffi::c_uint = 82;
pub const NET_TCP_MEM: core::ffi::c_uint = 83;
pub const NET_TCP_WMEM: core::ffi::c_uint = 84;
pub const NET_TCP_RMEM: core::ffi::c_uint = 85;
pub const NET_TCP_APP_WIN: core::ffi::c_uint = 86;
pub const NET_TCP_ADV_WIN_SCALE: core::ffi::c_uint = 87;
pub const NET_IPV4_NONLOCAL_BIND: core::ffi::c_uint = 88;
pub const NET_IPV4_ICMP_RATELIMIT: core::ffi::c_uint = 89;
pub const NET_IPV4_ICMP_RATEMASK: core::ffi::c_uint = 90;
pub const NET_TCP_TW_REUSE: core::ffi::c_uint = 91;
pub const NET_TCP_FRTO: core::ffi::c_uint = 92;
pub const NET_TCP_LOW_LATENCY: core::ffi::c_uint = 93;
pub const NET_IPV4_IPFRAG_SECRET_INTERVAL: core::ffi::c_uint = 94;
pub const NET_IPV4_IGMP_MAX_MSF: core::ffi::c_uint = 96;
pub const NET_TCP_NO_METRICS_SAVE: core::ffi::c_uint = 97;
pub const NET_TCP_DEFAULT_WIN_SCALE: core::ffi::c_uint = 105;
pub const NET_TCP_MODERATE_RCVBUF: core::ffi::c_uint = 106;
pub const NET_TCP_TSO_WIN_DIVISOR: core::ffi::c_uint = 107;
pub const NET_TCP_BIC_BETA: core::ffi::c_uint = 108;
pub const NET_IPV4_ICMP_ERRORS_USE_INBOUND_IFADDR: core::ffi::c_uint = 109;
pub const NET_TCP_CONG_CONTROL: core::ffi::c_uint = 110;
pub const NET_TCP_ABC: core::ffi::c_uint = 111;
pub const NET_IPV4_IPFRAG_MAX_DIST: core::ffi::c_uint = 112;
pub const NET_TCP_MTU_PROBING: core::ffi::c_uint = 113;
pub const NET_TCP_BASE_MSS: core::ffi::c_uint = 114;
pub const NET_IPV4_TCP_WORKAROUND_SIGNED_WINDOWS: core::ffi::c_uint = 115;
pub const NET_TCP_DMA_COPYBREAK: core::ffi::c_uint = 116;
pub const NET_TCP_SLOW_START_AFTER_IDLE: core::ffi::c_uint = 117;
pub const NET_CIPSOV4_CACHE_ENABLE: core::ffi::c_uint = 118;
pub const NET_CIPSOV4_CACHE_BUCKET_SIZE: core::ffi::c_uint = 119;
pub const NET_CIPSOV4_RBM_OPTFMT: core::ffi::c_uint = 120;
pub const NET_CIPSOV4_RBM_STRICTVALID: core::ffi::c_uint = 121;
pub const NET_TCP_AVAIL_CONG_CONTROL: core::ffi::c_uint = 122;
pub const NET_TCP_ALLOWED_CONG_CONTROL: core::ffi::c_uint = 123;
pub const NET_TCP_MAX_SSTHRESH: core::ffi::c_uint = 124;
pub const NET_TCP_FRTO_RESPONSE: core::ffi::c_uint = 125;
pub type _bindgen_ty_22 = core::ffi::c_uint;
pub const NET_IPV4_ROUTE_FLUSH: core::ffi::c_uint = 1;
pub const NET_IPV4_ROUTE_MIN_DELAY: core::ffi::c_uint = 2;
pub const NET_IPV4_ROUTE_MAX_DELAY: core::ffi::c_uint = 3;
pub const NET_IPV4_ROUTE_GC_THRESH: core::ffi::c_uint = 4;
pub const NET_IPV4_ROUTE_MAX_SIZE: core::ffi::c_uint = 5;
pub const NET_IPV4_ROUTE_GC_MIN_INTERVAL: core::ffi::c_uint = 6;
pub const NET_IPV4_ROUTE_GC_TIMEOUT: core::ffi::c_uint = 7;
pub const NET_IPV4_ROUTE_GC_INTERVAL: core::ffi::c_uint = 8;
pub const NET_IPV4_ROUTE_REDIRECT_LOAD: core::ffi::c_uint = 9;
pub const NET_IPV4_ROUTE_REDIRECT_NUMBER: core::ffi::c_uint = 10;
pub const NET_IPV4_ROUTE_REDIRECT_SILENCE: core::ffi::c_uint = 11;
pub const NET_IPV4_ROUTE_ERROR_COST: core::ffi::c_uint = 12;
pub const NET_IPV4_ROUTE_ERROR_BURST: core::ffi::c_uint = 13;
pub const NET_IPV4_ROUTE_GC_ELASTICITY: core::ffi::c_uint = 14;
pub const NET_IPV4_ROUTE_MTU_EXPIRES: core::ffi::c_uint = 15;
pub const NET_IPV4_ROUTE_MIN_PMTU: core::ffi::c_uint = 16;
pub const NET_IPV4_ROUTE_MIN_ADVMSS: core::ffi::c_uint = 17;
pub const NET_IPV4_ROUTE_SECRET_INTERVAL: core::ffi::c_uint = 18;
pub const NET_IPV4_ROUTE_GC_MIN_INTERVAL_MS: core::ffi::c_uint = 19;
pub type _bindgen_ty_23 = core::ffi::c_uint;
pub const NET_PROTO_CONF_ALL: core::ffi::c_int = -2;
pub const NET_PROTO_CONF_DEFAULT: core::ffi::c_int = -3;
pub type _bindgen_ty_24 = core::ffi::c_int;
pub const NET_IPV4_CONF_FORWARDING: core::ffi::c_uint = 1;
pub const NET_IPV4_CONF_MC_FORWARDING: core::ffi::c_uint = 2;
pub const NET_IPV4_CONF_PROXY_ARP: core::ffi::c_uint = 3;
pub const NET_IPV4_CONF_ACCEPT_REDIRECTS: core::ffi::c_uint = 4;
pub const NET_IPV4_CONF_SECURE_REDIRECTS: core::ffi::c_uint = 5;
pub const NET_IPV4_CONF_SEND_REDIRECTS: core::ffi::c_uint = 6;
pub const NET_IPV4_CONF_SHARED_MEDIA: core::ffi::c_uint = 7;
pub const NET_IPV4_CONF_RP_FILTER: core::ffi::c_uint = 8;
pub const NET_IPV4_CONF_ACCEPT_SOURCE_ROUTE: core::ffi::c_uint = 9;
pub const NET_IPV4_CONF_BOOTP_RELAY: core::ffi::c_uint = 10;
pub const NET_IPV4_CONF_LOG_MARTIANS: core::ffi::c_uint = 11;
pub const NET_IPV4_CONF_TAG: core::ffi::c_uint = 12;
pub const NET_IPV4_CONF_ARPFILTER: core::ffi::c_uint = 13;
pub const NET_IPV4_CONF_MEDIUM_ID: core::ffi::c_uint = 14;
pub const NET_IPV4_CONF_NOXFRM: core::ffi::c_uint = 15;
pub const NET_IPV4_CONF_NOPOLICY: core::ffi::c_uint = 16;
pub const NET_IPV4_CONF_FORCE_IGMP_VERSION: core::ffi::c_uint = 17;
pub const NET_IPV4_CONF_ARP_ANNOUNCE: core::ffi::c_uint = 18;
pub const NET_IPV4_CONF_ARP_IGNORE: core::ffi::c_uint = 19;
pub const NET_IPV4_CONF_PROMOTE_SECONDARIES: core::ffi::c_uint = 20;
pub const NET_IPV4_CONF_ARP_ACCEPT: core::ffi::c_uint = 21;
pub const NET_IPV4_CONF_ARP_NOTIFY: core::ffi::c_uint = 22;
pub const NET_IPV4_CONF_ARP_EVICT_NOCARRIER: core::ffi::c_uint = 23;
pub type _bindgen_ty_25 = core::ffi::c_uint;
pub const NET_IPV4_NF_CONNTRACK_MAX: core::ffi::c_uint = 1;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_SENT: core::ffi::c_uint = 2;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_SYN_RECV: core::ffi::c_uint = 3;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_ESTABLISHED: core::ffi::c_uint = 4;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_FIN_WAIT: core::ffi::c_uint = 5;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE_WAIT: core::ffi::c_uint = 6;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_LAST_ACK: core::ffi::c_uint = 7;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_TIME_WAIT: core::ffi::c_uint = 8;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_CLOSE: core::ffi::c_uint = 9;
pub const NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT: core::ffi::c_uint = 10;
pub const NET_IPV4_NF_CONNTRACK_UDP_TIMEOUT_STREAM: core::ffi::c_uint = 11;
pub const NET_IPV4_NF_CONNTRACK_ICMP_TIMEOUT: core::ffi::c_uint = 12;
pub const NET_IPV4_NF_CONNTRACK_GENERIC_TIMEOUT: core::ffi::c_uint = 13;
pub const NET_IPV4_NF_CONNTRACK_BUCKETS: core::ffi::c_uint = 14;
pub const NET_IPV4_NF_CONNTRACK_LOG_INVALID: core::ffi::c_uint = 15;
pub const NET_IPV4_NF_CONNTRACK_TCP_TIMEOUT_MAX_RETRANS: core::ffi::c_uint = 16;
pub const NET_IPV4_NF_CONNTRACK_TCP_LOOSE: core::ffi::c_uint = 17;
pub const NET_IPV4_NF_CONNTRACK_TCP_BE_LIBERAL: core::ffi::c_uint = 18;
pub const NET_IPV4_NF_CONNTRACK_TCP_MAX_RETRANS: core::ffi::c_uint = 19;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_CLOSED: core::ffi::c_uint = 20;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_WAIT: core::ffi::c_uint = 21;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_COOKIE_ECHOED: core::ffi::c_uint = 22;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_ESTABLISHED: core::ffi::c_uint = 23;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_SENT: core::ffi::c_uint = 24;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_RECD: core::ffi::c_uint = 25;
pub const NET_IPV4_NF_CONNTRACK_SCTP_TIMEOUT_SHUTDOWN_ACK_SENT: core::ffi::c_uint = 26;
pub const NET_IPV4_NF_CONNTRACK_COUNT: core::ffi::c_uint = 27;
pub const NET_IPV4_NF_CONNTRACK_CHECKSUM: core::ffi::c_uint = 28;
pub type _bindgen_ty_26 = core::ffi::c_uint;
pub const NET_IPV6_CONF: core::ffi::c_uint = 16;
pub const NET_IPV6_NEIGH: core::ffi::c_uint = 17;
pub const NET_IPV6_ROUTE: core::ffi::c_uint = 18;
pub const NET_IPV6_ICMP: core::ffi::c_uint = 19;
pub const NET_IPV6_BINDV6ONLY: core::ffi::c_uint = 20;
pub const NET_IPV6_IP6FRAG_HIGH_THRESH: core::ffi::c_uint = 21;
pub const NET_IPV6_IP6FRAG_LOW_THRESH: core::ffi::c_uint = 22;
pub const NET_IPV6_IP6FRAG_TIME: core::ffi::c_uint = 23;
pub const NET_IPV6_IP6FRAG_SECRET_INTERVAL: core::ffi::c_uint = 24;
pub const NET_IPV6_MLD_MAX_MSF: core::ffi::c_uint = 25;
pub type _bindgen_ty_27 = core::ffi::c_uint;
pub const NET_IPV6_ROUTE_FLUSH: core::ffi::c_uint = 1;
pub const NET_IPV6_ROUTE_GC_THRESH: core::ffi::c_uint = 2;
pub const NET_IPV6_ROUTE_MAX_SIZE: core::ffi::c_uint = 3;
pub const NET_IPV6_ROUTE_GC_MIN_INTERVAL: core::ffi::c_uint = 4;
pub const NET_IPV6_ROUTE_GC_TIMEOUT: core::ffi::c_uint = 5;
pub const NET_IPV6_ROUTE_GC_INTERVAL: core::ffi::c_uint = 6;
pub const NET_IPV6_ROUTE_GC_ELASTICITY: core::ffi::c_uint = 7;
pub const NET_IPV6_ROUTE_MTU_EXPIRES: core::ffi::c_uint = 8;
pub const NET_IPV6_ROUTE_MIN_ADVMSS: core::ffi::c_uint = 9;
pub const NET_IPV6_ROUTE_GC_MIN_INTERVAL_MS: core::ffi::c_uint = 10;
pub type _bindgen_ty_28 = core::ffi::c_uint;
pub const NET_IPV6_FORWARDING: core::ffi::c_uint = 1;
pub const NET_IPV6_HOP_LIMIT: core::ffi::c_uint = 2;
pub const NET_IPV6_MTU: core::ffi::c_uint = 3;
pub const NET_IPV6_ACCEPT_RA: core::ffi::c_uint = 4;
pub const NET_IPV6_ACCEPT_REDIRECTS: core::ffi::c_uint = 5;
pub const NET_IPV6_AUTOCONF: core::ffi::c_uint = 6;
pub const NET_IPV6_DAD_TRANSMITS: core::ffi::c_uint = 7;
pub const NET_IPV6_RTR_SOLICITS: core::ffi::c_uint = 8;
pub const NET_IPV6_RTR_SOLICIT_INTERVAL: core::ffi::c_uint = 9;
pub const NET_IPV6_RTR_SOLICIT_DELAY: core::ffi::c_uint = 10;
pub const NET_IPV6_USE_TEMPADDR: core::ffi::c_uint = 11;
pub const NET_IPV6_TEMP_VALID_LFT: core::ffi::c_uint = 12;
pub const NET_IPV6_TEMP_PREFERED_LFT: core::ffi::c_uint = 13;
pub const NET_IPV6_REGEN_MAX_RETRY: core::ffi::c_uint = 14;
pub const NET_IPV6_MAX_DESYNC_FACTOR: core::ffi::c_uint = 15;
pub const NET_IPV6_MAX_ADDRESSES: core::ffi::c_uint = 16;
pub const NET_IPV6_FORCE_MLD_VERSION: core::ffi::c_uint = 17;
pub const NET_IPV6_ACCEPT_RA_DEFRTR: core::ffi::c_uint = 18;
pub const NET_IPV6_ACCEPT_RA_PINFO: core::ffi::c_uint = 19;
pub const NET_IPV6_ACCEPT_RA_RTR_PREF: core::ffi::c_uint = 20;
pub const NET_IPV6_RTR_PROBE_INTERVAL: core::ffi::c_uint = 21;
pub const NET_IPV6_ACCEPT_RA_RT_INFO_MAX_PLEN: core::ffi::c_uint = 22;
pub const NET_IPV6_PROXY_NDP: core::ffi::c_uint = 23;
pub const NET_IPV6_ACCEPT_SOURCE_ROUTE: core::ffi::c_uint = 25;
pub const NET_IPV6_ACCEPT_RA_FROM_LOCAL: core::ffi::c_uint = 26;
pub const NET_IPV6_ACCEPT_RA_RT_INFO_MIN_PLEN: core::ffi::c_uint = 27;
pub const NET_IPV6_RA_DEFRTR_METRIC: core::ffi::c_uint = 28;
pub const __NET_IPV6_MAX: core::ffi::c_uint = 29;
pub type _bindgen_ty_29 = core::ffi::c_uint;
pub const NET_IPV6_ICMP_RATELIMIT: core::ffi::c_uint = 1;
pub const NET_IPV6_ICMP_ECHO_IGNORE_ALL: core::ffi::c_uint = 2;
pub type _bindgen_ty_30 = core::ffi::c_uint;
pub const NET_NEIGH_MCAST_SOLICIT: core::ffi::c_uint = 1;
pub const NET_NEIGH_UCAST_SOLICIT: core::ffi::c_uint = 2;
pub const NET_NEIGH_APP_SOLICIT: core::ffi::c_uint = 3;
pub const NET_NEIGH_RETRANS_TIME: core::ffi::c_uint = 4;
pub const NET_NEIGH_REACHABLE_TIME: core::ffi::c_uint = 5;
pub const NET_NEIGH_DELAY_PROBE_TIME: core::ffi::c_uint = 6;
pub const NET_NEIGH_GC_STALE_TIME: core::ffi::c_uint = 7;
pub const NET_NEIGH_UNRES_QLEN: core::ffi::c_uint = 8;
pub const NET_NEIGH_PROXY_QLEN: core::ffi::c_uint = 9;
pub const NET_NEIGH_ANYCAST_DELAY: core::ffi::c_uint = 10;
pub const NET_NEIGH_PROXY_DELAY: core::ffi::c_uint = 11;
pub const NET_NEIGH_LOCKTIME: core::ffi::c_uint = 12;
pub const NET_NEIGH_GC_INTERVAL: core::ffi::c_uint = 13;
pub const NET_NEIGH_GC_THRESH1: core::ffi::c_uint = 14;
pub const NET_NEIGH_GC_THRESH2: core::ffi::c_uint = 15;
pub const NET_NEIGH_GC_THRESH3: core::ffi::c_uint = 16;
pub const NET_NEIGH_RETRANS_TIME_MS: core::ffi::c_uint = 17;
pub const NET_NEIGH_REACHABLE_TIME_MS: core::ffi::c_uint = 18;
pub const NET_NEIGH_INTERVAL_PROBE_TIME_MS: core::ffi::c_uint = 19;
pub type _bindgen_ty_31 = core::ffi::c_uint;
pub const NET_DCCP_DEFAULT: core::ffi::c_uint = 1;
pub type _bindgen_ty_32 = core::ffi::c_uint;
pub const NET_IPX_PPROP_BROADCASTING: core::ffi::c_uint = 1;
pub const NET_IPX_FORWARDING: core::ffi::c_uint = 2;
pub type _bindgen_ty_33 = core::ffi::c_uint;
pub const NET_LLC2: core::ffi::c_uint = 1;
pub const NET_LLC_STATION: core::ffi::c_uint = 2;
pub type _bindgen_ty_34 = core::ffi::c_uint;
pub const NET_LLC2_TIMEOUT: core::ffi::c_uint = 1;
pub type _bindgen_ty_35 = core::ffi::c_uint;
pub const NET_LLC_STATION_ACK_TIMEOUT: core::ffi::c_uint = 1;
pub type _bindgen_ty_36 = core::ffi::c_uint;
pub const NET_LLC2_ACK_TIMEOUT: core::ffi::c_uint = 1;
pub const NET_LLC2_P_TIMEOUT: core::ffi::c_uint = 2;
pub const NET_LLC2_REJ_TIMEOUT: core::ffi::c_uint = 3;
pub const NET_LLC2_BUSY_TIMEOUT: core::ffi::c_uint = 4;
pub type _bindgen_ty_37 = core::ffi::c_uint;
pub const NET_ATALK_AARP_EXPIRY_TIME: core::ffi::c_uint = 1;
pub const NET_ATALK_AARP_TICK_TIME: core::ffi::c_uint = 2;
pub const NET_ATALK_AARP_RETRANSMIT_LIMIT: core::ffi::c_uint = 3;
pub const NET_ATALK_AARP_RESOLVE_TIME: core::ffi::c_uint = 4;
pub type _bindgen_ty_38 = core::ffi::c_uint;
pub const NET_NETROM_DEFAULT_PATH_QUALITY: core::ffi::c_uint = 1;
pub const NET_NETROM_OBSOLESCENCE_COUNT_INITIALISER: core::ffi::c_uint = 2;
pub const NET_NETROM_NETWORK_TTL_INITIALISER: core::ffi::c_uint = 3;
pub const NET_NETROM_TRANSPORT_TIMEOUT: core::ffi::c_uint = 4;
pub const NET_NETROM_TRANSPORT_MAXIMUM_TRIES: core::ffi::c_uint = 5;
pub const NET_NETROM_TRANSPORT_ACKNOWLEDGE_DELAY: core::ffi::c_uint = 6;
pub const NET_NETROM_TRANSPORT_BUSY_DELAY: core::ffi::c_uint = 7;
pub const NET_NETROM_TRANSPORT_REQUESTED_WINDOW_SIZE: core::ffi::c_uint = 8;
pub const NET_NETROM_TRANSPORT_NO_ACTIVITY_TIMEOUT: core::ffi::c_uint = 9;
pub const NET_NETROM_ROUTING_CONTROL: core::ffi::c_uint = 10;
pub const NET_NETROM_LINK_FAILS_COUNT: core::ffi::c_uint = 11;
pub const NET_NETROM_RESET: core::ffi::c_uint = 12;
pub type _bindgen_ty_39 = core::ffi::c_uint;
pub const NET_AX25_IP_DEFAULT_MODE: core::ffi::c_uint = 1;
pub const NET_AX25_DEFAULT_MODE: core::ffi::c_uint = 2;
pub const NET_AX25_BACKOFF_TYPE: core::ffi::c_uint = 3;
pub const NET_AX25_CONNECT_MODE: core::ffi::c_uint = 4;
pub const NET_AX25_STANDARD_WINDOW: core::ffi::c_uint = 5;
pub const NET_AX25_EXTENDED_WINDOW: core::ffi::c_uint = 6;
pub const NET_AX25_T1_TIMEOUT: core::ffi::c_uint = 7;
pub const NET_AX25_T2_TIMEOUT: core::ffi::c_uint = 8;
pub const NET_AX25_T3_TIMEOUT: core::ffi::c_uint = 9;
pub const NET_AX25_IDLE_TIMEOUT: core::ffi::c_uint = 10;
pub const NET_AX25_N2: core::ffi::c_uint = 11;
pub const NET_AX25_PACLEN: core::ffi::c_uint = 12;
pub const NET_AX25_PROTOCOL: core::ffi::c_uint = 13;
pub const NET_AX25_DAMA_SLAVE_TIMEOUT: core::ffi::c_uint = 14;
pub type _bindgen_ty_40 = core::ffi::c_uint;
pub const NET_ROSE_RESTART_REQUEST_TIMEOUT: core::ffi::c_uint = 1;
pub const NET_ROSE_CALL_REQUEST_TIMEOUT: core::ffi::c_uint = 2;
pub const NET_ROSE_RESET_REQUEST_TIMEOUT: core::ffi::c_uint = 3;
pub const NET_ROSE_CLEAR_REQUEST_TIMEOUT: core::ffi::c_uint = 4;
pub const NET_ROSE_ACK_HOLD_BACK_TIMEOUT: core::ffi::c_uint = 5;
pub const NET_ROSE_ROUTING_CONTROL: core::ffi::c_uint = 6;
pub const NET_ROSE_LINK_FAIL_TIMEOUT: core::ffi::c_uint = 7;
pub const NET_ROSE_MAX_VCS: core::ffi::c_uint = 8;
pub const NET_ROSE_WINDOW_SIZE: core::ffi::c_uint = 9;
pub const NET_ROSE_NO_ACTIVITY_TIMEOUT: core::ffi::c_uint = 10;
pub type _bindgen_ty_41 = core::ffi::c_uint;
pub const NET_X25_RESTART_REQUEST_TIMEOUT: core::ffi::c_uint = 1;
pub const NET_X25_CALL_REQUEST_TIMEOUT: core::ffi::c_uint = 2;
pub const NET_X25_RESET_REQUEST_TIMEOUT: core::ffi::c_uint = 3;
pub const NET_X25_CLEAR_REQUEST_TIMEOUT: core::ffi::c_uint = 4;
pub const NET_X25_ACK_HOLD_BACK_TIMEOUT: core::ffi::c_uint = 5;
pub const NET_X25_FORWARD: core::ffi::c_uint = 6;
pub type _bindgen_ty_42 = core::ffi::c_uint;
pub const NET_TR_RIF_TIMEOUT: core::ffi::c_uint = 1;
pub type _bindgen_ty_43 = core::ffi::c_uint;
pub const NET_DECNET_NODE_TYPE: core::ffi::c_uint = 1;
pub const NET_DECNET_NODE_ADDRESS: core::ffi::c_uint = 2;
pub const NET_DECNET_NODE_NAME: core::ffi::c_uint = 3;
pub const NET_DECNET_DEFAULT_DEVICE: core::ffi::c_uint = 4;
pub const NET_DECNET_TIME_WAIT: core::ffi::c_uint = 5;
pub const NET_DECNET_DN_COUNT: core::ffi::c_uint = 6;
pub const NET_DECNET_DI_COUNT: core::ffi::c_uint = 7;
pub const NET_DECNET_DR_COUNT: core::ffi::c_uint = 8;
pub const NET_DECNET_DST_GC_INTERVAL: core::ffi::c_uint = 9;
pub const NET_DECNET_CONF: core::ffi::c_uint = 10;
pub const NET_DECNET_NO_FC_MAX_CWND: core::ffi::c_uint = 11;
pub const NET_DECNET_MEM: core::ffi::c_uint = 12;
pub const NET_DECNET_RMEM: core::ffi::c_uint = 13;
pub const NET_DECNET_WMEM: core::ffi::c_uint = 14;
pub const NET_DECNET_DEBUG_LEVEL: core::ffi::c_uint = 255;
pub type _bindgen_ty_44 = core::ffi::c_uint;
pub const NET_DECNET_CONF_LOOPBACK: core::ffi::c_int = -2;
pub const NET_DECNET_CONF_DDCMP: core::ffi::c_int = -3;
pub const NET_DECNET_CONF_PPP: core::ffi::c_int = -4;
pub const NET_DECNET_CONF_X25: core::ffi::c_int = -5;
pub const NET_DECNET_CONF_GRE: core::ffi::c_int = -6;
pub const NET_DECNET_CONF_ETHER: core::ffi::c_int = -7;
pub type _bindgen_ty_45 = core::ffi::c_int;
pub const NET_DECNET_CONF_DEV_PRIORITY: core::ffi::c_uint = 1;
pub const NET_DECNET_CONF_DEV_T1: core::ffi::c_uint = 2;
pub const NET_DECNET_CONF_DEV_T2: core::ffi::c_uint = 3;
pub const NET_DECNET_CONF_DEV_T3: core::ffi::c_uint = 4;
pub const NET_DECNET_CONF_DEV_FORWARDING: core::ffi::c_uint = 5;
pub const NET_DECNET_CONF_DEV_BLKSIZE: core::ffi::c_uint = 6;
pub const NET_DECNET_CONF_DEV_STATE: core::ffi::c_uint = 7;
pub type _bindgen_ty_46 = core::ffi::c_uint;
pub const NET_SCTP_RTO_INITIAL: core::ffi::c_uint = 1;
pub const NET_SCTP_RTO_MIN: core::ffi::c_uint = 2;
pub const NET_SCTP_RTO_MAX: core::ffi::c_uint = 3;
pub const NET_SCTP_RTO_ALPHA: core::ffi::c_uint = 4;
pub const NET_SCTP_RTO_BETA: core::ffi::c_uint = 5;
pub const NET_SCTP_VALID_COOKIE_LIFE: core::ffi::c_uint = 6;
pub const NET_SCTP_ASSOCIATION_MAX_RETRANS: core::ffi::c_uint = 7;
pub const NET_SCTP_PATH_MAX_RETRANS: core::ffi::c_uint = 8;
pub const NET_SCTP_MAX_INIT_RETRANSMITS: core::ffi::c_uint = 9;
pub const NET_SCTP_HB_INTERVAL: core::ffi::c_uint = 10;
pub const NET_SCTP_PRESERVE_ENABLE: core::ffi::c_uint = 11;
pub const NET_SCTP_MAX_BURST: core::ffi::c_uint = 12;
pub const NET_SCTP_ADDIP_ENABLE: core::ffi::c_uint = 13;
pub const NET_SCTP_PRSCTP_ENABLE: core::ffi::c_uint = 14;
pub const NET_SCTP_SNDBUF_POLICY: core::ffi::c_uint = 15;
pub const NET_SCTP_SACK_TIMEOUT: core::ffi::c_uint = 16;
pub const NET_SCTP_RCVBUF_POLICY: core::ffi::c_uint = 17;
pub type _bindgen_ty_47 = core::ffi::c_uint;
pub const NET_BRIDGE_NF_CALL_ARPTABLES: core::ffi::c_uint = 1;
pub const NET_BRIDGE_NF_CALL_IPTABLES: core::ffi::c_uint = 2;
pub const NET_BRIDGE_NF_CALL_IP6TABLES: core::ffi::c_uint = 3;
pub const NET_BRIDGE_NF_FILTER_VLAN_TAGGED: core::ffi::c_uint = 4;
pub const NET_BRIDGE_NF_FILTER_PPPOE_TAGGED: core::ffi::c_uint = 5;
pub type _bindgen_ty_48 = core::ffi::c_uint;
pub const FS_NRINODE: core::ffi::c_uint = 1;
pub const FS_STATINODE: core::ffi::c_uint = 2;
pub const FS_MAXINODE: core::ffi::c_uint = 3;
pub const FS_NRDQUOT: core::ffi::c_uint = 4;
pub const FS_MAXDQUOT: core::ffi::c_uint = 5;
pub const FS_NRFILE: core::ffi::c_uint = 6;
pub const FS_MAXFILE: core::ffi::c_uint = 7;
pub const FS_DENTRY: core::ffi::c_uint = 8;
pub const FS_NRSUPER: core::ffi::c_uint = 9;
pub const FS_MAXSUPER: core::ffi::c_uint = 10;
pub const FS_OVERFLOWUID: core::ffi::c_uint = 11;
pub const FS_OVERFLOWGID: core::ffi::c_uint = 12;
pub const FS_LEASES: core::ffi::c_uint = 13;
pub const FS_DIR_NOTIFY: core::ffi::c_uint = 14;
pub const FS_LEASE_TIME: core::ffi::c_uint = 15;
pub const FS_DQSTATS: core::ffi::c_uint = 16;
pub const FS_XFS: core::ffi::c_uint = 17;
pub const FS_AIO_NR: core::ffi::c_uint = 18;
pub const FS_AIO_MAX_NR: core::ffi::c_uint = 19;
pub const FS_INOTIFY: core::ffi::c_uint = 20;
pub const FS_OCFS2: core::ffi::c_uint = 988;
pub type _bindgen_ty_49 = core::ffi::c_uint;
pub const FS_DQ_LOOKUPS: core::ffi::c_uint = 1;
pub const FS_DQ_DROPS: core::ffi::c_uint = 2;
pub const FS_DQ_READS: core::ffi::c_uint = 3;
pub const FS_DQ_WRITES: core::ffi::c_uint = 4;
pub const FS_DQ_CACHE_HITS: core::ffi::c_uint = 5;
pub const FS_DQ_ALLOCATED: core::ffi::c_uint = 6;
pub const FS_DQ_FREE: core::ffi::c_uint = 7;
pub const FS_DQ_SYNCS: core::ffi::c_uint = 8;
pub const FS_DQ_WARNINGS: core::ffi::c_uint = 9;
pub type _bindgen_ty_50 = core::ffi::c_uint;
pub const DEV_CDROM: core::ffi::c_uint = 1;
pub const DEV_HWMON: core::ffi::c_uint = 2;
pub const DEV_PARPORT: core::ffi::c_uint = 3;
pub const DEV_RAID: core::ffi::c_uint = 4;
pub const DEV_MAC_HID: core::ffi::c_uint = 5;
pub const DEV_SCSI: core::ffi::c_uint = 6;
pub const DEV_IPMI: core::ffi::c_uint = 7;
pub type _bindgen_ty_51 = core::ffi::c_uint;
pub const DEV_CDROM_INFO: core::ffi::c_uint = 1;
pub const DEV_CDROM_AUTOCLOSE: core::ffi::c_uint = 2;
pub const DEV_CDROM_AUTOEJECT: core::ffi::c_uint = 3;
pub const DEV_CDROM_DEBUG: core::ffi::c_uint = 4;
pub const DEV_CDROM_LOCK: core::ffi::c_uint = 5;
pub const DEV_CDROM_CHECK_MEDIA: core::ffi::c_uint = 6;
pub type _bindgen_ty_52 = core::ffi::c_uint;
pub const DEV_PARPORT_DEFAULT: core::ffi::c_int = -3;
pub type _bindgen_ty_53 = core::ffi::c_int;
pub const DEV_RAID_SPEED_LIMIT_MIN: core::ffi::c_uint = 1;
pub const DEV_RAID_SPEED_LIMIT_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_54 = core::ffi::c_uint;
pub const DEV_PARPORT_DEFAULT_TIMESLICE: core::ffi::c_uint = 1;
pub const DEV_PARPORT_DEFAULT_SPINTIME: core::ffi::c_uint = 2;
pub type _bindgen_ty_55 = core::ffi::c_uint;
pub const DEV_PARPORT_SPINTIME: core::ffi::c_uint = 1;
pub const DEV_PARPORT_BASE_ADDR: core::ffi::c_uint = 2;
pub const DEV_PARPORT_IRQ: core::ffi::c_uint = 3;
pub const DEV_PARPORT_DMA: core::ffi::c_uint = 4;
pub const DEV_PARPORT_MODES: core::ffi::c_uint = 5;
pub const DEV_PARPORT_DEVICES: core::ffi::c_uint = 6;
pub const DEV_PARPORT_AUTOPROBE: core::ffi::c_uint = 16;
pub type _bindgen_ty_56 = core::ffi::c_uint;
pub const DEV_PARPORT_DEVICES_ACTIVE: core::ffi::c_int = -3;
pub type _bindgen_ty_57 = core::ffi::c_int;
pub const DEV_PARPORT_DEVICE_TIMESLICE: core::ffi::c_uint = 1;
pub type _bindgen_ty_58 = core::ffi::c_uint;
pub const DEV_MAC_HID_KEYBOARD_SENDS_LINUX_KEYCODES: core::ffi::c_uint = 1;
pub const DEV_MAC_HID_KEYBOARD_LOCK_KEYCODES: core::ffi::c_uint = 2;
pub const DEV_MAC_HID_MOUSE_BUTTON_EMULATION: core::ffi::c_uint = 3;
pub const DEV_MAC_HID_MOUSE_BUTTON2_KEYCODE: core::ffi::c_uint = 4;
pub const DEV_MAC_HID_MOUSE_BUTTON3_KEYCODE: core::ffi::c_uint = 5;
pub const DEV_MAC_HID_ADB_MOUSE_SENDS_KEYCODES: core::ffi::c_uint = 6;
pub type _bindgen_ty_59 = core::ffi::c_uint;
pub const DEV_SCSI_LOGGING_LEVEL: core::ffi::c_uint = 1;
pub type _bindgen_ty_60 = core::ffi::c_uint;
pub const DEV_IPMI_POWEROFF_POWERCYCLE: core::ffi::c_uint = 1;
pub type _bindgen_ty_61 = core::ffi::c_uint;
pub const ABI_DEFHANDLER_COFF: core::ffi::c_uint = 1;
pub const ABI_DEFHANDLER_ELF: core::ffi::c_uint = 2;
pub const ABI_DEFHANDLER_LCALL7: core::ffi::c_uint = 3;
pub const ABI_DEFHANDLER_LIBCSO: core::ffi::c_uint = 4;
pub const ABI_TRACE: core::ffi::c_uint = 5;
pub const ABI_FAKE_UTSNAME: core::ffi::c_uint = 6;
pub type _bindgen_ty_62 = core::ffi::c_uint;
extern "C" {
    pub static mut sysctl_vals: [core::ffi::c_int; 0usize];
}
extern "C" {
    pub static mut sysctl_long_vals: [core::ffi::c_ulong; 0usize];
}
pub type proc_handler = ::core::option::Option<
    unsafe extern "C" fn(
        ctl: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn proc_dostring(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dobool(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_douintvec(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec_minmax(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_douintvec_minmax(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dou8vec_minmax(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec_jiffies(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec_ms_jiffies_minmax(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec_userhz_jiffies(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_dointvec_ms_jiffies(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_doulongvec_minmax(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_doulongvec_ms_jiffies_minmax(
        table: *mut ctl_table,
        arg1: core::ffi::c_int,
        arg2: *mut core::ffi::c_void,
        arg3: *mut usize,
        arg4: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_do_large_bitmap(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_do_static_key(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_poll {
    pub event: atomic_t,
    pub wait: wait_queue_head_t,
}
impl Default for ctl_table_poll {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table {
    pub procname: *const core::ffi::c_char,
    pub data: *mut core::ffi::c_void,
    pub maxlen: core::ffi::c_int,
    pub mode: umode_t,
    pub child: *mut ctl_table,
    pub proc_handler: proc_handler,
    pub poll: *mut ctl_table_poll,
    pub extra1: *mut core::ffi::c_void,
    pub extra2: *mut core::ffi::c_void,
}
impl Default for ctl_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_node {
    pub node: rb_node,
    pub header: *mut ctl_table_header,
}
impl Default for ctl_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1,
    pub unregistering: *mut completion,
    pub ctl_table_arg: *mut ctl_table,
    pub root: *mut ctl_table_root,
    pub set: *mut ctl_table_set,
    pub parent: *mut ctl_dir,
    pub node: *mut ctl_node,
    pub inodes: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ctl_table_header__bindgen_ty_1 {
    pub __bindgen_anon_1: ctl_table_header__bindgen_ty_1__bindgen_ty_1,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    pub ctl_table: *mut ctl_table,
    pub used: core::ffi::c_int,
    pub count: core::ffi::c_int,
    pub nreg: core::ffi::c_int,
}
impl Default for ctl_table_header__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for ctl_table_header__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for ctl_table_header {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_dir {
    pub header: ctl_table_header,
    pub root: rb_root,
}
impl Default for ctl_dir {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_set {
    pub is_seen:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ctl_table_set) -> core::ffi::c_int>,
    pub dir: ctl_dir,
}
impl Default for ctl_table_set {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_table_root {
    pub default_set: ctl_table_set,
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(root: *mut ctl_table_root) -> *mut ctl_table_set,
    >,
    pub set_ownership: ::core::option::Option<
        unsafe extern "C" fn(
            head: *mut ctl_table_header,
            table: *mut ctl_table,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ),
    >,
    pub permissions: ::core::option::Option<
        unsafe extern "C" fn(
            head: *mut ctl_table_header,
            table: *mut ctl_table,
        ) -> core::ffi::c_int,
    >,
}
impl Default for ctl_table_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctl_path {
    pub procname: *const core::ffi::c_char,
}
impl Default for ctl_path {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __register_sysctl_base(base_table: *mut ctl_table) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_sys_poll_notify(poll: *mut ctl_table_poll);
}
extern "C" {
    pub fn setup_sysctl_set(
        p: *mut ctl_table_set,
        root: *mut ctl_table_root,
        is_seen: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ctl_table_set) -> core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub fn retire_sysctl_set(set: *mut ctl_table_set);
}
extern "C" {
    pub fn __register_sysctl_table(
        set: *mut ctl_table_set,
        path: *const core::ffi::c_char,
        table: *mut ctl_table,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn __register_sysctl_paths(
        set: *mut ctl_table_set,
        path: *const ctl_path,
        table: *mut ctl_table,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn register_sysctl(
        path: *const core::ffi::c_char,
        table: *mut ctl_table,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn register_sysctl_table(table: *mut ctl_table) -> *mut ctl_table_header;
}
extern "C" {
    pub fn register_sysctl_paths(
        path: *const ctl_path,
        table: *mut ctl_table,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn unregister_sysctl_table(table: *mut ctl_table_header);
}
extern "C" {
    pub fn sysctl_init_bases() -> core::ffi::c_int;
}
extern "C" {
    pub fn __register_sysctl_init(
        path: *const core::ffi::c_char,
        table: *mut ctl_table,
        table_name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn register_sysctl_mount_point(path: *const core::ffi::c_char) -> *mut ctl_table_header;
}
extern "C" {
    pub fn do_sysctl_args();
}
extern "C" {
    pub fn do_proc_douintvec(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
        conv: ::core::option::Option<
            unsafe extern "C" fn(
                lvalp: *mut core::ffi::c_ulong,
                valp: *mut core::ffi::c_uint,
                write: core::ffi::c_int,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut pwrsw_enabled: core::ffi::c_int;
}
extern "C" {
    pub static mut unaligned_enabled: core::ffi::c_int;
}
extern "C" {
    pub static mut unaligned_dump_stack: core::ffi::c_int;
}
extern "C" {
    pub static mut no_unaligned_warning: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_mount_point: [ctl_table; 0usize];
}
extern "C" {
    pub fn sysctl_max_threads(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subprocess_info {
    pub work: work_struct,
    pub complete: *mut completion,
    pub path: *const core::ffi::c_char,
    pub argv: *mut *mut core::ffi::c_char,
    pub envp: *mut *mut core::ffi::c_char,
    pub wait: core::ffi::c_int,
    pub retval: core::ffi::c_int,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(info: *mut subprocess_info, new: *mut cred) -> core::ffi::c_int,
    >,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(info: *mut subprocess_info)>,
    pub data: *mut core::ffi::c_void,
}
impl Default for subprocess_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn call_usermodehelper(
        path: *const core::ffi::c_char,
        argv: *mut *mut core::ffi::c_char,
        envp: *mut *mut core::ffi::c_char,
        wait: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn call_usermodehelper_setup(
        path: *const core::ffi::c_char,
        argv: *mut *mut core::ffi::c_char,
        envp: *mut *mut core::ffi::c_char,
        gfp_mask: gfp_t,
        init: ::core::option::Option<
            unsafe extern "C" fn(info: *mut subprocess_info, new: *mut cred) -> core::ffi::c_int,
        >,
        cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut subprocess_info)>,
        data: *mut core::ffi::c_void,
    ) -> *mut subprocess_info;
}
extern "C" {
    pub fn call_usermodehelper_exec(
        info: *mut subprocess_info,
        wait: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut usermodehelper_table: [ctl_table; 0usize];
}
pub const umh_disable_depth_UMH_ENABLED: umh_disable_depth = 0;
pub const umh_disable_depth_UMH_FREEZING: umh_disable_depth = 1;
pub const umh_disable_depth_UMH_DISABLED: umh_disable_depth = 2;
pub type umh_disable_depth = core::ffi::c_uint;
extern "C" {
    pub fn __usermodehelper_disable(depth: umh_disable_depth) -> core::ffi::c_int;
}
extern "C" {
    pub fn __usermodehelper_set_disable_depth(depth: umh_disable_depth);
}
extern "C" {
    pub fn usermodehelper_read_trylock() -> core::ffi::c_int;
}
extern "C" {
    pub fn usermodehelper_read_lock_wait(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn usermodehelper_read_unlock();
}
extern "C" {
    pub static mut modprobe_path: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub fn __request_module(wait: bool_, name: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
pub type Elf32_Addr = __u32;
pub type Elf32_Half = __u16;
pub type Elf32_Off = __u32;
pub type Elf32_Sword = __s32;
pub type Elf32_Word = __u32;
pub type Elf64_Addr = __u64;
pub type Elf64_Half = __u16;
pub type Elf64_SHalf = __s16;
pub type Elf64_Off = __u64;
pub type Elf64_Sword = __s32;
pub type Elf64_Word = __u32;
pub type Elf64_Xword = __u64;
pub type Elf64_Sxword = __s64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dynamic {
    pub d_tag: Elf32_Sword,
    pub d_un: dynamic__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dynamic__bindgen_ty_1 {
    pub d_val: Elf32_Sword,
    pub d_ptr: Elf32_Addr,
    _bindgen_union_align: u32,
}
impl Default for dynamic__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for dynamic {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type Elf32_Dyn = dynamic;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Elf64_Dyn {
    pub d_tag: Elf64_Sxword,
    pub d_un: Elf64_Dyn__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Elf64_Dyn__bindgen_ty_1 {
    pub d_val: Elf64_Xword,
    pub d_ptr: Elf64_Addr,
    _bindgen_union_align: u64,
}
impl Default for Elf64_Dyn__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for Elf64_Dyn {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_rel {
    pub r_offset: Elf32_Addr,
    pub r_info: Elf32_Word,
}
pub type Elf32_Rel = elf32_rel;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_rel {
    pub r_offset: Elf64_Addr,
    pub r_info: Elf64_Xword,
}
pub type Elf64_Rel = elf64_rel;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_rela {
    pub r_offset: Elf32_Addr,
    pub r_info: Elf32_Word,
    pub r_addend: Elf32_Sword,
}
pub type Elf32_Rela = elf32_rela;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_rela {
    pub r_offset: Elf64_Addr,
    pub r_info: Elf64_Xword,
    pub r_addend: Elf64_Sxword,
}
pub type Elf64_Rela = elf64_rela;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_sym {
    pub st_name: Elf32_Word,
    pub st_value: Elf32_Addr,
    pub st_size: Elf32_Word,
    pub st_info: core::ffi::c_uchar,
    pub st_other: core::ffi::c_uchar,
    pub st_shndx: Elf32_Half,
}
pub type Elf32_Sym = elf32_sym;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_sym {
    pub st_name: Elf64_Word,
    pub st_info: core::ffi::c_uchar,
    pub st_other: core::ffi::c_uchar,
    pub st_shndx: Elf64_Half,
    pub st_value: Elf64_Addr,
    pub st_size: Elf64_Xword,
}
pub type Elf64_Sym = elf64_sym;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_hdr {
    pub e_ident: [core::ffi::c_uchar; 16usize],
    pub e_type: Elf32_Half,
    pub e_machine: Elf32_Half,
    pub e_version: Elf32_Word,
    pub e_entry: Elf32_Addr,
    pub e_phoff: Elf32_Off,
    pub e_shoff: Elf32_Off,
    pub e_flags: Elf32_Word,
    pub e_ehsize: Elf32_Half,
    pub e_phentsize: Elf32_Half,
    pub e_phnum: Elf32_Half,
    pub e_shentsize: Elf32_Half,
    pub e_shnum: Elf32_Half,
    pub e_shstrndx: Elf32_Half,
}
pub type Elf32_Ehdr = elf32_hdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_hdr {
    pub e_ident: [core::ffi::c_uchar; 16usize],
    pub e_type: Elf64_Half,
    pub e_machine: Elf64_Half,
    pub e_version: Elf64_Word,
    pub e_entry: Elf64_Addr,
    pub e_phoff: Elf64_Off,
    pub e_shoff: Elf64_Off,
    pub e_flags: Elf64_Word,
    pub e_ehsize: Elf64_Half,
    pub e_phentsize: Elf64_Half,
    pub e_phnum: Elf64_Half,
    pub e_shentsize: Elf64_Half,
    pub e_shnum: Elf64_Half,
    pub e_shstrndx: Elf64_Half,
}
pub type Elf64_Ehdr = elf64_hdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_phdr {
    pub p_type: Elf32_Word,
    pub p_offset: Elf32_Off,
    pub p_vaddr: Elf32_Addr,
    pub p_paddr: Elf32_Addr,
    pub p_filesz: Elf32_Word,
    pub p_memsz: Elf32_Word,
    pub p_flags: Elf32_Word,
    pub p_align: Elf32_Word,
}
pub type Elf32_Phdr = elf32_phdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_phdr {
    pub p_type: Elf64_Word,
    pub p_flags: Elf64_Word,
    pub p_offset: Elf64_Off,
    pub p_vaddr: Elf64_Addr,
    pub p_paddr: Elf64_Addr,
    pub p_filesz: Elf64_Xword,
    pub p_memsz: Elf64_Xword,
    pub p_align: Elf64_Xword,
}
pub type Elf64_Phdr = elf64_phdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_shdr {
    pub sh_name: Elf32_Word,
    pub sh_type: Elf32_Word,
    pub sh_flags: Elf32_Word,
    pub sh_addr: Elf32_Addr,
    pub sh_offset: Elf32_Off,
    pub sh_size: Elf32_Word,
    pub sh_link: Elf32_Word,
    pub sh_info: Elf32_Word,
    pub sh_addralign: Elf32_Word,
    pub sh_entsize: Elf32_Word,
}
pub type Elf32_Shdr = elf32_shdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_shdr {
    pub sh_name: Elf64_Word,
    pub sh_type: Elf64_Word,
    pub sh_flags: Elf64_Xword,
    pub sh_addr: Elf64_Addr,
    pub sh_offset: Elf64_Off,
    pub sh_size: Elf64_Xword,
    pub sh_link: Elf64_Word,
    pub sh_info: Elf64_Word,
    pub sh_addralign: Elf64_Xword,
    pub sh_entsize: Elf64_Xword,
}
pub type Elf64_Shdr = elf64_shdr;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf32_note {
    pub n_namesz: Elf32_Word,
    pub n_descsz: Elf32_Word,
    pub n_type: Elf32_Word,
}
pub type Elf32_Nhdr = elf32_note;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct elf64_note {
    pub n_namesz: Elf64_Word,
    pub n_descsz: Elf64_Word,
    pub n_type: Elf64_Word,
}
pub type Elf64_Nhdr = elf64_note;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhash_head {
    pub next: *mut rhash_head,
}
impl Default for rhash_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhlist_head {
    pub rhead: rhash_head,
    pub next: *mut rhlist_head,
}
impl Default for rhlist_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bucket_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable_compare_arg {
    pub ht: *mut rhashtable,
    pub key: *const core::ffi::c_void,
}
impl Default for rhashtable_compare_arg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type rht_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(data: *const core::ffi::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_hashfn_t = ::core::option::Option<
    unsafe extern "C" fn(data: *const core::ffi::c_void, len: u32_, seed: u32_) -> u32_,
>;
pub type rht_obj_cmpfn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut rhashtable_compare_arg,
        obj: *const core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rhashtable_params {
    pub nelem_hint: u16_,
    pub key_len: u16_,
    pub key_offset: u16_,
    pub head_offset: u16_,
    pub max_size: core::ffi::c_uint,
    pub min_size: u16_,
    pub automatic_shrinking: bool_,
    pub hashfn: rht_hashfn_t,
    pub obj_hashfn: rht_obj_hashfn_t,
    pub obj_cmpfn: rht_obj_cmpfn_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable {
    pub tbl: *mut bucket_table,
    pub key_len: core::ffi::c_uint,
    pub max_elems: core::ffi::c_uint,
    pub p: rhashtable_params,
    pub rhlist: bool_,
    pub run_work: work_struct,
    pub mutex: mutex,
    pub lock: spinlock_t,
    pub nelems: atomic_t,
}
impl Default for rhashtable {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhltable {
    pub ht: rhashtable,
}
impl Default for rhltable {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable_walker {
    pub list: list_head,
    pub tbl: *mut bucket_table,
}
impl Default for rhashtable_walker {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rhashtable_iter {
    pub ht: *mut rhashtable,
    pub p: *mut rhash_head,
    pub list: *mut rhlist_head,
    pub walker: rhashtable_walker,
    pub slot: core::ffi::c_uint,
    pub skip: core::ffi::c_uint,
    pub end_of_table: bool_,
}
impl Default for rhashtable_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn rhashtable_init(
        ht: *mut rhashtable,
        params: *const rhashtable_params,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rhltable_init(hlt: *mut rhltable, params: *const rhashtable_params) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ipc_perm {
    pub key: __kernel_key_t,
    pub uid: __kernel_uid_t,
    pub gid: __kernel_gid_t,
    pub cuid: __kernel_uid_t,
    pub cgid: __kernel_gid_t,
    pub mode: __kernel_mode_t,
    pub seq: core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Default)]
pub struct ipc64_perm {
    pub key: __kernel_key_t,
    pub uid: __kernel_uid32_t,
    pub gid: __kernel_gid32_t,
    pub cuid: __kernel_uid32_t,
    pub cgid: __kernel_gid32_t,
    pub mode: __kernel_mode_t,
    pub __pad1: __IncompleteArrayField<core::ffi::c_uchar>,
    pub seq: core::ffi::c_ushort,
    pub __pad2: core::ffi::c_ushort,
    pub __unused1: __kernel_ulong_t,
    pub __unused2: __kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipc_kludge {
    pub msgp: *mut msgbuf,
    pub msgtyp: core::ffi::c_long,
}
impl Default for ipc_kludge {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct kern_ipc_perm {
    pub lock: spinlock_t,
    pub deleted: bool_,
    pub id: core::ffi::c_int,
    pub key: key_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub cuid: kuid_t,
    pub cgid: kgid_t,
    pub mode: umode_t,
    pub seq: core::ffi::c_ulong,
    pub security: *mut core::ffi::c_void,
    pub khtnode: rhash_head,
    pub rcu: callback_head,
    pub refcount: refcount_t,
}
impl Default for kern_ipc_perm {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct semid_ds {
    pub sem_perm: ipc_perm,
    pub sem_otime: __kernel_old_time_t,
    pub sem_ctime: __kernel_old_time_t,
    pub sem_base: *mut sem,
    pub sem_pending: *mut sem_queue,
    pub sem_pending_last: *mut *mut sem_queue,
    pub undo: *mut sem_undo,
    pub sem_nsems: core::ffi::c_ushort,
}
impl Default for semid_ds {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct semid64_ds {
    pub sem_perm: ipc64_perm,
    pub sem_otime: core::ffi::c_long,
    pub sem_ctime: core::ffi::c_long,
    pub sem_nsems: core::ffi::c_ulong,
    pub __unused3: core::ffi::c_ulong,
    pub __unused4: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sembuf {
    pub sem_num: core::ffi::c_ushort,
    pub sem_op: core::ffi::c_short,
    pub sem_flg: core::ffi::c_short,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union semun {
    pub val: core::ffi::c_int,
    pub buf: *mut semid_ds,
    pub array: *mut core::ffi::c_ushort,
    pub __buf: *mut seminfo,
    pub __pad: *mut core::ffi::c_void,
    _bindgen_union_align: u64,
}
impl Default for semun {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seminfo {
    pub semmap: core::ffi::c_int,
    pub semmni: core::ffi::c_int,
    pub semmns: core::ffi::c_int,
    pub semmnu: core::ffi::c_int,
    pub semmsl: core::ffi::c_int,
    pub semopm: core::ffi::c_int,
    pub semume: core::ffi::c_int,
    pub semusz: core::ffi::c_int,
    pub semvmx: core::ffi::c_int,
    pub semaem: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sem_undo_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sysv_sem {
    pub undo_list: *mut sem_undo_list,
}
impl Default for sysv_sem {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn copy_semundo(clone_flags: core::ffi::c_ulong, tsk: *mut task_struct)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn exit_sem(tsk: *mut task_struct);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut core::ffi::c_void,
    pub iov_len: __kernel_size_t,
}
impl Default for iovec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kvec {
    pub iov_base: *mut core::ffi::c_void,
    pub iov_len: usize,
}
impl Default for kvec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const iter_type_ITER_IOVEC: iter_type = 0;
pub const iter_type_ITER_KVEC: iter_type = 1;
pub const iter_type_ITER_BVEC: iter_type = 2;
pub const iter_type_ITER_PIPE: iter_type = 3;
pub const iter_type_ITER_XARRAY: iter_type = 4;
pub const iter_type_ITER_DISCARD: iter_type = 5;
pub const iter_type_ITER_UBUF: iter_type = 6;
pub type iter_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct iov_iter_state {
    pub iov_offset: usize,
    pub count: usize,
    pub nr_segs: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iov_iter {
    pub iter_type: u8_,
    pub nofault: bool_,
    pub data_source: bool_,
    pub user_backed: bool_,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_1,
    pub count: usize,
    pub __bindgen_anon_2: iov_iter__bindgen_ty_2,
    pub __bindgen_anon_3: iov_iter__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_1 {
    pub iov_offset: usize,
    pub last_offset: core::ffi::c_int,
    _bindgen_union_align: u64,
}
impl Default for iov_iter__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_2 {
    pub iov: *const iovec,
    pub kvec: *const kvec,
    pub bvec: *const bio_vec,
    pub xarray: *mut xarray,
    pub pipe: *mut pipe_inode_info,
    pub ubuf: *mut core::ffi::c_void,
    _bindgen_union_align: u64,
}
impl Default for iov_iter__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iov_iter__bindgen_ty_3 {
    pub nr_segs: core::ffi::c_ulong,
    pub __bindgen_anon_1: iov_iter__bindgen_ty_3__bindgen_ty_1,
    pub xarray_start: loff_t,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct iov_iter__bindgen_ty_3__bindgen_ty_1 {
    pub head: core::ffi::c_uint,
    pub start_head: core::ffi::c_uint,
}
impl Default for iov_iter__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for iov_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn copy_page_from_iter_atomic(
        page: *mut page,
        offset: core::ffi::c_uint,
        bytes: usize,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn iov_iter_advance(i: *mut iov_iter, bytes: usize);
}
extern "C" {
    pub fn iov_iter_revert(i: *mut iov_iter, bytes: usize);
}
extern "C" {
    pub fn fault_in_iov_iter_readable(i: *const iov_iter, bytes: usize) -> usize;
}
extern "C" {
    pub fn fault_in_iov_iter_writeable(i: *const iov_iter, bytes: usize) -> usize;
}
extern "C" {
    pub fn iov_iter_single_seg_count(i: *const iov_iter) -> usize;
}
extern "C" {
    pub fn copy_page_to_iter(
        page: *mut page,
        offset: usize,
        bytes: usize,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn copy_page_from_iter(
        page: *mut page,
        offset: usize,
        bytes: usize,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn _copy_to_iter(addr: *const core::ffi::c_void, bytes: usize, i: *mut iov_iter) -> usize;
}
extern "C" {
    pub fn _copy_from_iter(addr: *mut core::ffi::c_void, bytes: usize, i: *mut iov_iter) -> usize;
}
extern "C" {
    pub fn _copy_from_iter_nocache(
        addr: *mut core::ffi::c_void,
        bytes: usize,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn iov_iter_zero(bytes: usize, arg1: *mut iov_iter) -> usize;
}
extern "C" {
    pub fn iov_iter_is_aligned(
        i: *const iov_iter,
        addr_mask: core::ffi::c_uint,
        len_mask: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn iov_iter_alignment(i: *const iov_iter) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn iov_iter_gap_alignment(i: *const iov_iter) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn iov_iter_init(
        i: *mut iov_iter,
        direction: core::ffi::c_uint,
        iov: *const iovec,
        nr_segs: core::ffi::c_ulong,
        count: usize,
    );
}
extern "C" {
    pub fn iov_iter_kvec(
        i: *mut iov_iter,
        direction: core::ffi::c_uint,
        kvec: *const kvec,
        nr_segs: core::ffi::c_ulong,
        count: usize,
    );
}
extern "C" {
    pub fn iov_iter_bvec(
        i: *mut iov_iter,
        direction: core::ffi::c_uint,
        bvec: *const bio_vec,
        nr_segs: core::ffi::c_ulong,
        count: usize,
    );
}
extern "C" {
    pub fn iov_iter_pipe(
        i: *mut iov_iter,
        direction: core::ffi::c_uint,
        pipe: *mut pipe_inode_info,
        count: usize,
    );
}
extern "C" {
    pub fn iov_iter_discard(i: *mut iov_iter, direction: core::ffi::c_uint, count: usize);
}
extern "C" {
    pub fn iov_iter_xarray(
        i: *mut iov_iter,
        direction: core::ffi::c_uint,
        xarray: *mut xarray,
        start: loff_t,
        count: usize,
    );
}
extern "C" {
    pub fn iov_iter_get_pages2(
        i: *mut iov_iter,
        pages: *mut *mut page,
        maxsize: usize,
        maxpages: core::ffi::c_uint,
        start: *mut usize,
    ) -> isize;
}
extern "C" {
    pub fn iov_iter_get_pages_alloc2(
        i: *mut iov_iter,
        pages: *mut *mut *mut page,
        maxsize: usize,
        start: *mut usize,
    ) -> isize;
}
extern "C" {
    pub fn iov_iter_npages(i: *const iov_iter, maxpages: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn iov_iter_restore(i: *mut iov_iter, state: *mut iov_iter_state);
}
extern "C" {
    pub fn dup_iter(
        new: *mut iov_iter,
        old: *mut iov_iter,
        flags: gfp_t,
    ) -> *const core::ffi::c_void;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct csum_state {
    pub csum: __wsum,
    pub off: usize,
}
extern "C" {
    pub fn csum_and_copy_to_iter(
        addr: *const core::ffi::c_void,
        bytes: usize,
        csstate: *mut core::ffi::c_void,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn csum_and_copy_from_iter(
        addr: *mut core::ffi::c_void,
        bytes: usize,
        csum: *mut __wsum,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn hash_and_copy_to_iter(
        addr: *const core::ffi::c_void,
        bytes: usize,
        hashp: *mut core::ffi::c_void,
        i: *mut iov_iter,
    ) -> usize;
}
extern "C" {
    pub fn iovec_from_user(
        uvector: *const iovec,
        nr_segs: core::ffi::c_ulong,
        fast_segs: core::ffi::c_ulong,
        fast_iov: *mut iovec,
        compat: bool_,
    ) -> *mut iovec;
}
extern "C" {
    pub fn import_iovec(
        type_: core::ffi::c_int,
        uvec: *const iovec,
        nr_segs: core::ffi::c_uint,
        fast_segs: core::ffi::c_uint,
        iovp: *mut *mut iovec,
        i: *mut iov_iter,
    ) -> isize;
}
extern "C" {
    pub fn __import_iovec(
        type_: core::ffi::c_int,
        uvec: *const iovec,
        nr_segs: core::ffi::c_uint,
        fast_segs: core::ffi::c_uint,
        iovp: *mut *mut iovec,
        i: *mut iov_iter,
        compat: bool_,
    ) -> isize;
}
extern "C" {
    pub fn import_single_range(
        type_: core::ffi::c_int,
        buf: *mut core::ffi::c_void,
        len: usize,
        iov: *mut iovec,
        i: *mut iov_iter,
    ) -> core::ffi::c_int;
}
pub type __kernel_sa_family_t = core::ffi::c_ushort;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __kernel_sockaddr_storage__bindgen_ty_1 {
    pub __bindgen_anon_1: __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1,
    pub __align: *mut core::ffi::c_void,
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    pub ss_family: __kernel_sa_family_t,
    pub __data: [core::ffi::c_char; 126usize],
}
impl Default for __kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for __kernel_sockaddr_storage__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for __kernel_sockaddr_storage {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn socket_seq_show(seq: *mut seq_file);
}
pub type sa_family_t = __kernel_sa_family_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [core::ffi::c_char; 14usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct linger {
    pub l_onoff: core::ffi::c_int,
    pub l_linger: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut core::ffi::c_void,
    pub msg_namelen: core::ffi::c_int,
    pub msg_inq: core::ffi::c_int,
    pub msg_iter: iov_iter,
    pub __bindgen_anon_1: msghdr__bindgen_ty_1,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub msg_flags: core::ffi::c_uint,
    pub msg_controllen: __kernel_size_t,
    pub msg_iocb: *mut kiocb,
    pub msg_ubuf: *mut ubuf_info,
    pub sg_from_iter: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            skb: *mut sk_buff,
            from: *mut iov_iter,
            length: usize,
        ) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msghdr__bindgen_ty_1 {
    pub msg_control: *mut core::ffi::c_void,
    pub msg_control_user: *mut core::ffi::c_void,
    _bindgen_union_align: u64,
}
impl Default for msghdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for msghdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl msghdr {
    #[inline]
    pub fn msg_control_is_user(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_control_is_user(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn msg_get_inq(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_msg_get_inq(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        msg_control_is_user: bool_,
        msg_get_inq: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let msg_control_is_user: u8 = unsafe { ::core::mem::transmute(msg_control_is_user) };
            msg_control_is_user as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let msg_get_inq: u8 = unsafe { ::core::mem::transmute(msg_get_inq) };
            msg_get_inq as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_msghdr {
    pub msg_name: *mut core::ffi::c_void,
    pub msg_namelen: core::ffi::c_int,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: __kernel_size_t,
    pub msg_control: *mut core::ffi::c_void,
    pub msg_controllen: __kernel_size_t,
    pub msg_flags: core::ffi::c_uint,
}
impl Default for user_msghdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmsghdr {
    pub msg_hdr: user_msghdr,
    pub msg_len: core::ffi::c_uint,
}
impl Default for mmsghdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: __kernel_size_t,
    pub cmsg_level: core::ffi::c_int,
    pub cmsg_type: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ucred {
    pub pid: __u32,
    pub uid: __u32,
    pub gid: __u32,
}
extern "C" {
    pub fn move_addr_to_kernel(
        uaddr: *mut core::ffi::c_void,
        ulen: core::ffi::c_int,
        kaddr: *mut __kernel_sockaddr_storage,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_cmsg(
        arg1: *mut msghdr,
        level: core::ffi::c_int,
        type_: core::ffi::c_int,
        len: core::ffi::c_int,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scm_timestamping_internal {
    pub ts: [timespec64; 3usize],
}
extern "C" {
    pub fn put_cmsg_scm_timestamping64(msg: *mut msghdr, tss: *mut scm_timestamping_internal);
}
extern "C" {
    pub fn put_cmsg_scm_timestamping(msg: *mut msghdr, tss: *mut scm_timestamping_internal);
}
extern "C" {
    pub fn __sys_recvmsg(
        fd: core::ffi::c_int,
        msg: *mut user_msghdr,
        flags: core::ffi::c_uint,
        forbid_cmsg_compat: bool_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn __sys_sendmsg(
        fd: core::ffi::c_int,
        msg: *mut user_msghdr,
        flags: core::ffi::c_uint,
        forbid_cmsg_compat: bool_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn __sys_recvmmsg(
        fd: core::ffi::c_int,
        mmsg: *mut mmsghdr,
        vlen: core::ffi::c_uint,
        flags: core::ffi::c_uint,
        timeout: *mut __kernel_timespec,
        timeout32: *mut old_timespec32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_sendmmsg(
        fd: core::ffi::c_int,
        mmsg: *mut mmsghdr,
        vlen: core::ffi::c_uint,
        flags: core::ffi::c_uint,
        forbid_cmsg_compat: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_sendmsg_sock(
        sock: *mut socket,
        msg: *mut msghdr,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn __sys_recvmsg_sock(
        sock: *mut socket,
        msg: *mut msghdr,
        umsg: *mut user_msghdr,
        uaddr: *mut sockaddr,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn sendmsg_copy_msghdr(
        msg: *mut msghdr,
        umsg: *mut user_msghdr,
        flags: core::ffi::c_uint,
        iov: *mut *mut iovec,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn recvmsg_copy_msghdr(
        msg: *mut msghdr,
        umsg: *mut user_msghdr,
        flags: core::ffi::c_uint,
        uaddr: *mut *mut sockaddr,
        iov: *mut *mut iovec,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __copy_msghdr(
        kmsg: *mut msghdr,
        umsg: *mut user_msghdr,
        save_addr: *mut *mut sockaddr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_recvfrom(
        fd: core::ffi::c_int,
        ubuf: *mut core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_uint,
        addr: *mut sockaddr,
        addr_len: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_sendto(
        fd: core::ffi::c_int,
        buff: *mut core::ffi::c_void,
        len: usize,
        flags: core::ffi::c_uint,
        addr: *mut sockaddr,
        addr_len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_accept(
        file: *mut file,
        file_flags: core::ffi::c_uint,
        upeer_sockaddr: *mut sockaddr,
        upeer_addrlen: *mut core::ffi::c_int,
        flags: core::ffi::c_int,
    ) -> *mut file;
}
extern "C" {
    pub fn __sys_accept4(
        fd: core::ffi::c_int,
        upeer_sockaddr: *mut sockaddr,
        upeer_addrlen: *mut core::ffi::c_int,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_socket(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        protocol: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_socket_file(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        protocol: core::ffi::c_int,
    ) -> *mut file;
}
extern "C" {
    pub fn __sys_bind(
        fd: core::ffi::c_int,
        umyaddr: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_connect_file(
        file: *mut file,
        addr: *mut __kernel_sockaddr_storage,
        addrlen: core::ffi::c_int,
        file_flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_connect(
        fd: core::ffi::c_int,
        uservaddr: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_listen(fd: core::ffi::c_int, backlog: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_getsockname(
        fd: core::ffi::c_int,
        usockaddr: *mut sockaddr,
        usockaddr_len: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_getpeername(
        fd: core::ffi::c_int,
        usockaddr: *mut sockaddr,
        usockaddr_len: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_socketpair(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        protocol: core::ffi::c_int,
        usockvec: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_shutdown_sock(sock: *mut socket, how: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sys_shutdown(fd: core::ffi::c_int, how: core::ffi::c_int) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sync_serial_settings {
    pub clock_rate: core::ffi::c_uint,
    pub clock_type: core::ffi::c_uint,
    pub loopback: core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct te1_settings {
    pub clock_rate: core::ffi::c_uint,
    pub clock_type: core::ffi::c_uint,
    pub loopback: core::ffi::c_ushort,
    pub slot_map: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct raw_hdlc_proto {
    pub encoding: core::ffi::c_ushort,
    pub parity: core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fr_proto {
    pub t391: core::ffi::c_uint,
    pub t392: core::ffi::c_uint,
    pub n391: core::ffi::c_uint,
    pub n392: core::ffi::c_uint,
    pub n393: core::ffi::c_uint,
    pub lmi: core::ffi::c_ushort,
    pub dce: core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fr_proto_pvc {
    pub dlci: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fr_proto_pvc_info {
    pub dlci: core::ffi::c_uint,
    pub master: [core::ffi::c_char; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cisco_proto {
    pub interval: core::ffi::c_uint,
    pub timeout: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x25_hdlc_proto {
    pub dce: core::ffi::c_ushort,
    pub modulo: core::ffi::c_uint,
    pub window: core::ffi::c_uint,
    pub t1: core::ffi::c_uint,
    pub t2: core::ffi::c_uint,
    pub n2: core::ffi::c_uint,
}
pub const net_device_flags_IFF_UP: net_device_flags = 1;
pub const net_device_flags_IFF_BROADCAST: net_device_flags = 2;
pub const net_device_flags_IFF_DEBUG: net_device_flags = 4;
pub const net_device_flags_IFF_LOOPBACK: net_device_flags = 8;
pub const net_device_flags_IFF_POINTOPOINT: net_device_flags = 16;
pub const net_device_flags_IFF_NOTRAILERS: net_device_flags = 32;
pub const net_device_flags_IFF_RUNNING: net_device_flags = 64;
pub const net_device_flags_IFF_NOARP: net_device_flags = 128;
pub const net_device_flags_IFF_PROMISC: net_device_flags = 256;
pub const net_device_flags_IFF_ALLMULTI: net_device_flags = 512;
pub const net_device_flags_IFF_MASTER: net_device_flags = 1024;
pub const net_device_flags_IFF_SLAVE: net_device_flags = 2048;
pub const net_device_flags_IFF_MULTICAST: net_device_flags = 4096;
pub const net_device_flags_IFF_PORTSEL: net_device_flags = 8192;
pub const net_device_flags_IFF_AUTOMEDIA: net_device_flags = 16384;
pub const net_device_flags_IFF_DYNAMIC: net_device_flags = 32768;
pub const net_device_flags_IFF_LOWER_UP: net_device_flags = 65536;
pub const net_device_flags_IFF_DORMANT: net_device_flags = 131072;
pub const net_device_flags_IFF_ECHO: net_device_flags = 262144;
pub type net_device_flags = core::ffi::c_uint;
pub const IF_OPER_UNKNOWN: core::ffi::c_uint = 0;
pub const IF_OPER_NOTPRESENT: core::ffi::c_uint = 1;
pub const IF_OPER_DOWN: core::ffi::c_uint = 2;
pub const IF_OPER_LOWERLAYERDOWN: core::ffi::c_uint = 3;
pub const IF_OPER_TESTING: core::ffi::c_uint = 4;
pub const IF_OPER_DORMANT: core::ffi::c_uint = 5;
pub const IF_OPER_UP: core::ffi::c_uint = 6;
pub type _bindgen_ty_63 = core::ffi::c_uint;
pub const IF_LINK_MODE_DEFAULT: core::ffi::c_uint = 0;
pub const IF_LINK_MODE_DORMANT: core::ffi::c_uint = 1;
pub const IF_LINK_MODE_TESTING: core::ffi::c_uint = 2;
pub type _bindgen_ty_64 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifmap {
    pub mem_start: core::ffi::c_ulong,
    pub mem_end: core::ffi::c_ulong,
    pub base_addr: core::ffi::c_ushort,
    pub irq: core::ffi::c_uchar,
    pub dma: core::ffi::c_uchar,
    pub port: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct if_settings {
    pub type_: core::ffi::c_uint,
    pub size: core::ffi::c_uint,
    pub ifs_ifsu: if_settings__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union if_settings__bindgen_ty_1 {
    pub raw_hdlc: *mut raw_hdlc_proto,
    pub cisco: *mut cisco_proto,
    pub fr: *mut fr_proto,
    pub fr_pvc: *mut fr_proto_pvc,
    pub fr_pvc_info: *mut fr_proto_pvc_info,
    pub x25: *mut x25_hdlc_proto,
    pub sync: *mut sync_serial_settings,
    pub te1: *mut te1_settings,
    _bindgen_union_align: u64,
}
impl Default for if_settings__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for if_settings {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifreq {
    pub ifr_ifrn: ifreq__bindgen_ty_1,
    pub ifr_ifru: ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_1 {
    pub ifrn_name: [core::ffi::c_char; 16usize],
    _bindgen_union_align: [u8; 16usize],
}
impl Default for ifreq__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifreq__bindgen_ty_2 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_netmask: sockaddr,
    pub ifru_hwaddr: sockaddr,
    pub ifru_flags: core::ffi::c_short,
    pub ifru_ivalue: core::ffi::c_int,
    pub ifru_mtu: core::ffi::c_int,
    pub ifru_map: ifmap,
    pub ifru_slave: [core::ffi::c_char; 16usize],
    pub ifru_newname: [core::ffi::c_char; 16usize],
    pub ifru_data: *mut core::ffi::c_void,
    pub ifru_settings: if_settings,
    _bindgen_union_align: [u64; 3usize],
}
impl Default for ifreq__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for ifreq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifconf {
    pub ifc_len: core::ffi::c_int,
    pub ifc_ifcu: ifconf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ifconf__bindgen_ty_1 {
    pub ifcu_buf: *mut core::ffi::c_char,
    pub ifcu_req: *mut ifreq,
    _bindgen_union_align: u64,
}
impl Default for ifconf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for ifconf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_bit_key {
    pub flags: *mut core::ffi::c_void,
    pub bit_nr: core::ffi::c_int,
    pub timeout: core::ffi::c_ulong,
}
impl Default for wait_bit_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_bit_queue_entry {
    pub key: wait_bit_key,
    pub wq_entry: wait_queue_entry,
}
impl Default for wait_bit_queue_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type wait_bit_action_f = ::core::option::Option<
    unsafe extern "C" fn(key: *mut wait_bit_key, mode: core::ffi::c_int) -> core::ffi::c_int,
>;
extern "C" {
    pub fn __wake_up_bit(
        wq_head: *mut wait_queue_head,
        word: *mut core::ffi::c_void,
        bit: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __wait_on_bit(
        wq_head: *mut wait_queue_head,
        wbq_entry: *mut wait_bit_queue_entry,
        action: wait_bit_action_f,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __wait_on_bit_lock(
        wq_head: *mut wait_queue_head,
        wbq_entry: *mut wait_bit_queue_entry,
        action: wait_bit_action_f,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn wake_up_bit(word: *mut core::ffi::c_void, bit: core::ffi::c_int);
}
extern "C" {
    pub fn out_of_line_wait_on_bit(
        word: *mut core::ffi::c_void,
        arg1: core::ffi::c_int,
        action: wait_bit_action_f,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn out_of_line_wait_on_bit_timeout(
        word: *mut core::ffi::c_void,
        arg1: core::ffi::c_int,
        action: wait_bit_action_f,
        mode: core::ffi::c_uint,
        timeout: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn out_of_line_wait_on_bit_lock(
        word: *mut core::ffi::c_void,
        arg1: core::ffi::c_int,
        action: wait_bit_action_f,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bit_waitqueue(
        word: *mut core::ffi::c_void,
        bit: core::ffi::c_int,
    ) -> *mut wait_queue_head;
}
extern "C" {
    pub fn wait_bit_init();
}
extern "C" {
    pub fn wake_bit_function(
        wq_entry: *mut wait_queue_entry,
        mode: core::ffi::c_uint,
        sync: core::ffi::c_int,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bit_wait(key: *mut wait_bit_key, mode: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn bit_wait_io(key: *mut wait_bit_key, mode: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn bit_wait_timeout(key: *mut wait_bit_key, mode: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn bit_wait_io_timeout(key: *mut wait_bit_key, mode: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn init_wait_var_entry(
        wbq_entry: *mut wait_bit_queue_entry,
        var: *mut core::ffi::c_void,
        flags: core::ffi::c_int,
    );
}
extern "C" {
    pub fn wake_up_var(var: *mut core::ffi::c_void);
}
extern "C" {
    pub fn __var_waitqueue(p: *mut core::ffi::c_void) -> *mut wait_queue_head_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_bl_head {
    pub first: *mut hlist_bl_node,
}
impl Default for hlist_bl_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_bl_node {
    pub next: *mut hlist_bl_node,
    pub pprev: *mut *mut hlist_bl_node,
}
impl Default for hlist_bl_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lockref {
    pub __bindgen_anon_1: lockref__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union lockref__bindgen_ty_1 {
    pub __bindgen_anon_1: lockref__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct lockref__bindgen_ty_1__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub count: core::ffi::c_int,
}
impl Default for lockref__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for lockref {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn lockref_get(arg1: *mut lockref);
}
extern "C" {
    pub fn lockref_put_return(arg1: *mut lockref) -> core::ffi::c_int;
}
extern "C" {
    pub fn lockref_get_not_zero(arg1: *mut lockref) -> core::ffi::c_int;
}
extern "C" {
    pub fn lockref_put_not_zero(arg1: *mut lockref) -> core::ffi::c_int;
}
extern "C" {
    pub fn lockref_put_or_lock(arg1: *mut lockref) -> core::ffi::c_int;
}
extern "C" {
    pub fn lockref_mark_dead(arg1: *mut lockref);
}
extern "C" {
    pub fn lockref_get_not_dead(arg1: *mut lockref) -> core::ffi::c_int;
}
extern "C" {
    pub fn full_name_hash(
        salt: *const core::ffi::c_void,
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn hashlen_string(salt: *const core::ffi::c_void, name: *const core::ffi::c_char) -> u64_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qstr {
    pub __bindgen_anon_1: qstr__bindgen_ty_1,
    pub name: *const core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union qstr__bindgen_ty_1 {
    pub __bindgen_anon_1: qstr__bindgen_ty_1__bindgen_ty_1,
    pub hash_len: u64_,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qstr__bindgen_ty_1__bindgen_ty_1 {
    pub hash: u32_,
    pub len: u32_,
}
impl Default for qstr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for qstr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static empty_name: qstr;
}
extern "C" {
    pub static slash_name: qstr;
}
extern "C" {
    pub static dotdot_name: qstr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dentry {
    pub d_flags: core::ffi::c_uint,
    pub d_seq: seqcount_spinlock_t,
    pub d_hash: hlist_bl_node,
    pub d_parent: *mut dentry,
    pub d_name: qstr,
    pub d_inode: *mut inode,
    pub d_iname: [core::ffi::c_uchar; 32usize],
    pub d_lockref: lockref,
    pub d_op: *const dentry_operations,
    pub d_sb: *mut super_block,
    pub d_time: core::ffi::c_ulong,
    pub d_fsdata: *mut core::ffi::c_void,
    pub __bindgen_anon_1: dentry__bindgen_ty_1,
    pub d_child: list_head,
    pub d_subdirs: list_head,
    pub d_u: dentry__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_1 {
    pub d_lru: list_head,
    pub d_wait: *mut wait_queue_head_t,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for dentry__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union dentry__bindgen_ty_2 {
    pub d_alias: hlist_node,
    pub d_in_lookup_hash: hlist_bl_node,
    pub d_rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for dentry__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for dentry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const dentry_d_lock_class_DENTRY_D_LOCK_NORMAL: dentry_d_lock_class = 0;
pub const dentry_d_lock_class_DENTRY_D_LOCK_NESTED: dentry_d_lock_class = 1;
pub type dentry_d_lock_class = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dentry_operations {
    pub d_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub d_weak_revalidate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub d_hash: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dentry, arg2: *mut qstr) -> core::ffi::c_int,
    >,
    pub d_compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const dentry,
            arg2: core::ffi::c_uint,
            arg3: *const core::ffi::c_char,
            arg4: *const qstr,
        ) -> core::ffi::c_int,
    >,
    pub d_delete:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dentry) -> core::ffi::c_int>,
    pub d_init: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry) -> core::ffi::c_int>,
    pub d_release: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_prune: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    pub d_iput: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut inode)>,
    pub d_dname: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut core::ffi::c_char,
            arg3: core::ffi::c_int,
        ) -> *mut core::ffi::c_char,
    >,
    pub d_automount: ::core::option::Option<unsafe extern "C" fn(arg1: *mut path) -> *mut vfsmount>,
    pub d_manage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const path, arg2: bool_) -> core::ffi::c_int,
    >,
    pub d_real: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *const inode) -> *mut dentry,
    >,
}
impl Default for dentry_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut rename_lock: seqlock_t;
}
extern "C" {
    pub fn d_instantiate(arg1: *mut dentry, arg2: *mut inode);
}
extern "C" {
    pub fn d_instantiate_new(arg1: *mut dentry, arg2: *mut inode);
}
extern "C" {
    pub fn d_instantiate_unique(arg1: *mut dentry, arg2: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_instantiate_anon(arg1: *mut dentry, arg2: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn __d_drop(dentry: *mut dentry);
}
extern "C" {
    pub fn d_drop(dentry: *mut dentry);
}
extern "C" {
    pub fn d_delete(arg1: *mut dentry);
}
extern "C" {
    pub fn d_set_d_op(dentry: *mut dentry, op: *const dentry_operations);
}
extern "C" {
    pub fn d_alloc(arg1: *mut dentry, arg2: *const qstr) -> *mut dentry;
}
extern "C" {
    pub fn d_alloc_anon(arg1: *mut super_block) -> *mut dentry;
}
extern "C" {
    pub fn d_alloc_parallel(
        arg1: *mut dentry,
        arg2: *const qstr,
        arg3: *mut wait_queue_head_t,
    ) -> *mut dentry;
}
extern "C" {
    pub fn d_splice_alias(arg1: *mut inode, arg2: *mut dentry) -> *mut dentry;
}
extern "C" {
    pub fn d_add_ci(arg1: *mut dentry, arg2: *mut inode, arg3: *mut qstr) -> *mut dentry;
}
extern "C" {
    pub fn d_same_name(dentry: *const dentry, parent: *const dentry, name: *const qstr) -> bool_;
}
extern "C" {
    pub fn d_exact_alias(arg1: *mut dentry, arg2: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_find_any_alias(inode: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_obtain_alias(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_obtain_root(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn shrink_dcache_sb(arg1: *mut super_block);
}
extern "C" {
    pub fn shrink_dcache_parent(arg1: *mut dentry);
}
extern "C" {
    pub fn shrink_dcache_for_umount(arg1: *mut super_block);
}
extern "C" {
    pub fn d_invalidate(arg1: *mut dentry);
}
extern "C" {
    pub fn d_make_root(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_genocide(arg1: *mut dentry);
}
extern "C" {
    pub fn d_tmpfile(arg1: *mut file, arg2: *mut inode);
}
extern "C" {
    pub fn d_find_alias(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn d_prune_aliases(arg1: *mut inode);
}
extern "C" {
    pub fn d_find_alias_rcu(arg1: *mut inode) -> *mut dentry;
}
extern "C" {
    pub fn path_has_submounts(arg1: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn d_rehash(arg1: *mut dentry);
}
extern "C" {
    pub fn d_add(arg1: *mut dentry, arg2: *mut inode);
}
extern "C" {
    pub fn d_move(arg1: *mut dentry, arg2: *mut dentry);
}
extern "C" {
    pub fn d_exchange(arg1: *mut dentry, arg2: *mut dentry);
}
extern "C" {
    pub fn d_ancestor(arg1: *mut dentry, arg2: *mut dentry) -> *mut dentry;
}
extern "C" {
    pub fn d_lookup(arg1: *const dentry, arg2: *const qstr) -> *mut dentry;
}
extern "C" {
    pub fn d_hash_and_lookup(arg1: *mut dentry, arg2: *mut qstr) -> *mut dentry;
}
extern "C" {
    pub fn __d_lookup(arg1: *const dentry, arg2: *const qstr) -> *mut dentry;
}
extern "C" {
    pub fn __d_lookup_rcu(
        parent: *const dentry,
        name: *const qstr,
        seq: *mut core::ffi::c_uint,
    ) -> *mut dentry;
}
extern "C" {
    pub fn dynamic_dname(
        arg1: *mut core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: *const core::ffi::c_char,
        ...
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn __d_path(
        arg1: *const path,
        arg2: *const path,
        arg3: *mut core::ffi::c_char,
        arg4: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn d_absolute_path(
        arg1: *const path,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn d_path(
        arg1: *const path,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn dentry_path_raw(
        arg1: *const dentry,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn dentry_path(
        arg1: *const dentry,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn dget_parent(dentry: *mut dentry) -> *mut dentry;
}
extern "C" {
    pub fn __d_lookup_unhash_wake(dentry: *mut dentry);
}
extern "C" {
    pub fn dput(arg1: *mut dentry);
}
extern "C" {
    pub fn d_set_fallthru(dentry: *mut dentry);
}
extern "C" {
    pub static mut sysctl_vfs_cache_pressure: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct name_snapshot {
    pub name: qstr,
    pub inline_name: [core::ffi::c_uchar; 32usize],
}
impl Default for name_snapshot {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn take_dentry_name_snapshot(arg1: *mut name_snapshot, arg2: *mut dentry);
}
extern "C" {
    pub fn release_dentry_name_snapshot(arg1: *mut name_snapshot);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct path {
    pub mnt: *mut vfsmount,
    pub dentry: *mut dentry,
}
impl Default for path {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn path_get(arg1: *const path);
}
extern "C" {
    pub fn path_put(arg1: *const path);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrink_control {
    pub gfp_mask: gfp_t,
    pub nid: core::ffi::c_int,
    pub nr_to_scan: core::ffi::c_ulong,
    pub nr_scanned: core::ffi::c_ulong,
    pub memcg: *mut mem_cgroup,
}
impl Default for shrink_control {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrinker {
    pub count_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> core::ffi::c_ulong,
    >,
    pub scan_objects: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut shrinker, sc: *mut shrink_control) -> core::ffi::c_ulong,
    >,
    pub batch: core::ffi::c_long,
    pub seeks: core::ffi::c_int,
    pub flags: core::ffi::c_uint,
    pub list: list_head,
    pub id: core::ffi::c_int,
    pub nr_deferred: *mut atomic_long_t,
}
impl Default for shrinker {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn prealloc_shrinker(
        shrinker: *mut shrinker,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn register_shrinker_prepared(shrinker: *mut shrinker);
}
extern "C" {
    pub fn register_shrinker(
        shrinker: *mut shrinker,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_shrinker(shrinker: *mut shrinker);
}
extern "C" {
    pub fn free_prealloced_shrinker(shrinker: *mut shrinker);
}
extern "C" {
    pub fn synchronize_shrinkers();
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct clone_args {
    pub flags: __u64,
    pub pidfd: __u64,
    pub child_tid: __u64,
    pub parent_tid: __u64,
    pub exit_signal: __u64,
    pub stack: __u64,
    pub stack_size: __u64,
    pub tls: __u64,
    pub set_tid: __u64,
    pub set_tid_size: __u64,
    pub cgroup: __u64,
}
pub const pid_type_PIDTYPE_PID: pid_type = 0;
pub const pid_type_PIDTYPE_TGID: pid_type = 1;
pub const pid_type_PIDTYPE_PGID: pid_type = 2;
pub const pid_type_PIDTYPE_SID: pid_type = 3;
pub const pid_type_PIDTYPE_MAX: pid_type = 4;
pub type pid_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct upid {
    pub nr: core::ffi::c_int,
    pub ns: *mut pid_namespace,
}
impl Default for upid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid {
    pub count: refcount_t,
    pub level: core::ffi::c_uint,
    pub lock: spinlock_t,
    pub tasks: [hlist_head; 4usize],
    pub inodes: hlist_head,
    pub wait_pidfd: wait_queue_head_t,
    pub rcu: callback_head,
    pub numbers: [upid; 1usize],
}
impl Default for pid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut init_struct_pid: pid;
}
extern "C" {
    pub static pidfd_fops: file_operations;
}
extern "C" {
    pub fn pidfd_pid(file: *const file) -> *mut pid;
}
extern "C" {
    pub fn pidfd_get_pid(fd: core::ffi::c_uint, flags: *mut core::ffi::c_uint) -> *mut pid;
}
extern "C" {
    pub fn pidfd_get_task(
        pidfd: core::ffi::c_int,
        flags: *mut core::ffi::c_uint,
    ) -> *mut task_struct;
}
extern "C" {
    pub fn pidfd_create(pid: *mut pid, flags: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_pid(pid: *mut pid);
}
extern "C" {
    pub fn pid_task(pid: *mut pid, arg1: pid_type) -> *mut task_struct;
}
extern "C" {
    pub fn get_pid_task(pid: *mut pid, arg1: pid_type) -> *mut task_struct;
}
extern "C" {
    pub fn get_task_pid(task: *mut task_struct, type_: pid_type) -> *mut pid;
}
extern "C" {
    pub fn attach_pid(task: *mut task_struct, arg1: pid_type);
}
extern "C" {
    pub fn detach_pid(task: *mut task_struct, arg1: pid_type);
}
extern "C" {
    pub fn change_pid(task: *mut task_struct, arg1: pid_type, pid: *mut pid);
}
extern "C" {
    pub fn exchange_tids(task: *mut task_struct, old: *mut task_struct);
}
extern "C" {
    pub fn transfer_pid(old: *mut task_struct, new: *mut task_struct, arg1: pid_type);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pid_namespace {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut init_pid_ns: pid_namespace;
}
extern "C" {
    pub static mut pid_max: core::ffi::c_int;
}
extern "C" {
    pub static mut pid_max_min: core::ffi::c_int;
}
extern "C" {
    pub static mut pid_max_max: core::ffi::c_int;
}
extern "C" {
    pub fn find_pid_ns(nr: core::ffi::c_int, ns: *mut pid_namespace) -> *mut pid;
}
extern "C" {
    pub fn find_vpid(nr: core::ffi::c_int) -> *mut pid;
}
extern "C" {
    pub fn find_get_pid(nr: core::ffi::c_int) -> *mut pid;
}
extern "C" {
    pub fn find_ge_pid(nr: core::ffi::c_int, arg1: *mut pid_namespace) -> *mut pid;
}
extern "C" {
    pub fn alloc_pid(ns: *mut pid_namespace, set_tid: *mut pid_t, set_tid_size: usize) -> *mut pid;
}
extern "C" {
    pub fn free_pid(pid: *mut pid);
}
extern "C" {
    pub fn disable_pid_allocation(ns: *mut pid_namespace);
}
extern "C" {
    pub fn pid_nr_ns(pid: *mut pid, ns: *mut pid_namespace) -> pid_t;
}
extern "C" {
    pub fn pid_vnr(pid: *mut pid) -> pid_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shmid_ds {
    pub shm_perm: ipc_perm,
    pub shm_segsz: core::ffi::c_int,
    pub shm_atime: __kernel_old_time_t,
    pub shm_dtime: __kernel_old_time_t,
    pub shm_ctime: __kernel_old_time_t,
    pub shm_cpid: __kernel_ipc_pid_t,
    pub shm_lpid: __kernel_ipc_pid_t,
    pub shm_nattch: core::ffi::c_ushort,
    pub shm_unused: core::ffi::c_ushort,
    pub shm_unused2: *mut core::ffi::c_void,
    pub shm_unused3: *mut core::ffi::c_void,
}
impl Default for shmid_ds {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct shmid64_ds {
    pub shm_perm: ipc64_perm,
    pub shm_segsz: __kernel_size_t,
    pub shm_atime: core::ffi::c_long,
    pub shm_dtime: core::ffi::c_long,
    pub shm_ctime: core::ffi::c_long,
    pub shm_cpid: __kernel_pid_t,
    pub shm_lpid: __kernel_pid_t,
    pub shm_nattch: core::ffi::c_ulong,
    pub __unused4: core::ffi::c_ulong,
    pub __unused5: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct shminfo64 {
    pub shmmax: core::ffi::c_ulong,
    pub shmmin: core::ffi::c_ulong,
    pub shmmni: core::ffi::c_ulong,
    pub shmseg: core::ffi::c_ulong,
    pub shmall: core::ffi::c_ulong,
    pub __unused1: core::ffi::c_ulong,
    pub __unused2: core::ffi::c_ulong,
    pub __unused3: core::ffi::c_ulong,
    pub __unused4: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct shminfo {
    pub shmmax: core::ffi::c_int,
    pub shmmin: core::ffi::c_int,
    pub shmmni: core::ffi::c_int,
    pub shmseg: core::ffi::c_int,
    pub shmall: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct shm_info {
    pub used_ids: core::ffi::c_int,
    pub shm_tot: __kernel_ulong_t,
    pub shm_rss: __kernel_ulong_t,
    pub shm_swp: __kernel_ulong_t,
    pub swap_attempts: __kernel_ulong_t,
    pub swap_successes: __kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sysv_shm {
    pub shm_clist: list_head,
}
impl Default for sysv_shm {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn do_shmat(
        shmid: core::ffi::c_int,
        shmaddr: *mut core::ffi::c_char,
        shmflg: core::ffi::c_int,
        addr: *mut core::ffi::c_ulong,
        shmlba: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn is_file_shm_hugepages(file: *mut file) -> bool_;
}
extern "C" {
    pub fn exit_shm(task: *mut task_struct);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmsan_context_state {
    pub param_tls: [core::ffi::c_char; 800usize],
    pub retval_tls: [core::ffi::c_char; 800usize],
    pub va_arg_tls: [core::ffi::c_char; 800usize],
    pub va_arg_origin_tls: [core::ffi::c_char; 800usize],
    pub va_arg_overflow_size_tls: u64_,
    pub param_origin_tls: [core::ffi::c_char; 800usize],
    pub retval_origin_tls: u32_,
}
impl Default for kmsan_context_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmsan_ctx {
    pub cstate: kmsan_context_state,
    pub kmsan_in_runtime: core::ffi::c_int,
    pub allow_reporting: bool_,
}
impl Default for kmsan_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct plist_head {
    pub node_list: list_head,
}
impl Default for plist_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct plist_node {
    pub prio: core::ffi::c_int,
    pub prio_list: list_head,
    pub node_list: list_head,
}
impl Default for plist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn plist_add(node: *mut plist_node, head: *mut plist_head);
}
extern "C" {
    pub fn plist_del(node: *mut plist_node, head: *mut plist_head);
}
extern "C" {
    pub fn plist_requeue(node: *mut plist_node, head: *mut plist_head);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timerqueue_node {
    pub node: rb_node,
    pub expires: ktime_t,
}
impl Default for timerqueue_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timerqueue_head {
    pub rb_root: rb_root_cached,
}
impl Default for timerqueue_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn timerqueue_add(head: *mut timerqueue_head, node: *mut timerqueue_node) -> bool_;
}
extern "C" {
    pub fn timerqueue_del(head: *mut timerqueue_head, node: *mut timerqueue_node) -> bool_;
}
extern "C" {
    pub fn timerqueue_iterate_next(node: *mut timerqueue_node) -> *mut timerqueue_node;
}
pub const hrtimer_mode_HRTIMER_MODE_ABS: hrtimer_mode = 0;
pub const hrtimer_mode_HRTIMER_MODE_REL: hrtimer_mode = 1;
pub const hrtimer_mode_HRTIMER_MODE_PINNED: hrtimer_mode = 2;
pub const hrtimer_mode_HRTIMER_MODE_SOFT: hrtimer_mode = 4;
pub const hrtimer_mode_HRTIMER_MODE_HARD: hrtimer_mode = 8;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED: hrtimer_mode = 2;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED: hrtimer_mode = 3;
pub const hrtimer_mode_HRTIMER_MODE_ABS_SOFT: hrtimer_mode = 4;
pub const hrtimer_mode_HRTIMER_MODE_REL_SOFT: hrtimer_mode = 5;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED_SOFT: hrtimer_mode = 6;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED_SOFT: hrtimer_mode = 7;
pub const hrtimer_mode_HRTIMER_MODE_ABS_HARD: hrtimer_mode = 8;
pub const hrtimer_mode_HRTIMER_MODE_REL_HARD: hrtimer_mode = 9;
pub const hrtimer_mode_HRTIMER_MODE_ABS_PINNED_HARD: hrtimer_mode = 10;
pub const hrtimer_mode_HRTIMER_MODE_REL_PINNED_HARD: hrtimer_mode = 11;
pub type hrtimer_mode = core::ffi::c_uint;
pub const hrtimer_restart_HRTIMER_NORESTART: hrtimer_restart = 0;
pub const hrtimer_restart_HRTIMER_RESTART: hrtimer_restart = 1;
pub type hrtimer_restart = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer {
    pub node: timerqueue_node,
    pub _softexpires: ktime_t,
    pub function:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut hrtimer) -> hrtimer_restart>,
    pub base: *mut hrtimer_clock_base,
    pub state: u8_,
    pub is_rel: u8_,
    pub is_soft: u8_,
    pub is_hard: u8_,
}
impl Default for hrtimer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hrtimer_sleeper {
    pub timer: hrtimer,
    pub task: *mut task_struct,
}
impl Default for hrtimer_sleeper {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_clock_base {
    pub cpu_base: *mut hrtimer_cpu_base,
    pub index: core::ffi::c_uint,
    pub clockid: clockid_t,
    pub seq: seqcount_raw_spinlock_t,
    pub running: *mut hrtimer,
    pub active: timerqueue_head,
    pub get_time: ::core::option::Option<unsafe extern "C" fn() -> ktime_t>,
    pub offset: ktime_t,
}
impl Default for hrtimer_clock_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const hrtimer_base_type_HRTIMER_BASE_MONOTONIC: hrtimer_base_type = 0;
pub const hrtimer_base_type_HRTIMER_BASE_REALTIME: hrtimer_base_type = 1;
pub const hrtimer_base_type_HRTIMER_BASE_BOOTTIME: hrtimer_base_type = 2;
pub const hrtimer_base_type_HRTIMER_BASE_TAI: hrtimer_base_type = 3;
pub const hrtimer_base_type_HRTIMER_BASE_MONOTONIC_SOFT: hrtimer_base_type = 4;
pub const hrtimer_base_type_HRTIMER_BASE_REALTIME_SOFT: hrtimer_base_type = 5;
pub const hrtimer_base_type_HRTIMER_BASE_BOOTTIME_SOFT: hrtimer_base_type = 6;
pub const hrtimer_base_type_HRTIMER_BASE_TAI_SOFT: hrtimer_base_type = 7;
pub const hrtimer_base_type_HRTIMER_MAX_CLOCK_BASES: hrtimer_base_type = 8;
pub type hrtimer_base_type = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct hrtimer_cpu_base {
    pub lock: raw_spinlock_t,
    pub cpu: core::ffi::c_uint,
    pub active_bases: core::ffi::c_uint,
    pub clock_was_set_seq: core::ffi::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub nr_events: core::ffi::c_uint,
    pub nr_retries: core::ffi::c_ushort,
    pub nr_hangs: core::ffi::c_ushort,
    pub max_hang_time: core::ffi::c_uint,
    pub expires_next: ktime_t,
    pub next_timer: *mut hrtimer,
    pub softirq_expires_next: ktime_t,
    pub softirq_next_timer: *mut hrtimer,
    pub __bindgen_padding_0: [u64; 5usize],
    pub clock_base: [hrtimer_clock_base; 8usize],
}
impl Default for hrtimer_cpu_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl hrtimer_cpu_base {
    #[inline]
    pub fn hres_active(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hres_active(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_hrtirq(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_hrtirq(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hang_detected(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hang_detected(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn softirq_activated(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_softirq_activated(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hres_active: core::ffi::c_uint,
        in_hrtirq: core::ffi::c_uint,
        hang_detected: core::ffi::c_uint,
        softirq_activated: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let hres_active: u32 = unsafe { ::core::mem::transmute(hres_active) };
            hres_active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let in_hrtirq: u32 = unsafe { ::core::mem::transmute(in_hrtirq) };
            in_hrtirq as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let hang_detected: u32 = unsafe { ::core::mem::transmute(hang_detected) };
            hang_detected as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let softirq_activated: u32 = unsafe { ::core::mem::transmute(softirq_activated) };
            softirq_activated as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clock_event_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hrtimer_interrupt(dev: *mut clock_event_device);
}
extern "C" {
    pub static mut hrtimer_resolution: core::ffi::c_uint;
}
extern "C" {
    pub fn timerfd_clock_was_set();
}
extern "C" {
    pub fn timerfd_resume();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tick_device {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut tick_cpu_device: tick_device;
}
extern "C" {
    pub fn hrtimer_init(timer: *mut hrtimer, which_clock: clockid_t, mode: hrtimer_mode);
}
extern "C" {
    pub fn hrtimer_init_sleeper(sl: *mut hrtimer_sleeper, clock_id: clockid_t, mode: hrtimer_mode);
}
extern "C" {
    pub fn hrtimer_start_range_ns(
        timer: *mut hrtimer,
        tim: ktime_t,
        range_ns: u64_,
        mode: hrtimer_mode,
    );
}
extern "C" {
    pub fn hrtimer_cancel(timer: *mut hrtimer) -> core::ffi::c_int;
}
extern "C" {
    pub fn hrtimer_try_to_cancel(timer: *mut hrtimer) -> core::ffi::c_int;
}
extern "C" {
    pub fn hrtimer_sleeper_start_expires(sl: *mut hrtimer_sleeper, mode: hrtimer_mode);
}
extern "C" {
    pub fn __hrtimer_get_remaining(timer: *const hrtimer, adjust: bool_) -> ktime_t;
}
extern "C" {
    pub fn hrtimer_get_next_event() -> u64_;
}
extern "C" {
    pub fn hrtimer_next_event_without(exclude: *const hrtimer) -> u64_;
}
extern "C" {
    pub fn hrtimer_active(timer: *const hrtimer) -> bool_;
}
extern "C" {
    pub fn hrtimer_forward(timer: *mut hrtimer, now: ktime_t, interval: ktime_t) -> u64_;
}
extern "C" {
    pub fn nanosleep_copyout(arg1: *mut restart_block, arg2: *mut timespec64) -> core::ffi::c_int;
}
extern "C" {
    pub fn hrtimer_nanosleep(
        rqtp: ktime_t,
        mode: hrtimer_mode,
        clockid: clockid_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule_hrtimeout_range(
        expires: *mut ktime_t,
        delta: u64_,
        mode: hrtimer_mode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn schedule_hrtimeout_range_clock(
        expires: *mut ktime_t,
        delta: u64_,
        mode: hrtimer_mode,
        clock_id: clockid_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn schedule_hrtimeout(expires: *mut ktime_t, mode: hrtimer_mode) -> core::ffi::c_int;
}
extern "C" {
    pub fn hrtimer_run_queues();
}
extern "C" {
    pub fn hrtimers_init();
}
extern "C" {
    pub fn sysrq_timer_list_show();
}
extern "C" {
    pub fn hrtimers_prepare_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn hrtimers_dead_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seccomp_data {
    pub nr: core::ffi::c_int,
    pub arch: __u32,
    pub instruction_pointer: __u64,
    pub args: [__u64; 6usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seccomp_notif_sizes {
    pub seccomp_notif: __u16,
    pub seccomp_notif_resp: __u16,
    pub seccomp_data: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seccomp_notif {
    pub id: __u64,
    pub pid: __u32,
    pub flags: __u32,
    pub data: seccomp_data,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seccomp_notif_resp {
    pub id: __u64,
    pub val: __s64,
    pub error: __s32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seccomp_notif_addfd {
    pub id: __u64,
    pub flags: __u32,
    pub srcfd: __u32,
    pub newfd: __u32,
    pub newfd_flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seccomp_filter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seccomp {
    pub mode: core::ffi::c_int,
    pub filter_count: atomic_t,
    pub filter: *mut seccomp_filter,
}
impl Default for seccomp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __secure_computing(sd: *const seccomp_data) -> core::ffi::c_int;
}
extern "C" {
    pub fn prctl_get_seccomp() -> core::ffi::c_long;
}
extern "C" {
    pub fn prctl_set_seccomp(
        arg1: core::ffi::c_ulong,
        arg2: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn seccomp_filter_release(tsk: *mut task_struct);
}
extern "C" {
    pub fn get_seccomp_filter(tsk: *mut task_struct);
}
extern "C" {
    pub fn seccomp_get_filter(
        task: *mut task_struct,
        filter_off: core::ffi::c_ulong,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn seccomp_get_metadata(
        task: *mut task_struct,
        filter_off: core::ffi::c_ulong,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rusage {
    pub ru_utime: __kernel_old_timeval,
    pub ru_stime: __kernel_old_timeval,
    pub ru_maxrss: __kernel_long_t,
    pub ru_ixrss: __kernel_long_t,
    pub ru_idrss: __kernel_long_t,
    pub ru_isrss: __kernel_long_t,
    pub ru_minflt: __kernel_long_t,
    pub ru_majflt: __kernel_long_t,
    pub ru_nswap: __kernel_long_t,
    pub ru_inblock: __kernel_long_t,
    pub ru_oublock: __kernel_long_t,
    pub ru_msgsnd: __kernel_long_t,
    pub ru_msgrcv: __kernel_long_t,
    pub ru_nsignals: __kernel_long_t,
    pub ru_nvcsw: __kernel_long_t,
    pub ru_nivcsw: __kernel_long_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: __kernel_ulong_t,
    pub rlim_max: __kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rlimit64 {
    pub rlim_cur: __u64,
    pub rlim_max: __u64,
}
extern "C" {
    pub fn getrusage(p: *mut task_struct, who: core::ffi::c_int, ru: *mut rusage);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct task_cputime {
    pub stime: u64_,
    pub utime: u64_,
    pub sum_exec_runtime: core::ffi::c_ulonglong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sigset_t {
    pub sig: [core::ffi::c_ulong; 1usize],
}
pub type old_sigset_t = core::ffi::c_ulong;
pub type __signalfn_t = ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>;
pub type __sighandler_t = __signalfn_t;
pub type __restorefn_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type __sigrestore_t = __restorefn_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaltstack {
    pub ss_sp: *mut core::ffi::c_void,
    pub ss_flags: core::ffi::c_int,
    pub ss_size: __kernel_size_t,
}
impl Default for sigaltstack {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct sigcontext {
    pub sc_regs: user_regs_struct,
    pub sc_fpregs: __riscv_fp_state,
}
impl Default for sigcontext {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn do_notify_resume(regs: *mut pt_regs, thread_info_flags: core::ffi::c_ulong);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: core::ffi::c_int,
    pub sival_ptr: *mut core::ffi::c_void,
    _bindgen_union_align: u64,
}
impl Default for sigval {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sigval_t = sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields {
    pub _kill: __sifields__bindgen_ty_1,
    pub _timer: __sifields__bindgen_ty_2,
    pub _rt: __sifields__bindgen_ty_3,
    pub _sigchld: __sifields__bindgen_ty_4,
    pub _sigfault: __sifields__bindgen_ty_5,
    pub _sigpoll: __sifields__bindgen_ty_6,
    pub _sigsys: __sifields__bindgen_ty_7,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_1 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_2 {
    pub _tid: __kernel_timer_t,
    pub _overrun: core::ffi::c_int,
    pub _sigval: sigval_t,
    pub _sys_private: core::ffi::c_int,
}
impl Default for __sifields__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_3 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _sigval: sigval_t,
}
impl Default for __sifields__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_4 {
    pub _pid: __kernel_pid_t,
    pub _uid: __kernel_uid32_t,
    pub _status: core::ffi::c_int,
    pub _utime: __kernel_clock_t,
    pub _stime: __kernel_clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5 {
    pub _addr: *mut core::ffi::c_void,
    pub __bindgen_anon_1: __sifields__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sifields__bindgen_ty_5__bindgen_ty_1 {
    pub _trapno: core::ffi::c_int,
    pub _addr_lsb: core::ffi::c_short,
    pub _addr_bnd: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub _perf: __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [core::ffi::c_char; 8usize],
    pub _lower: *mut core::ffi::c_void,
    pub _upper: *mut core::ffi::c_void,
}
impl Default for __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [core::ffi::c_char; 8usize],
    pub _pkey: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub _data: core::ffi::c_ulong,
    pub _type: __u32,
    pub _flags: __u32,
}
impl Default for __sifields__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for __sifields__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __sifields__bindgen_ty_6 {
    pub _band: core::ffi::c_long,
    pub _fd: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sifields__bindgen_ty_7 {
    pub _call_addr: *mut core::ffi::c_void,
    pub _syscall: core::ffi::c_int,
    pub _arch: core::ffi::c_uint,
}
impl Default for __sifields__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for __sifields {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo__bindgen_ty_1 {
    pub __bindgen_anon_1: siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _si_pad: [core::ffi::c_int; 32usize],
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub si_signo: core::ffi::c_int,
    pub si_errno: core::ffi::c_int,
    pub si_code: core::ffi::c_int,
    pub _sifields: __sifields,
}
impl Default for siginfo__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for siginfo__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for siginfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type siginfo_t = siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_value: sigval_t,
    pub sigev_signo: core::ffi::c_int,
    pub sigev_notify: core::ffi::c_int,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 {
    pub _pad: [core::ffi::c_int; 12usize],
    pub _tid: core::ffi::c_int,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval_t)>,
    pub _attribute: *mut core::ffi::c_void,
}
impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sigevent__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sigevent {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sigevent_t = sigevent;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo {
    pub __bindgen_anon_1: kernel_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_siginfo__bindgen_ty_1 {
    pub si_signo: core::ffi::c_int,
    pub si_errno: core::ffi::c_int,
    pub si_code: core::ffi::c_int,
    pub _sifields: __sifields,
}
impl Default for kernel_siginfo__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for kernel_siginfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type kernel_siginfo_t = kernel_siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigqueue {
    pub list: list_head,
    pub flags: core::ffi::c_int,
    pub info: kernel_siginfo_t,
    pub ucounts: *mut ucounts,
}
impl Default for sigqueue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigpending {
    pub list: list_head,
    pub signal: sigset_t,
}
impl Default for sigpending {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    pub sa_flags: core::ffi::c_ulong,
    pub sa_mask: sigset_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct k_sigaction {
    pub sa: sigaction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ksignal {
    pub ka: k_sigaction,
    pub info: kernel_siginfo_t,
    pub sig: core::ffi::c_int,
}
impl Default for ksignal {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct syscall_user_dispatch {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct task_io_accounting {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtc_device {
    _unused: [u8; 0],
}
pub const alarmtimer_type_ALARM_REALTIME: alarmtimer_type = 0;
pub const alarmtimer_type_ALARM_BOOTTIME: alarmtimer_type = 1;
pub const alarmtimer_type_ALARM_NUMTYPE: alarmtimer_type = 2;
pub const alarmtimer_type_ALARM_REALTIME_FREEZER: alarmtimer_type = 3;
pub const alarmtimer_type_ALARM_BOOTTIME_FREEZER: alarmtimer_type = 4;
pub type alarmtimer_type = core::ffi::c_uint;
pub const alarmtimer_restart_ALARMTIMER_NORESTART: alarmtimer_restart = 0;
pub const alarmtimer_restart_ALARMTIMER_RESTART: alarmtimer_restart = 1;
pub type alarmtimer_restart = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct alarm {
    pub node: timerqueue_node,
    pub timer: hrtimer,
    pub function: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut alarm, now: ktime_t) -> alarmtimer_restart,
    >,
    pub type_: alarmtimer_type,
    pub state: core::ffi::c_int,
    pub data: *mut core::ffi::c_void,
}
impl Default for alarm {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn alarm_init(
        alarm: *mut alarm,
        type_: alarmtimer_type,
        function: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut alarm, arg2: ktime_t) -> alarmtimer_restart,
        >,
    );
}
extern "C" {
    pub fn alarm_start(alarm: *mut alarm, start: ktime_t);
}
extern "C" {
    pub fn alarm_start_relative(alarm: *mut alarm, start: ktime_t);
}
extern "C" {
    pub fn alarm_restart(alarm: *mut alarm);
}
extern "C" {
    pub fn alarm_try_to_cancel(alarm: *mut alarm) -> core::ffi::c_int;
}
extern "C" {
    pub fn alarm_cancel(alarm: *mut alarm) -> core::ffi::c_int;
}
extern "C" {
    pub fn alarm_forward(alarm: *mut alarm, now: ktime_t, interval: ktime_t) -> u64_;
}
extern "C" {
    pub fn alarm_forward_now(alarm: *mut alarm, interval: ktime_t) -> u64_;
}
extern "C" {
    pub fn alarm_expires_remaining(alarm: *const alarm) -> ktime_t;
}
extern "C" {
    pub fn alarmtimer_get_rtcdev() -> *mut rtc_device;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_timer {
    pub node: timerqueue_node,
    pub head: *mut timerqueue_head,
    pub pid: *mut pid,
    pub elist: list_head,
    pub firing: core::ffi::c_int,
}
impl Default for cpu_timer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_cputimer_base {
    pub nextevt: u64_,
    pub tqhead: timerqueue_head,
}
impl Default for posix_cputimer_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_cputimers {
    pub bases: [posix_cputimer_base; 3usize],
    pub timers_active: core::ffi::c_uint,
    pub expiry_active: core::ffi::c_uint,
}
impl Default for posix_cputimers {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_cputimers_work {
    pub work: callback_head,
    pub scheduled: core::ffi::c_uint,
}
impl Default for posix_cputimers_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn posix_cputimers_group_init(pct: *mut posix_cputimers, cpu_limit: u64_);
}
extern "C" {
    pub fn clear_posix_cputimers_work(p: *mut task_struct);
}
extern "C" {
    pub fn posix_cputimers_init_work();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_itimer {
    pub list: list_head,
    pub t_hash: hlist_node,
    pub it_lock: spinlock_t,
    pub kclock: *mut k_clock,
    pub it_clock: clockid_t,
    pub it_id: timer_t,
    pub it_active: core::ffi::c_int,
    pub it_overrun: s64,
    pub it_overrun_last: s64,
    pub it_requeue_pending: core::ffi::c_int,
    pub it_sigev_notify: core::ffi::c_int,
    pub it_interval: ktime_t,
    pub it_signal: *mut signal_struct,
    pub __bindgen_anon_1: k_itimer__bindgen_ty_1,
    pub sigq: *mut sigqueue,
    pub it: k_itimer__bindgen_ty_2,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_itimer__bindgen_ty_1 {
    pub it_pid: *mut pid,
    pub it_process: *mut task_struct,
    _bindgen_union_align: u64,
}
impl Default for k_itimer__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union k_itimer__bindgen_ty_2 {
    pub real: k_itimer__bindgen_ty_2__bindgen_ty_1,
    pub cpu: cpu_timer,
    pub alarm: k_itimer__bindgen_ty_2__bindgen_ty_2,
    _bindgen_union_align: [u64; 15usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_itimer__bindgen_ty_2__bindgen_ty_1 {
    pub timer: hrtimer,
}
impl Default for k_itimer__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct k_itimer__bindgen_ty_2__bindgen_ty_2 {
    pub alarmtimer: alarm,
}
impl Default for k_itimer__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for k_itimer__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for k_itimer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn run_posix_cpu_timers();
}
extern "C" {
    pub fn posix_cpu_timers_exit(task: *mut task_struct);
}
extern "C" {
    pub fn posix_cpu_timers_exit_group(task: *mut task_struct);
}
extern "C" {
    pub fn set_process_cpu_timer(
        task: *mut task_struct,
        clock_idx: core::ffi::c_uint,
        newval: *mut u64_,
        oldval: *mut u64_,
    );
}
extern "C" {
    pub fn update_rlimit_cpu(
        task: *mut task_struct,
        rlim_new: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn posixtimer_rearm(info: *mut kernel_siginfo);
}
pub const rseq_cpu_id_state_RSEQ_CPU_ID_UNINITIALIZED: rseq_cpu_id_state = -1;
pub const rseq_cpu_id_state_RSEQ_CPU_ID_REGISTRATION_FAILED: rseq_cpu_id_state = -2;
pub type rseq_cpu_id_state = core::ffi::c_int;
pub const rseq_flags_RSEQ_FLAG_UNREGISTER: rseq_flags = 1;
pub type rseq_flags = core::ffi::c_uint;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT: rseq_cs_flags_bit = 0;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT: rseq_cs_flags_bit = 1;
pub const rseq_cs_flags_bit_RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT: rseq_cs_flags_bit = 2;
pub type rseq_cs_flags_bit = core::ffi::c_uint;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT: rseq_cs_flags = 1;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL: rseq_cs_flags = 2;
pub const rseq_cs_flags_RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE: rseq_cs_flags = 4;
pub type rseq_cs_flags = core::ffi::c_uint;
#[repr(C)]
#[repr(align(32))]
#[derive(Default, Copy, Clone)]
pub struct rseq_cs {
    pub version: __u32,
    pub flags: __u32,
    pub start_ip: __u64,
    pub post_commit_offset: __u64,
    pub abort_ip: __u64,
}
#[repr(C)]
#[repr(align(32))]
#[derive(Default, Copy, Clone)]
pub struct rseq {
    pub cpu_id_start: __u32,
    pub cpu_id: __u32,
    pub rseq_cs: __u64,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blk_plug {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_local_storage {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct capture_control {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cfs_rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct futex_pi_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_uring_task {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mempolicy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nameidata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct robust_list_head {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct root_domain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_param {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_delay_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct task_group {
    _unused: [u8; 0],
}
pub const TASK_COMM_LEN: core::ffi::c_uint = 16;
pub type _bindgen_ty_65 = core::ffi::c_uint;
extern "C" {
    pub fn scheduler_tick();
}
extern "C" {
    pub fn schedule_timeout(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule_timeout_interruptible(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule_timeout_killable(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule_timeout_uninterruptible(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule_timeout_idle(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn schedule();
}
extern "C" {
    pub fn schedule_preempt_disabled();
}
extern "C" {
    pub fn preempt_schedule_irq();
}
extern "C" {
    pub fn io_schedule_prepare() -> core::ffi::c_int;
}
extern "C" {
    pub fn io_schedule_finish(token: core::ffi::c_int);
}
extern "C" {
    pub fn io_schedule_timeout(timeout: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn io_schedule();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prev_cputime {
    pub utime: u64_,
    pub stime: u64_,
    pub lock: raw_spinlock_t,
}
impl Default for prev_cputime {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const vtime_state_VTIME_INACTIVE: vtime_state = 0;
pub const vtime_state_VTIME_IDLE: vtime_state = 1;
pub const vtime_state_VTIME_SYS: vtime_state = 2;
pub const vtime_state_VTIME_USER: vtime_state = 3;
pub const vtime_state_VTIME_GUEST: vtime_state = 4;
pub type vtime_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vtime {
    pub seqcount: seqcount_t,
    pub starttime: core::ffi::c_ulonglong,
    pub state: vtime_state,
    pub cpu: core::ffi::c_uint,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
}
impl Default for vtime {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const uclamp_id_UCLAMP_MIN: uclamp_id = 0;
pub const uclamp_id_UCLAMP_MAX: uclamp_id = 1;
pub const uclamp_id_UCLAMP_CNT: uclamp_id = 2;
pub type uclamp_id = core::ffi::c_uint;
extern "C" {
    pub static mut def_root_domain: root_domain;
}
extern "C" {
    pub static mut sched_domains_mutex: mutex;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_info {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct load_weight {
    pub weight: core::ffi::c_ulong,
    pub inv_weight: u32_,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct util_est {
    pub enqueued: core::ffi::c_uint,
    pub ewma: core::ffi::c_uint,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_avg {
    pub last_update_time: u64_,
    pub load_sum: u64_,
    pub runnable_sum: u64_,
    pub util_sum: u32_,
    pub period_contrib: u32_,
    pub load_avg: core::ffi::c_ulong,
    pub runnable_avg: core::ffi::c_ulong,
    pub util_avg: core::ffi::c_ulong,
    pub util_est: util_est,
}
impl Default for sched_avg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_statistics {}
impl Default for sched_statistics {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct sched_entity {
    pub load: load_weight,
    pub run_node: rb_node,
    pub group_node: list_head,
    pub on_rq: core::ffi::c_uint,
    pub exec_start: u64_,
    pub sum_exec_runtime: u64_,
    pub vruntime: u64_,
    pub prev_sum_exec_runtime: u64_,
    pub nr_migrations: u64_,
    pub depth: core::ffi::c_int,
    pub parent: *mut sched_entity,
    pub cfs_rq: *mut cfs_rq,
    pub my_q: *mut cfs_rq,
    pub runnable_weight: core::ffi::c_ulong,
    pub __bindgen_padding_0: [u64; 6usize],
    pub avg: sched_avg,
}
impl Default for sched_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_rt_entity {
    pub run_list: list_head,
    pub timeout: core::ffi::c_ulong,
    pub watchdog_stamp: core::ffi::c_ulong,
    pub time_slice: core::ffi::c_uint,
    pub on_rq: core::ffi::c_ushort,
    pub on_list: core::ffi::c_ushort,
    pub back: *mut sched_rt_entity,
    pub parent: *mut sched_rt_entity,
    pub rt_rq: *mut rt_rq,
    pub my_q: *mut rt_rq,
}
impl Default for sched_rt_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_dl_entity {
    pub rb_node: rb_node,
    pub dl_runtime: u64_,
    pub dl_deadline: u64_,
    pub dl_period: u64_,
    pub dl_bw: u64_,
    pub dl_density: u64_,
    pub runtime: s64,
    pub deadline: u64_,
    pub flags: core::ffi::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub dl_timer: hrtimer,
    pub inactive_timer: hrtimer,
    pub pi_se: *mut sched_dl_entity,
}
impl Default for sched_dl_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sched_dl_entity {
    #[inline]
    pub fn dl_throttled(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_throttled(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_yielded(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_yielded(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_non_contending(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_non_contending(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dl_overrun(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dl_overrun(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dl_throttled: core::ffi::c_uint,
        dl_yielded: core::ffi::c_uint,
        dl_non_contending: core::ffi::c_uint,
        dl_overrun: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let dl_throttled: u32 = unsafe { ::core::mem::transmute(dl_throttled) };
            dl_throttled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dl_yielded: u32 = unsafe { ::core::mem::transmute(dl_yielded) };
            dl_yielded as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dl_non_contending: u32 = unsafe { ::core::mem::transmute(dl_non_contending) };
            dl_non_contending as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let dl_overrun: u32 = unsafe { ::core::mem::transmute(dl_overrun) };
            dl_overrun as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rcu_special {
    pub b: rcu_special__bindgen_ty_1,
    pub s: u32_,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rcu_special__bindgen_ty_1 {
    pub blocked: u8_,
    pub need_qs: u8_,
    pub exp_hint: u8_,
    pub need_mb: u8_,
}
impl Default for rcu_special {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const perf_event_task_context_perf_invalid_context: perf_event_task_context = -1;
pub const perf_event_task_context_perf_hw_context: perf_event_task_context = 0;
pub const perf_event_task_context_perf_sw_context: perf_event_task_context = 1;
pub const perf_event_task_context_perf_nr_task_contexts: perf_event_task_context = 2;
pub type perf_event_task_context = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wake_q_node {
    pub next: *mut wake_q_node,
}
impl Default for wake_q_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kmap_ctrl {}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct task_struct {
    pub thread_info: thread_info,
    pub __state: core::ffi::c_uint,
    pub stack: *mut core::ffi::c_void,
    pub usage: refcount_t,
    pub flags: core::ffi::c_uint,
    pub ptrace: core::ffi::c_uint,
    pub on_cpu: core::ffi::c_int,
    pub wake_entry: __call_single_node,
    pub wakee_flips: core::ffi::c_uint,
    pub wakee_flip_decay_ts: core::ffi::c_ulong,
    pub last_wakee: *mut task_struct,
    pub recent_used_cpu: core::ffi::c_int,
    pub wake_cpu: core::ffi::c_int,
    pub on_rq: core::ffi::c_int,
    pub prio: core::ffi::c_int,
    pub static_prio: core::ffi::c_int,
    pub normal_prio: core::ffi::c_int,
    pub rt_priority: core::ffi::c_uint,
    pub __bindgen_padding_0: [u64; 6usize],
    pub se: sched_entity,
    pub rt: sched_rt_entity,
    pub dl: sched_dl_entity,
    pub sched_class: *mut sched_class,
    pub sched_task_group: *mut task_group,
    pub __bindgen_padding_1: u64,
    pub stats: sched_statistics,
    pub policy: core::ffi::c_uint,
    pub nr_cpus_allowed: core::ffi::c_int,
    pub cpus_ptr: *const cpumask_t,
    pub user_cpus_ptr: *mut cpumask_t,
    pub cpus_mask: cpumask_t,
    pub migration_pending: *mut core::ffi::c_void,
    pub migration_disabled: core::ffi::c_ushort,
    pub migration_flags: core::ffi::c_ushort,
    pub trc_reader_nesting: core::ffi::c_int,
    pub trc_ipi_to_cpu: core::ffi::c_int,
    pub trc_reader_special: rcu_special,
    pub trc_holdout_list: list_head,
    pub trc_blkd_node: list_head,
    pub trc_blkd_cpu: core::ffi::c_int,
    pub sched_info: sched_info,
    pub tasks: list_head,
    pub pushable_tasks: plist_node,
    pub pushable_dl_tasks: rb_node,
    pub mm: *mut mm_struct,
    pub active_mm: *mut mm_struct,
    pub rss_stat: task_rss_stat,
    pub exit_state: core::ffi::c_int,
    pub exit_code: core::ffi::c_int,
    pub exit_signal: core::ffi::c_int,
    pub pdeath_signal: core::ffi::c_int,
    pub jobctl: core::ffi::c_ulong,
    pub personality: core::ffi::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize], u8>,
    pub atomic_flags: core::ffi::c_ulong,
    pub restart_block: restart_block,
    pub pid: pid_t,
    pub tgid: pid_t,
    pub stack_canary: core::ffi::c_ulong,
    pub real_parent: *mut task_struct,
    pub parent: *mut task_struct,
    pub children: list_head,
    pub sibling: list_head,
    pub group_leader: *mut task_struct,
    pub ptraced: list_head,
    pub ptrace_entry: list_head,
    pub thread_pid: *mut pid,
    pub pid_links: [hlist_node; 4usize],
    pub thread_group: list_head,
    pub thread_node: list_head,
    pub vfork_done: *mut completion,
    pub set_child_tid: *mut core::ffi::c_int,
    pub clear_child_tid: *mut core::ffi::c_int,
    pub worker_private: *mut core::ffi::c_void,
    pub utime: u64_,
    pub stime: u64_,
    pub gtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: core::ffi::c_ulong,
    pub nivcsw: core::ffi::c_ulong,
    pub start_time: u64_,
    pub start_boottime: u64_,
    pub min_flt: core::ffi::c_ulong,
    pub maj_flt: core::ffi::c_ulong,
    pub posix_cputimers: posix_cputimers,
    pub posix_cputimers_work: posix_cputimers_work,
    pub ptracer_cred: *const cred,
    pub real_cred: *const cred,
    pub cred: *const cred,
    pub cached_requested_key: *mut key,
    pub comm: [core::ffi::c_char; 16usize],
    pub nameidata: *mut nameidata,
    pub sysvsem: sysv_sem,
    pub sysvshm: sysv_shm,
    pub last_switch_count: core::ffi::c_ulong,
    pub last_switch_time: core::ffi::c_ulong,
    pub fs: *mut fs_struct,
    pub files: *mut files_struct,
    pub io_uring: *mut io_uring_task,
    pub nsproxy: *mut nsproxy,
    pub signal: *mut signal_struct,
    pub sighand: *mut sighand_struct,
    pub blocked: sigset_t,
    pub real_blocked: sigset_t,
    pub saved_sigmask: sigset_t,
    pub pending: sigpending,
    pub sas_ss_sp: core::ffi::c_ulong,
    pub sas_ss_size: usize,
    pub sas_ss_flags: core::ffi::c_uint,
    pub task_works: *mut callback_head,
    pub audit_context: *mut audit_context,
    pub loginuid: kuid_t,
    pub sessionid: core::ffi::c_uint,
    pub seccomp: seccomp,
    pub syscall_dispatch: syscall_user_dispatch,
    pub parent_exec_id: u64_,
    pub self_exec_id: u64_,
    pub alloc_lock: spinlock_t,
    pub pi_lock: raw_spinlock_t,
    pub wake_q: wake_q_node,
    pub pi_waiters: rb_root_cached,
    pub pi_top_task: *mut task_struct,
    pub pi_blocked_on: *mut rt_mutex_waiter,
    pub blocked_on: *mut mutex_waiter,
    pub non_block_count: core::ffi::c_int,
    pub journal_info: *mut core::ffi::c_void,
    pub bio_list: *mut bio_list,
    pub plug: *mut blk_plug,
    pub reclaim_state: *mut reclaim_state,
    pub backing_dev_info: *mut backing_dev_info,
    pub io_context: *mut io_context,
    pub capture_control: *mut capture_control,
    pub ptrace_message: core::ffi::c_ulong,
    pub last_siginfo: *mut kernel_siginfo_t,
    pub ioac: task_io_accounting,
    pub mems_allowed: nodemask_t,
    pub mems_allowed_seq: seqcount_spinlock_t,
    pub cpuset_mem_spread_rotor: core::ffi::c_int,
    pub cpuset_slab_spread_rotor: core::ffi::c_int,
    pub cgroups: *mut css_set,
    pub cg_list: list_head,
    pub robust_list: *mut robust_list_head,
    pub compat_robust_list: *mut compat_robust_list_head,
    pub pi_state_list: list_head,
    pub pi_state_cache: *mut futex_pi_state,
    pub futex_exit_mutex: mutex,
    pub futex_state: core::ffi::c_uint,
    pub perf_event_ctxp: [*mut perf_event_context; 2usize],
    pub perf_event_mutex: mutex,
    pub perf_event_list: list_head,
    pub rseq: *mut rseq,
    pub rseq_sig: u32_,
    pub rseq_event_mask: core::ffi::c_ulong,
    pub tlb_ubc: tlbflush_unmap_batch,
    pub __bindgen_anon_1: task_struct__bindgen_ty_1,
    pub splice_pipe: *mut pipe_inode_info,
    pub task_frag: page_frag,
    pub nr_dirtied: core::ffi::c_int,
    pub nr_dirtied_pause: core::ffi::c_int,
    pub dirty_paused_when: core::ffi::c_ulong,
    pub timer_slack_ns: u64_,
    pub default_timer_slack_ns: u64_,
    pub memcg_in_oom: *mut mem_cgroup,
    pub memcg_oom_gfp_mask: gfp_t,
    pub memcg_oom_order: core::ffi::c_int,
    pub memcg_nr_pages_over_high: core::ffi::c_uint,
    pub active_memcg: *mut mem_cgroup,
    pub kmap_ctrl: kmap_ctrl,
    pub task_state_change: core::ffi::c_ulong,
    pub pagefault_disabled: core::ffi::c_int,
    pub oom_reaper_list: *mut task_struct,
    pub oom_reaper_timer: timer_list,
    pub stack_vm_area: *mut vm_struct,
    pub stack_refcount: refcount_t,
    pub security: *mut core::ffi::c_void,
    pub bpf_storage: *mut bpf_local_storage,
    pub bpf_ctx: *mut bpf_run_ctx,
    pub thread: thread_struct,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union task_struct__bindgen_ty_1 {
    pub rcu_users: refcount_t,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for task_struct__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for task_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl task_struct {
    #[inline]
    pub fn sched_reset_on_fork(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_reset_on_fork(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_contributes_to_load(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_contributes_to_load(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_migrated(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_migrated(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sched_remote_wakeup(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sched_remote_wakeup(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_execve(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_execve(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_iowait(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_iowait(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_user_fault(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_user_fault(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brk_randomized(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brk_randomized(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_migration(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_migration(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_eventfd(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_eventfd(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sched_reset_on_fork: core::ffi::c_uint,
        sched_contributes_to_load: core::ffi::c_uint,
        sched_migrated: core::ffi::c_uint,
        sched_remote_wakeup: core::ffi::c_uint,
        in_execve: core::ffi::c_uint,
        in_iowait: core::ffi::c_uint,
        in_user_fault: core::ffi::c_uint,
        brk_randomized: core::ffi::c_uint,
        no_cgroup_migration: core::ffi::c_uint,
        frozen: core::ffi::c_uint,
        in_eventfd: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 5usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sched_reset_on_fork: u32 = unsafe { ::core::mem::transmute(sched_reset_on_fork) };
            sched_reset_on_fork as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sched_contributes_to_load: u32 =
                unsafe { ::core::mem::transmute(sched_contributes_to_load) };
            sched_contributes_to_load as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sched_migrated: u32 = unsafe { ::core::mem::transmute(sched_migrated) };
            sched_migrated as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let sched_remote_wakeup: u32 = unsafe { ::core::mem::transmute(sched_remote_wakeup) };
            sched_remote_wakeup as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let in_execve: u32 = unsafe { ::core::mem::transmute(in_execve) };
            in_execve as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let in_iowait: u32 = unsafe { ::core::mem::transmute(in_iowait) };
            in_iowait as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let in_user_fault: u32 = unsafe { ::core::mem::transmute(in_user_fault) };
            in_user_fault as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let brk_randomized: u32 = unsafe { ::core::mem::transmute(brk_randomized) };
            brk_randomized as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let no_cgroup_migration: u32 = unsafe { ::core::mem::transmute(no_cgroup_migration) };
            no_cgroup_migration as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let frozen: u32 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let in_eventfd: u32 = unsafe { ::core::mem::transmute(in_eventfd) };
            in_eventfd as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn __task_pid_nr_ns(
        task: *mut task_struct,
        type_: pid_type,
        ns: *mut pid_namespace,
    ) -> pid_t;
}
extern "C" {
    pub static mut cad_pid: *mut pid;
}
extern "C" {
    pub fn cpuset_cpumask_can_shrink(
        cur: *const cpumask,
        trial: *const cpumask,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn task_can_attach(
        p: *mut task_struct,
        cs_effective_cpus: *const cpumask,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_set_cpus_allowed(p: *mut task_struct, new_mask: *const cpumask);
}
extern "C" {
    pub fn set_cpus_allowed_ptr(p: *mut task_struct, new_mask: *const cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn dup_user_cpus_ptr(
        dst: *mut task_struct,
        src: *mut task_struct,
        node: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn release_user_cpus_ptr(p: *mut task_struct);
}
extern "C" {
    pub fn dl_task_check_affinity(p: *mut task_struct, mask: *const cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_compatible_cpus_allowed_ptr(p: *mut task_struct);
}
extern "C" {
    pub fn relax_compatible_cpus_allowed_ptr(p: *mut task_struct);
}
extern "C" {
    pub fn yield_to(p: *mut task_struct, preempt: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_user_nice(p: *mut task_struct, nice: core::ffi::c_long);
}
extern "C" {
    pub fn task_prio(p: *const task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn can_nice(p: *const task_struct, nice: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn task_curr(p: *const task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn idle_cpu(cpu: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn available_idle_cpu(cpu: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        arg1: *mut task_struct,
        arg2: core::ffi::c_int,
        arg3: *const sched_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_setscheduler_nocheck(
        arg1: *mut task_struct,
        arg2: core::ffi::c_int,
        arg3: *const sched_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_set_fifo(p: *mut task_struct);
}
extern "C" {
    pub fn sched_set_fifo_low(p: *mut task_struct);
}
extern "C" {
    pub fn sched_set_normal(p: *mut task_struct, nice: core::ffi::c_int);
}
extern "C" {
    pub fn sched_setattr(arg1: *mut task_struct, arg2: *const sched_attr) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_setattr_nocheck(
        arg1: *mut task_struct,
        arg2: *const sched_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn idle_task(cpu: core::ffi::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn curr_task(cpu: core::ffi::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn ia64_set_curr_task(cpu: core::ffi::c_int, p: *mut task_struct);
}
extern "C" {
    #[link_name = "\u{1}yield"]
    pub fn yield_();
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub union thread_union {
    pub task: task_struct,
    pub stack: [core::ffi::c_ulong; 2048usize],
    _bindgen_union_align: [u8; 16384usize],
}
impl Default for thread_union {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut init_stack: [core::ffi::c_ulong; 2048usize];
}
extern "C" {
    pub fn find_task_by_vpid(nr: pid_t) -> *mut task_struct;
}
extern "C" {
    pub fn find_task_by_pid_ns(nr: pid_t, ns: *mut pid_namespace) -> *mut task_struct;
}
extern "C" {
    pub fn find_get_task_by_vpid(nr: pid_t) -> *mut task_struct;
}
extern "C" {
    pub fn wake_up_state(tsk: *mut task_struct, state: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn wake_up_process(tsk: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn wake_up_new_task(tsk: *mut task_struct);
}
extern "C" {
    pub fn kick_process(tsk: *mut task_struct);
}
extern "C" {
    pub fn __set_task_comm(tsk: *mut task_struct, from: *const core::ffi::c_char, exec: bool_);
}
extern "C" {
    pub fn __get_task_comm(
        to: *mut core::ffi::c_char,
        len: usize,
        tsk: *mut task_struct,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn wait_task_inactive(
        arg1: *mut task_struct,
        match_state: core::ffi::c_uint,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __cond_resched() -> core::ffi::c_int;
}
extern "C" {
    pub fn __cond_resched_lock(lock: *mut spinlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cond_resched_rwlock_read(lock: *mut rwlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cond_resched_rwlock_write(lock: *mut rwlock_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_task_cpu(p: *mut task_struct, cpu: core::ffi::c_uint);
}
extern "C" {
    pub fn sched_task_on_rq(p: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn get_wchan(p: *mut task_struct) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn cpu_curr_snapshot(cpu: core::ffi::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn sched_setaffinity(pid: pid_t, new_mask: *const cpumask) -> core::ffi::c_long;
}
extern "C" {
    pub fn sched_getaffinity(pid: pid_t, mask: *mut cpumask) -> core::ffi::c_long;
}
extern "C" {
    pub fn sched_cpu_util(cpu: core::ffi::c_int) -> core::ffi::c_ulong;
}
pub const rseq_event_mask_bits_RSEQ_EVENT_PREEMPT_BIT: rseq_event_mask_bits = 0;
pub const rseq_event_mask_bits_RSEQ_EVENT_SIGNAL_BIT: rseq_event_mask_bits = 1;
pub const rseq_event_mask_bits_RSEQ_EVENT_MIGRATE_BIT: rseq_event_mask_bits = 2;
pub type rseq_event_mask_bits = core::ffi::c_uint;
pub const rseq_event_mask_RSEQ_EVENT_PREEMPT: rseq_event_mask = 1;
pub const rseq_event_mask_RSEQ_EVENT_SIGNAL: rseq_event_mask = 2;
pub const rseq_event_mask_RSEQ_EVENT_MIGRATE: rseq_event_mask = 4;
pub type rseq_event_mask = core::ffi::c_uint;
extern "C" {
    pub fn __rseq_handle_notify_resume(sig: *mut ksignal, regs: *mut pt_regs);
}
extern "C" {
    pub fn sched_set_stop_task(cpu: core::ffi::c_int, stop: *mut task_struct);
}
pub type ioasid_t = core::ffi::c_uint;
pub type ioasid_alloc_fn_t = ::core::option::Option<
    unsafe extern "C" fn(min: ioasid_t, max: ioasid_t, data: *mut core::ffi::c_void) -> ioasid_t,
>;
pub type ioasid_free_fn_t =
    ::core::option::Option<unsafe extern "C" fn(ioasid: ioasid_t, data: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ioasid_set {
    pub dummy: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ioasid_allocator_ops {
    pub alloc: ioasid_alloc_fn_t,
    pub free: ioasid_free_fn_t,
    pub list: list_head,
    pub pdata: *mut core::ffi::c_void,
}
impl Default for ioasid_allocator_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mm_alloc() -> *mut mm_struct;
}
extern "C" {
    pub fn __mmdrop(mm: *mut mm_struct);
}
extern "C" {
    pub fn mmput(arg1: *mut mm_struct);
}
extern "C" {
    pub fn mmput_async(arg1: *mut mm_struct);
}
extern "C" {
    pub fn get_task_mm(task: *mut task_struct) -> *mut mm_struct;
}
extern "C" {
    pub fn mm_access(task: *mut task_struct, mode: core::ffi::c_uint) -> *mut mm_struct;
}
extern "C" {
    pub fn exit_mm_release(arg1: *mut task_struct, arg2: *mut mm_struct);
}
extern "C" {
    pub fn exec_mm_release(arg1: *mut task_struct, arg2: *mut mm_struct);
}
extern "C" {
    pub fn mm_update_next_owner(mm: *mut mm_struct);
}
extern "C" {
    pub fn arch_pick_mmap_layout(mm: *mut mm_struct, rlim_stack: *mut rlimit);
}
extern "C" {
    pub fn arch_get_unmapped_area(
        arg1: *mut file,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn arch_get_unmapped_area_topdown(
        filp: *mut file,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn generic_get_unmapped_area(
        filp: *mut file,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn generic_get_unmapped_area_topdown(
        filp: *mut file,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub static mut int_active_memcg: *mut mem_cgroup;
}
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY: core::ffi::c_uint = 1;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED: core::ffi::c_uint = 2;
pub const MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY: core::ffi::c_uint = 4;
pub const MEMBARRIER_STATE_GLOBAL_EXPEDITED: core::ffi::c_uint = 8;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY: core::ffi::c_uint = 16;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE: core::ffi::c_uint = 32;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY: core::ffi::c_uint = 64;
pub const MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ: core::ffi::c_uint = 128;
pub type _bindgen_ty_66 = core::ffi::c_uint;
pub const MEMBARRIER_FLAG_SYNC_CORE: core::ffi::c_uint = 1;
pub const MEMBARRIER_FLAG_RSEQ: core::ffi::c_uint = 2;
pub type _bindgen_ty_67 = core::ffi::c_uint;
extern "C" {
    pub fn membarrier_exec_mmap(mm: *mut mm_struct);
}
extern "C" {
    pub fn membarrier_update_current_mm(next_mm: *mut mm_struct);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xa_limit {
    pub max: u32_,
    pub min: u32_,
}
pub type xa_mark_t = core::ffi::c_uint;
pub const xa_lock_type_XA_LOCK_IRQ: xa_lock_type = 1;
pub const xa_lock_type_XA_LOCK_BH: xa_lock_type = 2;
pub type xa_lock_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xarray {
    pub xa_lock: spinlock_t,
    pub xa_flags: gfp_t,
    pub xa_head: *mut core::ffi::c_void,
}
impl Default for xarray {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn xa_load(arg1: *mut xarray, index: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_store(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        arg2: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_erase(arg1: *mut xarray, index: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_store_range(
        arg1: *mut xarray,
        first: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        arg2: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_get_mark(arg1: *mut xarray, index: core::ffi::c_ulong, arg2: xa_mark_t) -> bool_;
}
extern "C" {
    pub fn xa_set_mark(arg1: *mut xarray, index: core::ffi::c_ulong, arg2: xa_mark_t);
}
extern "C" {
    pub fn xa_clear_mark(arg1: *mut xarray, index: core::ffi::c_ulong, arg2: xa_mark_t);
}
extern "C" {
    pub fn xa_find(
        xa: *mut xarray,
        index: *mut core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        arg1: xa_mark_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_find_after(
        xa: *mut xarray,
        index: *mut core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        arg1: xa_mark_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xa_extract(
        arg1: *mut xarray,
        dst: *mut *mut core::ffi::c_void,
        start: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        n: core::ffi::c_uint,
        arg2: xa_mark_t,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn xa_destroy(arg1: *mut xarray);
}
extern "C" {
    pub fn __xa_erase(arg1: *mut xarray, index: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __xa_store(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        arg2: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __xa_cmpxchg(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        old: *mut core::ffi::c_void,
        entry: *mut core::ffi::c_void,
        arg2: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __xa_insert(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        entry: *mut core::ffi::c_void,
        arg2: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __xa_alloc(
        arg1: *mut xarray,
        id: *mut u32_,
        entry: *mut core::ffi::c_void,
        arg2: xa_limit,
        arg3: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __xa_alloc_cyclic(
        arg1: *mut xarray,
        id: *mut u32_,
        entry: *mut core::ffi::c_void,
        arg2: xa_limit,
        next: *mut u32_,
        arg3: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __xa_set_mark(arg1: *mut xarray, index: core::ffi::c_ulong, arg2: xa_mark_t);
}
extern "C" {
    pub fn __xa_clear_mark(arg1: *mut xarray, index: core::ffi::c_ulong, arg2: xa_mark_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xa_node {
    pub shift: core::ffi::c_uchar,
    pub offset: core::ffi::c_uchar,
    pub count: core::ffi::c_uchar,
    pub nr_values: core::ffi::c_uchar,
    pub parent: *mut xa_node,
    pub array: *mut xarray,
    pub __bindgen_anon_1: xa_node__bindgen_ty_1,
    pub slots: [*mut core::ffi::c_void; 64usize],
    pub __bindgen_anon_2: xa_node__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xa_node__bindgen_ty_1 {
    pub private_list: list_head,
    pub callback_head: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for xa_node__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xa_node__bindgen_ty_2 {
    pub tags: [[core::ffi::c_ulong; 1usize]; 3usize],
    pub marks: [[core::ffi::c_ulong; 1usize]; 3usize],
    _bindgen_union_align: [u64; 3usize],
}
impl Default for xa_node__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for xa_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn xa_dump(arg1: *const xarray);
}
extern "C" {
    pub fn xa_dump_node(arg1: *const xa_node);
}
pub type xa_update_node_t = ::core::option::Option<unsafe extern "C" fn(node: *mut xa_node)>;
extern "C" {
    pub fn xa_delete_node(arg1: *mut xa_node, arg2: xa_update_node_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xa_state {
    pub xa: *mut xarray,
    pub xa_index: core::ffi::c_ulong,
    pub xa_shift: core::ffi::c_uchar,
    pub xa_sibs: core::ffi::c_uchar,
    pub xa_offset: core::ffi::c_uchar,
    pub xa_pad: core::ffi::c_uchar,
    pub xa_node: *mut xa_node,
    pub xa_alloc: *mut xa_node,
    pub xa_update: xa_update_node_t,
    pub xa_lru: *mut list_lru,
}
impl Default for xa_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn xas_load(arg1: *mut xa_state) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xas_store(arg1: *mut xa_state, entry: *mut core::ffi::c_void) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xas_find(arg1: *mut xa_state, max: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xas_find_conflict(arg1: *mut xa_state) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xas_get_mark(arg1: *const xa_state, arg2: xa_mark_t) -> bool_;
}
extern "C" {
    pub fn xas_set_mark(arg1: *const xa_state, arg2: xa_mark_t);
}
extern "C" {
    pub fn xas_clear_mark(arg1: *const xa_state, arg2: xa_mark_t);
}
extern "C" {
    pub fn xas_find_marked(
        arg1: *mut xa_state,
        max: core::ffi::c_ulong,
        arg2: xa_mark_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn xas_init_marks(arg1: *const xa_state);
}
extern "C" {
    pub fn xas_nomem(arg1: *mut xa_state, arg2: gfp_t) -> bool_;
}
extern "C" {
    pub fn xas_destroy(arg1: *mut xa_state);
}
extern "C" {
    pub fn xas_pause(arg1: *mut xa_state);
}
extern "C" {
    pub fn xas_create_range(arg1: *mut xa_state);
}
pub const XA_CHECK_SCHED: core::ffi::c_uint = 4096;
pub type _bindgen_ty_68 = core::ffi::c_uint;
extern "C" {
    pub fn __xas_next(arg1: *mut xa_state) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __xas_prev(arg1: *mut xa_state) -> *mut core::ffi::c_void;
}
pub const lru_status_LRU_REMOVED: lru_status = 0;
pub const lru_status_LRU_REMOVED_RETRY: lru_status = 1;
pub const lru_status_LRU_ROTATE: lru_status = 2;
pub const lru_status_LRU_SKIP: lru_status = 3;
pub const lru_status_LRU_RETRY: lru_status = 4;
pub type lru_status = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru_one {
    pub list: list_head,
    pub nr_items: core::ffi::c_long,
}
impl Default for list_lru_one {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct list_lru_memcg {
    pub rcu: callback_head,
    pub node: __IncompleteArrayField<list_lru_one>,
}
impl Default for list_lru_memcg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct list_lru_node {
    pub lock: spinlock_t,
    pub lru: list_lru_one,
    pub nr_items: core::ffi::c_long,
}
impl Default for list_lru_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct list_lru {
    pub node: *mut list_lru_node,
    pub list: list_head,
    pub shrinker_id: core::ffi::c_int,
    pub memcg_aware: bool_,
    pub xa: xarray,
}
impl Default for list_lru {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn list_lru_destroy(lru: *mut list_lru);
}
extern "C" {
    pub fn __list_lru_init(
        lru: *mut list_lru,
        memcg_aware: bool_,
        key: *mut lock_class_key,
        shrinker: *mut shrinker,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memcg_list_lru_alloc(
        memcg: *mut mem_cgroup,
        lru: *mut list_lru,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memcg_reparent_list_lrus(memcg: *mut mem_cgroup, parent: *mut mem_cgroup);
}
extern "C" {
    pub fn list_lru_add(lru: *mut list_lru, item: *mut list_head) -> bool_;
}
extern "C" {
    pub fn list_lru_del(lru: *mut list_lru, item: *mut list_head) -> bool_;
}
extern "C" {
    pub fn list_lru_count_one(
        lru: *mut list_lru,
        nid: core::ffi::c_int,
        memcg: *mut mem_cgroup,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn list_lru_count_node(lru: *mut list_lru, nid: core::ffi::c_int) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn list_lru_isolate(list: *mut list_lru_one, item: *mut list_head);
}
extern "C" {
    pub fn list_lru_isolate_move(
        list: *mut list_lru_one,
        item: *mut list_head,
        head: *mut list_head,
    );
}
pub type list_lru_walk_cb = ::core::option::Option<
    unsafe extern "C" fn(
        item: *mut list_head,
        list: *mut list_lru_one,
        lock: *mut spinlock_t,
        cb_arg: *mut core::ffi::c_void,
    ) -> lru_status,
>;
extern "C" {
    pub fn list_lru_walk_one(
        lru: *mut list_lru,
        nid: core::ffi::c_int,
        memcg: *mut mem_cgroup,
        isolate: list_lru_walk_cb,
        cb_arg: *mut core::ffi::c_void,
        nr_to_walk: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn list_lru_walk_one_irq(
        lru: *mut list_lru,
        nid: core::ffi::c_int,
        memcg: *mut mem_cgroup,
        isolate: list_lru_walk_cb,
        cb_arg: *mut core::ffi::c_void,
        nr_to_walk: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn list_lru_walk_node(
        lru: *mut list_lru,
        nid: core::ffi::c_int,
        isolate: list_lru_walk_cb,
        cb_arg: *mut core::ffi::c_void,
        nr_to_walk: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_tree_preload {
    pub lock: local_lock_t,
    pub nr: core::ffi::c_uint,
    pub nodes: *mut xa_node,
}
impl Default for radix_tree_preload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut radix_tree_preloads: radix_tree_preload;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct radix_tree_iter {
    pub index: core::ffi::c_ulong,
    pub next_index: core::ffi::c_ulong,
    pub tags: core::ffi::c_ulong,
    pub node: *mut xa_node,
}
impl Default for radix_tree_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn radix_tree_insert(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        arg2: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __radix_tree_lookup(
        arg1: *const xarray,
        index: core::ffi::c_ulong,
        nodep: *mut *mut xa_node,
        slotp: *mut *mut *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_lookup(
        arg1: *const xarray,
        arg2: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_lookup_slot(
        arg1: *const xarray,
        index: core::ffi::c_ulong,
    ) -> *mut *mut core::ffi::c_void;
}
extern "C" {
    pub fn __radix_tree_replace(
        arg1: *mut xarray,
        arg2: *mut xa_node,
        slot: *mut *mut core::ffi::c_void,
        entry: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn radix_tree_iter_replace(
        arg1: *mut xarray,
        arg2: *const radix_tree_iter,
        slot: *mut *mut core::ffi::c_void,
        entry: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn radix_tree_replace_slot(
        arg1: *mut xarray,
        slot: *mut *mut core::ffi::c_void,
        entry: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn radix_tree_iter_delete(
        arg1: *mut xarray,
        iter: *mut radix_tree_iter,
        slot: *mut *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn radix_tree_delete_item(
        arg1: *mut xarray,
        arg2: core::ffi::c_ulong,
        arg3: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_delete(arg1: *mut xarray, arg2: core::ffi::c_ulong)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_gang_lookup(
        arg1: *const xarray,
        results: *mut *mut core::ffi::c_void,
        first_index: core::ffi::c_ulong,
        max_items: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn radix_tree_preload(gfp_mask: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn radix_tree_maybe_preload(gfp_mask: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn radix_tree_init();
}
extern "C" {
    pub fn radix_tree_tag_set(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        tag: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_tag_clear(
        arg1: *mut xarray,
        index: core::ffi::c_ulong,
        tag: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_tag_get(
        arg1: *const xarray,
        index: core::ffi::c_ulong,
        tag: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn radix_tree_iter_tag_clear(
        arg1: *mut xarray,
        iter: *const radix_tree_iter,
        tag: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn radix_tree_gang_lookup_tag(
        arg1: *const xarray,
        results: *mut *mut core::ffi::c_void,
        first_index: core::ffi::c_ulong,
        max_items: core::ffi::c_uint,
        tag: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn radix_tree_gang_lookup_tag_slot(
        arg1: *const xarray,
        results: *mut *mut *mut core::ffi::c_void,
        first_index: core::ffi::c_ulong,
        max_items: core::ffi::c_uint,
        tag: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn radix_tree_tagged(arg1: *const xarray, tag: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn idr_get_free(
        root: *mut xarray,
        iter: *mut radix_tree_iter,
        gfp: gfp_t,
        max: core::ffi::c_ulong,
    ) -> *mut *mut core::ffi::c_void;
}
pub const RADIX_TREE_ITER_TAG_MASK: core::ffi::c_uint = 15;
pub const RADIX_TREE_ITER_TAGGED: core::ffi::c_uint = 16;
pub const RADIX_TREE_ITER_CONTIG: core::ffi::c_uint = 32;
pub type _bindgen_ty_69 = core::ffi::c_uint;
extern "C" {
    pub fn radix_tree_next_chunk(
        arg1: *const xarray,
        iter: *mut radix_tree_iter,
        flags: core::ffi::c_uint,
    ) -> *mut *mut core::ffi::c_void;
}
extern "C" {
    pub fn radix_tree_iter_resume(
        slot: *mut *mut core::ffi::c_void,
        iter: *mut radix_tree_iter,
    ) -> *mut *mut core::ffi::c_void;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __user_cap_header_struct {
    pub version: __u32,
    pub pid: core::ffi::c_int,
}
pub type cap_user_header_t = *mut __user_cap_header_struct;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct __user_cap_data_struct {
    pub effective: __u32,
    pub permitted: __u32,
    pub inheritable: __u32,
}
pub type cap_user_data_t = *mut __user_cap_data_struct;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_cap_data__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_ns_cap_data {
    pub magic_etc: __le32,
    pub data: [vfs_ns_cap_data__bindgen_ty_1; 2usize],
    pub rootid: __le32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfs_ns_cap_data__bindgen_ty_1 {
    pub permitted: __le32,
    pub inheritable: __le32,
}
extern "C" {
    pub static mut file_caps_enabled: core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_cap_struct {
    pub cap: [__u32; 2usize],
}
pub type kernel_cap_t = kernel_cap_struct;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_vfs_cap_data {
    pub magic_etc: __u32,
    pub permitted: kernel_cap_t,
    pub inheritable: kernel_cap_t,
    pub rootid: kuid_t,
}
extern "C" {
    pub static __cap_empty_set: kernel_cap_t;
}
extern "C" {
    pub static __cap_init_eff_set: kernel_cap_t;
}
extern "C" {
    pub fn has_capability(t: *mut task_struct, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn has_ns_capability(
        t: *mut task_struct,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn has_capability_noaudit(t: *mut task_struct, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn has_ns_capability_noaudit(
        t: *mut task_struct,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn capable(cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn ns_capable(ns: *mut user_namespace, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn ns_capable_noaudit(ns: *mut user_namespace, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn ns_capable_setid(ns: *mut user_namespace, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn privileged_wrt_inode_uidgid(
        ns: *mut user_namespace,
        mnt_userns: *mut user_namespace,
        inode: *const inode,
    ) -> bool_;
}
extern "C" {
    pub fn capable_wrt_inode_uidgid(
        mnt_userns: *mut user_namespace,
        inode: *const inode,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn file_ns_capable(
        file: *const file,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn ptracer_capable(tsk: *mut task_struct, ns: *mut user_namespace) -> bool_;
}
extern "C" {
    pub fn get_vfs_caps_from_disk(
        mnt_userns: *mut user_namespace,
        dentry: *const dentry,
        cpu_caps: *mut cpu_vfs_cap_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_convert_nscap(
        mnt_userns: *mut user_namespace,
        dentry: *mut dentry,
        ivalue: *mut *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct semaphore {
    pub lock: raw_spinlock_t,
    pub count: core::ffi::c_uint,
    pub wait_list: list_head,
}
impl Default for semaphore {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn down(sem: *mut semaphore);
}
extern "C" {
    pub fn down_interruptible(sem: *mut semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_killable(sem: *mut semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_trylock(sem: *mut semaphore) -> core::ffi::c_int;
}
extern "C" {
    pub fn down_timeout(sem: *mut semaphore, jiffies: core::ffi::c_long) -> core::ffi::c_int;
}
extern "C" {
    pub fn up(sem: *mut semaphore);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct f_owner_ex {
    pub type_: core::ffi::c_int,
    pub pid: __kernel_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flock {
    pub l_type: core::ffi::c_short,
    pub l_whence: core::ffi::c_short,
    pub l_start: __kernel_off_t,
    pub l_len: __kernel_off_t,
    pub l_pid: __kernel_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flock64 {
    pub l_type: core::ffi::c_short,
    pub l_whence: core::ffi::c_short,
    pub l_start: __kernel_loff_t,
    pub l_len: __kernel_loff_t,
    pub l_pid: __kernel_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct open_how {
    pub flags: __u64,
    pub mode: __u64,
    pub resolve: __u64,
}
pub const migrate_mode_MIGRATE_ASYNC: migrate_mode = 0;
pub const migrate_mode_MIGRATE_SYNC_LIGHT: migrate_mode = 1;
pub const migrate_mode_MIGRATE_SYNC: migrate_mode = 2;
pub const migrate_mode_MIGRATE_SYNC_NO_COPY: migrate_mode = 3;
pub type migrate_mode = core::ffi::c_uint;
pub const migrate_reason_MR_COMPACTION: migrate_reason = 0;
pub const migrate_reason_MR_MEMORY_FAILURE: migrate_reason = 1;
pub const migrate_reason_MR_MEMORY_HOTPLUG: migrate_reason = 2;
pub const migrate_reason_MR_SYSCALL: migrate_reason = 3;
pub const migrate_reason_MR_MEMPOLICY_MBIND: migrate_reason = 4;
pub const migrate_reason_MR_NUMA_MISPLACED: migrate_reason = 5;
pub const migrate_reason_MR_CONTIG_RANGE: migrate_reason = 6;
pub const migrate_reason_MR_LONGTERM_PIN: migrate_reason = 7;
pub const migrate_reason_MR_DEMOTION: migrate_reason = 8;
pub const migrate_reason_MR_TYPES: migrate_reason = 9;
pub type migrate_reason = core::ffi::c_uint;
extern "C" {
    pub static mut print_fatal_signals: core::ffi::c_int;
}
extern "C" {
    pub fn copy_siginfo_to_user(
        to: *mut siginfo_t,
        from: *const kernel_siginfo_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn copy_siginfo_from_user(
        to: *mut kernel_siginfo_t,
        from: *const siginfo_t,
    ) -> core::ffi::c_int;
}
pub const siginfo_layout_SIL_KILL: siginfo_layout = 0;
pub const siginfo_layout_SIL_TIMER: siginfo_layout = 1;
pub const siginfo_layout_SIL_POLL: siginfo_layout = 2;
pub const siginfo_layout_SIL_FAULT: siginfo_layout = 3;
pub const siginfo_layout_SIL_FAULT_TRAPNO: siginfo_layout = 4;
pub const siginfo_layout_SIL_FAULT_MCEERR: siginfo_layout = 5;
pub const siginfo_layout_SIL_FAULT_BNDERR: siginfo_layout = 6;
pub const siginfo_layout_SIL_FAULT_PKUERR: siginfo_layout = 7;
pub const siginfo_layout_SIL_FAULT_PERF_EVENT: siginfo_layout = 8;
pub const siginfo_layout_SIL_CHLD: siginfo_layout = 9;
pub const siginfo_layout_SIL_RT: siginfo_layout = 10;
pub const siginfo_layout_SIL_SYS: siginfo_layout = 11;
pub type siginfo_layout = core::ffi::c_uint;
extern "C" {
    pub fn siginfo_layout(sig: core::ffi::c_uint, si_code: core::ffi::c_int) -> siginfo_layout;
}
extern "C" {
    pub fn flush_sigqueue(queue: *mut sigpending);
}
extern "C" {
    pub fn next_signal(pending: *mut sigpending, mask: *mut sigset_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_send_sig_info(
        sig: core::ffi::c_int,
        info: *mut kernel_siginfo,
        p: *mut task_struct,
        type_: pid_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn group_send_sig_info(
        sig: core::ffi::c_int,
        info: *mut kernel_siginfo,
        p: *mut task_struct,
        type_: pid_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_signal_locked(
        sig: core::ffi::c_int,
        info: *mut kernel_siginfo,
        p: *mut task_struct,
        type_: pid_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sigprocmask(
        arg1: core::ffi::c_int,
        arg2: *mut sigset_t,
        arg3: *mut sigset_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_current_blocked(arg1: *mut sigset_t);
}
extern "C" {
    pub fn __set_current_blocked(arg1: *const sigset_t);
}
extern "C" {
    pub static mut show_unhandled_signals: core::ffi::c_int;
}
extern "C" {
    pub fn get_signal(ksig: *mut ksignal) -> bool_;
}
extern "C" {
    pub fn signal_setup_done(
        failed: core::ffi::c_int,
        ksig: *mut ksignal,
        stepping: core::ffi::c_int,
    );
}
extern "C" {
    pub fn exit_signals(tsk: *mut task_struct);
}
extern "C" {
    pub fn kernel_sigaction(arg1: core::ffi::c_int, arg2: __sighandler_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmem_cache {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut sighand_cachep: *mut kmem_cache;
}
extern "C" {
    pub fn unhandled_signal(tsk: *mut task_struct, sig: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn signals_init();
}
extern "C" {
    pub fn restore_altstack(arg1: *const stack_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __save_altstack(arg1: *mut stack_t, arg2: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn render_sigset_t(
        arg1: *mut seq_file,
        arg2: *const core::ffi::c_char,
        arg3: *mut sigset_t,
    );
}
extern "C" {
    pub fn task_set_jobctl_pending(task: *mut task_struct, mask: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn task_clear_jobctl_trapping(task: *mut task_struct);
}
extern "C" {
    pub fn task_clear_jobctl_pending(task: *mut task_struct, mask: core::ffi::c_ulong);
}
extern "C" {
    pub fn apply_boot_alternatives();
}
extern "C" {
    pub fn apply_early_boot_alternatives();
}
extern "C" {
    pub fn apply_module_alternatives(start: *mut core::ffi::c_void, length: usize);
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct alt_entry {
    pub old_ptr: *mut core::ffi::c_void,
    pub alt_ptr: *mut core::ffi::c_void,
    pub vendor_id: core::ffi::c_ulong,
    pub alt_len: core::ffi::c_ulong,
    pub errata_id: core::ffi::c_uint,
}
impl Default for alt_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct errata_checkfunc_id {
    pub vendor_id: core::ffi::c_ulong,
    pub func: ::core::option::Option<unsafe extern "C" fn(alt: *mut alt_entry) -> bool_>,
}
extern "C" {
    pub fn sifive_errata_patch_func(
        begin: *mut alt_entry,
        end: *mut alt_entry,
        archid: core::ffi::c_ulong,
        impid: core::ffi::c_ulong,
        stage: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn thead_errata_patch_func(
        begin: *mut alt_entry,
        end: *mut alt_entry,
        archid: core::ffi::c_ulong,
        impid: core::ffi::c_ulong,
        stage: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn riscv_cpufeature_patch_func(
        begin: *mut alt_entry,
        end: *mut alt_entry,
        stage: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn flush_tlb_all();
}
extern "C" {
    pub fn flush_tlb_mm(mm: *mut mm_struct);
}
extern "C" {
    pub fn flush_tlb_page(vma: *mut vm_area_struct, addr: core::ffi::c_ulong);
}
extern "C" {
    pub fn flush_tlb_range(
        vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    );
}
extern "C" {
    pub static mut pgtable_l4_enabled: bool_;
}
extern "C" {
    pub static mut pgtable_l5_enabled: bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct p4d_t {
    pub p4d: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pud_t {
    pub pud: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pmd_t {
    pub pmd: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pt_alloc_ops {
    pub get_pte_virt: ::core::option::Option<unsafe extern "C" fn(pa: phys_addr_t) -> *mut pte_t>,
    pub alloc_pte: ::core::option::Option<unsafe extern "C" fn(va: usize) -> phys_addr_t>,
    pub get_pmd_virt: ::core::option::Option<unsafe extern "C" fn(pa: phys_addr_t) -> *mut pmd_t>,
    pub alloc_pmd: ::core::option::Option<unsafe extern "C" fn(va: usize) -> phys_addr_t>,
    pub get_pud_virt: ::core::option::Option<unsafe extern "C" fn(pa: phys_addr_t) -> *mut pud_t>,
    pub alloc_pud: ::core::option::Option<unsafe extern "C" fn(va: usize) -> phys_addr_t>,
    pub get_p4d_virt: ::core::option::Option<unsafe extern "C" fn(pa: phys_addr_t) -> *mut p4d_t>,
    pub alloc_p4d: ::core::option::Option<unsafe extern "C" fn(va: usize) -> phys_addr_t>,
}
extern "C" {
    pub static mut pt_ops: pt_alloc_ops;
}
extern "C" {
    pub static mut swapper_pg_dir: [pgd_t; 0usize];
}
extern "C" {
    pub fn flush_icache_pte(pte: pte_t);
}
extern "C" {
    pub static mut _start: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut _dtb_early_va: *mut core::ffi::c_void;
}
extern "C" {
    pub static mut _dtb_early_pa: usize;
}
extern "C" {
    pub static mut satp_mode: u64_;
}
extern "C" {
    pub fn paging_init();
}
extern "C" {
    pub fn misc_mem_init();
}
extern "C" {
    pub static mut empty_zero_page: [core::ffi::c_ulong; 512usize];
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct exception_table_entry {
    pub insn: core::ffi::c_int,
    pub fixup: core::ffi::c_int,
    pub type_: core::ffi::c_short,
    pub data: core::ffi::c_short,
}
extern "C" {
    pub fn fixup_exception(regs: *mut pt_regs) -> bool_;
}
extern "C" {
    pub fn __asm_copy_to_user(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __asm_copy_from_user(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        n: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn strncpy_from_user(
        dest: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
        count: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn strnlen_user(str_: *const core::ffi::c_char, n: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn __clear_user(addr: *mut core::ffi::c_void, n: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _copy_from_user(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn _copy_to_user(
        arg1: *mut core::ffi::c_void,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn check_zeroed_user(from: *const core::ffi::c_void, size: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn copy_from_kernel_nofault_allowed(
        unsafe_src: *const core::ffi::c_void,
        size: usize,
    ) -> bool_;
}
extern "C" {
    pub fn copy_from_kernel_nofault(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn copy_to_kernel_nofault(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn copy_from_user_nofault(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn copy_to_user_nofault(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn strncpy_from_kernel_nofault(
        dst: *mut core::ffi::c_char,
        unsafe_addr: *const core::ffi::c_void,
        count: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn strncpy_from_user_nofault(
        dst: *mut core::ffi::c_char,
        unsafe_addr: *const core::ffi::c_void,
        count: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn strnlen_user_nofault(
        unsafe_addr: *const core::ffi::c_void,
        count: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_clone_args {
    pub flags: u64_,
    pub pidfd: *mut core::ffi::c_int,
    pub child_tid: *mut core::ffi::c_int,
    pub parent_tid: *mut core::ffi::c_int,
    pub exit_signal: core::ffi::c_int,
    pub stack: core::ffi::c_ulong,
    pub stack_size: core::ffi::c_ulong,
    pub tls: core::ffi::c_ulong,
    pub set_tid: *mut pid_t,
    pub set_tid_size: usize,
    pub cgroup: core::ffi::c_int,
    pub io_thread: core::ffi::c_int,
    pub kthread: core::ffi::c_int,
    pub idle: core::ffi::c_int,
    pub fn_: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub fn_arg: *mut core::ffi::c_void,
    pub cgrp: *mut cgroup,
    pub cset: *mut css_set,
}
impl Default for kernel_clone_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut tasklist_lock: rwlock_t;
}
extern "C" {
    pub static mut mmlist_lock: spinlock_t;
}
extern "C" {
    pub static mut init_thread_union: thread_union;
}
extern "C" {
    pub static mut init_task: task_struct;
}
extern "C" {
    pub fn lockdep_tasklist_lock_is_held() -> core::ffi::c_int;
}
extern "C" {
    pub fn schedule_tail(prev: *mut task_struct);
}
extern "C" {
    pub fn init_idle(idle: *mut task_struct, cpu: core::ffi::c_int);
}
extern "C" {
    pub fn sched_fork(clone_flags: core::ffi::c_ulong, p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn sched_cgroup_fork(p: *mut task_struct, kargs: *mut kernel_clone_args);
}
extern "C" {
    pub fn sched_post_fork(p: *mut task_struct);
}
extern "C" {
    pub fn sched_dead(p: *mut task_struct);
}
extern "C" {
    pub fn do_task_dead();
}
extern "C" {
    pub fn make_task_dead(signr: core::ffi::c_int);
}
extern "C" {
    pub fn proc_caches_init();
}
extern "C" {
    pub fn fork_init();
}
extern "C" {
    pub fn release_task(p: *mut task_struct);
}
extern "C" {
    pub fn copy_thread(arg1: *mut task_struct, arg2: *const kernel_clone_args) -> core::ffi::c_int;
}
extern "C" {
    pub fn flush_thread();
}
extern "C" {
    pub fn do_group_exit(arg1: core::ffi::c_int);
}
extern "C" {
    pub fn exit_files(arg1: *mut task_struct);
}
extern "C" {
    pub fn exit_itimers(arg1: *mut task_struct);
}
extern "C" {
    pub fn kernel_clone(kargs: *mut kernel_clone_args) -> pid_t;
}
extern "C" {
    pub fn create_io_thread(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
        arg: *mut core::ffi::c_void,
        node: core::ffi::c_int,
    ) -> *mut task_struct;
}
extern "C" {
    pub fn fork_idle(arg1: core::ffi::c_int) -> *mut task_struct;
}
extern "C" {
    pub fn copy_init_mm() -> *mut mm_struct;
}
extern "C" {
    pub fn kernel_thread(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
        arg: *mut core::ffi::c_void,
        flags: core::ffi::c_ulong,
    ) -> pid_t;
}
extern "C" {
    pub fn user_mode_thread(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
        arg: *mut core::ffi::c_void,
        flags: core::ffi::c_ulong,
    ) -> pid_t;
}
extern "C" {
    pub fn kernel_wait4(
        arg1: pid_t,
        arg2: *mut core::ffi::c_int,
        arg3: core::ffi::c_int,
        arg4: *mut rusage,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn kernel_wait(pid: pid_t, stat: *mut core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn free_task(tsk: *mut task_struct);
}
extern "C" {
    pub fn sched_exec();
}
extern "C" {
    pub fn __put_task_struct(t: *mut task_struct);
}
extern "C" {
    pub fn put_task_struct_rcu_user(task: *mut task_struct);
}
extern "C" {
    pub fn release_thread(dead_task: *mut task_struct);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct assoc_array {
    pub root: *mut assoc_array_ptr,
    pub nr_leaves_on_tree: core::ffi::c_ulong,
}
impl Default for assoc_array {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct assoc_array_ops {
    pub get_key_chunk: ::core::option::Option<
        unsafe extern "C" fn(
            index_key: *const core::ffi::c_void,
            level: core::ffi::c_int,
        ) -> core::ffi::c_ulong,
    >,
    pub get_object_key_chunk: ::core::option::Option<
        unsafe extern "C" fn(
            object: *const core::ffi::c_void,
            level: core::ffi::c_int,
        ) -> core::ffi::c_ulong,
    >,
    pub compare_object: ::core::option::Option<
        unsafe extern "C" fn(
            object: *const core::ffi::c_void,
            index_key: *const core::ffi::c_void,
        ) -> bool_,
    >,
    pub diff_objects: ::core::option::Option<
        unsafe extern "C" fn(
            object: *const core::ffi::c_void,
            index_key: *const core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub free_object: ::core::option::Option<unsafe extern "C" fn(object: *mut core::ffi::c_void)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct assoc_array_edit {
    _unused: [u8; 0],
}
extern "C" {
    pub fn assoc_array_iterate(
        array: *const assoc_array,
        iterator: ::core::option::Option<
            unsafe extern "C" fn(
                object: *const core::ffi::c_void,
                iterator_data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        iterator_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn assoc_array_find(
        array: *const assoc_array,
        ops: *const assoc_array_ops,
        index_key: *const core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn assoc_array_destroy(array: *mut assoc_array, ops: *const assoc_array_ops);
}
extern "C" {
    pub fn assoc_array_insert(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
        index_key: *const core::ffi::c_void,
        object: *mut core::ffi::c_void,
    ) -> *mut assoc_array_edit;
}
extern "C" {
    pub fn assoc_array_insert_set_object(
        edit: *mut assoc_array_edit,
        object: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn assoc_array_delete(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
        index_key: *const core::ffi::c_void,
    ) -> *mut assoc_array_edit;
}
extern "C" {
    pub fn assoc_array_clear(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
    ) -> *mut assoc_array_edit;
}
extern "C" {
    pub fn assoc_array_apply_edit(edit: *mut assoc_array_edit);
}
extern "C" {
    pub fn assoc_array_cancel_edit(edit: *mut assoc_array_edit);
}
extern "C" {
    pub fn assoc_array_gc(
        array: *mut assoc_array,
        ops: *const assoc_array_ops,
        iterator: ::core::option::Option<
            unsafe extern "C" fn(
                object: *mut core::ffi::c_void,
                iterator_data: *mut core::ffi::c_void,
            ) -> bool_,
        >,
        iterator_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
pub type key_serial_t = i32;
pub type key_perm_t = u32;
pub const key_need_perm_KEY_NEED_UNSPECIFIED: key_need_perm = 0;
pub const key_need_perm_KEY_NEED_VIEW: key_need_perm = 1;
pub const key_need_perm_KEY_NEED_READ: key_need_perm = 2;
pub const key_need_perm_KEY_NEED_WRITE: key_need_perm = 3;
pub const key_need_perm_KEY_NEED_SEARCH: key_need_perm = 4;
pub const key_need_perm_KEY_NEED_LINK: key_need_perm = 5;
pub const key_need_perm_KEY_NEED_SETATTR: key_need_perm = 6;
pub const key_need_perm_KEY_NEED_UNLINK: key_need_perm = 7;
pub const key_need_perm_KEY_SYSADMIN_OVERRIDE: key_need_perm = 8;
pub const key_need_perm_KEY_AUTHTOKEN_OVERRIDE: key_need_perm = 9;
pub const key_need_perm_KEY_DEFER_PERM_CHECK: key_need_perm = 10;
pub type key_need_perm = core::ffi::c_uint;
pub const key_lookup_flag_KEY_LOOKUP_CREATE: key_lookup_flag = 1;
pub const key_lookup_flag_KEY_LOOKUP_PARTIAL: key_lookup_flag = 2;
pub const key_lookup_flag_KEY_LOOKUP_ALL: key_lookup_flag = 3;
pub type key_lookup_flag = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_owner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_name {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_tag {
    pub rcu: callback_head,
    pub usage: refcount_t,
    pub removed: bool_,
}
impl Default for key_tag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct keyring_index_key {
    pub hash: core::ffi::c_ulong,
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *const core::ffi::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union keyring_index_key__bindgen_ty_1 {
    pub __bindgen_anon_1: keyring_index_key__bindgen_ty_1__bindgen_ty_1,
    pub x: core::ffi::c_ulong,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct keyring_index_key__bindgen_ty_1__bindgen_ty_1 {
    pub desc_len: u16_,
    pub desc: [core::ffi::c_char; 6usize],
}
impl Default for keyring_index_key__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for keyring_index_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key_payload {
    pub rcu_data0: *mut core::ffi::c_void,
    pub data: [*mut core::ffi::c_void; 4usize],
    _bindgen_union_align: [u64; 4usize],
}
impl Default for key_payload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __key_reference_with_attributes {
    _unused: [u8; 0],
}
pub type key_ref_t = *mut __key_reference_with_attributes;
pub type key_restrict_link_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        dest_keyring: *mut key,
        type_: *const key_type,
        payload: *const key_payload,
        restriction_key: *mut key,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key_restriction {
    pub check: key_restrict_link_func_t,
    pub key: *mut key,
    pub keytype: *mut key_type,
}
impl Default for key_restriction {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const key_state_KEY_IS_UNINSTANTIATED: key_state = 0;
pub const key_state_KEY_IS_POSITIVE: key_state = 1;
pub type key_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key {
    pub usage: refcount_t,
    pub serial: key_serial_t,
    pub __bindgen_anon_1: key__bindgen_ty_1,
    pub sem: rw_semaphore,
    pub user: *mut key_user,
    pub security: *mut core::ffi::c_void,
    pub __bindgen_anon_2: key__bindgen_ty_2,
    pub last_used_at: time64_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub perm: key_perm_t,
    pub quotalen: core::ffi::c_ushort,
    pub datalen: core::ffi::c_ushort,
    pub state: core::ffi::c_short,
    pub flags: core::ffi::c_ulong,
    pub __bindgen_anon_3: key__bindgen_ty_3,
    pub __bindgen_anon_4: key__bindgen_ty_4,
    pub restrict_link: *mut key_restriction,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_1 {
    pub graveyard_link: list_head,
    pub serial_node: rb_node,
    _bindgen_union_align: [u64; 3usize],
}
impl Default for key__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_2 {
    pub expiry: time64_t,
    pub revoked_at: time64_t,
    _bindgen_union_align: u64,
}
impl Default for key__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_3 {
    pub index_key: keyring_index_key,
    pub __bindgen_anon_1: key__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key__bindgen_ty_3__bindgen_ty_1 {
    pub hash: core::ffi::c_ulong,
    pub len_desc: core::ffi::c_ulong,
    pub type_: *mut key_type,
    pub domain_tag: *mut key_tag,
    pub description: *mut core::ffi::c_char,
}
impl Default for key__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for key__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union key__bindgen_ty_4 {
    pub payload: key_payload,
    pub __bindgen_anon_1: key__bindgen_ty_4__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct key__bindgen_ty_4__bindgen_ty_1 {
    pub name_link: list_head,
    pub keys: assoc_array,
}
impl Default for key__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for key__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn key_alloc(
        type_: *mut key_type,
        desc: *const core::ffi::c_char,
        uid: kuid_t,
        gid: kgid_t,
        cred: *const cred,
        perm: key_perm_t,
        flags: core::ffi::c_ulong,
        restrict_link: *mut key_restriction,
    ) -> *mut key;
}
extern "C" {
    pub fn key_revoke(key: *mut key);
}
extern "C" {
    pub fn key_invalidate(key: *mut key);
}
extern "C" {
    pub fn key_put(key: *mut key);
}
extern "C" {
    pub fn key_put_tag(tag: *mut key_tag) -> bool_;
}
extern "C" {
    pub fn key_remove_domain(domain_tag: *mut key_tag);
}
extern "C" {
    pub fn request_key_tag(
        type_: *mut key_type,
        description: *const core::ffi::c_char,
        domain_tag: *mut key_tag,
        callout_info: *const core::ffi::c_char,
    ) -> *mut key;
}
extern "C" {
    pub fn request_key_rcu(
        type_: *mut key_type,
        description: *const core::ffi::c_char,
        domain_tag: *mut key_tag,
    ) -> *mut key;
}
extern "C" {
    pub fn request_key_with_auxdata(
        type_: *mut key_type,
        description: *const core::ffi::c_char,
        domain_tag: *mut key_tag,
        callout_info: *const core::ffi::c_void,
        callout_len: usize,
        aux: *mut core::ffi::c_void,
    ) -> *mut key;
}
extern "C" {
    pub fn wait_for_key_construction(key: *mut key, intr: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_validate(key: *const key) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_create_or_update(
        keyring: key_ref_t,
        type_: *const core::ffi::c_char,
        description: *const core::ffi::c_char,
        payload: *const core::ffi::c_void,
        plen: usize,
        perm: key_perm_t,
        flags: core::ffi::c_ulong,
    ) -> key_ref_t;
}
extern "C" {
    pub fn key_update(
        key: key_ref_t,
        payload: *const core::ffi::c_void,
        plen: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_link(keyring: *mut key, key: *mut key) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_move(
        key: *mut key,
        from_keyring: *mut key,
        to_keyring: *mut key,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_unlink(keyring: *mut key, key: *mut key) -> core::ffi::c_int;
}
extern "C" {
    pub fn keyring_alloc(
        description: *const core::ffi::c_char,
        uid: kuid_t,
        gid: kgid_t,
        cred: *const cred,
        perm: key_perm_t,
        flags: core::ffi::c_ulong,
        restrict_link: *mut key_restriction,
        dest: *mut key,
    ) -> *mut key;
}
extern "C" {
    pub fn restrict_link_reject(
        keyring: *mut key,
        type_: *const key_type,
        payload: *const key_payload,
        restriction_key: *mut key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn keyring_clear(keyring: *mut key) -> core::ffi::c_int;
}
extern "C" {
    pub fn keyring_search(
        keyring: key_ref_t,
        type_: *mut key_type,
        description: *const core::ffi::c_char,
        recurse: bool_,
    ) -> key_ref_t;
}
extern "C" {
    pub fn keyring_add_key(keyring: *mut key, key: *mut key) -> core::ffi::c_int;
}
extern "C" {
    pub fn keyring_restrict(
        keyring: key_ref_t,
        type_: *const core::ffi::c_char,
        restriction: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_lookup(id: key_serial_t) -> *mut key;
}
extern "C" {
    pub fn key_set_timeout(arg1: *mut key, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn lookup_user_key(
        id: key_serial_t,
        flags: core::ffi::c_ulong,
        need_perm: key_need_perm,
    ) -> key_ref_t;
}
extern "C" {
    pub fn key_free_user_ns(arg1: *mut user_namespace);
}
extern "C" {
    pub static mut key_sysctls: [ctl_table; 0usize];
}
extern "C" {
    pub fn install_thread_keyring_to_cred(cred: *mut cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn key_fsuid_changed(new_cred: *mut cred);
}
extern "C" {
    pub fn key_fsgid_changed(new_cred: *mut cred);
}
extern "C" {
    pub fn key_init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_counter {
    pub lock: raw_spinlock_t,
    pub count: s64,
    pub list: list_head,
    pub counters: *mut s32,
}
impl Default for percpu_counter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut percpu_counter_batch: core::ffi::c_int;
}
extern "C" {
    pub fn __percpu_counter_init(
        fbc: *mut percpu_counter,
        amount: s64,
        gfp: gfp_t,
        key: *mut lock_class_key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn percpu_counter_destroy(fbc: *mut percpu_counter);
}
extern "C" {
    pub fn percpu_counter_set(fbc: *mut percpu_counter, amount: s64);
}
extern "C" {
    pub fn percpu_counter_add_batch(fbc: *mut percpu_counter, amount: s64, batch: s32);
}
extern "C" {
    pub fn __percpu_counter_sum(fbc: *mut percpu_counter) -> s64;
}
extern "C" {
    pub fn __percpu_counter_compare(
        fbc: *mut percpu_counter,
        rhs: s64,
        batch: s32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn percpu_counter_sync(fbc: *mut percpu_counter);
}
extern "C" {
    pub static mut printk_ratelimit_state: ratelimit_state;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct user_struct {
    pub __count: refcount_t,
    pub epoll_watches: percpu_counter,
    pub unix_inflight: core::ffi::c_ulong,
    pub pipe_bufs: atomic_long_t,
    pub uidhash_node: hlist_node,
    pub uid: kuid_t,
    pub locked_vm: atomic_long_t,
    pub ratelimit: ratelimit_state,
}
impl Default for user_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn uids_sysfs_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn find_user(arg1: kuid_t) -> *mut user_struct;
}
extern "C" {
    pub static mut root_user: user_struct;
}
extern "C" {
    pub fn alloc_uid(arg1: kuid_t) -> *mut user_struct;
}
extern "C" {
    pub fn free_uid(arg1: *mut user_struct);
}
#[repr(C)]
#[derive(Default)]
pub struct group_info {
    pub usage: atomic_t,
    pub ngroups: core::ffi::c_int,
    pub gid: __IncompleteArrayField<kgid_t>,
}
extern "C" {
    pub fn groups_alloc(arg1: core::ffi::c_int) -> *mut group_info;
}
extern "C" {
    pub fn groups_free(arg1: *mut group_info);
}
extern "C" {
    pub fn in_group_p(arg1: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn in_egroup_p(arg1: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn groups_search(arg1: *const group_info, arg2: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_current_groups(arg1: *mut group_info) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_groups(arg1: *mut cred, arg2: *mut group_info);
}
extern "C" {
    pub fn may_setgroups() -> bool_;
}
extern "C" {
    pub fn groups_sort(arg1: *mut group_info);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cred {
    pub usage: atomic_t,
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub suid: kuid_t,
    pub sgid: kgid_t,
    pub euid: kuid_t,
    pub egid: kgid_t,
    pub fsuid: kuid_t,
    pub fsgid: kgid_t,
    pub securebits: core::ffi::c_uint,
    pub cap_inheritable: kernel_cap_t,
    pub cap_permitted: kernel_cap_t,
    pub cap_effective: kernel_cap_t,
    pub cap_bset: kernel_cap_t,
    pub cap_ambient: kernel_cap_t,
    pub jit_keyring: core::ffi::c_uchar,
    pub session_keyring: *mut key,
    pub process_keyring: *mut key,
    pub thread_keyring: *mut key,
    pub request_key_auth: *mut key,
    pub security: *mut core::ffi::c_void,
    pub user: *mut user_struct,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub group_info: *mut group_info,
    pub __bindgen_anon_1: cred__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cred__bindgen_ty_1 {
    pub non_rcu: core::ffi::c_int,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for cred__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for cred {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __put_cred(arg1: *mut cred);
}
extern "C" {
    pub fn exit_creds(arg1: *mut task_struct);
}
extern "C" {
    pub fn copy_creds(arg1: *mut task_struct, arg2: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_task_cred(arg1: *mut task_struct) -> *const cred;
}
extern "C" {
    pub fn cred_alloc_blank() -> *mut cred;
}
extern "C" {
    pub fn prepare_creds() -> *mut cred;
}
extern "C" {
    pub fn prepare_exec_creds() -> *mut cred;
}
extern "C" {
    pub fn commit_creds(arg1: *mut cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn abort_creds(arg1: *mut cred);
}
extern "C" {
    pub fn override_creds(arg1: *const cred) -> *const cred;
}
extern "C" {
    pub fn revert_creds(arg1: *const cred);
}
extern "C" {
    pub fn prepare_kernel_cred(arg1: *mut task_struct) -> *mut cred;
}
extern "C" {
    pub fn change_create_files_as(arg1: *mut cred, arg2: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_security_override(arg1: *mut cred, arg2: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_security_override_from_ctx(
        arg1: *mut cred,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_create_files_as(arg1: *mut cred, arg2: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn cred_fscmp(arg1: *const cred, arg2: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn cred_init();
}
extern "C" {
    pub fn set_cred_ucounts(arg1: *mut cred) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sighand_struct {
    pub siglock: spinlock_t,
    pub count: refcount_t,
    pub signalfd_wqh: wait_queue_head_t,
    pub action: [k_sigaction; 64usize],
}
impl Default for sighand_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pacct_struct {
    pub ac_flag: core::ffi::c_int,
    pub ac_exitcode: core::ffi::c_long,
    pub ac_mem: core::ffi::c_ulong,
    pub ac_utime: u64_,
    pub ac_stime: u64_,
    pub ac_minflt: core::ffi::c_ulong,
    pub ac_majflt: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_itimer {
    pub expires: u64_,
    pub incr: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct task_cputime_atomic {
    pub utime: atomic64_t,
    pub stime: atomic64_t,
    pub sum_exec_runtime: atomic64_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct thread_group_cputimer {
    pub cputime_atomic: task_cputime_atomic,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct multiprocess_signals {
    pub signal: sigset_t,
    pub node: hlist_node,
}
impl Default for multiprocess_signals {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_thread {
    pub task: *mut task_struct,
    pub next: *mut core_thread,
}
impl Default for core_thread {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct core_state {
    pub nr_threads: atomic_t,
    pub dumper: core_thread,
    pub startup: completion,
}
impl Default for core_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct signal_struct {
    pub sigcnt: refcount_t,
    pub live: atomic_t,
    pub nr_threads: core::ffi::c_int,
    pub quick_threads: core::ffi::c_int,
    pub thread_head: list_head,
    pub wait_chldexit: wait_queue_head_t,
    pub curr_target: *mut task_struct,
    pub shared_pending: sigpending,
    pub multiprocess: hlist_head,
    pub group_exit_code: core::ffi::c_int,
    pub notify_count: core::ffi::c_int,
    pub group_exec_task: *mut task_struct,
    pub group_stop_count: core::ffi::c_int,
    pub flags: core::ffi::c_uint,
    pub core_state: *mut core_state,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub posix_timer_id: core::ffi::c_int,
    pub posix_timers: list_head,
    pub real_timer: hrtimer,
    pub it_real_incr: ktime_t,
    pub it: [cpu_itimer; 2usize],
    pub cputimer: thread_group_cputimer,
    pub posix_cputimers: posix_cputimers,
    pub pids: [*mut pid; 4usize],
    pub tty_old_pgrp: *mut pid,
    pub leader: core::ffi::c_int,
    pub tty: *mut tty_struct,
    pub stats_lock: seqlock_t,
    pub utime: u64_,
    pub stime: u64_,
    pub cutime: u64_,
    pub cstime: u64_,
    pub gtime: u64_,
    pub cgtime: u64_,
    pub prev_cputime: prev_cputime,
    pub nvcsw: core::ffi::c_ulong,
    pub nivcsw: core::ffi::c_ulong,
    pub cnvcsw: core::ffi::c_ulong,
    pub cnivcsw: core::ffi::c_ulong,
    pub min_flt: core::ffi::c_ulong,
    pub maj_flt: core::ffi::c_ulong,
    pub cmin_flt: core::ffi::c_ulong,
    pub cmaj_flt: core::ffi::c_ulong,
    pub inblock: core::ffi::c_ulong,
    pub oublock: core::ffi::c_ulong,
    pub cinblock: core::ffi::c_ulong,
    pub coublock: core::ffi::c_ulong,
    pub maxrss: core::ffi::c_ulong,
    pub cmaxrss: core::ffi::c_ulong,
    pub ioac: task_io_accounting,
    pub sum_sched_runtime: core::ffi::c_ulonglong,
    pub rlim: [rlimit; 16usize],
    pub audit_tty: core::ffi::c_uint,
    pub tty_audit_buf: *mut tty_audit_buf,
    pub oom_flag_origin: bool_,
    pub oom_score_adj: core::ffi::c_short,
    pub oom_score_adj_min: core::ffi::c_short,
    pub oom_mm: *mut mm_struct,
    pub cred_guard_mutex: mutex,
    pub exec_update_lock: rw_semaphore,
}
impl Default for signal_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl signal_struct {
    #[inline]
    pub fn is_child_subreaper(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_child_subreaper(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_child_subreaper(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_child_subreaper(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_child_subreaper: core::ffi::c_uint,
        has_child_subreaper: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_child_subreaper: u32 = unsafe { ::core::mem::transmute(is_child_subreaper) };
            is_child_subreaper as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_child_subreaper: u32 = unsafe { ::core::mem::transmute(has_child_subreaper) };
            has_child_subreaper as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn flush_signals(arg1: *mut task_struct);
}
extern "C" {
    pub fn ignore_signals(arg1: *mut task_struct);
}
extern "C" {
    pub fn flush_signal_handlers(arg1: *mut task_struct, force_default: core::ffi::c_int);
}
extern "C" {
    pub fn dequeue_signal(
        task: *mut task_struct,
        mask: *mut sigset_t,
        info: *mut kernel_siginfo_t,
        type_: *mut pid_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_fault_to_task(
        sig: core::ffi::c_int,
        code: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
        t: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_fault(
        sig: core::ffi::c_int,
        code: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_sig_fault(
        sig: core::ffi::c_int,
        code: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
        t: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_mceerr(
        code: core::ffi::c_int,
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_short,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_sig_mceerr(
        code: core::ffi::c_int,
        arg1: *mut core::ffi::c_void,
        arg2: core::ffi::c_short,
        arg3: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_bnderr(
        addr: *mut core::ffi::c_void,
        lower: *mut core::ffi::c_void,
        upper: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_pkuerr(addr: *mut core::ffi::c_void, pkey: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_sig_perf(
        addr: *mut core::ffi::c_void,
        type_: u32_,
        sig_data: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_ptrace_errno_trap(
        errno: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_fault_trapno(
        sig: core::ffi::c_int,
        code: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
        trapno: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_sig_fault_trapno(
        sig: core::ffi::c_int,
        code: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
        trapno: core::ffi::c_int,
        t: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sig_seccomp(
        syscall: core::ffi::c_int,
        reason: core::ffi::c_int,
        force_coredump: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn send_sig_info(
        arg1: core::ffi::c_int,
        arg2: *mut kernel_siginfo,
        arg3: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn force_sigsegv(sig: core::ffi::c_int);
}
extern "C" {
    pub fn force_sig_info(arg1: *mut kernel_siginfo) -> core::ffi::c_int;
}
extern "C" {
    pub fn __kill_pgrp_info(
        sig: core::ffi::c_int,
        info: *mut kernel_siginfo,
        pgrp: *mut pid,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kill_pid_info(
        sig: core::ffi::c_int,
        info: *mut kernel_siginfo,
        pid: *mut pid,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kill_pid_usb_asyncio(
        sig: core::ffi::c_int,
        errno: core::ffi::c_int,
        addr: sigval_t,
        arg1: *mut pid,
        arg2: *const cred,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kill_pgrp(
        pid: *mut pid,
        sig: core::ffi::c_int,
        priv_: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kill_pid(
        pid: *mut pid,
        sig: core::ffi::c_int,
        priv_: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_notify_parent(arg1: *mut task_struct, arg2: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn __wake_up_parent(p: *mut task_struct, parent: *mut task_struct);
}
extern "C" {
    pub fn force_sig(arg1: core::ffi::c_int);
}
extern "C" {
    pub fn force_fatal_sig(arg1: core::ffi::c_int);
}
extern "C" {
    pub fn force_exit_sig(arg1: core::ffi::c_int);
}
extern "C" {
    pub fn send_sig(
        arg1: core::ffi::c_int,
        arg2: *mut task_struct,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn zap_other_threads(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn sigqueue_alloc() -> *mut sigqueue;
}
extern "C" {
    pub fn sigqueue_free(arg1: *mut sigqueue);
}
extern "C" {
    pub fn send_sigqueue(arg1: *mut sigqueue, arg2: *mut pid, arg3: pid_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_sigaction(
        arg1: core::ffi::c_int,
        arg2: *mut k_sigaction,
        arg3: *mut k_sigaction,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn recalc_sigpending_and_wake(t: *mut task_struct);
}
extern "C" {
    pub fn recalc_sigpending();
}
extern "C" {
    pub fn calculate_sigpending();
}
extern "C" {
    pub fn signal_wake_up_state(t: *mut task_struct, state: core::ffi::c_uint);
}
extern "C" {
    pub fn task_join_group_stop(task: *mut task_struct);
}
extern "C" {
    pub fn set_user_sigmask(umask: *const sigset_t, sigsetsize: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cleanup_sighand(arg1: *mut sighand_struct);
}
extern "C" {
    pub fn flush_itimer_signals();
}
extern "C" {
    pub fn current_is_single_threaded() -> bool_;
}
pub type proc_visitor = ::core::option::Option<
    unsafe extern "C" fn(p: *mut task_struct, data: *mut core::ffi::c_void) -> core::ffi::c_int,
>;
extern "C" {
    pub fn walk_process_tree(
        top: *mut task_struct,
        arg1: proc_visitor,
        arg2: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn thread_group_exited(pid: *mut pid) -> bool_;
}
extern "C" {
    pub fn __lock_task_sighand(
        task: *mut task_struct,
        flags: *mut core::ffi::c_ulong,
    ) -> *mut sighand_struct;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcuwait {
    pub task: *mut task_struct,
}
impl Default for rcuwait {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn rcuwait_wake_up(w: *mut rcuwait) -> core::ffi::c_int;
}
extern "C" {
    pub fn finish_rcuwait(w: *mut rcuwait);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rcu_sync {
    pub gp_state: core::ffi::c_int,
    pub gp_count: core::ffi::c_int,
    pub gp_wait: wait_queue_head_t,
    pub cb_head: callback_head,
}
impl Default for rcu_sync {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn rcu_sync_init(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_enter_start(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_enter(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_exit(arg1: *mut rcu_sync);
}
extern "C" {
    pub fn rcu_sync_dtor(arg1: *mut rcu_sync);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_rw_semaphore {
    pub rss: rcu_sync,
    pub read_count: *mut core::ffi::c_uint,
    pub writer: rcuwait,
    pub waiters: wait_queue_head_t,
    pub block: atomic_t,
}
impl Default for percpu_rw_semaphore {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __percpu_down_read(arg1: *mut percpu_rw_semaphore, arg2: bool_) -> bool_;
}
extern "C" {
    pub fn percpu_is_read_locked(arg1: *mut percpu_rw_semaphore) -> bool_;
}
extern "C" {
    pub fn percpu_down_write(arg1: *mut percpu_rw_semaphore);
}
extern "C" {
    pub fn percpu_up_write(arg1: *mut percpu_rw_semaphore);
}
extern "C" {
    pub fn __percpu_init_rwsem(
        arg1: *mut percpu_rw_semaphore,
        arg2: *const core::ffi::c_char,
        arg3: *mut lock_class_key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn percpu_free_rwsem(arg1: *mut percpu_rw_semaphore);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct delayed_call {
    pub fn_: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
    pub arg: *mut core::ffi::c_void,
}
impl Default for delayed_call {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct guid_t {
    pub b: [__u8; 16usize],
}
pub type uuid_le = guid_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uuid_t {
    pub b: [__u8; 16usize],
}
extern "C" {
    pub static guid_null: guid_t;
}
extern "C" {
    pub static uuid_null: uuid_t;
}
extern "C" {
    pub fn generate_random_uuid(uuid: *mut core::ffi::c_uchar);
}
extern "C" {
    pub fn generate_random_guid(guid: *mut core::ffi::c_uchar);
}
extern "C" {
    pub fn guid_gen(u: *mut guid_t);
}
extern "C" {
    pub fn uuid_gen(u: *mut uuid_t);
}
extern "C" {
    pub fn uuid_is_valid(uuid: *const core::ffi::c_char) -> bool_;
}
extern "C" {
    pub static guid_index: [u8_; 16usize];
}
extern "C" {
    pub static uuid_index: [u8_; 16usize];
}
extern "C" {
    pub fn guid_parse(uuid: *const core::ffi::c_char, u: *mut guid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn uuid_parse(uuid: *const core::ffi::c_char, u: *mut uuid_t) -> core::ffi::c_int;
}
pub type errseq_t = u32_;
extern "C" {
    pub fn errseq_set(eseq: *mut errseq_t, err: core::ffi::c_int) -> errseq_t;
}
extern "C" {
    pub fn errseq_sample(eseq: *mut errseq_t) -> errseq_t;
}
extern "C" {
    pub fn errseq_check(eseq: *mut errseq_t, since: errseq_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn errseq_check_and_advance(eseq: *mut errseq_t, since: *mut errseq_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_mutex_setprio(p: *mut task_struct, pi_task: *mut task_struct);
}
extern "C" {
    pub fn rt_mutex_adjust_pi(p: *mut task_struct);
}
extern "C" {
    pub fn normalize_rt_tasks();
}
pub const ICQ_EXITED: core::ffi::c_uint = 4;
pub const ICQ_DESTROYED: core::ffi::c_uint = 8;
pub type _bindgen_ty_70 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_cq {
    pub q: *mut request_queue,
    pub ioc: *mut io_context,
    pub __bindgen_anon_1: io_cq__bindgen_ty_1,
    pub __bindgen_anon_2: io_cq__bindgen_ty_2,
    pub flags: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_1 {
    pub q_node: list_head,
    pub __rcu_icq_cache: *mut kmem_cache,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for io_cq__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union io_cq__bindgen_ty_2 {
    pub ioc_node: hlist_node,
    pub __rcu_head: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for io_cq__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for io_cq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct io_context {
    pub refcount: atomic_long_t,
    pub active_ref: atomic_t,
    pub ioprio: core::ffi::c_ushort,
}
extern "C" {
    pub fn put_io_context(ioc: *mut io_context);
}
extern "C" {
    pub fn exit_io_context(task: *mut task_struct);
}
extern "C" {
    pub fn __copy_io(clone_flags: core::ffi::c_ulong, tsk: *mut task_struct) -> core::ffi::c_int;
}
pub const IOPRIO_CLASS_NONE: core::ffi::c_uint = 0;
pub const IOPRIO_CLASS_RT: core::ffi::c_uint = 1;
pub const IOPRIO_CLASS_BE: core::ffi::c_uint = 2;
pub const IOPRIO_CLASS_IDLE: core::ffi::c_uint = 3;
pub type _bindgen_ty_71 = core::ffi::c_uint;
pub const IOPRIO_WHO_PROCESS: core::ffi::c_uint = 1;
pub const IOPRIO_WHO_PGRP: core::ffi::c_uint = 2;
pub const IOPRIO_WHO_USER: core::ffi::c_uint = 3;
pub type _bindgen_ty_72 = core::ffi::c_uint;
extern "C" {
    pub fn __get_task_ioprio(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_task_ioprio(task: *mut task_struct, ioprio: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ioprio_check_cap(ioprio: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_ftype_to_dtype(filetype: core::ffi::c_uint) -> core::ffi::c_uchar;
}
extern "C" {
    pub fn fs_umode_to_ftype(mode: umode_t) -> core::ffi::c_uchar;
}
extern "C" {
    pub fn fs_umode_to_dtype(mode: umode_t) -> core::ffi::c_uchar;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vfsmount {
    pub mnt_root: *mut dentry,
    pub mnt_sb: *mut super_block,
    pub mnt_flags: core::ffi::c_int,
    pub mnt_userns: *mut user_namespace,
}
impl Default for vfsmount {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mnt_want_write(mnt: *mut vfsmount) -> core::ffi::c_int;
}
extern "C" {
    pub fn mnt_want_write_file(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn mnt_drop_write(mnt: *mut vfsmount);
}
extern "C" {
    pub fn mnt_drop_write_file(file: *mut file);
}
extern "C" {
    pub fn mntput(mnt: *mut vfsmount);
}
extern "C" {
    pub fn mntget(mnt: *mut vfsmount) -> *mut vfsmount;
}
extern "C" {
    pub fn mnt_clone_internal(path: *const path) -> *mut vfsmount;
}
extern "C" {
    pub fn __mnt_is_readonly(mnt: *mut vfsmount) -> bool_;
}
extern "C" {
    pub fn mnt_may_suid(mnt: *mut vfsmount) -> bool_;
}
extern "C" {
    pub fn clone_private_mount(path: *const path) -> *mut vfsmount;
}
extern "C" {
    pub fn __mnt_want_write(arg1: *mut vfsmount) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mnt_drop_write(arg1: *mut vfsmount);
}
extern "C" {
    pub fn fc_mount(fc: *mut fs_context) -> *mut vfsmount;
}
extern "C" {
    pub fn vfs_create_mount(fc: *mut fs_context) -> *mut vfsmount;
}
extern "C" {
    pub fn vfs_kern_mount(
        type_: *mut file_system_type,
        flags: core::ffi::c_int,
        name: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
    ) -> *mut vfsmount;
}
extern "C" {
    pub fn vfs_submount(
        mountpoint: *const dentry,
        type_: *mut file_system_type,
        name: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
    ) -> *mut vfsmount;
}
extern "C" {
    pub fn mnt_set_expiry(mnt: *mut vfsmount, expiry_list: *mut list_head);
}
extern "C" {
    pub fn mark_mounts_for_expiry(mounts: *mut list_head);
}
extern "C" {
    pub fn name_to_dev_t(name: *const core::ffi::c_char) -> dev_t;
}
extern "C" {
    pub fn path_is_mountpoint(path: *const path) -> bool_;
}
extern "C" {
    pub fn our_mnt(mnt: *mut vfsmount) -> bool_;
}
extern "C" {
    pub fn kern_mount(arg1: *mut file_system_type) -> *mut vfsmount;
}
extern "C" {
    pub fn kern_unmount(mnt: *mut vfsmount);
}
extern "C" {
    pub fn may_umount_tree(arg1: *mut vfsmount) -> core::ffi::c_int;
}
extern "C" {
    pub fn may_umount(arg1: *mut vfsmount) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_mount(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_char,
        arg3: *const core::ffi::c_char,
        arg4: core::ffi::c_ulong,
        arg5: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn collect_mounts(arg1: *const path) -> *mut vfsmount;
}
extern "C" {
    pub fn drop_collected_mounts(arg1: *mut vfsmount);
}
extern "C" {
    pub fn iterate_mounts(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut vfsmount,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg2: *mut core::ffi::c_void,
        arg3: *mut vfsmount,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kern_unmount_array(mnt: *mut *mut vfsmount, num: core::ffi::c_uint);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfsuid_t {
    pub val: uid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vfsgid_t {
    pub val: gid_t,
}
pub type percpu_ref_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut percpu_ref)>;
pub const __PERCPU_REF_ATOMIC: core::ffi::c_uint = 1;
pub const __PERCPU_REF_DEAD: core::ffi::c_uint = 2;
pub const __PERCPU_REF_ATOMIC_DEAD: core::ffi::c_uint = 3;
pub const __PERCPU_REF_FLAG_BITS: core::ffi::c_uint = 2;
pub type _bindgen_ty_73 = core::ffi::c_uint;
pub const PERCPU_REF_INIT_ATOMIC: core::ffi::c_uint = 1;
pub const PERCPU_REF_INIT_DEAD: core::ffi::c_uint = 2;
pub const PERCPU_REF_ALLOW_REINIT: core::ffi::c_uint = 4;
pub type _bindgen_ty_74 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_ref_data {
    pub count: atomic_long_t,
    pub release: percpu_ref_func_t,
    pub confirm_switch: percpu_ref_func_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub rcu: callback_head,
    pub ref_: *mut percpu_ref,
}
impl Default for percpu_ref_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl percpu_ref_data {
    #[inline]
    pub fn force_atomic(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_force_atomic(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_reinit(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_allow_reinit(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        force_atomic: bool_,
        allow_reinit: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let force_atomic: u8 = unsafe { ::core::mem::transmute(force_atomic) };
            force_atomic as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let allow_reinit: u8 = unsafe { ::core::mem::transmute(allow_reinit) };
            allow_reinit as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct percpu_ref {
    pub percpu_count_ptr: core::ffi::c_ulong,
    pub data: *mut percpu_ref_data,
}
impl Default for percpu_ref {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn percpu_ref_init(
        ref_: *mut percpu_ref,
        release: percpu_ref_func_t,
        flags: core::ffi::c_uint,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn percpu_ref_exit(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_switch_to_atomic(ref_: *mut percpu_ref, confirm_switch: percpu_ref_func_t);
}
extern "C" {
    pub fn percpu_ref_switch_to_atomic_sync(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_switch_to_percpu(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_kill_and_confirm(ref_: *mut percpu_ref, confirm_kill: percpu_ref_func_t);
}
extern "C" {
    pub fn percpu_ref_resurrect(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_reinit(ref_: *mut percpu_ref);
}
extern "C" {
    pub fn percpu_ref_is_zero(ref_: *mut percpu_ref) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct slab {
    _unused: [u8; 0],
}
pub type kasan_vmalloc_flags_t = core::ffi::c_uint;
extern "C" {
    pub fn kmem_cache_init();
}
extern "C" {
    pub fn slab_is_available() -> bool_;
}
extern "C" {
    pub fn kmem_cache_create(
        name: *const core::ffi::c_char,
        size: core::ffi::c_uint,
        align: core::ffi::c_uint,
        flags: slab_flags_t,
        ctor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
    ) -> *mut kmem_cache;
}
extern "C" {
    pub fn kmem_cache_create_usercopy(
        name: *const core::ffi::c_char,
        size: core::ffi::c_uint,
        align: core::ffi::c_uint,
        flags: slab_flags_t,
        useroffset: core::ffi::c_uint,
        usersize: core::ffi::c_uint,
        ctor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
    ) -> *mut kmem_cache;
}
extern "C" {
    pub fn kmem_cache_destroy(s: *mut kmem_cache);
}
extern "C" {
    pub fn kmem_cache_shrink(s: *mut kmem_cache) -> core::ffi::c_int;
}
extern "C" {
    pub fn krealloc(
        objp: *const core::ffi::c_void,
        new_size: usize,
        flags: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kfree(objp: *const core::ffi::c_void);
}
extern "C" {
    pub fn kfree_sensitive(objp: *const core::ffi::c_void);
}
extern "C" {
    pub fn __ksize(objp: *const core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn ksize(objp: *const core::ffi::c_void) -> usize;
}
extern "C" {
    pub fn kmem_valid_obj(object: *mut core::ffi::c_void) -> bool_;
}
extern "C" {
    pub fn kmem_dump_obj(object: *mut core::ffi::c_void);
}
pub const kmalloc_cache_type_KMALLOC_NORMAL: kmalloc_cache_type = 0;
pub const kmalloc_cache_type_KMALLOC_DMA: kmalloc_cache_type = 0;
pub const kmalloc_cache_type_KMALLOC_CGROUP: kmalloc_cache_type = 1;
pub const kmalloc_cache_type_KMALLOC_RECLAIM: kmalloc_cache_type = 2;
pub const kmalloc_cache_type_NR_KMALLOC_TYPES: kmalloc_cache_type = 3;
pub type kmalloc_cache_type = core::ffi::c_uint;
extern "C" {
    pub static mut kmalloc_caches: [[*mut kmem_cache; 14usize]; 3usize];
}
extern "C" {
    pub fn __kmalloc(size: usize, flags: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc(s: *mut kmem_cache, flags: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_lru(
        s: *mut kmem_cache,
        lru: *mut list_lru,
        gfpflags: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmem_cache_free(s: *mut kmem_cache, objp: *mut core::ffi::c_void);
}
extern "C" {
    pub fn kmem_cache_free_bulk(s: *mut kmem_cache, size: usize, p: *mut *mut core::ffi::c_void);
}
extern "C" {
    pub fn kmem_cache_alloc_bulk(
        s: *mut kmem_cache,
        flags: gfp_t,
        size: usize,
        p: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __kmalloc_node(
        size: usize,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmem_cache_alloc_node(
        s: *mut kmem_cache,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmalloc_large(size: usize, flags: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kmalloc_large_node(
        size: usize,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __kmalloc_node_track_caller(
        size: usize,
        flags: gfp_t,
        node: core::ffi::c_int,
        caller: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kvmalloc_node(
        size: usize,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kvrealloc(
        p: *const core::ffi::c_void,
        oldsize: usize,
        newsize: usize,
        flags: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kvfree(addr: *const core::ffi::c_void);
}
extern "C" {
    pub fn kvfree_sensitive(addr: *const core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn kmem_cache_size(s: *mut kmem_cache) -> core::ffi::c_uint;
}
extern "C" {
    pub fn kmalloc_size_roundup(size: usize) -> usize;
}
extern "C" {
    pub fn kmem_cache_init_late();
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_clone_range {
    pub src_fd: __s64,
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_offset: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fstrim_range {
    pub start: __u64,
    pub len: __u64,
    pub minlen: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_dedupe_range_info {
    pub dest_fd: __s64,
    pub dest_offset: __u64,
    pub bytes_deduped: __u64,
    pub status: __s32,
    pub reserved: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct file_dedupe_range {
    pub src_offset: __u64,
    pub src_length: __u64,
    pub dest_count: __u16,
    pub reserved1: __u16,
    pub reserved2: __u32,
    pub info: __IncompleteArrayField<file_dedupe_range_info>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct files_stat_struct {
    pub nr_files: core::ffi::c_ulong,
    pub nr_free_files: core::ffi::c_ulong,
    pub max_files: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct inodes_stat_t {
    pub nr_inodes: core::ffi::c_long,
    pub nr_unused: core::ffi::c_long,
    pub dummy: [core::ffi::c_long; 5usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fsxattr {
    pub fsx_xflags: __u32,
    pub fsx_extsize: __u32,
    pub fsx_nextents: __u32,
    pub fsx_projid: __u32,
    pub fsx_cowextsize: __u32,
    pub fsx_pad: [core::ffi::c_uchar; 8usize],
}
pub type __kernel_rwf_t = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_comp_batch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct export_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fiemap_extent_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hd_geometry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kstatfs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fscrypt_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsverity_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsverity_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fileattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iomap_ops {
    _unused: [u8; 0],
}
extern "C" {
    pub fn inode_init();
}
extern "C" {
    pub fn inode_init_early();
}
extern "C" {
    pub fn files_init();
}
extern "C" {
    pub fn files_maxfiles_init();
}
extern "C" {
    pub fn get_max_files() -> core::ffi::c_ulong;
}
extern "C" {
    pub static mut sysctl_nr_open: core::ffi::c_uint;
}
pub type rwf_t = __kernel_rwf_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct buffer_head {
    _unused: [u8; 0],
}
pub type get_block_t = ::core::option::Option<
    unsafe extern "C" fn(
        inode: *mut inode,
        iblock: sector_t,
        bh_result: *mut buffer_head,
        create: core::ffi::c_int,
    ) -> core::ffi::c_int,
>;
pub type dio_iodone_t = ::core::option::Option<
    unsafe extern "C" fn(
        iocb: *mut kiocb,
        offset: loff_t,
        bytes: isize,
        private: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iattr {
    pub ia_valid: core::ffi::c_uint,
    pub ia_mode: umode_t,
    pub __bindgen_anon_1: iattr__bindgen_ty_1,
    pub __bindgen_anon_2: iattr__bindgen_ty_2,
    pub ia_size: loff_t,
    pub ia_atime: timespec64,
    pub ia_mtime: timespec64,
    pub ia_ctime: timespec64,
    pub ia_file: *mut file,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_1 {
    pub ia_uid: kuid_t,
    pub ia_vfsuid: vfsuid_t,
    _bindgen_union_align: u32,
}
impl Default for iattr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iattr__bindgen_ty_2 {
    pub ia_gid: kgid_t,
    pub ia_vfsgid: vfsgid_t,
    _bindgen_union_align: u32,
}
impl Default for iattr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for iattr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_disk_quota {
    pub d_version: __s8,
    pub d_flags: __s8,
    pub d_fieldmask: __u16,
    pub d_id: __u32,
    pub d_blk_hardlimit: __u64,
    pub d_blk_softlimit: __u64,
    pub d_ino_hardlimit: __u64,
    pub d_ino_softlimit: __u64,
    pub d_bcount: __u64,
    pub d_icount: __u64,
    pub d_itimer: __s32,
    pub d_btimer: __s32,
    pub d_iwarns: __u16,
    pub d_bwarns: __u16,
    pub d_itimer_hi: __s8,
    pub d_btimer_hi: __s8,
    pub d_rtbtimer_hi: __s8,
    pub d_padding2: __s8,
    pub d_rtb_hardlimit: __u64,
    pub d_rtb_softlimit: __u64,
    pub d_rtbcount: __u64,
    pub d_rtbtimer: __s32,
    pub d_rtbwarns: __u16,
    pub d_padding3: __s16,
    pub d_padding4: [core::ffi::c_char; 8usize],
}
pub type fs_disk_quota_t = fs_disk_quota;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_qfilestat {
    pub qfs_ino: __u64,
    pub qfs_nblks: __u64,
    pub qfs_nextents: __u32,
}
pub type fs_qfilestat_t = fs_qfilestat;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_quota_stat {
    pub qs_version: __s8,
    pub qs_flags: __u16,
    pub qs_pad: __s8,
    pub qs_uquota: fs_qfilestat_t,
    pub qs_gquota: fs_qfilestat_t,
    pub qs_incoredqs: __u32,
    pub qs_btimelimit: __s32,
    pub qs_itimelimit: __s32,
    pub qs_rtbtimelimit: __s32,
    pub qs_bwarnlimit: __u16,
    pub qs_iwarnlimit: __u16,
}
pub type fs_quota_stat_t = fs_quota_stat;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_qfilestatv {
    pub qfs_ino: __u64,
    pub qfs_nblks: __u64,
    pub qfs_nextents: __u32,
    pub qfs_pad: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_quota_statv {
    pub qs_version: __s8,
    pub qs_pad1: __u8,
    pub qs_flags: __u16,
    pub qs_incoredqs: __u32,
    pub qs_uquota: fs_qfilestatv,
    pub qs_gquota: fs_qfilestatv,
    pub qs_pquota: fs_qfilestatv,
    pub qs_btimelimit: __s32,
    pub qs_itimelimit: __s32,
    pub qs_rtbtimelimit: __s32,
    pub qs_bwarnlimit: __u16,
    pub qs_iwarnlimit: __u16,
    pub qs_rtbwarnlimit: __u16,
    pub qs_pad3: __u16,
    pub qs_pad4: __u32,
    pub qs_pad2: [__u64; 7usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qtree_fmt_operations {
    pub mem2disk_dqblk: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut core::ffi::c_void, dquot: *mut dquot),
    >,
    pub disk2mem_dqblk: ::core::option::Option<
        unsafe extern "C" fn(dquot: *mut dquot, disk: *mut core::ffi::c_void),
    >,
    pub is_id: ::core::option::Option<
        unsafe extern "C" fn(disk: *mut core::ffi::c_void, dquot: *mut dquot) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qtree_mem_dqinfo {
    pub dqi_sb: *mut super_block,
    pub dqi_type: core::ffi::c_int,
    pub dqi_blocks: core::ffi::c_uint,
    pub dqi_free_blk: core::ffi::c_uint,
    pub dqi_free_entry: core::ffi::c_uint,
    pub dqi_blocksize_bits: core::ffi::c_uint,
    pub dqi_entry_size: core::ffi::c_uint,
    pub dqi_usable_bs: core::ffi::c_uint,
    pub dqi_qtree_depth: core::ffi::c_uint,
    pub dqi_ops: *const qtree_fmt_operations,
}
impl Default for qtree_mem_dqinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn qtree_write_dquot(info: *mut qtree_mem_dqinfo, dquot: *mut dquot) -> core::ffi::c_int;
}
extern "C" {
    pub fn qtree_read_dquot(info: *mut qtree_mem_dqinfo, dquot: *mut dquot) -> core::ffi::c_int;
}
extern "C" {
    pub fn qtree_delete_dquot(info: *mut qtree_mem_dqinfo, dquot: *mut dquot) -> core::ffi::c_int;
}
extern "C" {
    pub fn qtree_release_dquot(info: *mut qtree_mem_dqinfo, dquot: *mut dquot) -> core::ffi::c_int;
}
extern "C" {
    pub fn qtree_entry_unused(
        info: *mut qtree_mem_dqinfo,
        disk: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn qtree_get_next_id(info: *mut qtree_mem_dqinfo, qid: *mut kqid) -> core::ffi::c_int;
}
pub type projid_t = __kernel_uid32_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kprojid_t {
    pub val: projid_t,
}
extern "C" {
    pub fn make_kprojid(from: *mut user_namespace, projid: projid_t) -> kprojid_t;
}
extern "C" {
    pub fn from_kprojid(to: *mut user_namespace, projid: kprojid_t) -> projid_t;
}
extern "C" {
    pub fn from_kprojid_munged(to: *mut user_namespace, projid: kprojid_t) -> projid_t;
}
pub const QIF_BLIMITS_B: core::ffi::c_uint = 0;
pub const QIF_SPACE_B: core::ffi::c_uint = 1;
pub const QIF_ILIMITS_B: core::ffi::c_uint = 2;
pub const QIF_INODES_B: core::ffi::c_uint = 3;
pub const QIF_BTIME_B: core::ffi::c_uint = 4;
pub const QIF_ITIME_B: core::ffi::c_uint = 5;
pub type _bindgen_ty_75 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct if_dqblk {
    pub dqb_bhardlimit: __u64,
    pub dqb_bsoftlimit: __u64,
    pub dqb_curspace: __u64,
    pub dqb_ihardlimit: __u64,
    pub dqb_isoftlimit: __u64,
    pub dqb_curinodes: __u64,
    pub dqb_btime: __u64,
    pub dqb_itime: __u64,
    pub dqb_valid: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct if_nextdqblk {
    pub dqb_bhardlimit: __u64,
    pub dqb_bsoftlimit: __u64,
    pub dqb_curspace: __u64,
    pub dqb_ihardlimit: __u64,
    pub dqb_isoftlimit: __u64,
    pub dqb_curinodes: __u64,
    pub dqb_btime: __u64,
    pub dqb_itime: __u64,
    pub dqb_valid: __u32,
    pub dqb_id: __u32,
}
pub const DQF_ROOT_SQUASH_B: core::ffi::c_uint = 0;
pub const DQF_SYS_FILE_B: core::ffi::c_uint = 16;
pub const DQF_PRIVATE: core::ffi::c_uint = 17;
pub type _bindgen_ty_76 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct if_dqinfo {
    pub dqi_bgrace: __u64,
    pub dqi_igrace: __u64,
    pub dqi_flags: __u32,
    pub dqi_valid: __u32,
}
pub const QUOTA_NL_C_UNSPEC: core::ffi::c_uint = 0;
pub const QUOTA_NL_C_WARNING: core::ffi::c_uint = 1;
pub const __QUOTA_NL_C_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_77 = core::ffi::c_uint;
pub const QUOTA_NL_A_UNSPEC: core::ffi::c_uint = 0;
pub const QUOTA_NL_A_QTYPE: core::ffi::c_uint = 1;
pub const QUOTA_NL_A_EXCESS_ID: core::ffi::c_uint = 2;
pub const QUOTA_NL_A_WARNING: core::ffi::c_uint = 3;
pub const QUOTA_NL_A_DEV_MAJOR: core::ffi::c_uint = 4;
pub const QUOTA_NL_A_DEV_MINOR: core::ffi::c_uint = 5;
pub const QUOTA_NL_A_CAUSED_ID: core::ffi::c_uint = 6;
pub const QUOTA_NL_A_PAD: core::ffi::c_uint = 7;
pub const __QUOTA_NL_A_MAX: core::ffi::c_uint = 8;
pub type _bindgen_ty_78 = core::ffi::c_uint;
pub const quota_type_USRQUOTA: quota_type = 0;
pub const quota_type_GRPQUOTA: quota_type = 1;
pub const quota_type_PRJQUOTA: quota_type = 2;
pub type quota_type = core::ffi::c_uint;
pub type qid_t = __kernel_uid32_t;
pub type qsize_t = core::ffi::c_longlong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kqid {
    pub __bindgen_anon_1: kqid__bindgen_ty_1,
    pub type_: quota_type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kqid__bindgen_ty_1 {
    pub uid: kuid_t,
    pub gid: kgid_t,
    pub projid: kprojid_t,
    _bindgen_union_align: u32,
}
impl Default for kqid__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for kqid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn qid_eq(left: kqid, right: kqid) -> bool_;
}
extern "C" {
    pub fn qid_lt(left: kqid, right: kqid) -> bool_;
}
extern "C" {
    pub fn from_kqid(to: *mut user_namespace, qid: kqid) -> qid_t;
}
extern "C" {
    pub fn from_kqid_munged(to: *mut user_namespace, qid: kqid) -> qid_t;
}
extern "C" {
    pub fn qid_valid(qid: kqid) -> bool_;
}
extern "C" {
    pub static mut dq_data_lock: spinlock_t;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mem_dqblk {
    pub dqb_bhardlimit: qsize_t,
    pub dqb_bsoftlimit: qsize_t,
    pub dqb_curspace: qsize_t,
    pub dqb_rsvspace: qsize_t,
    pub dqb_ihardlimit: qsize_t,
    pub dqb_isoftlimit: qsize_t,
    pub dqb_curinodes: qsize_t,
    pub dqb_btime: time64_t,
    pub dqb_itime: time64_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_dqinfo {
    pub dqi_format: *mut quota_format_type,
    pub dqi_fmt_id: core::ffi::c_int,
    pub dqi_dirty_list: list_head,
    pub dqi_flags: core::ffi::c_ulong,
    pub dqi_bgrace: core::ffi::c_uint,
    pub dqi_igrace: core::ffi::c_uint,
    pub dqi_max_spc_limit: qsize_t,
    pub dqi_max_ino_limit: qsize_t,
    pub dqi_priv: *mut core::ffi::c_void,
}
impl Default for mem_dqinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const DQF_INFO_DIRTY_B: core::ffi::c_uint = 17;
pub type _bindgen_ty_79 = core::ffi::c_uint;
extern "C" {
    pub fn mark_info_dirty(sb: *mut super_block, type_: core::ffi::c_int);
}
pub const DQST_LOOKUPS: core::ffi::c_uint = 0;
pub const DQST_DROPS: core::ffi::c_uint = 1;
pub const DQST_READS: core::ffi::c_uint = 2;
pub const DQST_WRITES: core::ffi::c_uint = 3;
pub const DQST_CACHE_HITS: core::ffi::c_uint = 4;
pub const DQST_ALLOC_DQUOTS: core::ffi::c_uint = 5;
pub const DQST_FREE_DQUOTS: core::ffi::c_uint = 6;
pub const DQST_SYNCS: core::ffi::c_uint = 7;
pub const _DQST_DQSTAT_LAST: core::ffi::c_uint = 8;
pub type _bindgen_ty_80 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dqstats {
    pub stat: [core::ffi::c_ulong; 8usize],
    pub counter: [percpu_counter; 8usize],
}
impl Default for dqstats {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut dqstats: dqstats;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dquot {
    pub dq_hash: hlist_node,
    pub dq_inuse: list_head,
    pub dq_free: list_head,
    pub dq_dirty: list_head,
    pub dq_lock: mutex,
    pub dq_dqb_lock: spinlock_t,
    pub dq_count: atomic_t,
    pub dq_sb: *mut super_block,
    pub dq_id: kqid,
    pub dq_off: loff_t,
    pub dq_flags: core::ffi::c_ulong,
    pub dq_dqb: mem_dqblk,
}
impl Default for dquot {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct quota_format_ops {
    pub check_quota_file: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub read_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub write_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub free_file_info: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, type_: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub read_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> core::ffi::c_int>,
    pub commit_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> core::ffi::c_int>,
    pub release_dqblk:
        ::core::option::Option<unsafe extern "C" fn(dquot: *mut dquot) -> core::ffi::c_int>,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dquot_operations {
    pub write_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub alloc_dquot: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> *mut dquot,
    >,
    pub destroy_dquot: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot)>,
    pub acquire_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub release_dquot:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub mark_dirty:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dquot) -> core::ffi::c_int>,
    pub write_info: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub get_reserved_space:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> *mut qsize_t>,
    pub get_projid: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut kprojid_t) -> core::ffi::c_int,
    >,
    pub get_inode_usage: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut qsize_t) -> core::ffi::c_int,
    >,
    pub get_next_id: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, qid: *mut kqid) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_dqblk {
    pub d_fieldmask: core::ffi::c_int,
    pub d_spc_hardlimit: u64_,
    pub d_spc_softlimit: u64_,
    pub d_ino_hardlimit: u64_,
    pub d_ino_softlimit: u64_,
    pub d_space: u64_,
    pub d_ino_count: u64_,
    pub d_ino_timer: s64,
    pub d_spc_timer: s64,
    pub d_ino_warns: core::ffi::c_int,
    pub d_spc_warns: core::ffi::c_int,
    pub d_rt_spc_hardlimit: u64_,
    pub d_rt_spc_softlimit: u64_,
    pub d_rt_space: u64_,
    pub d_rt_spc_timer: s64,
    pub d_rt_spc_warns: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_type_state {
    pub flags: core::ffi::c_uint,
    pub spc_timelimit: core::ffi::c_uint,
    pub ino_timelimit: core::ffi::c_uint,
    pub rt_spc_timelimit: core::ffi::c_uint,
    pub spc_warnlimit: core::ffi::c_uint,
    pub ino_warnlimit: core::ffi::c_uint,
    pub rt_spc_warnlimit: core::ffi::c_uint,
    pub ino: core::ffi::c_ulonglong,
    pub blocks: blkcnt_t,
    pub nextents: blkcnt_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_state {
    pub s_incoredqs: core::ffi::c_uint,
    pub s_state: [qc_type_state; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qc_info {
    pub i_fieldmask: core::ffi::c_int,
    pub i_flags: core::ffi::c_uint,
    pub i_spc_timelimit: core::ffi::c_uint,
    pub i_ino_timelimit: core::ffi::c_uint,
    pub i_rt_spc_timelimit: core::ffi::c_uint,
    pub i_spc_warnlimit: core::ffi::c_uint,
    pub i_ino_warnlimit: core::ffi::c_uint,
    pub i_rt_spc_warnlimit: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct quotactl_ops {
    pub quota_on: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: core::ffi::c_int,
            arg3: core::ffi::c_int,
            arg4: *const path,
        ) -> core::ffi::c_int,
    >,
    pub quota_off: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub quota_enable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub quota_disable: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub quota_sync: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub set_info: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: core::ffi::c_int,
            arg3: *mut qc_info,
        ) -> core::ffi::c_int,
    >,
    pub get_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> core::ffi::c_int,
    >,
    pub get_nextdqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut kqid,
            arg3: *mut qc_dqblk,
        ) -> core::ffi::c_int,
    >,
    pub set_dqblk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: kqid,
            arg3: *mut qc_dqblk,
        ) -> core::ffi::c_int,
    >,
    pub get_state: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut qc_state) -> core::ffi::c_int,
    >,
    pub rm_xquota: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut super_block, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_format_type {
    pub qf_fmt_id: core::ffi::c_int,
    pub qf_ops: *const quota_format_ops,
    pub qf_owner: *mut module,
    pub qf_next: *mut quota_format_type,
}
impl Default for quota_format_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const _DQUOT_USAGE_ENABLED: core::ffi::c_uint = 0;
pub const _DQUOT_LIMITS_ENABLED: core::ffi::c_uint = 1;
pub const _DQUOT_SUSPENDED: core::ffi::c_uint = 2;
pub const _DQUOT_STATE_FLAGS: core::ffi::c_uint = 3;
pub type _bindgen_ty_81 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_info {
    pub flags: core::ffi::c_uint,
    pub dqio_sem: rw_semaphore,
    pub files: [*mut inode; 3usize],
    pub info: [mem_dqinfo; 3usize],
    pub ops: [*const quota_format_ops; 3usize],
}
impl Default for quota_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn register_quota_format(fmt: *mut quota_format_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_quota_format(fmt: *mut quota_format_type);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct quota_module_name {
    pub qm_fmt_id: core::ffi::c_int,
    pub qm_mod_name: *mut core::ffi::c_char,
}
impl Default for quota_module_name {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const positive_aop_returns_AOP_WRITEPAGE_ACTIVATE: positive_aop_returns = 524288;
pub const positive_aop_returns_AOP_TRUNCATED_PAGE: positive_aop_returns = 524289;
pub type positive_aop_returns = core::ffi::c_uint;
pub const rw_hint_WRITE_LIFE_NOT_SET: rw_hint = 0;
pub const rw_hint_WRITE_LIFE_NONE: rw_hint = 1;
pub const rw_hint_WRITE_LIFE_SHORT: rw_hint = 2;
pub const rw_hint_WRITE_LIFE_MEDIUM: rw_hint = 3;
pub const rw_hint_WRITE_LIFE_LONG: rw_hint = 4;
pub const rw_hint_WRITE_LIFE_EXTREME: rw_hint = 5;
pub type rw_hint = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kiocb {
    pub ki_filp: *mut file,
    pub ki_pos: loff_t,
    pub ki_complete:
        ::core::option::Option<unsafe extern "C" fn(iocb: *mut kiocb, ret: core::ffi::c_long)>,
    pub private: *mut core::ffi::c_void,
    pub ki_flags: core::ffi::c_int,
    pub ki_ioprio: u16_,
    pub ki_waitq: *mut wait_page_queue,
}
impl Default for kiocb {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct address_space_operations {
    pub writepage: ::core::option::Option<
        unsafe extern "C" fn(page: *mut page, wbc: *mut writeback_control) -> core::ffi::c_int,
    >,
    pub read_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file, arg2: *mut folio) -> core::ffi::c_int,
    >,
    pub writepages: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            arg2: *mut writeback_control,
        ) -> core::ffi::c_int,
    >,
    pub dirty_folio: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut folio) -> bool_,
    >,
    pub readahead: ::core::option::Option<unsafe extern "C" fn(arg1: *mut readahead_control)>,
    pub write_begin: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: core::ffi::c_uint,
            pagep: *mut *mut page,
            fsdata: *mut *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub write_end: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            mapping: *mut address_space,
            pos: loff_t,
            len: core::ffi::c_uint,
            copied: core::ffi::c_uint,
            page: *mut page,
            fsdata: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub bmap: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: sector_t) -> sector_t,
    >,
    pub invalidate_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, offset: usize, len: usize)>,
    pub release_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio, arg2: gfp_t) -> bool_>,
    pub free_folio: ::core::option::Option<unsafe extern "C" fn(folio: *mut folio)>,
    pub direct_IO: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut kiocb, iter: *mut iov_iter) -> isize,
    >,
    pub migrate_folio: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut address_space,
            dst: *mut folio,
            src: *mut folio,
            arg2: migrate_mode,
        ) -> core::ffi::c_int,
    >,
    pub launder_folio:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut folio) -> core::ffi::c_int>,
    pub is_partially_uptodate: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, from: usize, count: usize) -> bool_,
    >,
    pub is_dirty_writeback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut folio, dirty: *mut bool_, wb: *mut bool_),
    >,
    pub error_remove_page: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut address_space, arg2: *mut page) -> core::ffi::c_int,
    >,
    pub swap_activate: ::core::option::Option<
        unsafe extern "C" fn(
            sis: *mut swap_info_struct,
            file: *mut file,
            span: *mut sector_t,
        ) -> core::ffi::c_int,
    >,
    pub swap_deactivate: ::core::option::Option<unsafe extern "C" fn(file: *mut file)>,
    pub swap_rw: ::core::option::Option<
        unsafe extern "C" fn(iocb: *mut kiocb, iter: *mut iov_iter) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub static empty_aops: address_space_operations;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct address_space {
    pub host: *mut inode,
    pub i_pages: xarray,
    pub invalidate_lock: rw_semaphore,
    pub gfp_mask: gfp_t,
    pub i_mmap_writable: atomic_t,
    pub i_mmap: rb_root_cached,
    pub i_mmap_rwsem: rw_semaphore,
    pub nrpages: core::ffi::c_ulong,
    pub writeback_index: core::ffi::c_ulong,
    pub a_ops: *const address_space_operations,
    pub flags: core::ffi::c_ulong,
    pub wb_err: errseq_t,
    pub private_lock: spinlock_t,
    pub private_list: list_head,
    pub private_data: *mut core::ffi::c_void,
}
impl Default for address_space {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct posix_acl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fsnotify_mark_connector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inode {
    pub i_mode: umode_t,
    pub i_opflags: core::ffi::c_ushort,
    pub i_uid: kuid_t,
    pub i_gid: kgid_t,
    pub i_flags: core::ffi::c_uint,
    pub i_acl: *mut posix_acl,
    pub i_default_acl: *mut posix_acl,
    pub i_op: *const inode_operations,
    pub i_sb: *mut super_block,
    pub i_mapping: *mut address_space,
    pub i_security: *mut core::ffi::c_void,
    pub i_ino: core::ffi::c_ulong,
    pub __bindgen_anon_1: inode__bindgen_ty_1,
    pub i_rdev: dev_t,
    pub i_size: loff_t,
    pub i_atime: timespec64,
    pub i_mtime: timespec64,
    pub i_ctime: timespec64,
    pub i_lock: spinlock_t,
    pub i_bytes: core::ffi::c_ushort,
    pub i_blkbits: u8_,
    pub i_write_hint: u8_,
    pub i_blocks: blkcnt_t,
    pub i_state: core::ffi::c_ulong,
    pub i_rwsem: rw_semaphore,
    pub dirtied_when: core::ffi::c_ulong,
    pub dirtied_time_when: core::ffi::c_ulong,
    pub i_hash: hlist_node,
    pub i_io_list: list_head,
    pub i_lru: list_head,
    pub i_sb_list: list_head,
    pub i_wb_list: list_head,
    pub __bindgen_anon_2: inode__bindgen_ty_2,
    pub i_version: atomic64_t,
    pub i_sequence: atomic64_t,
    pub i_count: atomic_t,
    pub i_dio_count: atomic_t,
    pub i_writecount: atomic_t,
    pub i_readcount: atomic_t,
    pub __bindgen_anon_3: inode__bindgen_ty_3,
    pub i_flctx: *mut file_lock_context,
    pub i_data: address_space,
    pub i_devices: list_head,
    pub __bindgen_anon_4: inode__bindgen_ty_4,
    pub i_generation: __u32,
    pub i_fsnotify_mask: __u32,
    pub i_fsnotify_marks: *mut fsnotify_mark_connector,
    pub i_private: *mut core::ffi::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_1 {
    pub i_nlink: core::ffi::c_uint,
    pub __i_nlink: core::ffi::c_uint,
    _bindgen_union_align: u32,
}
impl Default for inode__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_2 {
    pub i_dentry: hlist_head,
    pub i_rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for inode__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_3 {
    pub i_fop: *const file_operations,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    _bindgen_union_align: u64,
}
impl Default for inode__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inode__bindgen_ty_4 {
    pub i_pipe: *mut pipe_inode_info,
    pub i_cdev: *mut cdev,
    pub i_link: *mut core::ffi::c_char,
    pub i_dir_seq: core::ffi::c_uint,
    _bindgen_union_align: u64,
}
impl Default for inode__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for inode {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn timestamp_truncate(t: timespec64, inode: *mut inode) -> timespec64;
}
pub const inode_i_mutex_lock_class_I_MUTEX_NORMAL: inode_i_mutex_lock_class = 0;
pub const inode_i_mutex_lock_class_I_MUTEX_PARENT: inode_i_mutex_lock_class = 1;
pub const inode_i_mutex_lock_class_I_MUTEX_CHILD: inode_i_mutex_lock_class = 2;
pub const inode_i_mutex_lock_class_I_MUTEX_XATTR: inode_i_mutex_lock_class = 3;
pub const inode_i_mutex_lock_class_I_MUTEX_NONDIR2: inode_i_mutex_lock_class = 4;
pub const inode_i_mutex_lock_class_I_MUTEX_PARENT2: inode_i_mutex_lock_class = 5;
pub type inode_i_mutex_lock_class = core::ffi::c_uint;
extern "C" {
    pub fn lock_two_nondirectories(arg1: *mut inode, arg2: *mut inode);
}
extern "C" {
    pub fn unlock_two_nondirectories(arg1: *mut inode, arg2: *mut inode);
}
extern "C" {
    pub fn filemap_invalidate_lock_two(mapping1: *mut address_space, mapping2: *mut address_space);
}
extern "C" {
    pub fn filemap_invalidate_unlock_two(
        mapping1: *mut address_space,
        mapping2: *mut address_space,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fown_struct {
    pub lock: rwlock_t,
    pub pid: *mut pid,
    pub pid_type: pid_type,
    pub uid: kuid_t,
    pub euid: kuid_t,
    pub signum: core::ffi::c_int,
}
impl Default for fown_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_ra_state {
    pub start: core::ffi::c_ulong,
    pub size: core::ffi::c_uint,
    pub async_size: core::ffi::c_uint,
    pub ra_pages: core::ffi::c_uint,
    pub mmap_miss: core::ffi::c_uint,
    pub prev_pos: loff_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file {
    pub __bindgen_anon_1: file__bindgen_ty_1,
    pub f_path: path,
    pub f_inode: *mut inode,
    pub f_op: *const file_operations,
    pub f_lock: spinlock_t,
    pub f_count: atomic_long_t,
    pub f_flags: core::ffi::c_uint,
    pub f_mode: fmode_t,
    pub f_pos_lock: mutex,
    pub f_pos: loff_t,
    pub f_owner: fown_struct,
    pub f_cred: *const cred,
    pub f_ra: file_ra_state,
    pub f_version: u64_,
    pub f_security: *mut core::ffi::c_void,
    pub private_data: *mut core::ffi::c_void,
    pub f_ep: *mut hlist_head,
    pub f_mapping: *mut address_space,
    pub f_wb_err: errseq_t,
    pub f_sb_err: errseq_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file__bindgen_ty_1 {
    pub f_llist: llist_node,
    pub f_rcuhead: callback_head,
    pub f_iocb_flags: core::ffi::c_uint,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for file__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct file_handle {
    pub handle_bytes: __u32,
    pub handle_type: core::ffi::c_int,
    pub f_handle: __IncompleteArrayField<core::ffi::c_uchar>,
}
pub type fl_owner_t = *mut core::ffi::c_void;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct file_lock_operations {
    pub fl_copy_lock:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut file_lock)>,
    pub fl_release_private: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lock_manager_operations {
    pub lm_mod_owner: *mut core::ffi::c_void,
    pub lm_get_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t) -> fl_owner_t>,
    pub lm_put_owner: ::core::option::Option<unsafe extern "C" fn(arg1: fl_owner_t)>,
    pub lm_notify: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock)>,
    pub lm_grant: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub lm_break: ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
    pub lm_change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file_lock,
            arg2: core::ffi::c_int,
            arg3: *mut list_head,
        ) -> core::ffi::c_int,
    >,
    pub lm_setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut file_lock, arg2: *mut *mut core::ffi::c_void),
    >,
    pub lm_breaker_owns_lease:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut file_lock) -> bool_>,
    pub lm_lock_expirable:
        ::core::option::Option<unsafe extern "C" fn(cfl: *mut file_lock) -> bool_>,
    pub lm_expire_lock: ::core::option::Option<unsafe extern "C" fn()>,
}
impl Default for lock_manager_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lock_manager {
    pub list: list_head,
    pub block_opens: bool_,
}
impl Default for lock_manager {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn locks_start_grace(arg1: *mut net, arg2: *mut lock_manager);
}
extern "C" {
    pub fn locks_end_grace(arg1: *mut lock_manager);
}
extern "C" {
    pub fn locks_in_grace(arg1: *mut net) -> bool_;
}
extern "C" {
    pub fn opens_in_grace(arg1: *mut net) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nlm_lockowner {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs_lock_info {
    pub state: u32_,
    pub owner: *mut nlm_lockowner,
    pub list: list_head,
}
impl Default for nfs_lock_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs4_lock_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nfs4_lock_info {
    pub owner: *mut nfs4_lock_state,
}
impl Default for nfs4_lock_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock {
    pub fl_blocker: *mut file_lock,
    pub fl_list: list_head,
    pub fl_link: hlist_node,
    pub fl_blocked_requests: list_head,
    pub fl_blocked_member: list_head,
    pub fl_owner: fl_owner_t,
    pub fl_flags: core::ffi::c_uint,
    pub fl_type: core::ffi::c_uchar,
    pub fl_pid: core::ffi::c_uint,
    pub fl_link_cpu: core::ffi::c_int,
    pub fl_wait: wait_queue_head_t,
    pub fl_file: *mut file,
    pub fl_start: loff_t,
    pub fl_end: loff_t,
    pub fl_fasync: *mut fasync_struct,
    pub fl_break_time: core::ffi::c_ulong,
    pub fl_downgrade_time: core::ffi::c_ulong,
    pub fl_ops: *const file_lock_operations,
    pub fl_lmops: *const lock_manager_operations,
    pub fl_u: file_lock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union file_lock__bindgen_ty_1 {
    pub nfs_fl: nfs_lock_info,
    pub nfs4_fl: nfs4_lock_info,
    pub afs: file_lock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock__bindgen_ty_1__bindgen_ty_1 {
    pub link: list_head,
    pub state: core::ffi::c_int,
    pub debug_id: core::ffi::c_uint,
}
impl Default for file_lock__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for file_lock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for file_lock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct file_lock_context {
    pub flc_lock: spinlock_t,
    pub flc_flock: list_head,
    pub flc_posix: list_head,
    pub flc_lease: list_head,
}
impl Default for file_lock_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn send_sigio(fown: *mut fown_struct, fd: core::ffi::c_int, band: core::ffi::c_int);
}
extern "C" {
    pub fn fcntl_getlk(
        arg1: *mut file,
        arg2: core::ffi::c_uint,
        arg3: *mut flock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fcntl_setlk(
        arg1: core::ffi::c_uint,
        arg2: *mut file,
        arg3: core::ffi::c_uint,
        arg4: *mut flock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fcntl_setlease(
        fd: core::ffi::c_uint,
        filp: *mut file,
        arg: core::ffi::c_long,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fcntl_getlease(filp: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn locks_free_lock_context(inode: *mut inode);
}
extern "C" {
    pub fn locks_free_lock(fl: *mut file_lock);
}
extern "C" {
    pub fn locks_init_lock(arg1: *mut file_lock);
}
extern "C" {
    pub fn locks_alloc_lock() -> *mut file_lock;
}
extern "C" {
    pub fn locks_copy_lock(arg1: *mut file_lock, arg2: *mut file_lock);
}
extern "C" {
    pub fn locks_copy_conflock(arg1: *mut file_lock, arg2: *mut file_lock);
}
extern "C" {
    pub fn locks_remove_posix(arg1: *mut file, arg2: fl_owner_t);
}
extern "C" {
    pub fn locks_remove_file(arg1: *mut file);
}
extern "C" {
    pub fn locks_release_private(arg1: *mut file_lock);
}
extern "C" {
    pub fn posix_test_lock(arg1: *mut file, arg2: *mut file_lock);
}
extern "C" {
    pub fn posix_lock_file(
        arg1: *mut file,
        arg2: *mut file_lock,
        arg3: *mut file_lock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn locks_delete_block(arg1: *mut file_lock) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_test_lock(arg1: *mut file, arg2: *mut file_lock) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_lock_file(
        arg1: *mut file,
        arg2: core::ffi::c_uint,
        arg3: *mut file_lock,
        arg4: *mut file_lock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_cancel_lock(filp: *mut file, fl: *mut file_lock) -> core::ffi::c_int;
}
extern "C" {
    pub fn locks_lock_inode_wait(inode: *mut inode, fl: *mut file_lock) -> core::ffi::c_int;
}
extern "C" {
    pub fn __break_lease(
        inode: *mut inode,
        flags: core::ffi::c_uint,
        type_: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lease_get_mtime(arg1: *mut inode, time: *mut timespec64);
}
extern "C" {
    pub fn generic_setlease(
        arg1: *mut file,
        arg2: core::ffi::c_long,
        arg3: *mut *mut file_lock,
        priv_: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_setlease(
        arg1: *mut file,
        arg2: core::ffi::c_long,
        arg3: *mut *mut file_lock,
        arg4: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lease_modify(
        arg1: *mut file_lock,
        arg2: core::ffi::c_int,
        arg3: *mut list_head,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lease_register_notifier(arg1: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn lease_unregister_notifier(arg1: *mut notifier_block);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct files_struct {
    _unused: [u8; 0],
}
extern "C" {
    pub fn show_fd_locks(f: *mut seq_file, filp: *mut file, files: *mut files_struct);
}
extern "C" {
    pub fn locks_owner_has_blockers(flctx: *mut file_lock_context, owner: fl_owner_t) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fasync_struct {
    pub fa_lock: rwlock_t,
    pub magic: core::ffi::c_int,
    pub fa_fd: core::ffi::c_int,
    pub fa_next: *mut fasync_struct,
    pub fa_file: *mut file,
    pub fa_rcu: callback_head,
}
impl Default for fasync_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn fasync_helper(
        arg1: core::ffi::c_int,
        arg2: *mut file,
        arg3: core::ffi::c_int,
        arg4: *mut *mut fasync_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fasync_insert_entry(
        arg1: core::ffi::c_int,
        arg2: *mut file,
        arg3: *mut *mut fasync_struct,
        arg4: *mut fasync_struct,
    ) -> *mut fasync_struct;
}
extern "C" {
    pub fn fasync_remove_entry(arg1: *mut file, arg2: *mut *mut fasync_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn fasync_alloc() -> *mut fasync_struct;
}
extern "C" {
    pub fn fasync_free(arg1: *mut fasync_struct);
}
extern "C" {
    pub fn kill_fasync(
        arg1: *mut *mut fasync_struct,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __f_setown(filp: *mut file, arg1: *mut pid, arg2: pid_type, force: core::ffi::c_int);
}
extern "C" {
    pub fn f_setown(
        filp: *mut file,
        arg: core::ffi::c_ulong,
        force: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn f_delown(filp: *mut file);
}
extern "C" {
    pub fn f_getown(filp: *mut file) -> pid_t;
}
extern "C" {
    pub fn send_sigurg(fown: *mut fown_struct) -> core::ffi::c_int;
}
pub const SB_UNFROZEN: core::ffi::c_uint = 0;
pub const SB_FREEZE_WRITE: core::ffi::c_uint = 1;
pub const SB_FREEZE_PAGEFAULT: core::ffi::c_uint = 2;
pub const SB_FREEZE_FS: core::ffi::c_uint = 3;
pub const SB_FREEZE_COMPLETE: core::ffi::c_uint = 4;
pub type _bindgen_ty_82 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sb_writers {
    pub frozen: core::ffi::c_int,
    pub wait_unfrozen: wait_queue_head_t,
    pub rw_sem: [percpu_rw_semaphore; 3usize],
}
impl Default for sb_writers {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct super_block {
    pub s_list: list_head,
    pub s_dev: dev_t,
    pub s_blocksize_bits: core::ffi::c_uchar,
    pub s_blocksize: core::ffi::c_ulong,
    pub s_maxbytes: loff_t,
    pub s_type: *mut file_system_type,
    pub s_op: *const super_operations,
    pub dq_op: *const dquot_operations,
    pub s_qcop: *const quotactl_ops,
    pub s_export_op: *const export_operations,
    pub s_flags: core::ffi::c_ulong,
    pub s_iflags: core::ffi::c_ulong,
    pub s_magic: core::ffi::c_ulong,
    pub s_root: *mut dentry,
    pub s_umount: rw_semaphore,
    pub s_count: core::ffi::c_int,
    pub s_active: atomic_t,
    pub s_security: *mut core::ffi::c_void,
    pub s_xattr: *mut *mut xattr_handler,
    pub s_roots: hlist_bl_head,
    pub s_mounts: list_head,
    pub s_bdev: *mut block_device,
    pub s_bdi: *mut backing_dev_info,
    pub s_mtd: *mut mtd_info,
    pub s_instances: hlist_node,
    pub s_quota_types: core::ffi::c_uint,
    pub s_dquot: quota_info,
    pub s_writers: sb_writers,
    pub s_fs_info: *mut core::ffi::c_void,
    pub s_time_gran: u32_,
    pub s_time_min: time64_t,
    pub s_time_max: time64_t,
    pub s_fsnotify_mask: __u32,
    pub s_fsnotify_marks: *mut fsnotify_mark_connector,
    pub s_id: [core::ffi::c_char; 32usize],
    pub s_uuid: uuid_t,
    pub s_max_links: core::ffi::c_uint,
    pub s_mode: fmode_t,
    pub s_vfs_rename_mutex: mutex,
    pub s_subtype: *const core::ffi::c_char,
    pub s_d_op: *const dentry_operations,
    pub s_shrink: shrinker,
    pub s_remove_count: atomic_long_t,
    pub s_fsnotify_connectors: atomic_long_t,
    pub s_readonly_remount: core::ffi::c_int,
    pub s_wb_err: errseq_t,
    pub s_dio_done_wq: *mut workqueue_struct,
    pub s_pins: hlist_head,
    pub s_user_ns: *mut user_namespace,
    pub s_dentry_lru: list_lru,
    pub s_inode_lru: list_lru,
    pub rcu: callback_head,
    pub destroy_work: work_struct,
    pub s_sync_lock: mutex,
    pub s_stack_depth: core::ffi::c_int,
    pub __bindgen_padding_0: [u64; 6usize],
    pub s_inode_list_lock: spinlock_t,
    pub s_inodes: list_head,
    pub s_inode_wblist_lock: spinlock_t,
    pub s_inodes_wb: list_head,
}
impl Default for super_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn current_time(inode: *mut inode) -> timespec64;
}
extern "C" {
    pub fn inode_owner_or_capable(mnt_userns: *mut user_namespace, inode: *const inode) -> bool_;
}
extern "C" {
    pub fn vfs_create(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: umode_t,
        arg5: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_mkdir(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: umode_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_mknod(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: umode_t,
        arg5: dev_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_symlink(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_link(
        arg1: *mut dentry,
        arg2: *mut user_namespace,
        arg3: *mut inode,
        arg4: *mut dentry,
        arg5: *mut *mut inode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_rmdir(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_unlink(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: *mut *mut inode,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct renamedata {
    pub old_mnt_userns: *mut user_namespace,
    pub old_dir: *mut inode,
    pub old_dentry: *mut dentry,
    pub new_mnt_userns: *mut user_namespace,
    pub new_dir: *mut inode,
    pub new_dentry: *mut dentry,
    pub delegated_inode: *mut *mut inode,
    pub flags: core::ffi::c_uint,
}
impl Default for renamedata {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn vfs_rename(arg1: *mut renamedata) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_tmpfile_open(
        mnt_userns: *mut user_namespace,
        parentpath: *const path,
        mode: umode_t,
        open_flag: core::ffi::c_int,
        cred: *const cred,
    ) -> *mut file;
}
extern "C" {
    pub fn vfs_mkobj(
        arg1: *mut dentry,
        arg2: umode_t,
        f: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut dentry,
                arg2: umode_t,
                arg3: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg3: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fchown(file: *mut file, user: uid_t, group: gid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fchmod(file: *mut file, mode: umode_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_utimes(path: *const path, times: *mut timespec64) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_ioctl(
        file: *mut file,
        cmd: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_ptr_ioctl(
        file: *mut file,
        cmd: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn inode_init_owner(
        mnt_userns: *mut user_namespace,
        inode: *mut inode,
        dir: *const inode,
        mode: umode_t,
    );
}
extern "C" {
    pub fn may_open_dev(path: *const path) -> bool_;
}
extern "C" {
    pub fn mode_strip_sgid(
        mnt_userns: *mut user_namespace,
        dir: *const inode,
        mode: umode_t,
    ) -> umode_t;
}
pub type filldir_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut dir_context,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_int,
        arg4: loff_t,
        arg5: u64_,
        arg6: core::ffi::c_uint,
    ) -> bool_,
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dir_context {
    pub actor: filldir_t,
    pub pos: loff_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct io_uring_cmd {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct inode_operations {
    pub lookup: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: core::ffi::c_uint,
        ) -> *mut dentry,
    >,
    pub get_link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut delayed_call,
        ) -> *const core::ffi::c_char,
    >,
    pub permission: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub get_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: core::ffi::c_int,
            arg3: bool_,
        ) -> *mut posix_acl,
    >,
    pub readlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut core::ffi::c_char,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: bool_,
        ) -> core::ffi::c_int,
    >,
    pub link: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut dentry,
            arg2: *mut inode,
            arg3: *mut dentry,
        ) -> core::ffi::c_int,
    >,
    pub unlink: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub symlink: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *const core::ffi::c_char,
        ) -> core::ffi::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
        ) -> core::ffi::c_int,
    >,
    pub rmdir: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub mknod: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: umode_t,
            arg5: dev_t,
        ) -> core::ffi::c_int,
    >,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut dentry,
            arg4: *mut inode,
            arg5: *mut dentry,
            arg6: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub setattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut dentry,
            arg3: *mut iattr,
        ) -> core::ffi::c_int,
    >,
    pub getattr: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *const path,
            arg3: *mut kstat,
            arg4: u32_,
            arg5: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub listxattr: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut core::ffi::c_char, arg3: usize) -> isize,
    >,
    pub fiemap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut fiemap_extent_info,
            start: u64_,
            len: u64_,
        ) -> core::ffi::c_int,
    >,
    pub update_time: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut timespec64,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub atomic_open: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut inode,
            arg2: *mut dentry,
            arg3: *mut file,
            open_flag: core::ffi::c_uint,
            create_mode: umode_t,
        ) -> core::ffi::c_int,
    >,
    pub tmpfile: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut file,
            arg4: umode_t,
        ) -> core::ffi::c_int,
    >,
    pub set_acl: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut user_namespace,
            arg2: *mut inode,
            arg3: *mut posix_acl,
            arg4: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub fileattr_set: ::core::option::Option<
        unsafe extern "C" fn(
            mnt_userns: *mut user_namespace,
            dentry: *mut dentry,
            fa: *mut fileattr,
        ) -> core::ffi::c_int,
    >,
    pub fileattr_get: ::core::option::Option<
        unsafe extern "C" fn(dentry: *mut dentry, fa: *mut fileattr) -> core::ffi::c_int,
    >,
}
impl Default for inode_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn vfs_read(
        arg1: *mut file,
        arg2: *mut core::ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn vfs_write(
        arg1: *mut file,
        arg2: *const core::ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn vfs_copy_file_range(
        arg1: *mut file,
        arg2: loff_t,
        arg3: *mut file,
        arg4: loff_t,
        arg5: usize,
        arg6: core::ffi::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn generic_copy_file_range(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        len: usize,
        flags: core::ffi::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn __generic_remap_file_range_prep(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        len: *mut loff_t,
        remap_flags: core::ffi::c_uint,
        dax_read_ops: *const iomap_ops,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_remap_file_range_prep(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        count: *mut loff_t,
        remap_flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_clone_file_range(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        len: loff_t,
        remap_flags: core::ffi::c_uint,
    ) -> loff_t;
}
extern "C" {
    pub fn vfs_clone_file_range(
        file_in: *mut file,
        pos_in: loff_t,
        file_out: *mut file,
        pos_out: loff_t,
        len: loff_t,
        remap_flags: core::ffi::c_uint,
    ) -> loff_t;
}
extern "C" {
    pub fn vfs_dedupe_file_range(file: *mut file, same: *mut file_dedupe_range)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_dedupe_file_range_one(
        src_file: *mut file,
        src_pos: loff_t,
        dst_file: *mut file,
        dst_pos: loff_t,
        len: loff_t,
        remap_flags: core::ffi::c_uint,
    ) -> loff_t;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct super_operations {
    pub alloc_inode:
        ::core::option::Option<unsafe extern "C" fn(sb: *mut super_block) -> *mut inode>,
    pub destroy_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub free_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub dirty_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode, flags: core::ffi::c_int)>,
    pub write_inode: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut inode, wbc: *mut writeback_control) -> core::ffi::c_int,
    >,
    pub drop_inode:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode) -> core::ffi::c_int>,
    pub evict_inode: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inode)>,
    pub put_super: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub sync_fs: ::core::option::Option<
        unsafe extern "C" fn(sb: *mut super_block, wait: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub freeze_super:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> core::ffi::c_int>,
    pub freeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> core::ffi::c_int>,
    pub thaw_super:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> core::ffi::c_int>,
    pub unfreeze_fs:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block) -> core::ffi::c_int>,
    pub statfs: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dentry, arg2: *mut kstatfs) -> core::ffi::c_int,
    >,
    pub remount_fs: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut core::ffi::c_int,
            arg3: *mut core::ffi::c_char,
        ) -> core::ffi::c_int,
    >,
    pub umount_begin: ::core::option::Option<unsafe extern "C" fn(arg1: *mut super_block)>,
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub show_devname: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub show_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut seq_file, arg2: *mut dentry) -> core::ffi::c_int,
    >,
    pub nr_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> core::ffi::c_long,
    >,
    pub free_cached_objects: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut super_block,
            arg2: *mut shrink_control,
        ) -> core::ffi::c_long,
    >,
}
extern "C" {
    pub fn __mark_inode_dirty(arg1: *mut inode, arg2: core::ffi::c_int);
}
extern "C" {
    pub fn inc_nlink(inode: *mut inode);
}
extern "C" {
    pub fn drop_nlink(inode: *mut inode);
}
extern "C" {
    pub fn clear_nlink(inode: *mut inode);
}
extern "C" {
    pub fn set_nlink(inode: *mut inode, nlink: core::ffi::c_uint);
}
pub const file_time_flags_S_ATIME: file_time_flags = 1;
pub const file_time_flags_S_MTIME: file_time_flags = 2;
pub const file_time_flags_S_CTIME: file_time_flags = 4;
pub const file_time_flags_S_VERSION: file_time_flags = 8;
pub type file_time_flags = core::ffi::c_uint;
extern "C" {
    pub fn atime_needs_update(arg1: *const path, arg2: *mut inode) -> bool_;
}
extern "C" {
    pub fn touch_atime(arg1: *const path);
}
extern "C" {
    pub fn inode_update_time(
        inode: *mut inode,
        time: *mut timespec64,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn file_modified(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn kiocb_modified(iocb: *mut kiocb) -> core::ffi::c_int;
}
extern "C" {
    pub fn sync_inode_metadata(inode: *mut inode, wait: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn mount_bdev(
        fs_type: *mut file_system_type,
        flags: core::ffi::c_int,
        dev_name: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut core::ffi::c_void,
                arg3: core::ffi::c_int,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut dentry;
}
extern "C" {
    pub fn mount_single(
        fs_type: *mut file_system_type,
        flags: core::ffi::c_int,
        data: *mut core::ffi::c_void,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut core::ffi::c_void,
                arg3: core::ffi::c_int,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut dentry;
}
extern "C" {
    pub fn mount_nodev(
        fs_type: *mut file_system_type,
        flags: core::ffi::c_int,
        data: *mut core::ffi::c_void,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut core::ffi::c_void,
                arg3: core::ffi::c_int,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut dentry;
}
extern "C" {
    pub fn mount_subtree(mnt: *mut vfsmount, path: *const core::ffi::c_char) -> *mut dentry;
}
extern "C" {
    pub fn retire_super(sb: *mut super_block);
}
extern "C" {
    pub fn generic_shutdown_super(sb: *mut super_block);
}
extern "C" {
    pub fn kill_block_super(sb: *mut super_block);
}
extern "C" {
    pub fn kill_anon_super(sb: *mut super_block);
}
extern "C" {
    pub fn kill_litter_super(sb: *mut super_block);
}
extern "C" {
    pub fn deactivate_super(sb: *mut super_block);
}
extern "C" {
    pub fn deactivate_locked_super(sb: *mut super_block);
}
extern "C" {
    pub fn set_anon_super(s: *mut super_block, data: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_anon_super_fc(s: *mut super_block, fc: *mut fs_context) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_anon_bdev(arg1: *mut dev_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn free_anon_bdev(arg1: dev_t);
}
extern "C" {
    pub fn sget_fc(
        fc: *mut fs_context,
        test: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut fs_context) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut fs_context) -> core::ffi::c_int,
        >,
    ) -> *mut super_block;
}
extern "C" {
    pub fn sget(
        type_: *mut file_system_type,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut super_block,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        flags: core::ffi::c_int,
        data: *mut core::ffi::c_void,
    ) -> *mut super_block;
}
extern "C" {
    pub fn register_filesystem(arg1: *mut file_system_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_filesystem(arg1: *mut file_system_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_statfs(arg1: *const path, arg2: *mut kstatfs) -> core::ffi::c_int;
}
extern "C" {
    pub fn user_statfs(arg1: *const core::ffi::c_char, arg2: *mut kstatfs) -> core::ffi::c_int;
}
extern "C" {
    pub fn fd_statfs(arg1: core::ffi::c_int, arg2: *mut kstatfs) -> core::ffi::c_int;
}
extern "C" {
    pub fn freeze_super(super_: *mut super_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn thaw_super(super_: *mut super_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn super_setup_bdi_name(
        sb: *mut super_block,
        fmt: *mut core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn super_setup_bdi(sb: *mut super_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn current_umask() -> core::ffi::c_int;
}
extern "C" {
    pub fn ihold(inode: *mut inode);
}
extern "C" {
    pub fn iput(arg1: *mut inode);
}
extern "C" {
    pub fn generic_update_time(
        arg1: *mut inode,
        arg2: *mut timespec64,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut fs_kobj: *mut kobject;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_names {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct filename {
    pub name: *const core::ffi::c_char,
    pub uptr: *const core::ffi::c_char,
    pub refcnt: core::ffi::c_int,
    pub aname: *mut audit_names,
    pub iname: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for filename {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn vfs_truncate(arg1: *const path, arg2: loff_t) -> core::ffi::c_long;
}
extern "C" {
    pub fn do_truncate(
        arg1: *mut user_namespace,
        arg2: *mut dentry,
        start: loff_t,
        time_attrs: core::ffi::c_uint,
        filp: *mut file,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fallocate(
        file: *mut file,
        mode: core::ffi::c_int,
        offset: loff_t,
        len: loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_sys_open(
        dfd: core::ffi::c_int,
        filename: *const core::ffi::c_char,
        flags: core::ffi::c_int,
        mode: umode_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn file_open_name(arg1: *mut filename, arg2: core::ffi::c_int, arg3: umode_t) -> *mut file;
}
extern "C" {
    pub fn filp_open(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: umode_t,
    ) -> *mut file;
}
extern "C" {
    pub fn file_open_root(
        arg1: *const path,
        arg2: *const core::ffi::c_char,
        arg3: core::ffi::c_int,
        arg4: umode_t,
    ) -> *mut file;
}
extern "C" {
    pub fn dentry_open(arg1: *const path, arg2: core::ffi::c_int, arg3: *const cred) -> *mut file;
}
extern "C" {
    pub fn dentry_create(
        path: *const path,
        flags: core::ffi::c_int,
        mode: umode_t,
        cred: *const cred,
    ) -> *mut file;
}
extern "C" {
    pub fn open_with_fake_path(
        arg1: *const path,
        arg2: core::ffi::c_int,
        arg3: *mut inode,
        arg4: *const cred,
    ) -> *mut file;
}
extern "C" {
    pub fn filp_close(arg1: *mut file, id: fl_owner_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn getname_flags(
        arg1: *const core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_int,
    ) -> *mut filename;
}
extern "C" {
    pub fn getname_uflags(arg1: *const core::ffi::c_char, arg2: core::ffi::c_int) -> *mut filename;
}
extern "C" {
    pub fn getname(arg1: *const core::ffi::c_char) -> *mut filename;
}
extern "C" {
    pub fn getname_kernel(arg1: *const core::ffi::c_char) -> *mut filename;
}
extern "C" {
    pub fn putname(name: *mut filename);
}
extern "C" {
    pub fn finish_open(
        file: *mut file,
        dentry: *mut dentry,
        open: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn finish_no_open(file: *mut file, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_caches_init_early();
}
extern "C" {
    pub fn vfs_caches_init();
}
extern "C" {
    pub static mut names_cachep: *mut kmem_cache;
}
extern "C" {
    pub static mut blockdev_superblock: *mut super_block;
}
extern "C" {
    pub fn emergency_thaw_all();
}
extern "C" {
    pub fn sync_filesystem(arg1: *mut super_block) -> core::ffi::c_int;
}
extern "C" {
    pub static def_blk_fops: file_operations;
}
extern "C" {
    pub static def_chr_fops: file_operations;
}
extern "C" {
    pub fn alloc_chrdev_region(
        arg1: *mut dev_t,
        arg2: core::ffi::c_uint,
        arg3: core::ffi::c_uint,
        arg4: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn register_chrdev_region(
        arg1: dev_t,
        arg2: core::ffi::c_uint,
        arg3: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __register_chrdev(
        major: core::ffi::c_uint,
        baseminor: core::ffi::c_uint,
        count: core::ffi::c_uint,
        name: *const core::ffi::c_char,
        fops: *const file_operations,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __unregister_chrdev(
        major: core::ffi::c_uint,
        baseminor: core::ffi::c_uint,
        count: core::ffi::c_uint,
        name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn unregister_chrdev_region(arg1: dev_t, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn chrdev_show(arg1: *mut seq_file, arg2: off_t);
}
extern "C" {
    pub fn init_special_inode(arg1: *mut inode, arg2: umode_t, arg3: dev_t);
}
extern "C" {
    pub fn make_bad_inode(arg1: *mut inode);
}
extern "C" {
    pub fn is_bad_inode(arg1: *mut inode) -> bool_;
}
extern "C" {
    pub fn file_fdatawait_range(file: *mut file, lstart: loff_t, lend: loff_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn file_check_and_advance_wb_err(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn file_write_and_wait_range(
        file: *mut file,
        start: loff_t,
        end: loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fsync_range(
        file: *mut file,
        start: loff_t,
        end: loff_t,
        datasync: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fsync(file: *mut file, datasync: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn sync_file_range(
        file: *mut file,
        offset: loff_t,
        nbytes: loff_t,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn emergency_sync();
}
extern "C" {
    pub fn emergency_remount();
}
extern "C" {
    pub fn bmap(inode: *mut inode, block: *mut sector_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn notify_change(
        arg1: *mut user_namespace,
        arg2: *mut dentry,
        arg3: *mut iattr,
        arg4: *mut *mut inode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inode_permission(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_permission(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __check_sticky(
        mnt_userns: *mut user_namespace,
        dir: *mut inode,
        inode: *mut inode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_pipe_flags(arg1: *mut core::ffi::c_int, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_read(
        arg1: *mut file,
        arg2: *mut core::ffi::c_void,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn __kernel_read(
        file: *mut file,
        buf: *mut core::ffi::c_void,
        count: usize,
        pos: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn kernel_write(
        arg1: *mut file,
        arg2: *const core::ffi::c_void,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn __kernel_write(
        arg1: *mut file,
        arg2: *const core::ffi::c_void,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn open_exec(arg1: *const core::ffi::c_char) -> *mut file;
}
extern "C" {
    pub fn is_subdir(arg1: *mut dentry, arg2: *mut dentry) -> bool_;
}
extern "C" {
    pub fn path_is_under(arg1: *const path, arg2: *const path) -> bool_;
}
extern "C" {
    pub fn file_path(
        arg1: *mut file,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn default_llseek(file: *mut file, offset: loff_t, whence: core::ffi::c_int) -> loff_t;
}
extern "C" {
    pub fn vfs_llseek(file: *mut file, offset: loff_t, whence: core::ffi::c_int) -> loff_t;
}
extern "C" {
    pub fn inode_init_always(arg1: *mut super_block, arg2: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn inode_init_once(arg1: *mut inode);
}
extern "C" {
    pub fn address_space_init_once(mapping: *mut address_space);
}
extern "C" {
    pub fn igrab(arg1: *mut inode) -> *mut inode;
}
extern "C" {
    pub fn iunique(arg1: *mut super_block, arg2: ino_t) -> ino_t;
}
extern "C" {
    pub fn inode_needs_sync(inode: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_delete_inode(inode: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn d_mark_dontcache(inode: *mut inode);
}
extern "C" {
    pub fn ilookup5_nowait(
        sb: *mut super_block,
        hashval: core::ffi::c_ulong,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn ilookup5(
        sb: *mut super_block,
        hashval: core::ffi::c_ulong,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn ilookup(sb: *mut super_block, ino: core::ffi::c_ulong) -> *mut inode;
}
extern "C" {
    pub fn inode_insert5(
        inode: *mut inode,
        hashval: core::ffi::c_ulong,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn iget5_locked(
        arg1: *mut super_block,
        arg2: core::ffi::c_ulong,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg3: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn iget_locked(arg1: *mut super_block, arg2: core::ffi::c_ulong) -> *mut inode;
}
extern "C" {
    pub fn find_inode_nowait(
        arg1: *mut super_block,
        arg2: core::ffi::c_ulong,
        match_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: core::ffi::c_ulong,
                arg3: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn find_inode_rcu(
        arg1: *mut super_block,
        arg2: core::ffi::c_ulong,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg4: *mut core::ffi::c_void,
    ) -> *mut inode;
}
extern "C" {
    pub fn find_inode_by_ino_rcu(arg1: *mut super_block, arg2: core::ffi::c_ulong) -> *mut inode;
}
extern "C" {
    pub fn insert_inode_locked4(
        arg1: *mut inode,
        arg2: core::ffi::c_ulong,
        test: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inode,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg3: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn insert_inode_locked(arg1: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn unlock_new_inode(arg1: *mut inode);
}
extern "C" {
    pub fn discard_new_inode(arg1: *mut inode);
}
extern "C" {
    pub fn get_next_ino() -> core::ffi::c_uint;
}
extern "C" {
    pub fn evict_inodes(sb: *mut super_block);
}
extern "C" {
    pub fn dump_mapping(arg1: *const address_space);
}
extern "C" {
    pub fn __iget(inode: *mut inode);
}
extern "C" {
    pub fn iget_failed(arg1: *mut inode);
}
extern "C" {
    pub fn clear_inode(arg1: *mut inode);
}
extern "C" {
    pub fn __destroy_inode(arg1: *mut inode);
}
extern "C" {
    pub fn new_inode_pseudo(sb: *mut super_block) -> *mut inode;
}
extern "C" {
    pub fn new_inode(sb: *mut super_block) -> *mut inode;
}
extern "C" {
    pub fn free_inode_nonrcu(inode: *mut inode);
}
extern "C" {
    pub fn should_remove_suid(arg1: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn file_remove_privs(arg1: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn __insert_inode_hash(arg1: *mut inode, hashval: core::ffi::c_ulong);
}
extern "C" {
    pub fn __remove_inode_hash(arg1: *mut inode);
}
extern "C" {
    pub fn inode_sb_list_add(inode: *mut inode);
}
extern "C" {
    pub fn inode_add_lru(inode: *mut inode);
}
extern "C" {
    pub fn sb_set_blocksize(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn sb_min_blocksize(arg1: *mut super_block, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_file_mmap(arg1: *mut file, arg2: *mut vm_area_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_file_readonly_mmap(
        arg1: *mut file,
        arg2: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_write_checks(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn generic_write_checks_count(iocb: *mut kiocb, count: *mut loff_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_write_check_limits(
        file: *mut file,
        pos: loff_t,
        count: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_file_rw_checks(file_in: *mut file, file_out: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_read(iocb: *mut kiocb, to: *mut iov_iter, already_read: isize) -> isize;
}
extern "C" {
    pub fn generic_file_read_iter(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn __generic_file_write_iter(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn generic_file_write_iter(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn generic_file_direct_write(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn generic_perform_write(arg1: *mut kiocb, arg2: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn vfs_iter_read(
        file: *mut file,
        iter: *mut iov_iter,
        ppos: *mut loff_t,
        flags: rwf_t,
    ) -> isize;
}
extern "C" {
    pub fn vfs_iter_write(
        file: *mut file,
        iter: *mut iov_iter,
        ppos: *mut loff_t,
        flags: rwf_t,
    ) -> isize;
}
extern "C" {
    pub fn vfs_iocb_iter_read(file: *mut file, iocb: *mut kiocb, iter: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn vfs_iocb_iter_write(file: *mut file, iocb: *mut kiocb, iter: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn generic_file_splice_read(
        arg1: *mut file,
        arg2: *mut loff_t,
        arg3: *mut pipe_inode_info,
        arg4: usize,
        arg5: core::ffi::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn iter_file_splice_write(
        arg1: *mut pipe_inode_info,
        arg2: *mut file,
        arg3: *mut loff_t,
        arg4: usize,
        arg5: core::ffi::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn generic_splice_sendpage(
        pipe: *mut pipe_inode_info,
        out: *mut file,
        arg1: *mut loff_t,
        len: usize,
        flags: core::ffi::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn do_splice_direct(
        in_: *mut file,
        ppos: *mut loff_t,
        out: *mut file,
        opos: *mut loff_t,
        len: usize,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn file_ra_state_init(ra: *mut file_ra_state, mapping: *mut address_space);
}
extern "C" {
    pub fn noop_llseek(file: *mut file, offset: loff_t, whence: core::ffi::c_int) -> loff_t;
}
extern "C" {
    pub fn vfs_setpos(file: *mut file, offset: loff_t, maxsize: loff_t) -> loff_t;
}
extern "C" {
    pub fn generic_file_llseek(file: *mut file, offset: loff_t, whence: core::ffi::c_int)
        -> loff_t;
}
extern "C" {
    pub fn generic_file_llseek_size(
        file: *mut file,
        offset: loff_t,
        whence: core::ffi::c_int,
        maxsize: loff_t,
        eof: loff_t,
    ) -> loff_t;
}
extern "C" {
    pub fn fixed_size_llseek(
        file: *mut file,
        offset: loff_t,
        whence: core::ffi::c_int,
        size: loff_t,
    ) -> loff_t;
}
extern "C" {
    pub fn no_seek_end_llseek_size(
        arg1: *mut file,
        arg2: loff_t,
        arg3: core::ffi::c_int,
        arg4: loff_t,
    ) -> loff_t;
}
extern "C" {
    pub fn no_seek_end_llseek(arg1: *mut file, arg2: loff_t, arg3: core::ffi::c_int) -> loff_t;
}
extern "C" {
    pub fn rw_verify_area(
        arg1: core::ffi::c_int,
        arg2: *mut file,
        arg3: *const loff_t,
        arg4: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_file_open(inode: *mut inode, filp: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn nonseekable_open(inode: *mut inode, filp: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn stream_open(inode: *mut inode, filp: *mut file) -> core::ffi::c_int;
}
pub type dio_submit_t = ::core::option::Option<
    unsafe extern "C" fn(bio: *mut bio, inode: *mut inode, file_offset: loff_t),
>;
pub const DIO_LOCKING: core::ffi::c_uint = 1;
pub const DIO_SKIP_HOLES: core::ffi::c_uint = 2;
pub type _bindgen_ty_83 = core::ffi::c_uint;
extern "C" {
    pub fn __blockdev_direct_IO(
        iocb: *mut kiocb,
        inode: *mut inode,
        bdev: *mut block_device,
        iter: *mut iov_iter,
        get_block: get_block_t,
        end_io: dio_iodone_t,
        submit_io: dio_submit_t,
        flags: core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn inode_dio_wait(inode: *mut inode);
}
extern "C" {
    pub fn dio_warn_stale_pagecache(filp: *mut file);
}
extern "C" {
    pub fn inode_set_flags(inode: *mut inode, flags: core::ffi::c_uint, mask: core::ffi::c_uint);
}
extern "C" {
    pub static generic_ro_fops: file_operations;
}
extern "C" {
    pub fn readlink_copy(
        arg1: *mut core::ffi::c_char,
        arg2: core::ffi::c_int,
        arg3: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn page_readlink(
        arg1: *mut dentry,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn page_get_link(
        arg1: *mut dentry,
        arg2: *mut inode,
        arg3: *mut delayed_call,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn page_put_link(arg1: *mut core::ffi::c_void);
}
extern "C" {
    pub fn page_symlink(
        inode: *mut inode,
        symname: *const core::ffi::c_char,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static page_symlink_inode_operations: inode_operations;
}
extern "C" {
    pub fn kfree_link(arg1: *mut core::ffi::c_void);
}
extern "C" {
    pub fn generic_fillattr(arg1: *mut user_namespace, arg2: *mut inode, arg3: *mut kstat);
}
extern "C" {
    pub fn generic_fill_statx_attr(inode: *mut inode, stat: *mut kstat);
}
extern "C" {
    pub fn vfs_getattr_nosec(
        arg1: *const path,
        arg2: *mut kstat,
        arg3: u32_,
        arg4: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_getattr(
        arg1: *const path,
        arg2: *mut kstat,
        arg3: u32_,
        arg4: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __inode_add_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn inode_add_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn __inode_sub_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn inode_sub_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn inode_get_bytes(inode: *mut inode) -> loff_t;
}
extern "C" {
    pub fn inode_set_bytes(inode: *mut inode, bytes: loff_t);
}
extern "C" {
    pub fn simple_get_link(
        arg1: *mut dentry,
        arg2: *mut inode,
        arg3: *mut delayed_call,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub static simple_symlink_inode_operations: inode_operations;
}
extern "C" {
    pub fn iterate_dir(arg1: *mut file, arg2: *mut dir_context) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fstatat(
        dfd: core::ffi::c_int,
        filename: *const core::ffi::c_char,
        stat: *mut kstat,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_fstat(fd: core::ffi::c_int, stat: *mut kstat) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_get_link(arg1: *mut dentry, arg2: *mut delayed_call) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn vfs_readlink(
        arg1: *mut dentry,
        arg2: *mut core::ffi::c_char,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_filesystem(fs: *mut file_system_type) -> *mut file_system_type;
}
extern "C" {
    pub fn put_filesystem(fs: *mut file_system_type);
}
extern "C" {
    pub fn get_fs_type(name: *const core::ffi::c_char) -> *mut file_system_type;
}
extern "C" {
    pub fn get_super(arg1: *mut block_device) -> *mut super_block;
}
extern "C" {
    pub fn get_active_super(bdev: *mut block_device) -> *mut super_block;
}
extern "C" {
    pub fn drop_super(sb: *mut super_block);
}
extern "C" {
    pub fn drop_super_exclusive(sb: *mut super_block);
}
extern "C" {
    pub fn iterate_supers(
        arg1: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut core::ffi::c_void),
        >,
        arg2: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn iterate_supers_type(
        arg1: *mut file_system_type,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut super_block, arg2: *mut core::ffi::c_void),
        >,
        arg3: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn dcache_dir_open(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn dcache_dir_close(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn dcache_dir_lseek(arg1: *mut file, arg2: loff_t, arg3: core::ffi::c_int) -> loff_t;
}
extern "C" {
    pub fn dcache_readdir(arg1: *mut file, arg2: *mut dir_context) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_setattr(
        arg1: *mut user_namespace,
        arg2: *mut dentry,
        arg3: *mut iattr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_getattr(
        arg1: *mut user_namespace,
        arg2: *const path,
        arg3: *mut kstat,
        arg4: u32_,
        arg5: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_statfs(arg1: *mut dentry, arg2: *mut kstatfs) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_open(inode: *mut inode, file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_link(arg1: *mut dentry, arg2: *mut inode, arg3: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_unlink(arg1: *mut inode, arg2: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_rmdir(arg1: *mut inode, arg2: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_rename_exchange(
        old_dir: *mut inode,
        old_dentry: *mut dentry,
        new_dir: *mut inode,
        new_dentry: *mut dentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_rename(
        arg1: *mut user_namespace,
        arg2: *mut inode,
        arg3: *mut dentry,
        arg4: *mut inode,
        arg5: *mut dentry,
        arg6: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_recursive_removal(
        arg1: *mut dentry,
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dentry)>,
    );
}
extern "C" {
    pub fn noop_fsync(
        arg1: *mut file,
        arg2: loff_t,
        arg3: loff_t,
        arg4: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn noop_direct_IO(iocb: *mut kiocb, iter: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn simple_empty(arg1: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_write_begin(
        file: *mut file,
        mapping: *mut address_space,
        pos: loff_t,
        len: core::ffi::c_uint,
        pagep: *mut *mut page,
        fsdata: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static ram_aops: address_space_operations;
}
extern "C" {
    pub fn always_delete_dentry(arg1: *const dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn alloc_anon_inode(arg1: *mut super_block) -> *mut inode;
}
extern "C" {
    pub fn simple_nosetlease(
        arg1: *mut file,
        arg2: core::ffi::c_long,
        arg3: *mut *mut file_lock,
        arg4: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static simple_dentry_operations: dentry_operations;
}
extern "C" {
    pub fn simple_lookup(
        arg1: *mut inode,
        arg2: *mut dentry,
        flags: core::ffi::c_uint,
    ) -> *mut dentry;
}
extern "C" {
    pub fn generic_read_dir(
        arg1: *mut file,
        arg2: *mut core::ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub static simple_dir_operations: file_operations;
}
extern "C" {
    pub static simple_dir_inode_operations: inode_operations;
}
extern "C" {
    pub fn make_empty_dir_inode(inode: *mut inode);
}
extern "C" {
    pub fn is_empty_dir_inode(inode: *mut inode) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tree_descr {
    pub name: *const core::ffi::c_char,
    pub ops: *const file_operations,
    pub mode: core::ffi::c_int,
}
impl Default for tree_descr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn d_alloc_name(arg1: *mut dentry, arg2: *const core::ffi::c_char) -> *mut dentry;
}
extern "C" {
    pub fn simple_fill_super(
        arg1: *mut super_block,
        arg2: core::ffi::c_ulong,
        arg3: *const tree_descr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_pin_fs(
        arg1: *mut file_system_type,
        mount: *mut *mut vfsmount,
        count: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_release_fs(mount: *mut *mut vfsmount, count: *mut core::ffi::c_int);
}
extern "C" {
    pub fn simple_read_from_buffer(
        to: *mut core::ffi::c_void,
        count: usize,
        ppos: *mut loff_t,
        from: *const core::ffi::c_void,
        available: usize,
    ) -> isize;
}
extern "C" {
    pub fn simple_write_to_buffer(
        to: *mut core::ffi::c_void,
        available: usize,
        ppos: *mut loff_t,
        from: *const core::ffi::c_void,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn __generic_file_fsync(
        arg1: *mut file,
        arg2: loff_t,
        arg3: loff_t,
        arg4: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_file_fsync(
        arg1: *mut file,
        arg2: loff_t,
        arg3: loff_t,
        arg4: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_check_addressable(arg1: core::ffi::c_uint, arg2: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_set_encrypted_ci_d_ops(dentry: *mut dentry);
}
extern "C" {
    pub fn may_setattr(
        mnt_userns: *mut user_namespace,
        inode: *mut inode,
        ia_valid: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn setattr_prepare(
        arg1: *mut user_namespace,
        arg2: *mut dentry,
        arg3: *mut iattr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inode_newsize_ok(arg1: *const inode, offset: loff_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn setattr_copy(arg1: *mut user_namespace, inode: *mut inode, attr: *const iattr);
}
extern "C" {
    pub fn file_update_time(file: *mut file) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default)]
pub struct simple_transaction_argresp {
    pub size: isize,
    pub data: __IncompleteArrayField<core::ffi::c_char>,
}
extern "C" {
    pub fn simple_transaction_get(
        file: *mut file,
        buf: *const core::ffi::c_char,
        size: usize,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn simple_transaction_read(
        file: *mut file,
        buf: *mut core::ffi::c_char,
        size: usize,
        pos: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn simple_transaction_release(inode: *mut inode, file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_transaction_set(file: *mut file, n: usize);
}
extern "C" {
    pub fn simple_attr_open(
        inode: *mut inode,
        file: *mut file,
        get: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void, arg2: *mut u64_) -> core::ffi::c_int,
        >,
        set: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void, arg2: u64_) -> core::ffi::c_int,
        >,
        fmt: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_attr_release(inode: *mut inode, file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn simple_attr_read(
        file: *mut file,
        buf: *mut core::ffi::c_char,
        len: usize,
        ppos: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn simple_attr_write(
        file: *mut file,
        buf: *const core::ffi::c_char,
        len: usize,
        ppos: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn list_bdev_fs_names(buf: *mut core::ffi::c_char, size: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn path_noexec(path: *const path) -> bool_;
}
extern "C" {
    pub fn inode_nohighmem(inode: *mut inode);
}
extern "C" {
    pub fn vfs_fadvise(
        file: *mut file,
        offset: loff_t,
        len: loff_t,
        advice: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_fadvise(
        file: *mut file,
        offset: loff_t,
        len: loff_t,
        advice: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
pub type aio_context_t = __kernel_ulong_t;
pub const IOCB_CMD_PREAD: core::ffi::c_uint = 0;
pub const IOCB_CMD_PWRITE: core::ffi::c_uint = 1;
pub const IOCB_CMD_FSYNC: core::ffi::c_uint = 2;
pub const IOCB_CMD_FDSYNC: core::ffi::c_uint = 3;
pub const IOCB_CMD_POLL: core::ffi::c_uint = 5;
pub const IOCB_CMD_NOOP: core::ffi::c_uint = 6;
pub const IOCB_CMD_PREADV: core::ffi::c_uint = 7;
pub const IOCB_CMD_PWRITEV: core::ffi::c_uint = 8;
pub type _bindgen_ty_84 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct io_event {
    pub data: __u64,
    pub obj: __u64,
    pub res: __s64,
    pub res2: __s64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct iocb {
    pub aio_data: __u64,
    pub aio_key: __u32,
    pub aio_rw_flags: __kernel_rwf_t,
    pub aio_lio_opcode: __u16,
    pub aio_reqprio: __s16,
    pub aio_fildes: __u32,
    pub aio_buf: __u64,
    pub aio_nbytes: __u64,
    pub aio_offset: __s64,
    pub aio_reserved2: __u64,
    pub aio_flags: __u32,
    pub aio_resfd: __u32,
}
extern "C" {
    pub fn put_task_stack(tsk: *mut task_struct);
}
extern "C" {
    pub fn exit_task_stack_account(tsk: *mut task_struct);
}
extern "C" {
    pub fn thread_stack_cache_init();
}
extern "C" {
    pub fn set_task_stack_end_magic(tsk: *mut task_struct);
}
pub type compat_size_t = u32_;
pub type compat_ssize_t = s32;
pub type compat_clock_t = s32;
pub type compat_pid_t = s32;
pub type compat_ino_t = u32_;
pub type compat_off_t = s32;
pub type compat_loff_t = s64;
pub type compat_daddr_t = s32;
pub type compat_timer_t = s32;
pub type compat_key_t = s32;
pub type compat_short_t = s16;
pub type compat_int_t = s32;
pub type compat_long_t = s32;
pub type compat_ushort_t = u16_;
pub type compat_uint_t = u32_;
pub type compat_ulong_t = u32_;
pub type compat_uptr_t = u32_;
pub type compat_caddr_t = u32_;
pub type compat_aio_context_t = u32_;
pub type compat_old_sigset_t = u32_;
pub type __compat_uid_t = u32_;
pub type __compat_gid_t = u32_;
pub type __compat_uid32_t = u32_;
pub type __compat_gid32_t = u32_;
pub type compat_mode_t = u32_;
pub type compat_s64 = s64;
pub type compat_u64 = u64_;
pub type compat_sigset_word = u32_;
pub type compat_dev_t = u32_;
pub type compat_ipc_pid_t = s32;
pub type compat_fsid_t = __kernel_fsid_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_statfs {
    pub f_type: compat_int_t,
    pub f_bsize: compat_int_t,
    pub f_blocks: compat_int_t,
    pub f_bfree: compat_int_t,
    pub f_bavail: compat_int_t,
    pub f_files: compat_int_t,
    pub f_ffree: compat_int_t,
    pub f_fsid: compat_fsid_t,
    pub f_namelen: compat_int_t,
    pub f_frsize: compat_int_t,
    pub f_flags: compat_int_t,
    pub f_spare: [compat_int_t; 4usize],
}
#[repr(C)]
#[derive(Default)]
pub struct compat_ipc64_perm {
    pub key: compat_key_t,
    pub uid: __compat_uid32_t,
    pub gid: __compat_gid32_t,
    pub cuid: __compat_uid32_t,
    pub cgid: __compat_gid32_t,
    pub mode: compat_mode_t,
    pub __pad1: __IncompleteArrayField<core::ffi::c_uchar>,
    pub seq: compat_ushort_t,
    pub __pad2: compat_ushort_t,
    pub unused1: compat_ulong_t,
    pub unused2: compat_ulong_t,
}
#[repr(C)]
#[derive(Default)]
pub struct compat_semid64_ds {
    pub sem_perm: compat_ipc64_perm,
    pub sem_otime: compat_ulong_t,
    pub sem_otime_high: compat_ulong_t,
    pub sem_ctime: compat_ulong_t,
    pub sem_ctime_high: compat_ulong_t,
    pub sem_nsems: compat_ulong_t,
    pub __unused3: compat_ulong_t,
    pub __unused4: compat_ulong_t,
}
#[repr(C)]
#[derive(Default)]
pub struct compat_msqid64_ds {
    pub msg_perm: compat_ipc64_perm,
    pub msg_stime: compat_ulong_t,
    pub msg_stime_high: compat_ulong_t,
    pub msg_rtime: compat_ulong_t,
    pub msg_rtime_high: compat_ulong_t,
    pub msg_ctime: compat_ulong_t,
    pub msg_ctime_high: compat_ulong_t,
    pub msg_cbytes: compat_ulong_t,
    pub msg_qnum: compat_ulong_t,
    pub msg_qbytes: compat_ulong_t,
    pub msg_lspid: compat_pid_t,
    pub msg_lrpid: compat_pid_t,
    pub __unused4: compat_ulong_t,
    pub __unused5: compat_ulong_t,
}
#[repr(C)]
#[derive(Default)]
pub struct compat_shmid64_ds {
    pub shm_perm: compat_ipc64_perm,
    pub shm_segsz: compat_size_t,
    pub shm_atime: compat_ulong_t,
    pub shm_atime_high: compat_ulong_t,
    pub shm_dtime: compat_ulong_t,
    pub shm_dtime_high: compat_ulong_t,
    pub shm_ctime: compat_ulong_t,
    pub shm_ctime_high: compat_ulong_t,
    pub shm_cpid: compat_pid_t,
    pub shm_lpid: compat_pid_t,
    pub shm_nattch: compat_ulong_t,
    pub __unused4: compat_ulong_t,
    pub __unused5: compat_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_user_regs_struct {
    pub pc: compat_ulong_t,
    pub ra: compat_ulong_t,
    pub sp: compat_ulong_t,
    pub gp: compat_ulong_t,
    pub tp: compat_ulong_t,
    pub t0: compat_ulong_t,
    pub t1: compat_ulong_t,
    pub t2: compat_ulong_t,
    pub s0: compat_ulong_t,
    pub s1: compat_ulong_t,
    pub a0: compat_ulong_t,
    pub a1: compat_ulong_t,
    pub a2: compat_ulong_t,
    pub a3: compat_ulong_t,
    pub a4: compat_ulong_t,
    pub a5: compat_ulong_t,
    pub a6: compat_ulong_t,
    pub a7: compat_ulong_t,
    pub s2: compat_ulong_t,
    pub s3: compat_ulong_t,
    pub s4: compat_ulong_t,
    pub s5: compat_ulong_t,
    pub s6: compat_ulong_t,
    pub s7: compat_ulong_t,
    pub s8: compat_ulong_t,
    pub s9: compat_ulong_t,
    pub s10: compat_ulong_t,
    pub s11: compat_ulong_t,
    pub t3: compat_ulong_t,
    pub t4: compat_ulong_t,
    pub t5: compat_ulong_t,
    pub t6: compat_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_iovec {
    pub iov_base: compat_uptr_t,
    pub iov_len: compat_size_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigaltstack {
    pub ss_sp: compat_uptr_t,
    pub ss_flags: core::ffi::c_int,
    pub ss_size: compat_size_t,
}
pub type compat_stack_t = compat_sigaltstack;
pub type compat_uid_t = __compat_uid32_t;
pub type compat_gid_t = __compat_gid32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sel_arg_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct old_itimerval32 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_tms {
    pub tms_utime: compat_clock_t,
    pub tms_stime: compat_clock_t,
    pub tms_cutime: compat_clock_t,
    pub tms_cstime: compat_clock_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigset_t {
    pub sig: [compat_sigset_word; 2usize],
}
extern "C" {
    pub fn set_compat_user_sigmask(
        umask: *const compat_sigset_t,
        sigsetsize: usize,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigaction {
    pub sa_handler: compat_uptr_t,
    pub sa_flags: compat_ulong_t,
    pub sa_mask: compat_sigset_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_sigval {
    pub sival_int: compat_int_t,
    pub sival_ptr: compat_uptr_t,
    _bindgen_union_align: u32,
}
impl Default for compat_sigval {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type compat_sigval_t = compat_sigval;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo {
    pub si_signo: core::ffi::c_int,
    pub si_errno: core::ffi::c_int,
    pub si_code: core::ffi::c_int,
    pub _sifields: compat_siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_siginfo__bindgen_ty_1 {
    pub _pad: [core::ffi::c_int; 29usize],
    pub _kill: compat_siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _timer: compat_siginfo__bindgen_ty_1__bindgen_ty_2,
    pub _rt: compat_siginfo__bindgen_ty_1__bindgen_ty_3,
    pub _sigchld: compat_siginfo__bindgen_ty_1__bindgen_ty_4,
    pub _sigfault: compat_siginfo__bindgen_ty_1__bindgen_ty_5,
    pub _sigpoll: compat_siginfo__bindgen_ty_1__bindgen_ty_6,
    pub _sigsys: compat_siginfo__bindgen_ty_1__bindgen_ty_7,
    _bindgen_union_align: [u32; 29usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub _pid: compat_pid_t,
    pub _uid: __compat_uid32_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub _tid: compat_timer_t,
    pub _overrun: core::ffi::c_int,
    pub _sigval: compat_sigval_t,
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub _pid: compat_pid_t,
    pub _uid: __compat_uid32_t,
    pub _sigval: compat_sigval_t,
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub _pid: compat_pid_t,
    pub _uid: __compat_uid32_t,
    pub _status: core::ffi::c_int,
    pub _utime: compat_clock_t,
    pub _stime: compat_clock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub _addr: compat_uptr_t,
    pub __bindgen_anon_1: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    pub _trapno: core::ffi::c_int,
    pub _addr_lsb: core::ffi::c_short,
    pub _addr_bnd: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub _addr_pkey: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub _perf: compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u32; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub _dummy_bnd: [core::ffi::c_char; 4usize],
    pub _lower: compat_uptr_t,
    pub _upper: compat_uptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub _dummy_pkey: [core::ffi::c_char; 4usize],
    pub _pkey: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub _data: compat_ulong_t,
    pub _type: u32_,
    pub _flags: u32_,
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for compat_siginfo__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_6 {
    pub _band: compat_long_t,
    pub _fd: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_siginfo__bindgen_ty_1__bindgen_ty_7 {
    pub _call_addr: compat_uptr_t,
    pub _syscall: core::ffi::c_int,
    pub _arch: core::ffi::c_uint,
}
impl Default for compat_siginfo__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for compat_siginfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type compat_siginfo_t = compat_siginfo;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_rlimit {
    pub rlim_cur: compat_ulong_t,
    pub rlim_max: compat_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_flock {
    pub l_type: core::ffi::c_short,
    pub l_whence: core::ffi::c_short,
    pub l_start: compat_off_t,
    pub l_len: compat_off_t,
    pub l_pid: compat_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_flock64 {
    pub l_type: core::ffi::c_short,
    pub l_whence: core::ffi::c_short,
    pub l_start: compat_loff_t,
    pub l_len: compat_loff_t,
    pub l_pid: compat_pid_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_rusage {
    pub ru_utime: old_timeval32,
    pub ru_stime: old_timeval32,
    pub ru_maxrss: compat_long_t,
    pub ru_ixrss: compat_long_t,
    pub ru_idrss: compat_long_t,
    pub ru_isrss: compat_long_t,
    pub ru_minflt: compat_long_t,
    pub ru_majflt: compat_long_t,
    pub ru_nswap: compat_long_t,
    pub ru_inblock: compat_long_t,
    pub ru_oublock: compat_long_t,
    pub ru_msgsnd: compat_long_t,
    pub ru_msgrcv: compat_long_t,
    pub ru_nsignals: compat_long_t,
    pub ru_nvcsw: compat_long_t,
    pub ru_nivcsw: compat_long_t,
}
extern "C" {
    pub fn put_compat_rusage(arg1: *const rusage, arg2: *mut compat_rusage) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __compat_aio_sigset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_dirent {
    pub d_ino: u32_,
    pub d_off: compat_off_t,
    pub d_reclen: u16_,
    pub d_name: [core::ffi::c_char; 256usize],
}
impl Default for compat_dirent {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_ustat {
    pub f_tfree: compat_daddr_t,
    pub f_tinode: compat_ino_t,
    pub f_fname: [core::ffi::c_char; 6usize],
    pub f_fpack: [core::ffi::c_char; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sigevent {
    pub sigev_value: compat_sigval_t,
    pub sigev_signo: compat_int_t,
    pub sigev_notify: compat_int_t,
    pub _sigev_un: compat_sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_sigevent__bindgen_ty_1 {
    pub _pad: [compat_int_t; 13usize],
    pub _tid: compat_int_t,
    pub _sigev_thread: compat_sigevent__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u32; 13usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: compat_uptr_t,
    pub _attribute: compat_uptr_t,
}
impl Default for compat_sigevent__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for compat_sigevent {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type compat_sigevent_t = compat_sigevent;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_ifmap {
    pub mem_start: compat_ulong_t,
    pub mem_end: compat_ulong_t,
    pub base_addr: core::ffi::c_ushort,
    pub irq: core::ffi::c_uchar,
    pub dma: core::ffi::c_uchar,
    pub port: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_if_settings {
    pub type_: core::ffi::c_uint,
    pub size: core::ffi::c_uint,
    pub ifs_ifsu: compat_uptr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_ifreq {
    pub ifr_ifrn: compat_ifreq__bindgen_ty_1,
    pub ifr_ifru: compat_ifreq__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_ifreq__bindgen_ty_1 {
    pub ifrn_name: [core::ffi::c_char; 16usize],
    _bindgen_union_align: [u8; 16usize],
}
impl Default for compat_ifreq__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union compat_ifreq__bindgen_ty_2 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_netmask: sockaddr,
    pub ifru_hwaddr: sockaddr,
    pub ifru_flags: core::ffi::c_short,
    pub ifru_ivalue: compat_int_t,
    pub ifru_mtu: compat_int_t,
    pub ifru_map: compat_ifmap,
    pub ifru_slave: [core::ffi::c_char; 16usize],
    pub ifru_newname: [core::ffi::c_char; 16usize],
    pub ifru_data: compat_caddr_t,
    pub ifru_settings: compat_if_settings,
    _bindgen_union_align: [u32; 4usize],
}
impl Default for compat_ifreq__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for compat_ifreq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_ifconf {
    pub ifc_len: compat_int_t,
    pub ifcbuf: compat_caddr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_robust_list {
    pub next: compat_uptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_robust_list_head {
    pub list: compat_robust_list,
    pub futex_offset: compat_long_t,
    pub list_op_pending: compat_uptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_keyctl_kdf_params {
    pub hashname: compat_uptr_t,
    pub otherinfo: compat_uptr_t,
    pub otherinfolen: __u32,
    pub __spare: [__u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_stat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_statfs64 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_old_linux_dirent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_linux_dirent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct linux_dirent64 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_msghdr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_mmsghdr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sysinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_sysctl_args {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_kexec_segment {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_mq_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct compat_msgbuf {
    _unused: [u8; 0],
}
extern "C" {
    pub fn copy_siginfo_to_external32(to: *mut compat_siginfo, from: *const kernel_siginfo);
}
extern "C" {
    pub fn copy_siginfo_from_user32(
        to: *mut kernel_siginfo_t,
        from: *const compat_siginfo,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __copy_siginfo_to_user32(
        to: *mut compat_siginfo,
        from: *const kernel_siginfo_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_compat_sigevent(
        event: *mut sigevent,
        u_event: *const compat_sigevent,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_compat_sigset(
        set: *mut sigset_t,
        compat: *const compat_sigset_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn compat_ptrace_request(
        child: *mut task_struct,
        request: compat_long_t,
        addr: compat_ulong_t,
        data: compat_ulong_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn compat_arch_ptrace(
        child: *mut task_struct,
        request: compat_long_t,
        addr: compat_ulong_t,
        data: compat_ulong_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_restore_altstack(uss: *const compat_stack_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __compat_save_altstack(
        arg1: *mut compat_stack_t,
        arg2: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn compat_sys_io_setup(nr_reqs: core::ffi::c_uint, ctx32p: *mut u32_) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_io_submit(
        ctx_id: compat_aio_context_t,
        nr: core::ffi::c_int,
        iocb: *mut u32_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_io_pgetevents(
        ctx_id: compat_aio_context_t,
        min_nr: compat_long_t,
        nr: compat_long_t,
        events: *mut io_event,
        timeout: *mut old_timespec32,
        usig: *const __compat_aio_sigset,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_io_pgetevents_time64(
        ctx_id: compat_aio_context_t,
        min_nr: compat_long_t,
        nr: compat_long_t,
        events: *mut io_event,
        timeout: *mut __kernel_timespec,
        usig: *const __compat_aio_sigset,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_lookup_dcookie(
        arg1: u32_,
        arg2: u32_,
        arg3: *mut core::ffi::c_char,
        arg4: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_epoll_pwait(
        epfd: core::ffi::c_int,
        events: *mut epoll_event,
        maxevents: core::ffi::c_int,
        timeout: core::ffi::c_int,
        sigmask: *const compat_sigset_t,
        sigsetsize: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_epoll_pwait2(
        epfd: core::ffi::c_int,
        events: *mut epoll_event,
        maxevents: core::ffi::c_int,
        timeout: *const __kernel_timespec,
        sigmask: *const compat_sigset_t,
        sigsetsize: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_fcntl(
        fd: core::ffi::c_uint,
        cmd: core::ffi::c_uint,
        arg: compat_ulong_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_fcntl64(
        fd: core::ffi::c_uint,
        cmd: core::ffi::c_uint,
        arg: compat_ulong_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_ioctl(
        fd: core::ffi::c_uint,
        cmd: core::ffi::c_uint,
        arg: compat_ulong_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_statfs(
        pathname: *const core::ffi::c_char,
        buf: *mut compat_statfs,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_statfs64(
        pathname: *const core::ffi::c_char,
        sz: compat_size_t,
        buf: *mut compat_statfs64,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_fstatfs(fd: core::ffi::c_uint, buf: *mut compat_statfs) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_fstatfs64(
        fd: core::ffi::c_uint,
        sz: compat_size_t,
        buf: *mut compat_statfs64,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_truncate(
        arg1: *const core::ffi::c_char,
        arg2: compat_off_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_ftruncate(arg1: core::ffi::c_uint, arg2: compat_ulong_t)
        -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_openat(
        dfd: core::ffi::c_int,
        filename: *const core::ffi::c_char,
        flags: core::ffi::c_int,
        mode: umode_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_getdents(
        fd: core::ffi::c_uint,
        dirent: *mut compat_linux_dirent,
        count: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_lseek(
        arg1: core::ffi::c_uint,
        arg2: compat_off_t,
        arg3: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_preadv(
        fd: compat_ulong_t,
        vec: *const iovec,
        vlen: compat_ulong_t,
        pos_low: u32_,
        pos_high: u32_,
    ) -> isize;
}
extern "C" {
    pub fn compat_sys_pwritev(
        fd: compat_ulong_t,
        vec: *const iovec,
        vlen: compat_ulong_t,
        pos_low: u32_,
        pos_high: u32_,
    ) -> isize;
}
extern "C" {
    pub fn compat_sys_sendfile(
        out_fd: core::ffi::c_int,
        in_fd: core::ffi::c_int,
        offset: *mut compat_off_t,
        count: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_sendfile64(
        out_fd: core::ffi::c_int,
        in_fd: core::ffi::c_int,
        offset: *mut compat_loff_t,
        count: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_pselect6_time32(
        n: core::ffi::c_int,
        inp: *mut compat_ulong_t,
        outp: *mut compat_ulong_t,
        exp: *mut compat_ulong_t,
        tsp: *mut old_timespec32,
        sig: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_pselect6_time64(
        n: core::ffi::c_int,
        inp: *mut compat_ulong_t,
        outp: *mut compat_ulong_t,
        exp: *mut compat_ulong_t,
        tsp: *mut __kernel_timespec,
        sig: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_ppoll_time32(
        ufds: *mut pollfd,
        nfds: core::ffi::c_uint,
        tsp: *mut old_timespec32,
        sigmask: *const compat_sigset_t,
        sigsetsize: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_ppoll_time64(
        ufds: *mut pollfd,
        nfds: core::ffi::c_uint,
        tsp: *mut __kernel_timespec,
        sigmask: *const compat_sigset_t,
        sigsetsize: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_signalfd4(
        ufd: core::ffi::c_int,
        sigmask: *const compat_sigset_t,
        sigsetsize: compat_size_t,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_newfstatat(
        dfd: core::ffi::c_uint,
        filename: *const core::ffi::c_char,
        statbuf: *mut compat_stat,
        flag: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_newfstat(
        fd: core::ffi::c_uint,
        statbuf: *mut compat_stat,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_waitid(
        arg1: core::ffi::c_int,
        arg2: compat_pid_t,
        arg3: *mut compat_siginfo,
        arg4: core::ffi::c_int,
        arg5: *mut compat_rusage,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_set_robust_list(
        head: *mut compat_robust_list_head,
        len: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_get_robust_list(
        pid: core::ffi::c_int,
        head_ptr: *mut compat_uptr_t,
        len_ptr: *mut compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_getitimer(
        which: core::ffi::c_int,
        it: *mut old_itimerval32,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_setitimer(
        which: core::ffi::c_int,
        in_: *mut old_itimerval32,
        out: *mut old_itimerval32,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_kexec_load(
        entry: compat_ulong_t,
        nr_segments: compat_ulong_t,
        arg1: *mut compat_kexec_segment,
        flags: compat_ulong_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_timer_create(
        which_clock: clockid_t,
        timer_event_spec: *mut compat_sigevent,
        created_timer_id: *mut timer_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_ptrace(
        request: compat_long_t,
        pid: compat_long_t,
        addr: compat_long_t,
        data: compat_long_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_sched_setaffinity(
        pid: compat_pid_t,
        len: core::ffi::c_uint,
        user_mask_ptr: *mut compat_ulong_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_sched_getaffinity(
        pid: compat_pid_t,
        len: core::ffi::c_uint,
        user_mask_ptr: *mut compat_ulong_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_sigaltstack(
        uss_ptr: *const compat_stack_t,
        uoss_ptr: *mut compat_stack_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_rt_sigsuspend(
        unewset: *mut compat_sigset_t,
        sigsetsize: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_rt_sigaction(
        arg1: core::ffi::c_int,
        arg2: *const compat_sigaction,
        arg3: *mut compat_sigaction,
        arg4: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_rt_sigprocmask(
        how: core::ffi::c_int,
        set: *mut compat_sigset_t,
        oset: *mut compat_sigset_t,
        sigsetsize: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_rt_sigpending(
        uset: *mut compat_sigset_t,
        sigsetsize: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_rt_sigtimedwait_time32(
        uthese: *mut compat_sigset_t,
        uinfo: *mut compat_siginfo,
        uts: *mut old_timespec32,
        sigsetsize: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_rt_sigtimedwait_time64(
        uthese: *mut compat_sigset_t,
        uinfo: *mut compat_siginfo,
        uts: *mut __kernel_timespec,
        sigsetsize: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_rt_sigqueueinfo(
        pid: compat_pid_t,
        sig: core::ffi::c_int,
        uinfo: *mut compat_siginfo,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_times(tbuf: *mut compat_tms) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_getrlimit(
        resource: core::ffi::c_uint,
        rlim: *mut compat_rlimit,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_setrlimit(
        resource: core::ffi::c_uint,
        rlim: *mut compat_rlimit,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_getrusage(who: core::ffi::c_int, ru: *mut compat_rusage)
        -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_gettimeofday(tv: *mut old_timeval32, tz: *mut timezone) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_settimeofday(tv: *mut old_timeval32, tz: *mut timezone) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_sysinfo(info: *mut compat_sysinfo) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_mq_open(
        u_name: *const core::ffi::c_char,
        oflag: core::ffi::c_int,
        mode: compat_mode_t,
        u_attr: *mut compat_mq_attr,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_mq_notify(
        mqdes: mqd_t,
        u_notification: *const compat_sigevent,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_mq_getsetattr(
        mqdes: mqd_t,
        u_mqstat: *const compat_mq_attr,
        u_omqstat: *mut compat_mq_attr,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_msgctl(
        first: core::ffi::c_int,
        second: core::ffi::c_int,
        uptr: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_msgrcv(
        msqid: core::ffi::c_int,
        msgp: compat_uptr_t,
        msgsz: compat_ssize_t,
        msgtyp: compat_long_t,
        msgflg: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_msgsnd(
        msqid: core::ffi::c_int,
        msgp: compat_uptr_t,
        msgsz: compat_ssize_t,
        msgflg: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_semctl(
        semid: core::ffi::c_int,
        semnum: core::ffi::c_int,
        cmd: core::ffi::c_int,
        arg: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_shmctl(
        first: core::ffi::c_int,
        second: core::ffi::c_int,
        uptr: *mut core::ffi::c_void,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_shmat(
        shmid: core::ffi::c_int,
        shmaddr: compat_uptr_t,
        shmflg: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_recvfrom(
        fd: core::ffi::c_int,
        buf: *mut core::ffi::c_void,
        len: compat_size_t,
        flags: core::ffi::c_uint,
        addr: *mut sockaddr,
        addrlen: *mut core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_sendmsg(
        fd: core::ffi::c_int,
        msg: *mut compat_msghdr,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_recvmsg(
        fd: core::ffi::c_int,
        msg: *mut compat_msghdr,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_keyctl(
        option: u32_,
        arg2: u32_,
        arg3: u32_,
        arg4: u32_,
        arg5: u32_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_execve(
        filename: *const core::ffi::c_char,
        argv: *const compat_uptr_t,
        envp: *const compat_uptr_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_rt_tgsigqueueinfo(
        tgid: compat_pid_t,
        pid: compat_pid_t,
        sig: core::ffi::c_int,
        uinfo: *mut compat_siginfo,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_recvmmsg_time64(
        fd: core::ffi::c_int,
        mmsg: *mut compat_mmsghdr,
        vlen: core::ffi::c_uint,
        flags: core::ffi::c_uint,
        timeout: *mut __kernel_timespec,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_recvmmsg_time32(
        fd: core::ffi::c_int,
        mmsg: *mut compat_mmsghdr,
        vlen: core::ffi::c_uint,
        flags: core::ffi::c_uint,
        timeout: *mut old_timespec32,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_wait4(
        pid: compat_pid_t,
        stat_addr: *mut compat_uint_t,
        options: core::ffi::c_int,
        ru: *mut compat_rusage,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_fanotify_mark(
        arg1: core::ffi::c_int,
        arg2: core::ffi::c_uint,
        arg3: __u32,
        arg4: __u32,
        arg5: core::ffi::c_int,
        arg6: *const core::ffi::c_char,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_open_by_handle_at(
        mountdirfd: core::ffi::c_int,
        handle: *mut file_handle,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_sendmmsg(
        fd: core::ffi::c_int,
        mmsg: *mut compat_mmsghdr,
        vlen: core::ffi::c_uint,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_execveat(
        dfd: core::ffi::c_int,
        filename: *const core::ffi::c_char,
        argv: *const compat_uptr_t,
        envp: *const compat_uptr_t,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_preadv2(
        fd: compat_ulong_t,
        vec: *const iovec,
        vlen: compat_ulong_t,
        pos_low: u32_,
        pos_high: u32_,
        flags: rwf_t,
    ) -> isize;
}
extern "C" {
    pub fn compat_sys_pwritev2(
        fd: compat_ulong_t,
        vec: *const iovec,
        vlen: compat_ulong_t,
        pos_low: u32_,
        pos_high: u32_,
        flags: rwf_t,
    ) -> isize;
}
extern "C" {
    pub fn compat_sys_open(
        filename: *const core::ffi::c_char,
        flags: core::ffi::c_int,
        mode: umode_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_signalfd(
        ufd: core::ffi::c_int,
        sigmask: *const compat_sigset_t,
        sigsetsize: compat_size_t,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_newstat(
        filename: *const core::ffi::c_char,
        statbuf: *mut compat_stat,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_newlstat(
        filename: *const core::ffi::c_char,
        statbuf: *mut compat_stat,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_select(
        n: core::ffi::c_int,
        inp: *mut compat_ulong_t,
        outp: *mut compat_ulong_t,
        exp: *mut compat_ulong_t,
        tvp: *mut old_timeval32,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_ustat(dev: core::ffi::c_uint, u32_: *mut compat_ustat) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_recv(
        fd: core::ffi::c_int,
        buf: *mut core::ffi::c_void,
        len: compat_size_t,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_old_readdir(
        fd: core::ffi::c_uint,
        arg1: *mut compat_old_linux_dirent,
        count: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_old_select(arg: *mut compat_sel_arg_struct) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_ipc(
        arg1: u32_,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_int,
        arg4: u32_,
        arg5: compat_uptr_t,
        arg6: u32_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_socketcall(call: core::ffi::c_int, args: *mut u32_) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_truncate64(
        pathname: *const core::ffi::c_char,
        len_hi: u32_,
        len_lo: u32_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_ftruncate64(
        fd: core::ffi::c_uint,
        len_hi: u32_,
        len_lo: u32_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_fallocate(
        fd: core::ffi::c_int,
        mode: core::ffi::c_int,
        offset_hi: u32_,
        offset_lo: u32_,
        len_hi: u32_,
        len_lo: u32_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_pread64(
        fd: core::ffi::c_uint,
        buf: *mut core::ffi::c_char,
        count: usize,
        pos_hi: u32_,
        pos_lo: u32_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_pwrite64(
        fd: core::ffi::c_uint,
        buf: *const core::ffi::c_char,
        count: usize,
        pos_hi: u32_,
        pos_lo: u32_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_sync_file_range(
        fd: core::ffi::c_int,
        pos_hi: u32_,
        pos_lo: u32_,
        nbytes_hi: u32_,
        nbytes_lo: u32_,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_fadvise64_64(
        fd: core::ffi::c_int,
        pos_hi: u32_,
        pos_lo: u32_,
        len_hi: u32_,
        len_lo: u32_,
        advice: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_sys_readahead(
        fd: core::ffi::c_int,
        offset_hi: u32_,
        offset_lo: u32_,
        count: usize,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn kcompat_sys_statfs64(
        pathname: *const core::ffi::c_char,
        sz: compat_size_t,
        buf: *mut compat_statfs64,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kcompat_sys_fstatfs64(
        fd: core::ffi::c_uint,
        sz: compat_size_t,
        buf: *mut compat_statfs64,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn compat_get_bitmap(
        mask: *mut core::ffi::c_ulong,
        umask: *const compat_ulong_t,
        bitmap_size: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn compat_put_bitmap(
        umask: *mut compat_ulong_t,
        mask: *mut core::ffi::c_ulong,
        bitmap_size: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
pub type elf_greg_t = core::ffi::c_ulong;
pub type elf_gregset_t = user_regs_struct;
pub type elf_fpreg_t = __u64;
pub type elf_fpregset_t = __riscv_fp_state;
pub const cache_type_CACHE_TYPE_NOCACHE: cache_type = 0;
pub const cache_type_CACHE_TYPE_INST: cache_type = 1;
pub const cache_type_CACHE_TYPE_DATA: cache_type = 2;
pub const cache_type_CACHE_TYPE_SEPARATE: cache_type = 3;
pub const cache_type_CACHE_TYPE_UNIFIED: cache_type = 4;
pub type cache_type = core::ffi::c_uint;
extern "C" {
    pub static mut coherency_max_size: core::ffi::c_uint;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cacheinfo {
    pub id: core::ffi::c_uint,
    pub type_: cache_type,
    pub level: core::ffi::c_uint,
    pub coherency_line_size: core::ffi::c_uint,
    pub number_of_sets: core::ffi::c_uint,
    pub ways_of_associativity: core::ffi::c_uint,
    pub physical_line_partition: core::ffi::c_uint,
    pub size: core::ffi::c_uint,
    pub shared_cpu_map: cpumask_t,
    pub attributes: core::ffi::c_uint,
    pub fw_token: *mut core::ffi::c_void,
    pub disable_sysfs: bool_,
    pub priv_: *mut core::ffi::c_void,
}
impl Default for cacheinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_cacheinfo {
    pub info_list: *mut cacheinfo,
    pub num_levels: core::ffi::c_uint,
    pub num_leaves: core::ffi::c_uint,
    pub cpu_map_populated: bool_,
}
impl Default for cpu_cacheinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn get_cpu_cacheinfo(cpu: core::ffi::c_uint) -> *mut cpu_cacheinfo;
}
extern "C" {
    pub fn init_cache_level(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn populate_cache_leaves(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn cache_setup_acpi(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn last_level_cache_is_valid(cpu: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn last_level_cache_is_shared(cpu_x: core::ffi::c_uint, cpu_y: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn detect_cache_attributes(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn cache_get_priv_group(this_leaf: *mut cacheinfo) -> *const attribute_group;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct riscv_cacheinfo_ops {
    pub get_priv_group: ::core::option::Option<
        unsafe extern "C" fn(this_leaf: *mut cacheinfo) -> *const attribute_group,
    >,
}
extern "C" {
    pub fn riscv_set_cacheinfo_ops(ops: *mut riscv_cacheinfo_ops);
}
extern "C" {
    pub fn get_cache_size(level: u32_, type_: cache_type) -> usize;
}
extern "C" {
    pub fn get_cache_geometry(level: u32_, type_: cache_type) -> usize;
}
extern "C" {
    pub fn compat_elf_check_arch(hdr: *mut Elf32_Ehdr) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct linux_binprm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn arch_setup_additional_pages(
        bprm: *mut linux_binprm,
        uses_interp: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
pub type compat_elf_greg_t = compat_ulong_t;
pub type compat_elf_gregset_t = [compat_elf_greg_t; 32usize];
extern "C" {
    pub fn compat_arch_setup_additional_pages(
        bprm: *mut linux_binprm,
        uses_interp: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut _DYNAMIC: [Elf64_Dyn; 0usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct coredump_params {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct gnu_property {
    pub pr_type: u32_,
    pub pr_datasz: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arch_elf_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct idr {
    pub idr_rt: xarray,
    pub idr_base: core::ffi::c_uint,
    pub idr_next: core::ffi::c_uint,
}
impl Default for idr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn idr_preload(gfp_mask: gfp_t);
}
extern "C" {
    pub fn idr_alloc(
        arg1: *mut idr,
        ptr: *mut core::ffi::c_void,
        start: core::ffi::c_int,
        end: core::ffi::c_int,
        arg2: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn idr_alloc_u32(
        arg1: *mut idr,
        ptr: *mut core::ffi::c_void,
        id: *mut u32_,
        max: core::ffi::c_ulong,
        arg2: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn idr_alloc_cyclic(
        arg1: *mut idr,
        ptr: *mut core::ffi::c_void,
        start: core::ffi::c_int,
        end: core::ffi::c_int,
        arg2: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn idr_remove(arg1: *mut idr, id: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn idr_find(arg1: *const idr, id: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn idr_for_each(
        arg1: *const idr,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                id: core::ffi::c_int,
                p: *mut core::ffi::c_void,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn idr_get_next(arg1: *mut idr, nextid: *mut core::ffi::c_int) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn idr_get_next_ul(
        arg1: *mut idr,
        nextid: *mut core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn idr_replace(
        arg1: *mut idr,
        arg2: *mut core::ffi::c_void,
        id: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn idr_destroy(arg1: *mut idr);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ida_bitmap {
    pub bitmap: [core::ffi::c_ulong; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ida {
    pub xa: xarray,
}
impl Default for ida {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ida_alloc_range(
        arg1: *mut ida,
        min: core::ffi::c_uint,
        max: core::ffi::c_uint,
        arg2: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ida_free(arg1: *mut ida, id: core::ffi::c_uint);
}
extern "C" {
    pub fn ida_destroy(ida: *mut ida);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_iattrs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_global_locks {
    pub open_file_mutex: [mutex; 1024usize],
}
impl Default for kernfs_global_locks {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const kernfs_node_type_KERNFS_DIR: kernfs_node_type = 1;
pub const kernfs_node_type_KERNFS_FILE: kernfs_node_type = 2;
pub const kernfs_node_type_KERNFS_LINK: kernfs_node_type = 4;
pub type kernfs_node_type = core::ffi::c_uint;
pub const kernfs_node_flag_KERNFS_ACTIVATED: kernfs_node_flag = 16;
pub const kernfs_node_flag_KERNFS_NS: kernfs_node_flag = 32;
pub const kernfs_node_flag_KERNFS_HAS_SEQ_SHOW: kernfs_node_flag = 64;
pub const kernfs_node_flag_KERNFS_HAS_MMAP: kernfs_node_flag = 128;
pub const kernfs_node_flag_KERNFS_LOCKDEP: kernfs_node_flag = 256;
pub const kernfs_node_flag_KERNFS_HIDDEN: kernfs_node_flag = 512;
pub const kernfs_node_flag_KERNFS_SUICIDAL: kernfs_node_flag = 1024;
pub const kernfs_node_flag_KERNFS_SUICIDED: kernfs_node_flag = 2048;
pub const kernfs_node_flag_KERNFS_EMPTY_DIR: kernfs_node_flag = 4096;
pub const kernfs_node_flag_KERNFS_HAS_RELEASE: kernfs_node_flag = 8192;
pub const kernfs_node_flag_KERNFS_REMOVING: kernfs_node_flag = 16384;
pub type kernfs_node_flag = core::ffi::c_uint;
pub const kernfs_root_flag_KERNFS_ROOT_CREATE_DEACTIVATED: kernfs_root_flag = 1;
pub const kernfs_root_flag_KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK: kernfs_root_flag = 2;
pub const kernfs_root_flag_KERNFS_ROOT_SUPPORT_EXPORTOP: kernfs_root_flag = 4;
pub const kernfs_root_flag_KERNFS_ROOT_SUPPORT_USER_XATTR: kernfs_root_flag = 8;
pub type kernfs_root_flag = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_dir {
    pub subdirs: core::ffi::c_ulong,
    pub children: rb_root,
    pub root: *mut kernfs_root,
    pub rev: core::ffi::c_ulong,
}
impl Default for kernfs_elem_dir {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_symlink {
    pub target_kn: *mut kernfs_node,
}
impl Default for kernfs_elem_symlink {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_elem_attr {
    pub ops: *const kernfs_ops,
    pub open: *mut kernfs_open_node,
    pub size: loff_t,
    pub notify_next: *mut kernfs_node,
}
impl Default for kernfs_elem_attr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_node {
    pub count: atomic_t,
    pub active: atomic_t,
    pub parent: *mut kernfs_node,
    pub name: *const core::ffi::c_char,
    pub rb: rb_node,
    pub ns: *const core::ffi::c_void,
    pub hash: core::ffi::c_uint,
    pub __bindgen_anon_1: kernfs_node__bindgen_ty_1,
    pub priv_: *mut core::ffi::c_void,
    pub id: u64_,
    pub flags: core::ffi::c_ushort,
    pub mode: umode_t,
    pub iattr: *mut kernfs_iattrs,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernfs_node__bindgen_ty_1 {
    pub dir: kernfs_elem_dir,
    pub symlink: kernfs_elem_symlink,
    pub attr: kernfs_elem_attr,
    _bindgen_union_align: [u64; 4usize],
}
impl Default for kernfs_node__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for kernfs_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernfs_syscall_ops {
    pub show_options: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, root: *mut kernfs_root) -> core::ffi::c_int,
    >,
    pub mkdir: ::core::option::Option<
        unsafe extern "C" fn(
            parent: *mut kernfs_node,
            name: *const core::ffi::c_char,
            mode: umode_t,
        ) -> core::ffi::c_int,
    >,
    pub rmdir:
        ::core::option::Option<unsafe extern "C" fn(kn: *mut kernfs_node) -> core::ffi::c_int>,
    pub rename: ::core::option::Option<
        unsafe extern "C" fn(
            kn: *mut kernfs_node,
            new_parent: *mut kernfs_node,
            new_name: *const core::ffi::c_char,
        ) -> core::ffi::c_int,
    >,
    pub show_path: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            kn: *mut kernfs_node,
            root: *mut kernfs_root,
        ) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub fn kernfs_root_to_node(root: *mut kernfs_root) -> *mut kernfs_node;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_open_file {
    pub kn: *mut kernfs_node,
    pub file: *mut file,
    pub seq_file: *mut seq_file,
    pub priv_: *mut core::ffi::c_void,
    pub mutex: mutex,
    pub prealloc_mutex: mutex,
    pub event: core::ffi::c_int,
    pub list: list_head,
    pub prealloc_buf: *mut core::ffi::c_char,
    pub atomic_write_len: usize,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub vm_ops: *const vm_operations_struct,
}
impl Default for kernfs_open_file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl kernfs_open_file {
    #[inline]
    pub fn mmapped(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mmapped(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn released(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_released(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mmapped: bool_,
        released: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let mmapped: u8 = unsafe { ::core::mem::transmute(mmapped) };
            mmapped as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let released: u8 = unsafe { ::core::mem::transmute(released) };
            released as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernfs_ops {
    pub open:
        ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> core::ffi::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut core::ffi::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut core::ffi::c_void,
            ppos: *mut loff_t,
        ) -> *mut core::ffi::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut core::ffi::c_void)>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut core::ffi::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub atomic_write_len: usize,
    pub prealloc: bool_,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut core::ffi::c_char,
            bytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            vma: *mut vm_area_struct,
        ) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernfs_fs_context {
    pub root: *mut kernfs_root,
    pub ns_tag: *mut core::ffi::c_void,
    pub magic: core::ffi::c_ulong,
    pub new_sb_created: bool_,
}
impl Default for kernfs_fs_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kernfs_name(
        kn: *mut kernfs_node,
        buf: *mut core::ffi::c_char,
        buflen: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_path_from_node(
        root_kn: *mut kernfs_node,
        kn: *mut kernfs_node,
        buf: *mut core::ffi::c_char,
        buflen: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pr_cont_kernfs_name(kn: *mut kernfs_node);
}
extern "C" {
    pub fn pr_cont_kernfs_path(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_get_parent(kn: *mut kernfs_node) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_find_and_get_ns(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
        ns: *const core::ffi::c_void,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_walk_and_get_ns(
        parent: *mut kernfs_node,
        path: *const core::ffi::c_char,
        ns: *const core::ffi::c_void,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_get(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_put(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_node_from_dentry(dentry: *mut dentry) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_root_from_sb(sb: *mut super_block) -> *mut kernfs_root;
}
extern "C" {
    pub fn kernfs_get_inode(sb: *mut super_block, kn: *mut kernfs_node) -> *mut inode;
}
extern "C" {
    pub fn kernfs_node_dentry(kn: *mut kernfs_node, sb: *mut super_block) -> *mut dentry;
}
extern "C" {
    pub fn kernfs_create_root(
        scops: *mut kernfs_syscall_ops,
        flags: core::ffi::c_uint,
        priv_: *mut core::ffi::c_void,
    ) -> *mut kernfs_root;
}
extern "C" {
    pub fn kernfs_destroy_root(root: *mut kernfs_root);
}
extern "C" {
    pub fn kernfs_create_dir_ns(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
        mode: umode_t,
        uid: kuid_t,
        gid: kgid_t,
        priv_: *mut core::ffi::c_void,
        ns: *const core::ffi::c_void,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_create_empty_dir(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn __kernfs_create_file(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
        mode: umode_t,
        uid: kuid_t,
        gid: kgid_t,
        size: loff_t,
        ops: *const kernfs_ops,
        priv_: *mut core::ffi::c_void,
        ns: *const core::ffi::c_void,
        key: *mut lock_class_key,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_create_link(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
        target: *mut kernfs_node,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn kernfs_activate(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_show(kn: *mut kernfs_node, show: bool_);
}
extern "C" {
    pub fn kernfs_remove(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_break_active_protection(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_unbreak_active_protection(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_remove_self(kn: *mut kernfs_node) -> bool_;
}
extern "C" {
    pub fn kernfs_remove_by_name_ns(
        parent: *mut kernfs_node,
        name: *const core::ffi::c_char,
        ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_rename_ns(
        kn: *mut kernfs_node,
        new_parent: *mut kernfs_node,
        new_name: *const core::ffi::c_char,
        new_ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_setattr(kn: *mut kernfs_node, iattr: *const iattr) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_generic_poll(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t;
}
extern "C" {
    pub fn kernfs_notify(kn: *mut kernfs_node);
}
extern "C" {
    pub fn kernfs_xattr_get(
        kn: *mut kernfs_node,
        name: *const core::ffi::c_char,
        value: *mut core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_xattr_set(
        kn: *mut kernfs_node,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_super_ns(sb: *mut super_block) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn kernfs_get_tree(fc: *mut fs_context) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernfs_free_fs_context(fc: *mut fs_context);
}
extern "C" {
    pub fn kernfs_kill_sb(sb: *mut super_block);
}
extern "C" {
    pub fn kernfs_init();
}
extern "C" {
    pub fn kernfs_find_and_get_node_by_id(root: *mut kernfs_root, id: u64_) -> *mut kernfs_node;
}
pub const kobj_ns_type_KOBJ_NS_TYPE_NONE: kobj_ns_type = 0;
pub const kobj_ns_type_KOBJ_NS_TYPE_NET: kobj_ns_type = 1;
pub const kobj_ns_type_KOBJ_NS_TYPES: kobj_ns_type = 2;
pub type kobj_ns_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_ns_type_operations {
    pub type_: kobj_ns_type,
    pub current_may_mount: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub grab_current_ns: ::core::option::Option<unsafe extern "C" fn() -> *mut core::ffi::c_void>,
    pub netlink_ns:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> *const core::ffi::c_void>,
    pub initial_ns: ::core::option::Option<unsafe extern "C" fn() -> *const core::ffi::c_void>,
    pub drop_ns: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
}
impl Default for kobj_ns_type_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kobj_ns_type_register(ops: *const kobj_ns_type_operations) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobj_ns_type_registered(type_: kobj_ns_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobj_child_ns_ops(parent: *mut kobject) -> *const kobj_ns_type_operations;
}
extern "C" {
    pub fn kobj_ns_ops(kobj: *mut kobject) -> *const kobj_ns_type_operations;
}
extern "C" {
    pub fn kobj_ns_current_may_mount(type_: kobj_ns_type) -> bool_;
}
extern "C" {
    pub fn kobj_ns_grab_current(type_: kobj_ns_type) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kobj_ns_netlink(type_: kobj_ns_type, sk: *mut sock) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn kobj_ns_initial(type_: kobj_ns_type) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn kobj_ns_drop(type_: kobj_ns_type, ns: *mut core::ffi::c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct attribute {
    pub name: *const core::ffi::c_char,
    pub mode: umode_t,
}
impl Default for attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct attribute_group {
    pub name: *const core::ffi::c_char,
    pub is_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: core::ffi::c_int,
        ) -> umode_t,
    >,
    pub is_bin_visible: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut bin_attribute,
            arg3: core::ffi::c_int,
        ) -> umode_t,
    >,
    pub attrs: *mut *mut attribute,
    pub bin_attrs: *mut *mut bin_attribute,
}
impl Default for attribute_group {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bin_attribute {
    pub attr: attribute,
    pub size: usize,
    pub private: *mut core::ffi::c_void,
    pub f_mapping: ::core::option::Option<unsafe extern "C" fn() -> *mut address_space>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut core::ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            arg3: *mut bin_attribute,
            arg4: *mut core::ffi::c_char,
            arg5: loff_t,
            arg6: usize,
        ) -> isize,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut file,
            arg2: *mut kobject,
            attr: *mut bin_attribute,
            vma: *mut vm_area_struct,
        ) -> core::ffi::c_int,
    >,
}
impl Default for bin_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sysfs_ops {
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut kobject,
            arg2: *mut attribute,
            arg3: *const core::ffi::c_char,
            arg4: usize,
        ) -> isize,
    >,
}
extern "C" {
    pub fn sysfs_create_dir_ns(
        kobj: *mut kobject,
        ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_dir(kobj: *mut kobject);
}
extern "C" {
    pub fn sysfs_rename_dir_ns(
        kobj: *mut kobject,
        new_name: *const core::ffi::c_char,
        new_ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_move_dir_ns(
        kobj: *mut kobject,
        new_parent_kobj: *mut kobject,
        new_ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_create_mount_point(
        parent_kobj: *mut kobject,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_mount_point(parent_kobj: *mut kobject, name: *const core::ffi::c_char);
}
extern "C" {
    pub fn sysfs_create_file_ns(
        kobj: *mut kobject,
        attr: *const attribute,
        ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_create_files(
        kobj: *mut kobject,
        attr: *const *const attribute,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_chmod_file(
        kobj: *mut kobject,
        attr: *const attribute,
        mode: umode_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_break_active_protection(
        kobj: *mut kobject,
        attr: *const attribute,
    ) -> *mut kernfs_node;
}
extern "C" {
    pub fn sysfs_unbreak_active_protection(kn: *mut kernfs_node);
}
extern "C" {
    pub fn sysfs_remove_file_ns(
        kobj: *mut kobject,
        attr: *const attribute,
        ns: *const core::ffi::c_void,
    );
}
extern "C" {
    pub fn sysfs_remove_file_self(kobj: *mut kobject, attr: *const attribute) -> bool_;
}
extern "C" {
    pub fn sysfs_remove_files(kobj: *mut kobject, attr: *const *const attribute);
}
extern "C" {
    pub fn sysfs_create_bin_file(
        kobj: *mut kobject,
        attr: *const bin_attribute,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_bin_file(kobj: *mut kobject, attr: *const bin_attribute);
}
extern "C" {
    pub fn sysfs_create_link(
        kobj: *mut kobject,
        target: *mut kobject,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_create_link_nowarn(
        kobj: *mut kobject,
        target: *mut kobject,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_link(kobj: *mut kobject, name: *const core::ffi::c_char);
}
extern "C" {
    pub fn sysfs_rename_link_ns(
        kobj: *mut kobject,
        target: *mut kobject,
        old_name: *const core::ffi::c_char,
        new_name: *const core::ffi::c_char,
        new_ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_delete_link(dir: *mut kobject, targ: *mut kobject, name: *const core::ffi::c_char);
}
extern "C" {
    pub fn sysfs_create_group(kobj: *mut kobject, grp: *const attribute_group) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_create_groups(
        kobj: *mut kobject,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_update_groups(
        kobj: *mut kobject,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_update_group(kobj: *mut kobject, grp: *const attribute_group) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_group(kobj: *mut kobject, grp: *const attribute_group);
}
extern "C" {
    pub fn sysfs_remove_groups(kobj: *mut kobject, groups: *mut *const attribute_group);
}
extern "C" {
    pub fn sysfs_add_file_to_group(
        kobj: *mut kobject,
        attr: *const attribute,
        group: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_file_from_group(
        kobj: *mut kobject,
        attr: *const attribute,
        group: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn sysfs_merge_group(kobj: *mut kobject, grp: *const attribute_group) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_unmerge_group(kobj: *mut kobject, grp: *const attribute_group);
}
extern "C" {
    pub fn sysfs_add_link_to_group(
        kobj: *mut kobject,
        group_name: *const core::ffi::c_char,
        target: *mut kobject,
        link_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_remove_link_from_group(
        kobj: *mut kobject,
        group_name: *const core::ffi::c_char,
        link_name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn compat_only_sysfs_link_entry_to_kobj(
        kobj: *mut kobject,
        target_kobj: *mut kobject,
        target_name: *const core::ffi::c_char,
        symlink_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_notify(
        kobj: *mut kobject,
        dir: *const core::ffi::c_char,
        attr: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn sysfs_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_file_change_owner(
        kobj: *mut kobject,
        name: *const core::ffi::c_char,
        kuid: kuid_t,
        kgid: kgid_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_change_owner(kobj: *mut kobject, kuid: kuid_t, kgid: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_link_change_owner(
        kobj: *mut kobject,
        targ: *mut kobject,
        name: *const core::ffi::c_char,
        kuid: kuid_t,
        kgid: kgid_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_groups_change_owner(
        kobj: *mut kobject,
        groups: *mut *const attribute_group,
        kuid: kuid_t,
        kgid: kgid_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_group_change_owner(
        kobj: *mut kobject,
        groups: *const attribute_group,
        kuid: kuid_t,
        kgid: kgid_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_emit(
        buf: *mut core::ffi::c_char,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_emit_at(
        buf: *mut core::ffi::c_char,
        at: core::ffi::c_int,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut uevent_seqnum: u64_;
}
pub const kobject_action_KOBJ_ADD: kobject_action = 0;
pub const kobject_action_KOBJ_REMOVE: kobject_action = 1;
pub const kobject_action_KOBJ_CHANGE: kobject_action = 2;
pub const kobject_action_KOBJ_MOVE: kobject_action = 3;
pub const kobject_action_KOBJ_ONLINE: kobject_action = 4;
pub const kobject_action_KOBJ_OFFLINE: kobject_action = 5;
pub const kobject_action_KOBJ_BIND: kobject_action = 6;
pub const kobject_action_KOBJ_UNBIND: kobject_action = 7;
pub type kobject_action = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobject {
    pub name: *const core::ffi::c_char,
    pub entry: list_head,
    pub parent: *mut kobject,
    pub kset: *mut kset,
    pub ktype: *const kobj_type,
    pub sd: *mut kernfs_node,
    pub kref: kref,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for kobject {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl kobject {
    #[inline]
    pub fn state_initialized(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_initialized(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_in_sysfs(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_in_sysfs(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_add_uevent_sent(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_add_uevent_sent(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_remove_uevent_sent(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_state_remove_uevent_sent(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uevent_suppress(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_uevent_suppress(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        state_initialized: core::ffi::c_uint,
        state_in_sysfs: core::ffi::c_uint,
        state_add_uevent_sent: core::ffi::c_uint,
        state_remove_uevent_sent: core::ffi::c_uint,
        uevent_suppress: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let state_initialized: u32 = unsafe { ::core::mem::transmute(state_initialized) };
            state_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let state_in_sysfs: u32 = unsafe { ::core::mem::transmute(state_in_sysfs) };
            state_in_sysfs as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let state_add_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_add_uevent_sent) };
            state_add_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_remove_uevent_sent: u32 =
                unsafe { ::core::mem::transmute(state_remove_uevent_sent) };
            state_remove_uevent_sent as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let uevent_suppress: u32 = unsafe { ::core::mem::transmute(uevent_suppress) };
            uevent_suppress as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn kobject_set_name(
        kobj: *mut kobject,
        name: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_set_name_vargs(
        kobj: *mut kobject,
        fmt: *const core::ffi::c_char,
        vargs: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_init(kobj: *mut kobject, ktype: *const kobj_type);
}
extern "C" {
    pub fn kobject_add(
        kobj: *mut kobject,
        parent: *mut kobject,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_init_and_add(
        kobj: *mut kobject,
        ktype: *const kobj_type,
        parent: *mut kobject,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_del(kobj: *mut kobject);
}
extern "C" {
    pub fn kobject_create_and_add(
        name: *const core::ffi::c_char,
        parent: *mut kobject,
    ) -> *mut kobject;
}
extern "C" {
    pub fn kobject_rename(
        arg1: *mut kobject,
        new_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_move(arg1: *mut kobject, arg2: *mut kobject) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_get(kobj: *mut kobject) -> *mut kobject;
}
extern "C" {
    pub fn kobject_get_unless_zero(kobj: *mut kobject) -> *mut kobject;
}
extern "C" {
    pub fn kobject_put(kobj: *mut kobject);
}
extern "C" {
    pub fn kobject_namespace(kobj: *mut kobject) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn kobject_get_ownership(kobj: *mut kobject, uid: *mut kuid_t, gid: *mut kgid_t);
}
extern "C" {
    pub fn kobject_get_path(kobj: *mut kobject, flag: gfp_t) -> *mut core::ffi::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_type {
    pub release: ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject)>,
    pub sysfs_ops: *const sysfs_ops,
    pub default_groups: *mut *const attribute_group,
    pub child_ns_type: ::core::option::Option<
        unsafe extern "C" fn(kobj: *mut kobject) -> *const kobj_ns_type_operations,
    >,
    pub namespace: ::core::option::Option<
        unsafe extern "C" fn(kobj: *mut kobject) -> *const core::ffi::c_void,
    >,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(kobj: *mut kobject, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
}
impl Default for kobj_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_uevent_env {
    pub argv: [*mut core::ffi::c_char; 3usize],
    pub envp: [*mut core::ffi::c_char; 64usize],
    pub envp_idx: core::ffi::c_int,
    pub buf: [core::ffi::c_char; 2048usize],
    pub buflen: core::ffi::c_int,
}
impl Default for kobj_uevent_env {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kset_uevent_ops {
    pub filter:
        ::core::option::Option<unsafe extern "C" fn(kobj: *mut kobject) -> core::ffi::c_int>,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(kobj: *mut kobject) -> *const core::ffi::c_char,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(kobj: *mut kobject, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kobj_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            kobj: *mut kobject,
            attr: *mut kobj_attribute,
            buf: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            kobj: *mut kobject,
            attr: *mut kobj_attribute,
            buf: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for kobj_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static kobj_sysfs_ops: sysfs_ops;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kset {
    pub list: list_head,
    pub list_lock: spinlock_t,
    pub kobj: kobject,
    pub uevent_ops: *const kset_uevent_ops,
}
impl Default for kset {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kset_init(kset: *mut kset);
}
extern "C" {
    pub fn kset_register(kset: *mut kset) -> core::ffi::c_int;
}
extern "C" {
    pub fn kset_unregister(kset: *mut kset);
}
extern "C" {
    pub fn kset_create_and_add(
        name: *const core::ffi::c_char,
        u: *const kset_uevent_ops,
        parent_kobj: *mut kobject,
    ) -> *mut kset;
}
extern "C" {
    pub fn kset_find_obj(arg1: *mut kset, arg2: *const core::ffi::c_char) -> *mut kobject;
}
extern "C" {
    pub static mut kernel_kobj: *mut kobject;
}
extern "C" {
    pub static mut mm_kobj: *mut kobject;
}
extern "C" {
    pub static mut hypervisor_kobj: *mut kobject;
}
extern "C" {
    pub static mut power_kobj: *mut kobject;
}
extern "C" {
    pub static mut firmware_kobj: *mut kobject;
}
extern "C" {
    pub fn kobject_uevent(kobj: *mut kobject, action: kobject_action) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_uevent_env(
        kobj: *mut kobject,
        action: kobject_action,
        envp: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kobject_synth_uevent(
        kobj: *mut kobject,
        buf: *const core::ffi::c_char,
        count: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn add_uevent_var(
        env: *mut kobj_uevent_env,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
pub const KERNEL_PARAM_OPS_FL_NOARG: core::ffi::c_uint = 1;
pub type _bindgen_ty_85 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_param_ops {
    pub flags: core::ffi::c_uint,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            val: *const core::ffi::c_char,
            kp: *const kernel_param,
        ) -> core::ffi::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            buffer: *mut core::ffi::c_char,
            kp: *const kernel_param,
        ) -> core::ffi::c_int,
    >,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg: *mut core::ffi::c_void)>,
}
pub const KERNEL_PARAM_FL_UNSAFE: core::ffi::c_uint = 1;
pub const KERNEL_PARAM_FL_HWPARAM: core::ffi::c_uint = 2;
pub type _bindgen_ty_86 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kernel_param {
    pub name: *const core::ffi::c_char,
    pub mod_: *mut module,
    pub ops: *const kernel_param_ops,
    pub perm: u16_,
    pub level: s8,
    pub flags: u8_,
    pub __bindgen_anon_1: kernel_param__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union kernel_param__bindgen_ty_1 {
    pub arg: *mut core::ffi::c_void,
    pub str_: *const kparam_string,
    pub arr: *const kparam_array,
    _bindgen_union_align: u64,
}
impl Default for kernel_param__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for kernel_param {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut __start___param: [kernel_param; 0usize];
}
extern "C" {
    pub static mut __stop___param: [kernel_param; 0usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kparam_string {
    pub maxlen: core::ffi::c_uint,
    pub string: *mut core::ffi::c_char,
}
impl Default for kparam_string {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kparam_array {
    pub max: core::ffi::c_uint,
    pub elemsize: core::ffi::c_uint,
    pub num: *mut core::ffi::c_uint,
    pub ops: *const kernel_param_ops,
    pub elem: *mut core::ffi::c_void,
}
impl Default for kparam_array {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kernel_param_lock(mod_: *mut module);
}
extern "C" {
    pub fn kernel_param_unlock(mod_: *mut module);
}
extern "C" {
    pub fn parameq(name1: *const core::ffi::c_char, name2: *const core::ffi::c_char) -> bool_;
}
extern "C" {
    pub fn parameqn(
        name1: *const core::ffi::c_char,
        name2: *const core::ffi::c_char,
        n: usize,
    ) -> bool_;
}
extern "C" {
    pub fn parse_args(
        name: *const core::ffi::c_char,
        args: *mut core::ffi::c_char,
        params: *const kernel_param,
        num: core::ffi::c_uint,
        level_min: s16,
        level_max: s16,
        arg: *mut core::ffi::c_void,
        unknown: ::core::option::Option<
            unsafe extern "C" fn(
                param: *mut core::ffi::c_char,
                val: *mut core::ffi::c_char,
                doing: *const core::ffi::c_char,
                arg: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn destroy_params(params: *const kernel_param, num: core::ffi::c_uint);
}
extern "C" {
    pub static param_ops_byte: kernel_param_ops;
}
extern "C" {
    pub fn param_set_byte(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_byte(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_short: kernel_param_ops;
}
extern "C" {
    pub fn param_set_short(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_short(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_ushort: kernel_param_ops;
}
extern "C" {
    pub fn param_set_ushort(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_ushort(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_int: kernel_param_ops;
}
extern "C" {
    pub fn param_set_int(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_int(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_uint: kernel_param_ops;
}
extern "C" {
    pub fn param_set_uint(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_uint(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_set_uint_minmax(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
        min: core::ffi::c_uint,
        max: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_long: kernel_param_ops;
}
extern "C" {
    pub fn param_set_long(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_long(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_ulong: kernel_param_ops;
}
extern "C" {
    pub fn param_set_ulong(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_ulong(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_ullong: kernel_param_ops;
}
extern "C" {
    pub fn param_set_ullong(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_ullong(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_hexint: kernel_param_ops;
}
extern "C" {
    pub fn param_set_hexint(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_hexint(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_charp: kernel_param_ops;
}
extern "C" {
    pub fn param_set_charp(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_charp(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_free_charp(arg: *mut core::ffi::c_void);
}
extern "C" {
    pub static param_ops_bool: kernel_param_ops;
}
extern "C" {
    pub fn param_set_bool(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_bool(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_bool_enable_only: kernel_param_ops;
}
extern "C" {
    pub fn param_set_bool_enable_only(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_invbool: kernel_param_ops;
}
extern "C" {
    pub fn param_set_invbool(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_invbool(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static param_ops_bint: kernel_param_ops;
}
extern "C" {
    pub fn param_set_bint(
        val: *const core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
pub const hwparam_type_hwparam_ioport: hwparam_type = 0;
pub const hwparam_type_hwparam_iomem: hwparam_type = 1;
pub const hwparam_type_hwparam_ioport_or_iomem: hwparam_type = 2;
pub const hwparam_type_hwparam_irq: hwparam_type = 3;
pub const hwparam_type_hwparam_dma: hwparam_type = 4;
pub const hwparam_type_hwparam_dma_addr: hwparam_type = 5;
pub const hwparam_type_hwparam_other: hwparam_type = 6;
pub type hwparam_type = core::ffi::c_uint;
extern "C" {
    pub static param_array_ops: kernel_param_ops;
}
extern "C" {
    pub static param_ops_string: kernel_param_ops;
}
extern "C" {
    pub fn param_set_copystring(
        val: *const core::ffi::c_char,
        arg1: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn param_get_string(
        buffer: *mut core::ffi::c_char,
        kp: *const kernel_param,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn module_param_sysfs_setup(
        mod_: *mut module,
        kparam: *const kernel_param,
        num_params: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn module_param_sysfs_remove(mod_: *mut module);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct latch_tree_node {
    pub node: [rb_node; 2usize],
}
impl Default for latch_tree_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct latch_tree_root {
    pub seq: seqcount_latch_t,
    pub tree: [rb_root; 2usize],
}
impl Default for latch_tree_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct latch_tree_ops {
    pub less: ::core::option::Option<
        unsafe extern "C" fn(a: *mut latch_tree_node, b: *mut latch_tree_node) -> bool_,
    >,
    pub comp: ::core::option::Option<
        unsafe extern "C" fn(
            key: *mut core::ffi::c_void,
            b: *mut latch_tree_node,
        ) -> core::ffi::c_int,
    >,
}
pub const EI_ETYPE_NONE: core::ffi::c_uint = 0;
pub const EI_ETYPE_NULL: core::ffi::c_uint = 1;
pub const EI_ETYPE_ERRNO: core::ffi::c_uint = 2;
pub const EI_ETYPE_ERRNO_NULL: core::ffi::c_uint = 3;
pub const EI_ETYPE_TRUE: core::ffi::c_uint = 4;
pub type _bindgen_ty_87 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct error_injection_entry {
    pub addr: core::ffi::c_ulong,
    pub etype: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_print_flags {
    pub mask: core::ffi::c_ulong,
    pub name: *const core::ffi::c_char,
}
impl Default for trace_print_flags {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct trace_print_flags_u64 {
    pub mask: core::ffi::c_ulonglong,
    pub name: *const core::ffi::c_char,
}
impl Default for trace_print_flags_u64 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint_func {
    pub func: *mut core::ffi::c_void,
    pub data: *mut core::ffi::c_void,
    pub prio: core::ffi::c_int,
}
impl Default for tracepoint_func {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tracepoint {
    pub name: *const core::ffi::c_char,
    pub key: static_key,
    pub static_call_key: *mut static_call_key,
    pub static_call_tramp: *mut core::ffi::c_void,
    pub iterator: *mut core::ffi::c_void,
    pub regfunc: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub unregfunc: ::core::option::Option<unsafe extern "C" fn()>,
    pub funcs: *mut tracepoint_func,
}
impl Default for tracepoint {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type tracepoint_ptr_t = *mut tracepoint;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct bpf_raw_event_map {
    pub tp: *mut tracepoint,
    pub bpf_func: *mut core::ffi::c_void,
    pub num_args: u32_,
    pub writable_size: u32_,
}
impl Default for bpf_raw_event_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn module_emit_got_entry(mod_: *mut module, val: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn module_emit_plt_entry(mod_: *mut module, val: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mod_section {
    pub shdr: *mut Elf64_Shdr,
    pub num_entries: core::ffi::c_int,
    pub max_entries: core::ffi::c_int,
}
impl Default for mod_section {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mod_arch_specific {
    pub got: mod_section,
    pub plt: mod_section,
    pub got_plt: mod_section,
}
impl Default for mod_arch_specific {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct got_entry {
    pub symbol_addr: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct plt_entry {
    pub insn_auipc: u32_,
    pub insn_ld: u32_,
    pub insn_jr: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct modversion_info {
    pub crc: core::ffi::c_ulong,
    pub name: [core::ffi::c_char; 56usize],
}
impl Default for modversion_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_kobject {
    pub kobj: kobject,
    pub mod_: *mut module,
    pub drivers_dir: *mut kobject,
    pub mp: *mut module_param_attrs,
    pub kobj_completion: *mut completion,
}
impl Default for module_kobject {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module_attribute,
            arg2: *mut module_kobject,
            arg3: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
    pub setup: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut module, arg2: *const core::ffi::c_char),
    >,
    pub test: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module) -> core::ffi::c_int>,
    pub free: ::core::option::Option<unsafe extern "C" fn(arg1: *mut module)>,
}
impl Default for module_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_version_attribute {
    pub mattr: module_attribute,
    pub module_name: *const core::ffi::c_char,
    pub version: *const core::ffi::c_char,
}
impl Default for module_version_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __modver_version_show(
        arg1: *mut module_attribute,
        arg2: *mut module_kobject,
        arg3: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub static mut module_uevent: module_attribute;
}
extern "C" {
    pub fn init_module() -> core::ffi::c_int;
}
extern "C" {
    pub fn cleanup_module();
}
extern "C" {
    pub static mut modules_disabled: core::ffi::c_int;
}
extern "C" {
    pub fn __symbol_get(symbol: *const core::ffi::c_char) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __symbol_get_gpl(symbol: *const core::ffi::c_char) -> *mut core::ffi::c_void;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_use {
    pub source_list: list_head,
    pub target_list: list_head,
    pub source: *mut module,
    pub target: *mut module,
}
impl Default for module_use {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const module_state_MODULE_STATE_LIVE: module_state = 0;
pub const module_state_MODULE_STATE_COMING: module_state = 1;
pub const module_state_MODULE_STATE_GOING: module_state = 2;
pub const module_state_MODULE_STATE_UNFORMED: module_state = 3;
pub type module_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mod_tree_node {
    pub mod_: *mut module,
    pub node: latch_tree_node,
}
impl Default for mod_tree_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_layout {
    pub base: *mut core::ffi::c_void,
    pub size: core::ffi::c_uint,
    pub text_size: core::ffi::c_uint,
    pub ro_size: core::ffi::c_uint,
    pub ro_after_init_size: core::ffi::c_uint,
    pub mtn: mod_tree_node,
}
impl Default for module_layout {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mod_kallsyms {
    pub symtab: *mut Elf64_Sym,
    pub num_symtab: core::ffi::c_uint,
    pub strtab: *mut core::ffi::c_char,
    pub typetab: *mut core::ffi::c_char,
}
impl Default for mod_kallsyms {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __module_text_address(addr: core::ffi::c_ulong) -> *mut module;
}
extern "C" {
    pub fn __module_address(addr: core::ffi::c_ulong) -> *mut module;
}
extern "C" {
    pub fn is_module_address(addr: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn __is_module_percpu_address(
        addr: core::ffi::c_ulong,
        can_addr: *mut core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn is_module_percpu_address(addr: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn is_module_text_address(addr: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn find_module(name: *const core::ffi::c_char) -> *mut module;
}
extern "C" {
    pub fn module_get_kallsym(
        symnum: core::ffi::c_uint,
        value: *mut core::ffi::c_ulong,
        type_: *mut core::ffi::c_char,
        name: *mut core::ffi::c_char,
        module_name: *mut core::ffi::c_char,
        exported: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn module_kallsyms_lookup_name(name: *const core::ffi::c_char) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __module_put_and_kthread_exit(mod_: *mut module, code: core::ffi::c_long);
}
extern "C" {
    pub fn module_refcount(mod_: *mut module) -> core::ffi::c_int;
}
extern "C" {
    pub fn __symbol_put(symbol: *const core::ffi::c_char);
}
extern "C" {
    pub fn symbol_put_addr(addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn __module_get(module: *mut module);
}
extern "C" {
    pub fn try_module_get(module: *mut module) -> bool_;
}
extern "C" {
    pub fn module_put(module: *mut module);
}
extern "C" {
    pub fn dereference_module_function_descriptor(
        mod_: *mut module,
        ptr: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn module_address_lookup(
        addr: core::ffi::c_ulong,
        symbolsize: *mut core::ffi::c_ulong,
        offset: *mut core::ffi::c_ulong,
        modname: *mut *mut core::ffi::c_char,
        modbuildid: *mut *const core::ffi::c_uchar,
        namebuf: *mut core::ffi::c_char,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn lookup_module_symbol_name(
        addr: core::ffi::c_ulong,
        symname: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lookup_module_symbol_attrs(
        addr: core::ffi::c_ulong,
        size: *mut core::ffi::c_ulong,
        offset: *mut core::ffi::c_ulong,
        modname: *mut core::ffi::c_char,
        name: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn register_module_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_module_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn print_modules();
}
extern "C" {
    pub fn set_module_sig_enforced();
}
extern "C" {
    pub static mut module_kset: *mut kset;
}
extern "C" {
    pub static mut module_ktype: kobj_type;
}
extern "C" {
    pub static mut module_sysfs_initialized: core::ffi::c_int;
}
extern "C" {
    pub fn module_bug_finalize(arg1: *const Elf64_Ehdr, arg2: *const Elf64_Shdr, arg3: *mut module);
}
extern "C" {
    pub fn module_bug_cleanup(arg1: *mut module);
}
extern "C" {
    pub fn module_kallsyms_on_each_symbol(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut core::ffi::c_void,
                arg2: *const core::ffi::c_char,
                arg3: *mut module,
                arg4: core::ffi::c_ulong,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
pub const kunit_status_KUNIT_SUCCESS: kunit_status = 0;
pub const kunit_status_KUNIT_FAILURE: kunit_status = 1;
pub const kunit_status_KUNIT_SKIPPED: kunit_status = 2;
pub type kunit_status = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_case {
    pub run_case: ::core::option::Option<unsafe extern "C" fn(test: *mut kunit)>,
    pub name: *const core::ffi::c_char,
    pub generate_params: ::core::option::Option<
        unsafe extern "C" fn(
            prev: *const core::ffi::c_void,
            desc: *mut core::ffi::c_char,
        ) -> *const core::ffi::c_void,
    >,
    pub status: kunit_status,
    pub log: *mut core::ffi::c_char,
}
impl Default for kunit_case {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_suite {
    pub name: [core::ffi::c_char; 256usize],
    pub suite_init:
        ::core::option::Option<unsafe extern "C" fn(suite: *mut kunit_suite) -> core::ffi::c_int>,
    pub suite_exit: ::core::option::Option<unsafe extern "C" fn(suite: *mut kunit_suite)>,
    pub init: ::core::option::Option<unsafe extern "C" fn(test: *mut kunit) -> core::ffi::c_int>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(test: *mut kunit)>,
    pub test_cases: *mut kunit_case,
    pub status_comment: [core::ffi::c_char; 256usize],
    pub debugfs: *mut dentry,
    pub log: *mut core::ffi::c_char,
    pub suite_init_err: core::ffi::c_int,
}
impl Default for kunit_suite {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit {
    pub priv_: *mut core::ffi::c_void,
    pub name: *const core::ffi::c_char,
    pub log: *mut core::ffi::c_char,
    pub try_catch: kunit_try_catch,
    pub param_value: *const core::ffi::c_void,
    pub param_index: core::ffi::c_int,
    pub lock: spinlock_t,
    pub status: kunit_status,
    pub resources: list_head,
    pub status_comment: [core::ffi::c_char; 256usize],
}
impl Default for kunit {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kunit_enabled() -> bool_;
}
extern "C" {
    pub fn kunit_init_test(
        test: *mut kunit,
        name: *const core::ffi::c_char,
        log: *mut core::ffi::c_char,
    );
}
extern "C" {
    pub fn kunit_run_tests(suite: *mut kunit_suite) -> core::ffi::c_int;
}
extern "C" {
    pub fn kunit_suite_num_test_cases(suite: *mut kunit_suite) -> usize;
}
extern "C" {
    pub fn kunit_test_case_num(
        suite: *mut kunit_suite,
        test_case: *mut kunit_case,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __kunit_test_suites_init(
        suites: *const *mut kunit_suite,
        num_suites: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __kunit_test_suites_exit(suites: *mut *mut kunit_suite, num_suites: core::ffi::c_int);
}
extern "C" {
    pub fn kunit_suite_has_succeeded(suite: *mut kunit_suite) -> kunit_status;
}
extern "C" {
    pub fn kunit_kmalloc_array(
        test: *mut kunit,
        n: usize,
        size: usize,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kunit_kfree(test: *mut kunit, ptr: *const core::ffi::c_void);
}
extern "C" {
    pub fn kunit_cleanup(test: *mut kunit);
}
extern "C" {
    pub fn kunit_log_append(log: *mut core::ffi::c_char, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn kunit_do_failed_assertion(
        test: *mut kunit,
        loc: *const kunit_loc,
        type_: kunit_assert_type,
        assert: *const kunit_assert,
        assert_format: assert_format_t,
        fmt: *const core::ffi::c_char,
        ...
    );
}
pub type kunit_resource_init_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut kunit_resource,
        arg2: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
pub type kunit_resource_free_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut kunit_resource)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kunit_resource {
    pub data: *mut core::ffi::c_void,
    pub name: *const core::ffi::c_char,
    pub free: kunit_resource_free_t,
    pub refcount: kref,
    pub node: list_head,
    pub should_kfree: bool_,
}
impl Default for kunit_resource {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __kunit_add_resource(
        test: *mut kunit,
        init: kunit_resource_init_t,
        free: kunit_resource_free_t,
        res: *mut kunit_resource,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
pub type kunit_resource_match_t = ::core::option::Option<
    unsafe extern "C" fn(
        test: *mut kunit,
        res: *mut kunit_resource,
        match_data: *mut core::ffi::c_void,
    ) -> bool_,
>;
extern "C" {
    pub fn kunit_destroy_resource(
        test: *mut kunit,
        match_: kunit_resource_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kunit_remove_resource(test: *mut kunit, res: *mut kunit_resource);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clk_notifier {
    pub clk: *mut clk,
    pub notifier_head: srcu_notifier_head,
    pub node: list_head,
}
impl Default for clk_notifier {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clk_notifier_data {
    pub clk: *mut clk,
    pub old_rate: core::ffi::c_ulong,
    pub new_rate: core::ffi::c_ulong,
}
impl Default for clk_notifier_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct clk_bulk_data {
    pub id: *const core::ffi::c_char,
    pub clk: *mut clk,
}
impl Default for clk_bulk_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn clk_notifier_register(clk: *mut clk, nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_notifier_unregister(clk: *mut clk, nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_clk_notifier_register(
        dev: *mut device,
        clk: *mut clk,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_get_accuracy(clk: *mut clk) -> core::ffi::c_long;
}
extern "C" {
    pub fn clk_set_phase(clk: *mut clk, degrees: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_get_phase(clk: *mut clk) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_set_duty_cycle(
        clk: *mut clk,
        num: core::ffi::c_uint,
        den: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_get_scaled_duty_cycle(clk: *mut clk, scale: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_is_match(p: *const clk, q: *const clk) -> bool_;
}
extern "C" {
    pub fn clk_prepare(clk: *mut clk) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_bulk_prepare(
        num_clks: core::ffi::c_int,
        clks: *const clk_bulk_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_is_enabled_when_prepared(clk: *mut clk) -> bool_;
}
extern "C" {
    pub fn clk_unprepare(clk: *mut clk);
}
extern "C" {
    pub fn clk_bulk_unprepare(num_clks: core::ffi::c_int, clks: *const clk_bulk_data);
}
extern "C" {
    pub fn clk_get(dev: *mut device, id: *const core::ffi::c_char) -> *mut clk;
}
extern "C" {
    pub fn clk_bulk_get(
        dev: *mut device,
        num_clks: core::ffi::c_int,
        clks: *mut clk_bulk_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_bulk_get_all(dev: *mut device, clks: *mut *mut clk_bulk_data) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_bulk_get_optional(
        dev: *mut device,
        num_clks: core::ffi::c_int,
        clks: *mut clk_bulk_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_clk_bulk_get(
        dev: *mut device,
        num_clks: core::ffi::c_int,
        clks: *mut clk_bulk_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_clk_bulk_get_optional(
        dev: *mut device,
        num_clks: core::ffi::c_int,
        clks: *mut clk_bulk_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_clk_bulk_get_all(
        dev: *mut device,
        clks: *mut *mut clk_bulk_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_clk_get(dev: *mut device, id: *const core::ffi::c_char) -> *mut clk;
}
extern "C" {
    pub fn devm_clk_get_prepared(dev: *mut device, id: *const core::ffi::c_char) -> *mut clk;
}
extern "C" {
    pub fn devm_clk_get_enabled(dev: *mut device, id: *const core::ffi::c_char) -> *mut clk;
}
extern "C" {
    pub fn devm_clk_get_optional(dev: *mut device, id: *const core::ffi::c_char) -> *mut clk;
}
extern "C" {
    pub fn devm_clk_get_optional_prepared(
        dev: *mut device,
        id: *const core::ffi::c_char,
    ) -> *mut clk;
}
extern "C" {
    pub fn devm_clk_get_optional_enabled(
        dev: *mut device,
        id: *const core::ffi::c_char,
    ) -> *mut clk;
}
extern "C" {
    pub fn devm_get_clk_from_child(
        dev: *mut device,
        np: *mut device_node,
        con_id: *const core::ffi::c_char,
    ) -> *mut clk;
}
extern "C" {
    pub fn clk_rate_exclusive_get(clk: *mut clk) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_rate_exclusive_put(clk: *mut clk);
}
extern "C" {
    pub fn clk_enable(clk: *mut clk) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_bulk_enable(
        num_clks: core::ffi::c_int,
        clks: *const clk_bulk_data,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_disable(clk: *mut clk);
}
extern "C" {
    pub fn clk_bulk_disable(num_clks: core::ffi::c_int, clks: *const clk_bulk_data);
}
extern "C" {
    pub fn clk_get_rate(clk: *mut clk) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn clk_put(clk: *mut clk);
}
extern "C" {
    pub fn clk_bulk_put(num_clks: core::ffi::c_int, clks: *mut clk_bulk_data);
}
extern "C" {
    pub fn clk_bulk_put_all(num_clks: core::ffi::c_int, clks: *mut clk_bulk_data);
}
extern "C" {
    pub fn devm_clk_put(dev: *mut device, clk: *mut clk);
}
extern "C" {
    pub fn clk_round_rate(clk: *mut clk, rate: core::ffi::c_ulong) -> core::ffi::c_long;
}
extern "C" {
    pub fn clk_set_rate(clk: *mut clk, rate: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_set_rate_exclusive(clk: *mut clk, rate: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_has_parent(clk: *const clk, parent: *const clk) -> bool_;
}
extern "C" {
    pub fn clk_set_rate_range(
        clk: *mut clk,
        min: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_set_min_rate(clk: *mut clk, rate: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_set_max_rate(clk: *mut clk, rate: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_set_parent(clk: *mut clk, parent: *mut clk) -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_get_parent(clk: *mut clk) -> *mut clk;
}
extern "C" {
    pub fn clk_get_sys(
        dev_id: *const core::ffi::c_char,
        con_id: *const core::ffi::c_char,
    ) -> *mut clk;
}
extern "C" {
    pub fn clk_save_context() -> core::ffi::c_int;
}
extern "C" {
    pub fn clk_restore_context();
}
extern "C" {
    pub fn of_clk_get(np: *mut device_node, index: core::ffi::c_int) -> *mut clk;
}
extern "C" {
    pub fn of_clk_get_by_name(np: *mut device_node, name: *const core::ffi::c_char) -> *mut clk;
}
extern "C" {
    pub fn of_clk_get_from_provider(clkspec: *mut of_phandle_args) -> *mut clk;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_printk_info {
    pub subsystem: [core::ffi::c_char; 16usize],
    pub device: [core::ffi::c_char; 48usize],
}
impl Default for dev_printk_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn dev_vprintk_emit(
        level: core::ffi::c_int,
        dev: *const device,
        fmt: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_printk_emit(
        level: core::ffi::c_int,
        dev: *const device,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn _dev_printk(
        level: *const core::ffi::c_char,
        dev: *const device,
        fmt: *const core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn _dev_emerg(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_alert(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_crit(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_err(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_warn(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_notice(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn _dev_info(dev: *const device, fmt: *const core::ffi::c_char, ...);
}
pub const cpu_idle_type_CPU_IDLE: cpu_idle_type = 0;
pub const cpu_idle_type_CPU_NOT_IDLE: cpu_idle_type = 1;
pub const cpu_idle_type_CPU_NEWLY_IDLE: cpu_idle_type = 2;
pub const cpu_idle_type_CPU_MAX_IDLE_TYPES: cpu_idle_type = 3;
pub type cpu_idle_type = core::ffi::c_uint;
extern "C" {
    pub fn wake_up_if_idle(cpu: core::ffi::c_int);
}
pub const __SD_BALANCE_NEWIDLE: core::ffi::c_uint = 0;
pub const __SD_BALANCE_EXEC: core::ffi::c_uint = 1;
pub const __SD_BALANCE_FORK: core::ffi::c_uint = 2;
pub const __SD_BALANCE_WAKE: core::ffi::c_uint = 3;
pub const __SD_WAKE_AFFINE: core::ffi::c_uint = 4;
pub const __SD_ASYM_CPUCAPACITY: core::ffi::c_uint = 5;
pub const __SD_ASYM_CPUCAPACITY_FULL: core::ffi::c_uint = 6;
pub const __SD_SHARE_CPUCAPACITY: core::ffi::c_uint = 7;
pub const __SD_SHARE_PKG_RESOURCES: core::ffi::c_uint = 8;
pub const __SD_SERIALIZE: core::ffi::c_uint = 9;
pub const __SD_ASYM_PACKING: core::ffi::c_uint = 10;
pub const __SD_PREFER_SIBLING: core::ffi::c_uint = 11;
pub const __SD_OVERLAP: core::ffi::c_uint = 12;
pub const __SD_NUMA: core::ffi::c_uint = 13;
pub const __SD_FLAG_CNT: core::ffi::c_uint = 14;
pub type _bindgen_ty_88 = core::ffi::c_uint;
pub const SD_BALANCE_NEWIDLE: core::ffi::c_uint = 1;
pub const SD_BALANCE_EXEC: core::ffi::c_uint = 2;
pub const SD_BALANCE_FORK: core::ffi::c_uint = 4;
pub const SD_BALANCE_WAKE: core::ffi::c_uint = 8;
pub const SD_WAKE_AFFINE: core::ffi::c_uint = 16;
pub const SD_ASYM_CPUCAPACITY: core::ffi::c_uint = 32;
pub const SD_ASYM_CPUCAPACITY_FULL: core::ffi::c_uint = 64;
pub const SD_SHARE_CPUCAPACITY: core::ffi::c_uint = 128;
pub const SD_SHARE_PKG_RESOURCES: core::ffi::c_uint = 256;
pub const SD_SERIALIZE: core::ffi::c_uint = 512;
pub const SD_ASYM_PACKING: core::ffi::c_uint = 1024;
pub const SD_PREFER_SIBLING: core::ffi::c_uint = 2048;
pub const SD_OVERLAP: core::ffi::c_uint = 4096;
pub const SD_NUMA: core::ffi::c_uint = 8192;
pub type _bindgen_ty_89 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sd_flag_debug {
    pub meta_flags: core::ffi::c_uint,
    pub name: *mut core::ffi::c_char,
}
impl Default for sd_flag_debug {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut sd_flag_debug: [sd_flag_debug; 0usize];
}
extern "C" {
    pub fn arch_asym_cpu_priority(cpu: core::ffi::c_int) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_domain_attr {
    pub relax_domain_level: core::ffi::c_int,
}
extern "C" {
    pub static mut sched_domain_level_max: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_domain_shared {
    pub ref_: atomic_t,
    pub nr_busy_cpus: atomic_t,
    pub has_idle_cores: core::ffi::c_int,
    pub nr_idle_scan: core::ffi::c_int,
}
#[repr(C)]
pub struct sched_domain {
    pub parent: *mut sched_domain,
    pub child: *mut sched_domain,
    pub groups: *mut sched_group,
    pub min_interval: core::ffi::c_ulong,
    pub max_interval: core::ffi::c_ulong,
    pub busy_factor: core::ffi::c_uint,
    pub imbalance_pct: core::ffi::c_uint,
    pub cache_nice_tries: core::ffi::c_uint,
    pub imb_numa_nr: core::ffi::c_uint,
    pub nohz_idle: core::ffi::c_int,
    pub flags: core::ffi::c_int,
    pub level: core::ffi::c_int,
    pub last_balance: core::ffi::c_ulong,
    pub balance_interval: core::ffi::c_uint,
    pub nr_balance_failed: core::ffi::c_uint,
    pub max_newidle_lb_cost: u64_,
    pub last_decay_max_lb_cost: core::ffi::c_ulong,
    pub avg_scan_cost: u64_,
    pub name: *mut core::ffi::c_char,
    pub __bindgen_anon_1: sched_domain__bindgen_ty_1,
    pub shared: *mut sched_domain_shared,
    pub span_weight: core::ffi::c_uint,
    pub span: __IncompleteArrayField<core::ffi::c_ulong>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sched_domain__bindgen_ty_1 {
    pub private: *mut core::ffi::c_void,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for sched_domain__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sched_domain {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn partition_sched_domains_locked(
        ndoms_new: core::ffi::c_int,
        doms_new: *mut cpumask_var_t,
        dattr_new: *mut sched_domain_attr,
    );
}
extern "C" {
    pub fn partition_sched_domains(
        ndoms_new: core::ffi::c_int,
        doms_new: *mut cpumask_var_t,
        dattr_new: *mut sched_domain_attr,
    );
}
extern "C" {
    pub fn alloc_sched_domains(ndoms: core::ffi::c_uint) -> *mut cpumask_var_t;
}
extern "C" {
    pub fn free_sched_domains(doms: *mut cpumask_var_t, ndoms: core::ffi::c_uint);
}
extern "C" {
    pub fn cpus_share_cache(this_cpu: core::ffi::c_int, that_cpu: core::ffi::c_int) -> bool_;
}
pub type sched_domain_mask_f =
    ::core::option::Option<unsafe extern "C" fn(cpu: core::ffi::c_int) -> *const cpumask>;
pub type sched_domain_flags_f = ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sd_data {
    pub sd: *mut *mut sched_domain,
    pub sds: *mut *mut sched_domain_shared,
    pub sg: *mut *mut sched_group,
    pub sgc: *mut *mut sched_group_capacity,
}
impl Default for sd_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_domain_topology_level {
    pub mask: sched_domain_mask_f,
    pub sd_flags: sched_domain_flags_f,
    pub flags: core::ffi::c_int,
    pub numa_level: core::ffi::c_int,
    pub data: sd_data,
    pub name: *mut core::ffi::c_char,
}
impl Default for sched_domain_topology_level {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn set_sched_topology(tl: *mut sched_domain_topology_level);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct em_perf_state {
    pub frequency: core::ffi::c_ulong,
    pub power: core::ffi::c_ulong,
    pub cost: core::ffi::c_ulong,
    pub flags: core::ffi::c_ulong,
}
#[repr(C)]
pub struct em_perf_domain {
    pub table: *mut em_perf_state,
    pub nr_perf_states: core::ffi::c_int,
    pub flags: core::ffi::c_ulong,
    pub cpus: __IncompleteArrayField<core::ffi::c_ulong>,
}
impl Default for em_perf_domain {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct em_data_callback {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct resource {
    pub start: resource_size_t,
    pub end: resource_size_t,
    pub name: *const core::ffi::c_char,
    pub flags: core::ffi::c_ulong,
    pub desc: core::ffi::c_ulong,
    pub parent: *mut resource,
    pub sibling: *mut resource,
    pub child: *mut resource,
}
impl Default for resource {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const IORES_DESC_NONE: core::ffi::c_uint = 0;
pub const IORES_DESC_CRASH_KERNEL: core::ffi::c_uint = 1;
pub const IORES_DESC_ACPI_TABLES: core::ffi::c_uint = 2;
pub const IORES_DESC_ACPI_NV_STORAGE: core::ffi::c_uint = 3;
pub const IORES_DESC_PERSISTENT_MEMORY: core::ffi::c_uint = 4;
pub const IORES_DESC_PERSISTENT_MEMORY_LEGACY: core::ffi::c_uint = 5;
pub const IORES_DESC_DEVICE_PRIVATE_MEMORY: core::ffi::c_uint = 6;
pub const IORES_DESC_RESERVED: core::ffi::c_uint = 7;
pub const IORES_DESC_SOFT_RESERVED: core::ffi::c_uint = 8;
pub const IORES_DESC_CXL: core::ffi::c_uint = 9;
pub type _bindgen_ty_90 = core::ffi::c_uint;
pub const IORES_MAP_SYSTEM_RAM: core::ffi::c_uint = 1;
pub const IORES_MAP_ENCRYPTED: core::ffi::c_uint = 2;
pub type _bindgen_ty_91 = core::ffi::c_uint;
extern "C" {
    pub static mut ioport_resource: resource;
}
extern "C" {
    pub static mut iomem_resource: resource;
}
extern "C" {
    pub fn request_resource_conflict(root: *mut resource, new: *mut resource) -> *mut resource;
}
extern "C" {
    pub fn request_resource(root: *mut resource, new: *mut resource) -> core::ffi::c_int;
}
extern "C" {
    pub fn release_resource(new: *mut resource) -> core::ffi::c_int;
}
extern "C" {
    pub fn release_child_resources(new: *mut resource);
}
extern "C" {
    pub fn reserve_region_with_split(
        root: *mut resource,
        start: resource_size_t,
        end: resource_size_t,
        name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn insert_resource_conflict(parent: *mut resource, new: *mut resource) -> *mut resource;
}
extern "C" {
    pub fn insert_resource(parent: *mut resource, new: *mut resource) -> core::ffi::c_int;
}
extern "C" {
    pub fn insert_resource_expand_to_fit(root: *mut resource, new: *mut resource);
}
extern "C" {
    pub fn remove_resource(old: *mut resource) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_remove_reservations(avail: *mut resource);
}
extern "C" {
    pub fn allocate_resource(
        root: *mut resource,
        new: *mut resource,
        size: resource_size_t,
        min: resource_size_t,
        max: resource_size_t,
        align: resource_size_t,
        alignf: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut core::ffi::c_void,
                arg2: *const resource,
                arg3: resource_size_t,
                arg4: resource_size_t,
            ) -> resource_size_t,
        >,
        alignf_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lookup_resource(root: *mut resource, start: resource_size_t) -> *mut resource;
}
extern "C" {
    pub fn adjust_resource(
        res: *mut resource,
        start: resource_size_t,
        size: resource_size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn resource_alignment(res: *mut resource) -> resource_size_t;
}
extern "C" {
    pub fn __request_region(
        arg1: *mut resource,
        start: resource_size_t,
        n: resource_size_t,
        name: *const core::ffi::c_char,
        flags: core::ffi::c_int,
    ) -> *mut resource;
}
extern "C" {
    pub fn __release_region(arg1: *mut resource, arg2: resource_size_t, arg3: resource_size_t);
}
extern "C" {
    pub fn devm_request_resource(
        dev: *mut device,
        root: *mut resource,
        new: *mut resource,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_release_resource(dev: *mut device, new: *mut resource);
}
extern "C" {
    pub fn __devm_request_region(
        dev: *mut device,
        parent: *mut resource,
        start: resource_size_t,
        n: resource_size_t,
        name: *const core::ffi::c_char,
    ) -> *mut resource;
}
extern "C" {
    pub fn __devm_release_region(
        dev: *mut device,
        parent: *mut resource,
        start: resource_size_t,
        n: resource_size_t,
    );
}
extern "C" {
    pub fn iomem_map_sanity_check(
        addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn iomem_is_exclusive(addr: u64_) -> bool_;
}
extern "C" {
    pub fn walk_system_ram_range(
        start_pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        arg: *mut core::ffi::c_void,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: core::ffi::c_ulong,
                arg2: core::ffi::c_ulong,
                arg3: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn walk_mem_res(
        start: u64_,
        end: u64_,
        arg: *mut core::ffi::c_void,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut resource,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn walk_system_ram_res(
        start: u64_,
        end: u64_,
        arg: *mut core::ffi::c_void,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut resource,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn walk_iomem_res_desc(
        desc: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        start: u64_,
        end: u64_,
        arg: *mut core::ffi::c_void,
        func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut resource,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_request_free_mem_region(
        dev: *mut device,
        base: *mut resource,
        size: core::ffi::c_ulong,
    ) -> *mut resource;
}
extern "C" {
    pub fn request_free_mem_region(
        base: *mut resource,
        size: core::ffi::c_ulong,
        name: *const core::ffi::c_char,
    ) -> *mut resource;
}
extern "C" {
    pub fn alloc_free_mem_region(
        base: *mut resource,
        size: core::ffi::c_ulong,
        align: core::ffi::c_ulong,
        name: *const core::ffi::c_char,
    ) -> *mut resource;
}
extern "C" {
    pub fn iomem_get_mapping() -> *mut address_space;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct klist {
    pub k_lock: spinlock_t,
    pub k_list: list_head,
    pub get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
    pub put: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
}
impl Default for klist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn klist_init(
        k: *mut klist,
        get: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
        put: ::core::option::Option<unsafe extern "C" fn(arg1: *mut klist_node)>,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct klist_node {
    pub n_klist: *mut core::ffi::c_void,
    pub n_node: list_head,
    pub n_ref: kref,
}
impl Default for klist_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn klist_add_tail(n: *mut klist_node, k: *mut klist);
}
extern "C" {
    pub fn klist_add_head(n: *mut klist_node, k: *mut klist);
}
extern "C" {
    pub fn klist_add_behind(n: *mut klist_node, pos: *mut klist_node);
}
extern "C" {
    pub fn klist_add_before(n: *mut klist_node, pos: *mut klist_node);
}
extern "C" {
    pub fn klist_del(n: *mut klist_node);
}
extern "C" {
    pub fn klist_remove(n: *mut klist_node);
}
extern "C" {
    pub fn klist_node_attached(n: *mut klist_node) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct klist_iter {
    pub i_klist: *mut klist,
    pub i_cur: *mut klist_node,
}
impl Default for klist_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn klist_iter_init(k: *mut klist, i: *mut klist_iter);
}
extern "C" {
    pub fn klist_iter_init_node(k: *mut klist, i: *mut klist_iter, n: *mut klist_node);
}
extern "C" {
    pub fn klist_iter_exit(i: *mut klist_iter);
}
extern "C" {
    pub fn klist_prev(i: *mut klist_iter) -> *mut klist_node;
}
extern "C" {
    pub fn klist_next(i: *mut klist_iter) -> *mut klist_node;
}
extern "C" {
    pub static mut pm_power_off: ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub static mut power_group_name: [core::ffi::c_char; 0usize];
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pm_message {
    pub event: core::ffi::c_int,
}
pub type pm_message_t = pm_message;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_ops {
    pub prepare: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub complete: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub freeze: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub thaw: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub poweroff:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub restore: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub suspend_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub resume_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub freeze_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub thaw_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub poweroff_late:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub restore_early:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub suspend_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub resume_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub freeze_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub thaw_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub poweroff_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub restore_noirq:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub runtime_suspend:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub runtime_resume:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub runtime_idle:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
}
pub const rpm_status_RPM_INVALID: rpm_status = -1;
pub const rpm_status_RPM_ACTIVE: rpm_status = 0;
pub const rpm_status_RPM_RESUMING: rpm_status = 1;
pub const rpm_status_RPM_SUSPENDED: rpm_status = 2;
pub const rpm_status_RPM_SUSPENDING: rpm_status = 3;
pub type rpm_status = core::ffi::c_int;
pub const rpm_request_RPM_REQ_NONE: rpm_request = 0;
pub const rpm_request_RPM_REQ_IDLE: rpm_request = 1;
pub const rpm_request_RPM_REQ_SUSPEND: rpm_request = 2;
pub const rpm_request_RPM_REQ_AUTOSUSPEND: rpm_request = 3;
pub const rpm_request_RPM_REQ_RESUME: rpm_request = 4;
pub type rpm_request = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wake_irq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_domain_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pm_subsys_data {
    pub lock: spinlock_t,
    pub refcount: core::ffi::c_uint,
    pub clock_op_might_sleep: core::ffi::c_uint,
    pub clock_mutex: mutex,
    pub clock_list: list_head,
    pub domain_data: *mut pm_domain_data,
}
impl Default for pm_subsys_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pm_info {
    pub power_state: pm_message_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub driver_flags: u32_,
    pub lock: spinlock_t,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub suspend_timer: hrtimer,
    pub timer_expires: u64_,
    pub work: work_struct,
    pub wait_queue: wait_queue_head_t,
    pub wakeirq: *mut wake_irq,
    pub usage_count: atomic_t,
    pub child_count: atomic_t,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub links_count: core::ffi::c_uint,
    pub request: rpm_request,
    pub runtime_status: rpm_status,
    pub last_status: rpm_status,
    pub runtime_error: core::ffi::c_int,
    pub autosuspend_delay: core::ffi::c_int,
    pub last_busy: u64_,
    pub active_time: u64_,
    pub suspended_time: u64_,
    pub accounting_timestamp: u64_,
    pub subsys_data: *mut pm_subsys_data,
    pub set_latency_tolerance:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: s32)>,
    pub qos: *mut dev_pm_qos,
}
impl Default for dev_pm_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl dev_pm_info {
    #[inline]
    pub fn can_wakeup(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_can_wakeup(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn async_suspend(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_async_suspend(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_dpm_list(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_dpm_list(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_prepared(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_prepared(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_noirq_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_noirq_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_late_suspended(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_late_suspended(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_pm(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_pm(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn direct_complete(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_direct_complete(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        can_wakeup: core::ffi::c_uint,
        async_suspend: core::ffi::c_uint,
        in_dpm_list: bool_,
        is_prepared: bool_,
        is_suspended: bool_,
        is_noirq_suspended: bool_,
        is_late_suspended: bool_,
        no_pm: bool_,
        early_init: bool_,
        direct_complete: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let can_wakeup: u32 = unsafe { ::core::mem::transmute(can_wakeup) };
            can_wakeup as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let async_suspend: u32 = unsafe { ::core::mem::transmute(async_suspend) };
            async_suspend as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let in_dpm_list: u8 = unsafe { ::core::mem::transmute(in_dpm_list) };
            in_dpm_list as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_prepared: u8 = unsafe { ::core::mem::transmute(is_prepared) };
            is_prepared as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_suspended: u8 = unsafe { ::core::mem::transmute(is_suspended) };
            is_suspended as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_noirq_suspended: u8 = unsafe { ::core::mem::transmute(is_noirq_suspended) };
            is_noirq_suspended as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let is_late_suspended: u8 = unsafe { ::core::mem::transmute(is_late_suspended) };
            is_late_suspended as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let no_pm: u8 = unsafe { ::core::mem::transmute(no_pm) };
            no_pm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let direct_complete: u8 = unsafe { ::core::mem::transmute(direct_complete) };
            direct_complete as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn should_wakeup(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_should_wakeup(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        should_wakeup: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let should_wakeup: u32 = unsafe { ::core::mem::transmute(should_wakeup) };
            should_wakeup as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn disable_depth(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_disable_depth(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn idle_notification(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_idle_notification(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn request_pending(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_request_pending(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn deferred_resume(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_deferred_resume(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn needs_force_resume(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_needs_force_resume(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn runtime_auto(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_runtime_auto(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_children(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_children(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_callbacks(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_callbacks(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn irq_safe(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_irq_safe(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_autosuspend(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_autosuspend(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timer_autosuspends(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_timer_autosuspends(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn memalloc_noio(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_memalloc_noio(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        disable_depth: core::ffi::c_uint,
        idle_notification: core::ffi::c_uint,
        request_pending: core::ffi::c_uint,
        deferred_resume: core::ffi::c_uint,
        needs_force_resume: core::ffi::c_uint,
        runtime_auto: core::ffi::c_uint,
        ignore_children: bool_,
        no_callbacks: core::ffi::c_uint,
        irq_safe: core::ffi::c_uint,
        use_autosuspend: core::ffi::c_uint,
        timer_autosuspends: core::ffi::c_uint,
        memalloc_noio: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let disable_depth: u32 = unsafe { ::core::mem::transmute(disable_depth) };
            disable_depth as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let idle_notification: u32 = unsafe { ::core::mem::transmute(idle_notification) };
            idle_notification as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let request_pending: u32 = unsafe { ::core::mem::transmute(request_pending) };
            request_pending as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let deferred_resume: u32 = unsafe { ::core::mem::transmute(deferred_resume) };
            deferred_resume as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let needs_force_resume: u32 = unsafe { ::core::mem::transmute(needs_force_resume) };
            needs_force_resume as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let runtime_auto: u32 = unsafe { ::core::mem::transmute(runtime_auto) };
            runtime_auto as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ignore_children: u8 = unsafe { ::core::mem::transmute(ignore_children) };
            ignore_children as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let no_callbacks: u32 = unsafe { ::core::mem::transmute(no_callbacks) };
            no_callbacks as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let irq_safe: u32 = unsafe { ::core::mem::transmute(irq_safe) };
            irq_safe as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let use_autosuspend: u32 = unsafe { ::core::mem::transmute(use_autosuspend) };
            use_autosuspend as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let timer_autosuspends: u32 = unsafe { ::core::mem::transmute(timer_autosuspends) };
            timer_autosuspends as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let memalloc_noio: u32 = unsafe { ::core::mem::transmute(memalloc_noio) };
            memalloc_noio as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn dev_pm_get_subsys_data(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_pm_put_subsys_data(dev: *mut device);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_domain {
    pub ops: dev_pm_ops,
    pub start: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub detach: ::core::option::Option<unsafe extern "C" fn(dev: *mut device, power_off: bool_)>,
    pub activate:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub sync: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub dismiss: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
}
pub const dpm_order_DPM_ORDER_NONE: dpm_order = 0;
pub const dpm_order_DPM_ORDER_DEV_AFTER_PARENT: dpm_order = 1;
pub const dpm_order_DPM_ORDER_PARENT_BEFORE_DEV: dpm_order = 2;
pub const dpm_order_DPM_ORDER_DEV_LAST: dpm_order = 3;
pub type dpm_order = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bus_type {
    pub name: *const core::ffi::c_char,
    pub dev_name: *const core::ffi::c_char,
    pub dev_root: *mut device,
    pub bus_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub drv_groups: *mut *const attribute_group,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, drv: *mut device_driver) -> core::ffi::c_int,
    >,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub online: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub offline: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> core::ffi::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub num_vf: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub dma_configure:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub dma_cleanup: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
    pub iommu_ops: *const iommu_ops,
    pub p: *mut subsys_private,
    pub lock_key: lock_class_key,
    pub need_parent_lock: bool_,
}
impl Default for bus_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn bus_register(bus: *mut bus_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_unregister(bus: *mut bus_type);
}
extern "C" {
    pub fn bus_rescan_devices(bus: *mut bus_type) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bus_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(bus: *mut bus_type, buf: *mut core::ffi::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            bus: *mut bus_type,
            buf: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for bus_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn bus_create_file(arg1: *mut bus_type, arg2: *mut bus_attribute) -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_remove_file(arg1: *mut bus_type, arg2: *mut bus_attribute);
}
extern "C" {
    pub fn device_match_name(dev: *mut device, name: *const core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_of_node(dev: *mut device, np: *const core::ffi::c_void)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_fwnode(
        dev: *mut device,
        fwnode: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_devt(dev: *mut device, pdevt: *const core::ffi::c_void)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_acpi_dev(
        dev: *mut device,
        adev: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_acpi_handle(
        dev: *mut device,
        handle: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_match_any(dev: *mut device, unused: *const core::ffi::c_void)
        -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subsys_dev_iter {
    pub ki: klist_iter,
    pub type_: *const device_type,
}
impl Default for subsys_dev_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn subsys_dev_iter_init(
        iter: *mut subsys_dev_iter,
        subsys: *mut bus_type,
        start: *mut device,
        type_: *const device_type,
    );
}
extern "C" {
    pub fn subsys_dev_iter_next(iter: *mut subsys_dev_iter) -> *mut device;
}
extern "C" {
    pub fn subsys_dev_iter_exit(iter: *mut subsys_dev_iter);
}
extern "C" {
    pub fn bus_for_each_dev(
        bus: *mut bus_type,
        start: *mut device,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_find_device(
        bus: *mut bus_type,
        start: *mut device,
        data: *const core::ffi::c_void,
        match_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *const core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut device;
}
extern "C" {
    pub fn subsys_find_device_by_id(
        bus: *mut bus_type,
        id: core::ffi::c_uint,
        hint: *mut device,
    ) -> *mut device;
}
extern "C" {
    pub fn bus_for_each_drv(
        bus: *mut bus_type,
        start: *mut device_driver,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device_driver,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_sort_breadthfirst(
        bus: *mut bus_type,
        compare: ::core::option::Option<
            unsafe extern "C" fn(a: *const device, b: *const device) -> core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub fn bus_register_notifier(bus: *mut bus_type, nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_unregister_notifier(bus: *mut bus_type, nb: *mut notifier_block)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn bus_get_kset(bus: *mut bus_type) -> *mut kset;
}
extern "C" {
    pub fn bus_get_device_klist(bus: *mut bus_type) -> *mut klist;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class {
    pub name: *const core::ffi::c_char,
    pub owner: *mut module,
    pub class_groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub dev_kobj: *mut kobject,
    pub dev_uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, mode: *mut umode_t) -> *mut core::ffi::c_char,
    >,
    pub class_release: ::core::option::Option<unsafe extern "C" fn(class: *mut class)>,
    pub dev_release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub shutdown_pre:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub ns_type: *const kobj_ns_type_operations,
    pub namespace:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> *const core::ffi::c_void>,
    pub get_ownership: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, uid: *mut kuid_t, gid: *mut kgid_t),
    >,
    pub pm: *const dev_pm_ops,
    pub p: *mut subsys_private,
}
impl Default for class {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_dev_iter {
    pub ki: klist_iter,
    pub type_: *const device_type,
}
impl Default for class_dev_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut sysfs_dev_block_kobj: *mut kobject;
}
extern "C" {
    pub static mut sysfs_dev_char_kobj: *mut kobject;
}
extern "C" {
    pub fn __class_register(class: *mut class, key: *mut lock_class_key) -> core::ffi::c_int;
}
extern "C" {
    pub fn class_unregister(class: *mut class);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_compat {
    _unused: [u8; 0],
}
extern "C" {
    pub fn class_compat_register(name: *const core::ffi::c_char) -> *mut class_compat;
}
extern "C" {
    pub fn class_compat_unregister(cls: *mut class_compat);
}
extern "C" {
    pub fn class_compat_create_link(
        cls: *mut class_compat,
        dev: *mut device,
        device_link: *mut device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn class_compat_remove_link(
        cls: *mut class_compat,
        dev: *mut device,
        device_link: *mut device,
    );
}
extern "C" {
    pub fn class_dev_iter_init(
        iter: *mut class_dev_iter,
        class: *mut class,
        start: *mut device,
        type_: *const device_type,
    );
}
extern "C" {
    pub fn class_dev_iter_next(iter: *mut class_dev_iter) -> *mut device;
}
extern "C" {
    pub fn class_dev_iter_exit(iter: *mut class_dev_iter);
}
extern "C" {
    pub fn class_for_each_device(
        class: *mut class,
        start: *mut device,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn class_find_device(
        class: *mut class,
        start: *mut device,
        data: *const core::ffi::c_void,
        match_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *const core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut device;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            class: *mut class,
            attr: *mut class_attribute,
            buf: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            class: *mut class,
            attr: *mut class_attribute,
            buf: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for class_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn class_create_file_ns(
        class: *mut class,
        attr: *const class_attribute,
        ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn class_remove_file_ns(
        class: *mut class,
        attr: *const class_attribute,
        ns: *const core::ffi::c_void,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_attribute_string {
    pub attr: class_attribute,
    pub str_: *mut core::ffi::c_char,
}
impl Default for class_attribute_string {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn show_class_attr_string(
        class: *mut class,
        attr: *mut class_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct class_interface {
    pub node: list_head,
    pub class: *mut class,
    pub add_dev: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut device, arg2: *mut class_interface) -> core::ffi::c_int,
    >,
    pub remove_dev:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut device, arg2: *mut class_interface)>,
}
impl Default for class_interface {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn class_interface_register(arg1: *mut class_interface) -> core::ffi::c_int;
}
extern "C" {
    pub fn class_interface_unregister(arg1: *mut class_interface);
}
extern "C" {
    pub fn __class_create(
        owner: *mut module,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
    ) -> *mut class;
}
extern "C" {
    pub fn class_destroy(cls: *mut class);
}
pub const probe_type_PROBE_DEFAULT_STRATEGY: probe_type = 0;
pub const probe_type_PROBE_PREFER_ASYNCHRONOUS: probe_type = 1;
pub const probe_type_PROBE_FORCE_SYNCHRONOUS: probe_type = 2;
pub type probe_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_driver {
    pub name: *const core::ffi::c_char,
    pub bus: *mut bus_type,
    pub owner: *mut module,
    pub mod_name: *const core::ffi::c_char,
    pub suppress_bind_attrs: bool_,
    pub probe_type: probe_type,
    pub of_match_table: *const of_device_id,
    pub acpi_match_table: *const acpi_device_id,
    pub probe: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub sync_state: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub remove: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, state: pm_message_t) -> core::ffi::c_int,
    >,
    pub resume: ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>,
    pub groups: *mut *const attribute_group,
    pub dev_groups: *mut *const attribute_group,
    pub pm: *const dev_pm_ops,
    pub coredump: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub p: *mut driver_private,
}
impl Default for device_driver {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn driver_register(drv: *mut device_driver) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_unregister(drv: *mut device_driver);
}
extern "C" {
    pub fn driver_find(name: *const core::ffi::c_char, bus: *mut bus_type) -> *mut device_driver;
}
extern "C" {
    pub fn driver_probe_done() -> core::ffi::c_int;
}
extern "C" {
    pub fn wait_for_device_probe();
}
extern "C" {
    pub fn wait_for_init_devices_probe();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct driver_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(driver: *mut device_driver, buf: *mut core::ffi::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            driver: *mut device_driver,
            buf: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for driver_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn driver_create_file(
        driver: *mut device_driver,
        attr: *const driver_attribute,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_remove_file(driver: *mut device_driver, attr: *const driver_attribute);
}
extern "C" {
    pub fn driver_set_override(
        dev: *mut device,
        override_: *mut *const core::ffi::c_char,
        s: *const core::ffi::c_char,
        len: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_for_each_device(
        drv: *mut device_driver,
        start: *mut device,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                arg1: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_find_device(
        drv: *mut device_driver,
        start: *mut device,
        data: *const core::ffi::c_void,
        match_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *const core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut device;
}
extern "C" {
    pub static mut driver_deferred_probe_timeout: core::ffi::c_int;
}
extern "C" {
    pub fn driver_deferred_probe_add(dev: *mut device);
}
extern "C" {
    pub fn driver_deferred_probe_check_state(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_init();
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_archdata {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pdev_archdata {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct driver_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subsys_private {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iommu_group {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_iommu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_device_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct subsys_interface {
    pub name: *const core::ffi::c_char,
    pub subsys: *mut bus_type,
    pub node: list_head,
    pub add_dev: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, sif: *mut subsys_interface) -> core::ffi::c_int,
    >,
    pub remove_dev:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device, sif: *mut subsys_interface)>,
}
impl Default for subsys_interface {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn subsys_interface_register(sif: *mut subsys_interface) -> core::ffi::c_int;
}
extern "C" {
    pub fn subsys_interface_unregister(sif: *mut subsys_interface);
}
extern "C" {
    pub fn subsys_system_register(
        subsys: *mut bus_type,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn subsys_virtual_register(
        subsys: *mut bus_type,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_type {
    pub name: *const core::ffi::c_char,
    pub groups: *mut *const attribute_group,
    pub uevent: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut device, env: *mut kobj_uevent_env) -> core::ffi::c_int,
    >,
    pub devnode: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            mode: *mut umode_t,
            uid: *mut kuid_t,
            gid: *mut kgid_t,
        ) -> *mut core::ffi::c_char,
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub pm: *const dev_pm_ops,
}
impl Default for device_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            attr: *mut device_attribute,
            buf: *mut core::ffi::c_char,
        ) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut device,
            attr: *mut device_attribute,
            buf: *const core::ffi::c_char,
            count: usize,
        ) -> isize,
    >,
}
impl Default for device_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_ext_attribute {
    pub attr: device_attribute,
    pub var: *mut core::ffi::c_void,
}
impl Default for dev_ext_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn device_show_ulong(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn device_store_ulong(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *const core::ffi::c_char,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn device_show_int(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn device_store_int(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *const core::ffi::c_char,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn device_show_bool(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn device_store_bool(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *const core::ffi::c_char,
        count: usize,
    ) -> isize;
}
extern "C" {
    pub fn device_create_file(
        device: *mut device,
        entry: *const device_attribute,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_remove_file(dev: *mut device, attr: *const device_attribute);
}
extern "C" {
    pub fn device_remove_file_self(dev: *mut device, attr: *const device_attribute) -> bool_;
}
extern "C" {
    pub fn device_create_bin_file(dev: *mut device, attr: *const bin_attribute)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn device_remove_bin_file(dev: *mut device, attr: *const bin_attribute);
}
pub type dr_release_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut device, res: *mut core::ffi::c_void)>;
pub type dr_match_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut device,
        res: *mut core::ffi::c_void,
        match_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn __devres_alloc_node(
        release: dr_release_t,
        size: usize,
        gfp: gfp_t,
        nid: core::ffi::c_int,
        name: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devres_for_each_res(
        dev: *mut device,
        release: dr_release_t,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut device,
                arg2: *mut core::ffi::c_void,
                arg3: *mut core::ffi::c_void,
            ),
        >,
        data: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn devres_free(res: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devres_add(dev: *mut device, res: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devres_find(
        dev: *mut device,
        release: dr_release_t,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devres_get(
        dev: *mut device,
        new_res: *mut core::ffi::c_void,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devres_remove(
        dev: *mut device,
        release: dr_release_t,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devres_destroy(
        dev: *mut device,
        release: dr_release_t,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devres_release(
        dev: *mut device,
        release: dr_release_t,
        match_: dr_match_t,
        match_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devres_open_group(
        dev: *mut device,
        id: *mut core::ffi::c_void,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devres_close_group(dev: *mut device, id: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devres_remove_group(dev: *mut device, id: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devres_release_group(dev: *mut device, id: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_kmalloc(dev: *mut device, size: usize, gfp: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_krealloc(
        dev: *mut device,
        ptr: *mut core::ffi::c_void,
        size: usize,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_kvasprintf(
        dev: *mut device,
        gfp: gfp_t,
        fmt: *const core::ffi::c_char,
        ap: va_list,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn devm_kasprintf(
        dev: *mut device,
        gfp: gfp_t,
        fmt: *const core::ffi::c_char,
        ...
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn devm_kfree(dev: *mut device, p: *const core::ffi::c_void);
}
extern "C" {
    pub fn devm_kstrdup(
        dev: *mut device,
        s: *const core::ffi::c_char,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn devm_kstrdup_const(
        dev: *mut device,
        s: *const core::ffi::c_char,
        gfp: gfp_t,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn devm_kmemdup(
        dev: *mut device,
        src: *const core::ffi::c_void,
        len: usize,
        gfp: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_get_free_pages(
        dev: *mut device,
        gfp_mask: gfp_t,
        order: core::ffi::c_uint,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn devm_free_pages(dev: *mut device, addr: core::ffi::c_ulong);
}
extern "C" {
    pub fn devm_ioremap_resource(dev: *mut device, res: *const resource) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_ioremap_resource_wc(
        dev: *mut device,
        res: *const resource,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_of_iomap(
        dev: *mut device,
        node: *mut device_node,
        index: core::ffi::c_int,
        size: *mut resource_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_add_action(
        dev: *mut device,
        action: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_remove_action(
        dev: *mut device,
        action: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
        data: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn devm_release_action(
        dev: *mut device,
        action: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
        data: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __devm_alloc_percpu(
        dev: *mut device,
        size: usize,
        align: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_free_percpu(dev: *mut device, pdata: *mut core::ffi::c_void);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct device_dma_parameters {
    pub max_segment_size: core::ffi::c_uint,
    pub min_align_mask: core::ffi::c_uint,
    pub segment_boundary_mask: core::ffi::c_ulong,
}
pub const device_link_state_DL_STATE_NONE: device_link_state = -1;
pub const device_link_state_DL_STATE_DORMANT: device_link_state = 0;
pub const device_link_state_DL_STATE_AVAILABLE: device_link_state = 1;
pub const device_link_state_DL_STATE_CONSUMER_PROBE: device_link_state = 2;
pub const device_link_state_DL_STATE_ACTIVE: device_link_state = 3;
pub const device_link_state_DL_STATE_SUPPLIER_UNBIND: device_link_state = 4;
pub type device_link_state = core::ffi::c_int;
pub const dl_dev_state_DL_DEV_NO_DRIVER: dl_dev_state = 0;
pub const dl_dev_state_DL_DEV_PROBING: dl_dev_state = 1;
pub const dl_dev_state_DL_DEV_DRIVER_BOUND: dl_dev_state = 2;
pub const dl_dev_state_DL_DEV_UNBINDING: dl_dev_state = 3;
pub type dl_dev_state = core::ffi::c_uint;
pub const device_removable_DEVICE_REMOVABLE_NOT_SUPPORTED: device_removable = 0;
pub const device_removable_DEVICE_REMOVABLE_UNKNOWN: device_removable = 1;
pub const device_removable_DEVICE_FIXED: device_removable = 2;
pub const device_removable_DEVICE_REMOVABLE: device_removable = 3;
pub type device_removable = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_links_info {
    pub suppliers: list_head,
    pub consumers: list_head,
    pub defer_sync: list_head,
    pub status: dl_dev_state,
}
impl Default for dev_links_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_msi_info {
    pub domain: *mut irq_domain,
    pub data: *mut msi_device_data,
}
impl Default for dev_msi_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const device_physical_location_panel_DEVICE_PANEL_TOP: device_physical_location_panel = 0;
pub const device_physical_location_panel_DEVICE_PANEL_BOTTOM: device_physical_location_panel = 1;
pub const device_physical_location_panel_DEVICE_PANEL_LEFT: device_physical_location_panel = 2;
pub const device_physical_location_panel_DEVICE_PANEL_RIGHT: device_physical_location_panel = 3;
pub const device_physical_location_panel_DEVICE_PANEL_FRONT: device_physical_location_panel = 4;
pub const device_physical_location_panel_DEVICE_PANEL_BACK: device_physical_location_panel = 5;
pub const device_physical_location_panel_DEVICE_PANEL_UNKNOWN: device_physical_location_panel = 6;
pub type device_physical_location_panel = core::ffi::c_uint;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_UPPER:
    device_physical_location_vertical_position = 0;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_CENTER:
    device_physical_location_vertical_position = 1;
pub const device_physical_location_vertical_position_DEVICE_VERT_POS_LOWER:
    device_physical_location_vertical_position = 2;
pub type device_physical_location_vertical_position = core::ffi::c_uint;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_LEFT:
    device_physical_location_horizontal_position = 0;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_CENTER:
    device_physical_location_horizontal_position = 1;
pub const device_physical_location_horizontal_position_DEVICE_HORI_POS_RIGHT:
    device_physical_location_horizontal_position = 2;
pub type device_physical_location_horizontal_position = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_physical_location {
    pub panel: device_physical_location_panel,
    pub vertical_position: device_physical_location_vertical_position,
    pub horizontal_position: device_physical_location_horizontal_position,
    pub dock: bool_,
    pub lid: bool_,
}
impl Default for device_physical_location {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device {
    pub kobj: kobject,
    pub parent: *mut device,
    pub p: *mut device_private,
    pub init_name: *const core::ffi::c_char,
    pub type_: *const device_type,
    pub bus: *mut bus_type,
    pub driver: *mut device_driver,
    pub platform_data: *mut core::ffi::c_void,
    pub driver_data: *mut core::ffi::c_void,
    pub mutex: mutex,
    pub links: dev_links_info,
    pub power: dev_pm_info,
    pub pm_domain: *mut dev_pm_domain,
    pub pins: *mut dev_pin_info,
    pub msi: dev_msi_info,
    pub dma_mask: *mut u64_,
    pub coherent_dma_mask: u64_,
    pub bus_dma_limit: u64_,
    pub dma_range_map: *mut bus_dma_region,
    pub dma_parms: *mut device_dma_parameters,
    pub dma_pools: list_head,
    pub dma_mem: *mut dma_coherent_mem,
    pub dma_io_tlb_mem: *mut io_tlb_mem,
    pub archdata: dev_archdata,
    pub of_node: *mut device_node,
    pub fwnode: *mut fwnode_handle,
    pub devt: dev_t,
    pub id: u32_,
    pub devres_lock: spinlock_t,
    pub devres_head: list_head,
    pub class: *mut class,
    pub groups: *mut *const attribute_group,
    pub release: ::core::option::Option<unsafe extern "C" fn(dev: *mut device)>,
    pub iommu_group: *mut iommu_group,
    pub iommu: *mut dev_iommu,
    pub physical_location: *mut device_physical_location,
    pub removable: device_removable,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl device {
    #[inline]
    pub fn offline_disabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline_disabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offline(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offline(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn of_node_reused(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_of_node_reused(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn state_synced(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_state_synced(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn can_match(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_can_match(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        offline_disabled: bool_,
        offline: bool_,
        of_node_reused: bool_,
        state_synced: bool_,
        can_match: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let offline_disabled: u8 = unsafe { ::core::mem::transmute(offline_disabled) };
            offline_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let offline: u8 = unsafe { ::core::mem::transmute(offline) };
            offline as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let of_node_reused: u8 = unsafe { ::core::mem::transmute(of_node_reused) };
            of_node_reused as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let state_synced: u8 = unsafe { ::core::mem::transmute(state_synced) };
            state_synced as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let can_match: u8 = unsafe { ::core::mem::transmute(can_match) };
            can_match as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_link {
    pub supplier: *mut device,
    pub s_node: list_head,
    pub consumer: *mut device,
    pub c_node: list_head,
    pub link_dev: device,
    pub status: device_link_state,
    pub flags: u32_,
    pub rpm_active: refcount_t,
    pub kref: kref,
    pub rm_work: work_struct,
    pub supplier_preactivated: bool_,
}
impl Default for device_link {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wakeup_source {
    pub name: *const core::ffi::c_char,
    pub id: core::ffi::c_int,
    pub entry: list_head,
    pub lock: spinlock_t,
    pub wakeirq: *mut wake_irq,
    pub timer: timer_list,
    pub timer_expires: core::ffi::c_ulong,
    pub total_time: ktime_t,
    pub max_time: ktime_t,
    pub last_time: ktime_t,
    pub start_prevent_time: ktime_t,
    pub prevent_sleep_time: ktime_t,
    pub event_count: core::ffi::c_ulong,
    pub active_count: core::ffi::c_ulong,
    pub relax_count: core::ffi::c_ulong,
    pub expire_count: core::ffi::c_ulong,
    pub wakeup_count: core::ffi::c_ulong,
    pub dev: *mut device,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl Default for wakeup_source {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl wakeup_source {
    #[inline]
    pub fn active(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_active(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autosleep_enabled(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autosleep_enabled(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        active: bool_,
        autosleep_enabled: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let active: u8 = unsafe { ::core::mem::transmute(active) };
            active as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autosleep_enabled: u8 = unsafe { ::core::mem::transmute(autosleep_enabled) };
            autosleep_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn dev_set_name(dev: *mut device, name: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_register(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_unregister(dev: *mut device);
}
extern "C" {
    pub fn device_initialize(dev: *mut device);
}
extern "C" {
    pub fn device_add(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_del(dev: *mut device);
}
extern "C" {
    pub fn device_for_each_child(
        dev: *mut device,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_for_each_child_reverse(
        dev: *mut device,
        data: *mut core::ffi::c_void,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_find_child(
        dev: *mut device,
        data: *mut core::ffi::c_void,
        match_: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut device,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut device;
}
extern "C" {
    pub fn device_find_child_by_name(
        parent: *mut device,
        name: *const core::ffi::c_char,
    ) -> *mut device;
}
extern "C" {
    pub fn device_find_any_child(parent: *mut device) -> *mut device;
}
extern "C" {
    pub fn device_rename(dev: *mut device, new_name: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_move(
        dev: *mut device,
        new_parent: *mut device,
        dpm_order: dpm_order,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_change_owner(dev: *mut device, kuid: kuid_t, kgid: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_get_devnode(
        dev: *mut device,
        mode: *mut umode_t,
        uid: *mut kuid_t,
        gid: *mut kgid_t,
        tmp: *mut *const core::ffi::c_char,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn device_is_dependent(
        dev: *mut device,
        target: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lock_device_hotplug();
}
extern "C" {
    pub fn unlock_device_hotplug();
}
extern "C" {
    pub fn lock_device_hotplug_sysfs() -> core::ffi::c_int;
}
extern "C" {
    pub fn device_offline(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_online(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_primary_fwnode(dev: *mut device, fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn set_secondary_fwnode(dev: *mut device, fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn device_set_of_node_from_dev(dev: *mut device, dev2: *const device);
}
extern "C" {
    pub fn device_set_node(dev: *mut device, fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn __root_device_register(
        name: *const core::ffi::c_char,
        owner: *mut module,
    ) -> *mut device;
}
extern "C" {
    pub fn root_device_unregister(root: *mut device);
}
extern "C" {
    pub fn device_driver_attach(drv: *mut device_driver, dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_bind_driver(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_release_driver(dev: *mut device);
}
extern "C" {
    pub fn device_attach(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn driver_attach(drv: *mut device_driver) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_initial_probe(dev: *mut device);
}
extern "C" {
    pub fn device_reprobe(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_is_bound(dev: *mut device) -> bool_;
}
extern "C" {
    pub fn device_create(
        cls: *mut class,
        parent: *mut device,
        devt: dev_t,
        drvdata: *mut core::ffi::c_void,
        fmt: *const core::ffi::c_char,
        ...
    ) -> *mut device;
}
extern "C" {
    pub fn device_create_with_groups(
        cls: *mut class,
        parent: *mut device,
        devt: dev_t,
        drvdata: *mut core::ffi::c_void,
        groups: *mut *const attribute_group,
        fmt: *const core::ffi::c_char,
        ...
    ) -> *mut device;
}
extern "C" {
    pub fn device_destroy(cls: *mut class, devt: dev_t);
}
extern "C" {
    pub fn device_add_groups(
        dev: *mut device,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_remove_groups(dev: *mut device, groups: *mut *const attribute_group);
}
extern "C" {
    pub fn devm_device_add_groups(
        dev: *mut device,
        groups: *mut *const attribute_group,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_device_remove_groups(dev: *mut device, groups: *mut *const attribute_group);
}
extern "C" {
    pub fn devm_device_add_group(dev: *mut device, grp: *const attribute_group)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_device_remove_group(dev: *mut device, grp: *const attribute_group);
}
extern "C" {
    pub static mut platform_notify:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>;
}
extern "C" {
    pub static mut platform_notify_remove:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut device) -> core::ffi::c_int>;
}
extern "C" {
    pub fn get_device(dev: *mut device) -> *mut device;
}
extern "C" {
    pub fn put_device(dev: *mut device);
}
extern "C" {
    pub fn kill_device(dev: *mut device) -> bool_;
}
extern "C" {
    pub fn devtmpfs_mount() -> core::ffi::c_int;
}
extern "C" {
    pub fn device_shutdown();
}
extern "C" {
    pub fn dev_driver_string(dev: *const device) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn device_link_add(
        consumer: *mut device,
        supplier: *mut device,
        flags: u32_,
    ) -> *mut device_link;
}
extern "C" {
    pub fn device_link_del(link: *mut device_link);
}
extern "C" {
    pub fn device_link_remove(consumer: *mut core::ffi::c_void, supplier: *mut device);
}
extern "C" {
    pub fn device_links_supplier_sync_state_pause();
}
extern "C" {
    pub fn device_links_supplier_sync_state_resume();
}
extern "C" {
    pub fn dev_err_probe(
        dev: *const device,
        err: core::ffi::c_int,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
pub type kernel_ulong_t = core::ffi::c_ulong;
pub const PCI_ID_F_VFIO_DRIVER_OVERRIDE: core::ffi::c_uint = 1;
pub type _bindgen_ty_92 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pci_device_id {
    pub vendor: __u32,
    pub device: __u32,
    pub subvendor: __u32,
    pub subdevice: __u32,
    pub class: __u32,
    pub class_mask: __u32,
    pub driver_data: kernel_ulong_t,
    pub override_only: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ieee1394_device_id {
    pub match_flags: __u32,
    pub vendor_id: __u32,
    pub model_id: __u32,
    pub specifier_id: __u32,
    pub version: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct usb_device_id {
    pub match_flags: __u16,
    pub idVendor: __u16,
    pub idProduct: __u16,
    pub bcdDevice_lo: __u16,
    pub bcdDevice_hi: __u16,
    pub bDeviceClass: __u8,
    pub bDeviceSubClass: __u8,
    pub bDeviceProtocol: __u8,
    pub bInterfaceClass: __u8,
    pub bInterfaceSubClass: __u8,
    pub bInterfaceProtocol: __u8,
    pub bInterfaceNumber: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hid_device_id {
    pub bus: __u16,
    pub group: __u16,
    pub vendor: __u32,
    pub product: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ccw_device_id {
    pub match_flags: __u16,
    pub cu_type: __u16,
    pub dev_type: __u16,
    pub cu_model: __u8,
    pub dev_model: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ap_device_id {
    pub match_flags: __u16,
    pub dev_type: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct css_device_id {
    pub match_flags: __u8,
    pub type_: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct acpi_device_id {
    pub id: [__u8; 16usize],
    pub driver_data: kernel_ulong_t,
    pub cls: __u32,
    pub cls_msk: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pnp_device_id {
    pub id: [__u8; 8usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pnp_card_device_id {
    pub id: [__u8; 8usize],
    pub driver_data: kernel_ulong_t,
    pub devs: [pnp_card_device_id__bindgen_ty_1; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pnp_card_device_id__bindgen_ty_1 {
    pub id: [__u8; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct serio_device_id {
    pub type_: __u8,
    pub extra: __u8,
    pub id: __u8,
    pub proto: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hda_device_id {
    pub vendor_id: __u32,
    pub rev_id: __u32,
    pub api_version: __u8,
    pub name: *const core::ffi::c_char,
    pub driver_data: core::ffi::c_ulong,
}
impl Default for hda_device_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sdw_device_id {
    pub mfg_id: __u16,
    pub part_id: __u16,
    pub sdw_version: __u8,
    pub class_id: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub type_: [core::ffi::c_char; 32usize],
    pub compatible: [core::ffi::c_char; 128usize],
    pub data: *const core::ffi::c_void,
}
impl Default for of_device_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vio_device_id {
    pub type_: [core::ffi::c_char; 32usize],
    pub compat: [core::ffi::c_char; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pcmcia_device_id {
    pub match_flags: __u16,
    pub manf_id: __u16,
    pub card_id: __u16,
    pub func_id: __u8,
    pub function: __u8,
    pub device_no: __u8,
    pub prod_id_hash: [__u32; 4usize],
    pub prod_id: [*const core::ffi::c_char; 4usize],
    pub driver_info: kernel_ulong_t,
    pub cisfile: *mut core::ffi::c_char,
}
impl Default for pcmcia_device_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct input_device_id {
    pub flags: kernel_ulong_t,
    pub bustype: __u16,
    pub vendor: __u16,
    pub product: __u16,
    pub version: __u16,
    pub evbit: [kernel_ulong_t; 1usize],
    pub keybit: [kernel_ulong_t; 12usize],
    pub relbit: [kernel_ulong_t; 1usize],
    pub absbit: [kernel_ulong_t; 1usize],
    pub mscbit: [kernel_ulong_t; 1usize],
    pub ledbit: [kernel_ulong_t; 1usize],
    pub sndbit: [kernel_ulong_t; 1usize],
    pub ffbit: [kernel_ulong_t; 2usize],
    pub swbit: [kernel_ulong_t; 1usize],
    pub propbit: [kernel_ulong_t; 1usize],
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct eisa_device_id {
    pub sig: [core::ffi::c_char; 8usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct parisc_device_id {
    pub hw_type: __u8,
    pub hversion_rev: __u8,
    pub hversion: __u16,
    pub sversion: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sdio_device_id {
    pub class: __u8,
    pub vendor: __u16,
    pub device: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C, packed(2))]
#[derive(Default, Copy, Clone)]
pub struct ssb_device_id {
    pub vendor: __u16,
    pub coreid: __u16,
    pub revision: __u8,
    pub __pad: __u8,
}
#[repr(C, packed(2))]
#[derive(Default, Copy, Clone)]
pub struct bcma_device_id {
    pub manuf: __u16,
    pub id: __u16,
    pub rev: __u8,
    pub class: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct virtio_device_id {
    pub device: __u32,
    pub vendor: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hv_vmbus_device_id {
    pub guid: guid_t,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rpmsg_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct i2c_device_id {
    pub name: [core::ffi::c_char; 20usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pci_epf_device_id {
    pub name: [core::ffi::c_char; 20usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct i3c_device_id {
    pub match_flags: __u8,
    pub dcr: __u8,
    pub manuf_id: __u16,
    pub part_id: __u16,
    pub extra_info: __u16,
    pub data: *const core::ffi::c_void,
}
impl Default for i3c_device_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct spi_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct slim_device_id {
    pub manf_id: __u16,
    pub prod_code: __u16,
    pub dev_index: __u16,
    pub instance: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct apr_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub domain_id: __u32,
    pub svc_id: __u32,
    pub svc_version: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct spmi_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
pub const dmi_field_DMI_NONE: dmi_field = 0;
pub const dmi_field_DMI_BIOS_VENDOR: dmi_field = 1;
pub const dmi_field_DMI_BIOS_VERSION: dmi_field = 2;
pub const dmi_field_DMI_BIOS_DATE: dmi_field = 3;
pub const dmi_field_DMI_BIOS_RELEASE: dmi_field = 4;
pub const dmi_field_DMI_EC_FIRMWARE_RELEASE: dmi_field = 5;
pub const dmi_field_DMI_SYS_VENDOR: dmi_field = 6;
pub const dmi_field_DMI_PRODUCT_NAME: dmi_field = 7;
pub const dmi_field_DMI_PRODUCT_VERSION: dmi_field = 8;
pub const dmi_field_DMI_PRODUCT_SERIAL: dmi_field = 9;
pub const dmi_field_DMI_PRODUCT_UUID: dmi_field = 10;
pub const dmi_field_DMI_PRODUCT_SKU: dmi_field = 11;
pub const dmi_field_DMI_PRODUCT_FAMILY: dmi_field = 12;
pub const dmi_field_DMI_BOARD_VENDOR: dmi_field = 13;
pub const dmi_field_DMI_BOARD_NAME: dmi_field = 14;
pub const dmi_field_DMI_BOARD_VERSION: dmi_field = 15;
pub const dmi_field_DMI_BOARD_SERIAL: dmi_field = 16;
pub const dmi_field_DMI_BOARD_ASSET_TAG: dmi_field = 17;
pub const dmi_field_DMI_CHASSIS_VENDOR: dmi_field = 18;
pub const dmi_field_DMI_CHASSIS_TYPE: dmi_field = 19;
pub const dmi_field_DMI_CHASSIS_VERSION: dmi_field = 20;
pub const dmi_field_DMI_CHASSIS_SERIAL: dmi_field = 21;
pub const dmi_field_DMI_CHASSIS_ASSET_TAG: dmi_field = 22;
pub const dmi_field_DMI_STRING_MAX: dmi_field = 23;
pub const dmi_field_DMI_OEM_STRING: dmi_field = 24;
pub type dmi_field = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dmi_strmatch {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub substr: [core::ffi::c_char; 79usize],
}
impl Default for dmi_strmatch {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl dmi_strmatch {
    #[inline]
    pub fn slot(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_slot(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn exact_match(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_exact_match(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slot: core::ffi::c_uchar,
        exact_match: core::ffi::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let slot: u8 = unsafe { ::core::mem::transmute(slot) };
            slot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let exact_match: u8 = unsafe { ::core::mem::transmute(exact_match) };
            exact_match as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dmi_system_id {
    pub callback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const dmi_system_id) -> core::ffi::c_int,
    >,
    pub ident: *const core::ffi::c_char,
    pub matches: [dmi_strmatch; 4usize],
    pub driver_data: *mut core::ffi::c_void,
}
impl Default for dmi_system_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct platform_device_id {
    pub name: [core::ffi::c_char; 20usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mdio_device_id {
    pub phy_id: __u32,
    pub phy_id_mask: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct zorro_device_id {
    pub id: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct isapnp_device_id {
    pub card_vendor: core::ffi::c_ushort,
    pub card_device: core::ffi::c_ushort,
    pub vendor: core::ffi::c_ushort,
    pub function: core::ffi::c_ushort,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amba_id {
    pub id: core::ffi::c_uint,
    pub mask: core::ffi::c_uint,
    pub data: *mut core::ffi::c_void,
}
impl Default for amba_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mips_cdmm_device_id {
    pub type_: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct x86_cpu_id {
    pub vendor: __u16,
    pub family: __u16,
    pub model: __u16,
    pub steppings: __u16,
    pub feature: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_feature {
    pub feature: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ipack_device_id {
    pub format: __u8,
    pub vendor: __u32,
    pub device: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mei_cl_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub uuid: uuid_le,
    pub version: __u8,
    pub driver_info: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rio_device_id {
    pub did: __u16,
    pub vid: __u16,
    pub asm_did: __u16,
    pub asm_vid: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mcb_device_id {
    pub device: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ulpi_device_id {
    pub vendor: __u16,
    pub product: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fsl_mc_device_id {
    pub vendor: __u16,
    pub obj_type: [core::ffi::c_char; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tb_service_id {
    pub match_flags: __u32,
    pub protocol_key: [core::ffi::c_char; 9usize],
    pub protocol_id: __u32,
    pub protocol_version: __u32,
    pub protocol_revision: __u32,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct typec_device_id {
    pub svid: __u16,
    pub mode: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tee_client_device_id {
    pub uuid: uuid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wmi_device_id {
    pub guid_string: [core::ffi::c_char; 37usize],
    pub context: *const core::ffi::c_void,
}
impl Default for wmi_device_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mhi_device_id {
    pub chan: [core::ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct auxiliary_device_id {
    pub name: [core::ffi::c_char; 32usize],
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ssam_device_id {
    pub match_flags: __u8,
    pub domain: __u8,
    pub category: __u8,
    pub target: __u8,
    pub instance: __u8,
    pub function: __u8,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dfl_device_id {
    pub type_: __u16,
    pub feature_id: __u16,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ishtp_device_id {
    pub guid: guid_t,
    pub driver_data: kernel_ulong_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct taskstats {
    pub version: __u16,
    pub ac_exitcode: __u32,
    pub ac_flag: __u8,
    pub ac_nice: __u8,
    pub cpu_count: __u64,
    pub cpu_delay_total: __u64,
    pub blkio_count: __u64,
    pub blkio_delay_total: __u64,
    pub swapin_count: __u64,
    pub swapin_delay_total: __u64,
    pub cpu_run_real_total: __u64,
    pub cpu_run_virtual_total: __u64,
    pub ac_comm: [core::ffi::c_char; 32usize],
    pub ac_sched: __u8,
    pub ac_pad: [__u8; 3usize],
    pub __bindgen_padding_0: u32,
    pub ac_uid: __u32,
    pub ac_gid: __u32,
    pub ac_pid: __u32,
    pub ac_ppid: __u32,
    pub ac_btime: __u32,
    pub ac_etime: __u64,
    pub ac_utime: __u64,
    pub ac_stime: __u64,
    pub ac_minflt: __u64,
    pub ac_majflt: __u64,
    pub coremem: __u64,
    pub virtmem: __u64,
    pub hiwater_rss: __u64,
    pub hiwater_vm: __u64,
    pub read_char: __u64,
    pub write_char: __u64,
    pub read_syscalls: __u64,
    pub write_syscalls: __u64,
    pub read_bytes: __u64,
    pub write_bytes: __u64,
    pub cancelled_write_bytes: __u64,
    pub nvcsw: __u64,
    pub nivcsw: __u64,
    pub ac_utimescaled: __u64,
    pub ac_stimescaled: __u64,
    pub cpu_scaled_run_real_total: __u64,
    pub freepages_count: __u64,
    pub freepages_delay_total: __u64,
    pub thrashing_count: __u64,
    pub thrashing_delay_total: __u64,
    pub ac_btime64: __u64,
    pub compact_count: __u64,
    pub compact_delay_total: __u64,
    pub ac_tgid: __u32,
    pub ac_tgetime: __u64,
    pub ac_exe_dev: __u64,
    pub ac_exe_inode: __u64,
    pub wpcopy_count: __u64,
    pub wpcopy_delay_total: __u64,
}
pub const TASKSTATS_CMD_UNSPEC: core::ffi::c_uint = 0;
pub const TASKSTATS_CMD_GET: core::ffi::c_uint = 1;
pub const TASKSTATS_CMD_NEW: core::ffi::c_uint = 2;
pub const __TASKSTATS_CMD_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_93 = core::ffi::c_uint;
pub const TASKSTATS_TYPE_UNSPEC: core::ffi::c_uint = 0;
pub const TASKSTATS_TYPE_PID: core::ffi::c_uint = 1;
pub const TASKSTATS_TYPE_TGID: core::ffi::c_uint = 2;
pub const TASKSTATS_TYPE_STATS: core::ffi::c_uint = 3;
pub const TASKSTATS_TYPE_AGGR_PID: core::ffi::c_uint = 4;
pub const TASKSTATS_TYPE_AGGR_TGID: core::ffi::c_uint = 5;
pub const TASKSTATS_TYPE_NULL: core::ffi::c_uint = 6;
pub const __TASKSTATS_TYPE_MAX: core::ffi::c_uint = 7;
pub type _bindgen_ty_94 = core::ffi::c_uint;
pub const TASKSTATS_CMD_ATTR_UNSPEC: core::ffi::c_uint = 0;
pub const TASKSTATS_CMD_ATTR_PID: core::ffi::c_uint = 1;
pub const TASKSTATS_CMD_ATTR_TGID: core::ffi::c_uint = 2;
pub const TASKSTATS_CMD_ATTR_REGISTER_CPUMASK: core::ffi::c_uint = 3;
pub const TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK: core::ffi::c_uint = 4;
pub const __TASKSTATS_CMD_ATTR_MAX: core::ffi::c_uint = 5;
pub type _bindgen_ty_95 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cgroupstats {
    pub nr_sleeping: __u64,
    pub nr_running: __u64,
    pub nr_stopped: __u64,
    pub nr_uninterruptible: __u64,
    pub nr_io_wait: __u64,
}
pub const CGROUPSTATS_CMD_UNSPEC: core::ffi::c_uint = 3;
pub const CGROUPSTATS_CMD_GET: core::ffi::c_uint = 4;
pub const CGROUPSTATS_CMD_NEW: core::ffi::c_uint = 5;
pub const __CGROUPSTATS_CMD_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_96 = core::ffi::c_uint;
pub const CGROUPSTATS_TYPE_UNSPEC: core::ffi::c_uint = 0;
pub const CGROUPSTATS_TYPE_CGROUP_STATS: core::ffi::c_uint = 1;
pub const __CGROUPSTATS_TYPE_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_97 = core::ffi::c_uint;
pub const CGROUPSTATS_CMD_ATTR_UNSPEC: core::ffi::c_uint = 0;
pub const CGROUPSTATS_CMD_ATTR_FD: core::ffi::c_uint = 1;
pub const __CGROUPSTATS_CMD_ATTR_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_98 = core::ffi::c_uint;
extern "C" {
    pub static mut _ctype: [core::ffi::c_uchar; 0usize];
}
pub const string_size_units_STRING_UNITS_10: string_size_units = 0;
pub const string_size_units_STRING_UNITS_2: string_size_units = 1;
pub type string_size_units = core::ffi::c_uint;
extern "C" {
    pub fn string_get_size(
        size: u64_,
        blk_size: u64_,
        units: string_size_units,
        buf: *mut core::ffi::c_char,
        len: core::ffi::c_int,
    );
}
extern "C" {
    pub fn parse_int_array_user(
        from: *const core::ffi::c_char,
        count: usize,
        array: *mut *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn string_unescape(
        src: *mut core::ffi::c_char,
        dst: *mut core::ffi::c_char,
        size: usize,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn string_escape_mem(
        src: *const core::ffi::c_char,
        isz: usize,
        dst: *mut core::ffi::c_char,
        osz: usize,
        flags: core::ffi::c_uint,
        only: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kstrdup_quotable(src: *const core::ffi::c_char, gfp: gfp_t) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kstrdup_quotable_cmdline(task: *mut task_struct, gfp: gfp_t) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kstrdup_quotable_file(file: *mut file, gfp: gfp_t) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn kasprintf_strarray(
        gfp: gfp_t,
        prefix: *const core::ffi::c_char,
        n: usize,
    ) -> *mut *mut core::ffi::c_char;
}
extern "C" {
    pub fn kfree_strarray(array: *mut *mut core::ffi::c_char, n: usize);
}
extern "C" {
    pub fn devm_kasprintf_strarray(
        dev: *mut device,
        prefix: *const core::ffi::c_char,
        n: usize,
    ) -> *mut *mut core::ffi::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_file {
    pub buf: *mut core::ffi::c_char,
    pub size: usize,
    pub from: usize,
    pub count: usize,
    pub pad_until: usize,
    pub index: loff_t,
    pub read_pos: loff_t,
    pub lock: mutex,
    pub op: *const seq_operations,
    pub poll_event: core::ffi::c_int,
    pub file: *const file,
    pub private: *mut core::ffi::c_void,
}
impl Default for seq_file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seq_operations {
    pub start: ::core::option::Option<
        unsafe extern "C" fn(m: *mut seq_file, pos: *mut loff_t) -> *mut core::ffi::c_void,
    >,
    pub stop:
        ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, v: *mut core::ffi::c_void)>,
    pub next: ::core::option::Option<
        unsafe extern "C" fn(
            m: *mut seq_file,
            v: *mut core::ffi::c_void,
            pos: *mut loff_t,
        ) -> *mut core::ffi::c_void,
    >,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(m: *mut seq_file, v: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub fn seq_pad(m: *mut seq_file, c: core::ffi::c_char);
}
extern "C" {
    pub fn mangle_path(
        s: *mut core::ffi::c_char,
        p: *const core::ffi::c_char,
        esc: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn seq_open(arg1: *mut file, arg2: *const seq_operations) -> core::ffi::c_int;
}
extern "C" {
    pub fn seq_read(
        arg1: *mut file,
        arg2: *mut core::ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn seq_read_iter(iocb: *mut kiocb, iter: *mut iov_iter) -> isize;
}
extern "C" {
    pub fn seq_lseek(arg1: *mut file, arg2: loff_t, arg3: core::ffi::c_int) -> loff_t;
}
extern "C" {
    pub fn seq_release(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn seq_write(
        seq: *mut seq_file,
        data: *const core::ffi::c_void,
        len: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn seq_vprintf(m: *mut seq_file, fmt: *const core::ffi::c_char, args: va_list);
}
extern "C" {
    pub fn seq_printf(m: *mut seq_file, fmt: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn seq_putc(m: *mut seq_file, c: core::ffi::c_char);
}
extern "C" {
    pub fn seq_puts(m: *mut seq_file, s: *const core::ffi::c_char);
}
extern "C" {
    pub fn seq_put_decimal_ull_width(
        m: *mut seq_file,
        delimiter: *const core::ffi::c_char,
        num: core::ffi::c_ulonglong,
        width: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn seq_put_decimal_ull(
        m: *mut seq_file,
        delimiter: *const core::ffi::c_char,
        num: core::ffi::c_ulonglong,
    );
}
extern "C" {
    pub fn seq_put_decimal_ll(
        m: *mut seq_file,
        delimiter: *const core::ffi::c_char,
        num: core::ffi::c_longlong,
    );
}
extern "C" {
    pub fn seq_put_hex_ll(
        m: *mut seq_file,
        delimiter: *const core::ffi::c_char,
        v: core::ffi::c_ulonglong,
        width: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn seq_escape_mem(
        m: *mut seq_file,
        src: *const core::ffi::c_char,
        len: usize,
        flags: core::ffi::c_uint,
        esc: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn seq_hex_dump(
        m: *mut seq_file,
        prefix_str: *const core::ffi::c_char,
        prefix_type: core::ffi::c_int,
        rowsize: core::ffi::c_int,
        groupsize: core::ffi::c_int,
        buf: *const core::ffi::c_void,
        len: usize,
        ascii: bool_,
    );
}
extern "C" {
    pub fn seq_path(
        arg1: *mut seq_file,
        arg2: *const path,
        arg3: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn seq_file_path(
        arg1: *mut seq_file,
        arg2: *mut file,
        arg3: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn seq_dentry(
        arg1: *mut seq_file,
        arg2: *mut dentry,
        arg3: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn seq_path_root(
        m: *mut seq_file,
        path: *const path,
        root: *const path,
        esc: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn single_start(arg1: *mut seq_file, arg2: *mut loff_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn single_open(
        arg1: *mut file,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg3: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn single_open_size(
        arg1: *mut file,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut seq_file,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg3: *mut core::ffi::c_void,
        arg4: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn single_release(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn __seq_open_private(
        arg1: *mut file,
        arg2: *const seq_operations,
        arg3: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn seq_open_private(
        arg1: *mut file,
        arg2: *const seq_operations,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn seq_release_private(arg1: *mut inode, arg2: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn seq_bprintf(m: *mut seq_file, f: *const core::ffi::c_char, binary: *const u32_);
}
extern "C" {
    pub fn seq_list_start(head: *mut list_head, pos: loff_t) -> *mut list_head;
}
extern "C" {
    pub fn seq_list_start_head(head: *mut list_head, pos: loff_t) -> *mut list_head;
}
extern "C" {
    pub fn seq_list_next(
        v: *mut core::ffi::c_void,
        head: *mut list_head,
        ppos: *mut loff_t,
    ) -> *mut list_head;
}
extern "C" {
    pub fn seq_list_start_rcu(head: *mut list_head, pos: loff_t) -> *mut list_head;
}
extern "C" {
    pub fn seq_list_start_head_rcu(head: *mut list_head, pos: loff_t) -> *mut list_head;
}
extern "C" {
    pub fn seq_list_next_rcu(
        v: *mut core::ffi::c_void,
        head: *mut list_head,
        ppos: *mut loff_t,
    ) -> *mut list_head;
}
extern "C" {
    pub fn seq_hlist_start(head: *mut hlist_head, pos: loff_t) -> *mut hlist_node;
}
extern "C" {
    pub fn seq_hlist_start_head(head: *mut hlist_head, pos: loff_t) -> *mut hlist_node;
}
extern "C" {
    pub fn seq_hlist_next(
        v: *mut core::ffi::c_void,
        head: *mut hlist_head,
        ppos: *mut loff_t,
    ) -> *mut hlist_node;
}
extern "C" {
    pub fn seq_hlist_start_rcu(head: *mut hlist_head, pos: loff_t) -> *mut hlist_node;
}
extern "C" {
    pub fn seq_hlist_start_head_rcu(head: *mut hlist_head, pos: loff_t) -> *mut hlist_node;
}
extern "C" {
    pub fn seq_hlist_next_rcu(
        v: *mut core::ffi::c_void,
        head: *mut hlist_head,
        ppos: *mut loff_t,
    ) -> *mut hlist_node;
}
extern "C" {
    pub fn seq_hlist_start_percpu(
        head: *mut hlist_head,
        cpu: *mut core::ffi::c_int,
        pos: loff_t,
    ) -> *mut hlist_node;
}
extern "C" {
    pub fn seq_hlist_next_percpu(
        v: *mut core::ffi::c_void,
        head: *mut hlist_head,
        cpu: *mut core::ffi::c_int,
        pos: *mut loff_t,
    ) -> *mut hlist_node;
}
extern "C" {
    pub fn seq_file_init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct proc_ns_operations {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ns_common {
    pub stashed: atomic_long_t,
    pub ops: *const proc_ns_operations,
    pub inum: core::ffi::c_uint,
    pub count: refcount_t,
}
impl Default for ns_common {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mnt_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uts_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipc_namespace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsproxy {
    pub count: atomic_t,
    pub uts_ns: *mut uts_namespace,
    pub ipc_ns: *mut ipc_namespace,
    pub mnt_ns: *mut mnt_namespace,
    pub pid_ns_for_children: *mut pid_namespace,
    pub net_ns: *mut net,
    pub time_ns: *mut time_namespace,
    pub time_ns_for_children: *mut time_namespace,
    pub cgroup_ns: *mut cgroup_namespace,
}
impl Default for nsproxy {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut init_nsproxy: nsproxy;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nsset {
    pub flags: core::ffi::c_uint,
    pub nsproxy: *mut nsproxy,
    pub fs: *mut fs_struct,
    pub cred: *const cred,
}
impl Default for nsset {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn copy_namespaces(flags: core::ffi::c_ulong, tsk: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn exit_task_namespaces(tsk: *mut task_struct);
}
extern "C" {
    pub fn switch_task_namespaces(tsk: *mut task_struct, new: *mut nsproxy);
}
extern "C" {
    pub fn free_nsproxy(ns: *mut nsproxy);
}
extern "C" {
    pub fn unshare_nsproxy_namespaces(
        arg1: core::ffi::c_ulong,
        arg2: *mut *mut nsproxy,
        arg3: *mut cred,
        arg4: *mut fs_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nsproxy_cache_init() -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct uid_gid_extent {
    pub first: u32_,
    pub lower_first: u32_,
    pub count: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uid_gid_map {
    pub nr_extents: u32_,
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union uid_gid_map__bindgen_ty_1 {
    pub extent: [uid_gid_extent; 5usize],
    pub __bindgen_anon_1: uid_gid_map__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uid_gid_map__bindgen_ty_1__bindgen_ty_1 {
    pub forward: *mut uid_gid_extent,
    pub reverse: *mut uid_gid_extent,
}
impl Default for uid_gid_map__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for uid_gid_map__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for uid_gid_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const ucount_type_UCOUNT_USER_NAMESPACES: ucount_type = 0;
pub const ucount_type_UCOUNT_PID_NAMESPACES: ucount_type = 1;
pub const ucount_type_UCOUNT_UTS_NAMESPACES: ucount_type = 2;
pub const ucount_type_UCOUNT_IPC_NAMESPACES: ucount_type = 3;
pub const ucount_type_UCOUNT_NET_NAMESPACES: ucount_type = 4;
pub const ucount_type_UCOUNT_MNT_NAMESPACES: ucount_type = 5;
pub const ucount_type_UCOUNT_CGROUP_NAMESPACES: ucount_type = 6;
pub const ucount_type_UCOUNT_TIME_NAMESPACES: ucount_type = 7;
pub const ucount_type_UCOUNT_INOTIFY_INSTANCES: ucount_type = 8;
pub const ucount_type_UCOUNT_INOTIFY_WATCHES: ucount_type = 9;
pub const ucount_type_UCOUNT_COUNTS: ucount_type = 10;
pub type ucount_type = core::ffi::c_uint;
pub const rlimit_type_UCOUNT_RLIMIT_NPROC: rlimit_type = 0;
pub const rlimit_type_UCOUNT_RLIMIT_MSGQUEUE: rlimit_type = 1;
pub const rlimit_type_UCOUNT_RLIMIT_SIGPENDING: rlimit_type = 2;
pub const rlimit_type_UCOUNT_RLIMIT_MEMLOCK: rlimit_type = 3;
pub const rlimit_type_UCOUNT_RLIMIT_COUNTS: rlimit_type = 4;
pub type rlimit_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ucounts {
    pub node: hlist_node,
    pub ns: *mut user_namespace,
    pub uid: kuid_t,
    pub count: atomic_t,
    pub ucount: [atomic_long_t; 10usize],
    pub rlimit: [atomic_long_t; 4usize],
}
impl Default for ucounts {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut init_ucounts: ucounts;
}
extern "C" {
    pub fn setup_userns_sysctls(ns: *mut user_namespace) -> bool_;
}
extern "C" {
    pub fn retire_userns_sysctls(ns: *mut user_namespace);
}
extern "C" {
    pub fn inc_ucount(ns: *mut user_namespace, uid: kuid_t, type_: ucount_type) -> *mut ucounts;
}
extern "C" {
    pub fn dec_ucount(ucounts: *mut ucounts, type_: ucount_type);
}
extern "C" {
    pub fn alloc_ucounts(ns: *mut user_namespace, uid: kuid_t) -> *mut ucounts;
}
extern "C" {
    pub fn get_ucounts(ucounts: *mut ucounts) -> *mut ucounts;
}
extern "C" {
    pub fn put_ucounts(ucounts: *mut ucounts);
}
extern "C" {
    pub fn inc_rlimit_ucounts(
        ucounts: *mut ucounts,
        type_: rlimit_type,
        v: core::ffi::c_long,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn dec_rlimit_ucounts(
        ucounts: *mut ucounts,
        type_: rlimit_type,
        v: core::ffi::c_long,
    ) -> bool_;
}
extern "C" {
    pub fn inc_rlimit_get_ucounts(ucounts: *mut ucounts, type_: rlimit_type) -> core::ffi::c_long;
}
extern "C" {
    pub fn dec_rlimit_put_ucounts(ucounts: *mut ucounts, type_: rlimit_type);
}
extern "C" {
    pub fn is_rlimit_overlimit(
        ucounts: *mut ucounts,
        type_: rlimit_type,
        max: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn create_user_ns(new: *mut cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn unshare_userns(
        unshare_flags: core::ffi::c_ulong,
        new_cred: *mut *mut cred,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __put_user_ns(ns: *mut user_namespace);
}
extern "C" {
    pub static proc_uid_seq_operations: seq_operations;
}
extern "C" {
    pub static proc_gid_seq_operations: seq_operations;
}
extern "C" {
    pub static proc_projid_seq_operations: seq_operations;
}
extern "C" {
    pub fn proc_uid_map_write(
        arg1: *mut file,
        arg2: *const core::ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn proc_gid_map_write(
        arg1: *mut file,
        arg2: *const core::ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn proc_projid_map_write(
        arg1: *mut file,
        arg2: *const core::ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn proc_setgroups_write(
        arg1: *mut file,
        arg2: *const core::ffi::c_char,
        arg3: usize,
        arg4: *mut loff_t,
    ) -> isize;
}
extern "C" {
    pub fn proc_setgroups_show(m: *mut seq_file, v: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn userns_may_setgroups(ns: *const user_namespace) -> bool_;
}
extern "C" {
    pub fn in_userns(ancestor: *const user_namespace, child: *const user_namespace) -> bool_;
}
extern "C" {
    pub fn current_in_userns(target_ns: *const user_namespace) -> bool_;
}
extern "C" {
    pub fn ns_get_owner(ns: *mut ns_common) -> *mut ns_common;
}
pub const ctx_state_CONTEXT_DISABLED: ctx_state = -1;
pub const ctx_state_CONTEXT_KERNEL: ctx_state = 0;
pub const ctx_state_CONTEXT_IDLE: ctx_state = 1;
pub const ctx_state_CONTEXT_USER: ctx_state = 2;
pub const ctx_state_CONTEXT_GUEST: ctx_state = 3;
pub const ctx_state_CONTEXT_MAX: ctx_state = 4;
pub type ctx_state = core::ffi::c_int;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct context_tracking {
    pub state: atomic_t,
    pub dynticks_nesting: core::ffi::c_long,
    pub dynticks_nmi_nesting: core::ffi::c_long,
}
extern "C" {
    pub static mut context_tracking: context_tracking;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct irq_cpustat_t {
    pub __softirq_pending: core::ffi::c_uint,
}
impl Default for irq_cpustat_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut irq_stat: irq_cpustat_t;
}
pub type irq_flow_handler_t = ::core::option::Option<unsafe extern "C" fn(desc: *mut irq_desc)>;
extern "C" {
    pub fn ptep_clear_flush(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        ptep: *mut pte_t,
    ) -> pte_t;
}
extern "C" {
    pub fn pmdp_huge_clear_flush(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pmdp: *mut pmd_t,
    ) -> pmd_t;
}
extern "C" {
    pub fn pudp_huge_clear_flush(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pudp: *mut pud_t,
    ) -> pud_t;
}
extern "C" {
    pub fn pgtable_trans_huge_deposit(mm: *mut mm_struct, pmdp: *mut pmd_t, pgtable: pgtable_t);
}
extern "C" {
    pub fn pgtable_trans_huge_withdraw(mm: *mut mm_struct, pmdp: *mut pmd_t) -> pgtable_t;
}
extern "C" {
    pub fn pmdp_invalidate(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pmdp: *mut pmd_t,
    ) -> pmd_t;
}
extern "C" {
    pub fn pmdp_invalidate_ad(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pmdp: *mut pmd_t,
    ) -> pmd_t;
}
extern "C" {
    pub fn pgd_clear_bad(arg1: *mut pgd_t);
}
extern "C" {
    pub fn p4d_clear_bad(arg1: *mut p4d_t);
}
extern "C" {
    pub fn pud_clear_bad(arg1: *mut pud_t);
}
extern "C" {
    pub fn pmd_clear_bad(arg1: *mut pmd_t);
}
extern "C" {
    pub fn phys_mem_access_prot_allowed(
        file: *mut file,
        pfn: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        vma_prot: *mut pgprot_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pgtable_cache_init();
}
pub type pgtbl_mod_mask = core::ffi::c_uint;
extern "C" {
    pub fn early_ioremap(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn early_memremap(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn early_memremap_ro(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn early_memremap_prot(
        phys_addr: resource_size_t,
        size: core::ffi::c_ulong,
        prot_val: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn early_iounmap(addr: *mut core::ffi::c_void, size: core::ffi::c_ulong);
}
extern "C" {
    pub fn early_memunmap(addr: *mut core::ffi::c_void, size: core::ffi::c_ulong);
}
extern "C" {
    pub fn early_ioremap_init();
}
extern "C" {
    pub fn early_ioremap_setup();
}
extern "C" {
    pub fn early_ioremap_reset();
}
extern "C" {
    pub fn copy_from_early_mem(
        dest: *mut core::ffi::c_void,
        src: phys_addr_t,
        size: core::ffi::c_ulong,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pci_dev {
    _unused: [u8; 0],
}
extern "C" {
    pub fn pci_iomap(
        dev: *mut pci_dev,
        bar: core::ffi::c_int,
        max: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn pci_iomap_wc(
        dev: *mut pci_dev,
        bar: core::ffi::c_int,
        max: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn pci_iomap_range(
        dev: *mut pci_dev,
        bar: core::ffi::c_int,
        offset: core::ffi::c_ulong,
        maxlen: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn pci_iomap_wc_range(
        dev: *mut pci_dev,
        bar: core::ffi::c_int,
        offset: core::ffi::c_ulong,
        maxlen: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn pci_iounmap(dev: *mut pci_dev, arg1: *mut core::ffi::c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_handle {
    pub secondary: *mut fwnode_handle,
    pub ops: *const fwnode_operations,
    pub dev: *mut device,
    pub suppliers: list_head,
    pub consumers: list_head,
    pub flags: u8_,
}
impl Default for fwnode_handle {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_link {
    pub supplier: *mut fwnode_handle,
    pub s_hook: list_head,
    pub consumer: *mut fwnode_handle,
    pub c_hook: list_head,
}
impl Default for fwnode_link {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_endpoint {
    pub port: core::ffi::c_uint,
    pub id: core::ffi::c_uint,
    pub local_fwnode: *const fwnode_handle,
}
impl Default for fwnode_endpoint {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fwnode_reference_args {
    pub fwnode: *mut fwnode_handle,
    pub nargs: core::ffi::c_uint,
    pub args: [u64_; 8usize],
}
impl Default for fwnode_reference_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fwnode_operations {
    pub get: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub put: ::core::option::Option<unsafe extern "C" fn(fwnode: *mut fwnode_handle)>,
    pub device_is_available:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
    pub device_get_match_data: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            dev: *const device,
        ) -> *const core::ffi::c_void,
    >,
    pub device_dma_supported:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> bool_>,
    pub device_get_dma_attr:
        ::core::option::Option<unsafe extern "C" fn(fwnode: *const fwnode_handle) -> dev_dma_attr>,
    pub property_present: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const core::ffi::c_char,
        ) -> bool_,
    >,
    pub property_read_int_array: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            propname: *const core::ffi::c_char,
            elem_size: core::ffi::c_uint,
            val: *mut core::ffi::c_void,
            nval: usize,
        ) -> core::ffi::c_int,
    >,
    pub property_read_string_array: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode_handle: *const fwnode_handle,
            propname: *const core::ffi::c_char,
            val: *mut *const core::ffi::c_char,
            nval: usize,
        ) -> core::ffi::c_int,
    >,
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *const core::ffi::c_char,
    >,
    pub get_name_prefix: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *const core::ffi::c_char,
    >,
    pub get_parent: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub get_next_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            child: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub get_named_child_node: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            name: *const core::ffi::c_char,
        ) -> *mut fwnode_handle,
    >,
    pub get_reference_args: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prop: *const core::ffi::c_char,
            nargs_prop: *const core::ffi::c_char,
            nargs: core::ffi::c_uint,
            index: core::ffi::c_uint,
            args: *mut fwnode_reference_args,
        ) -> core::ffi::c_int,
    >,
    pub graph_get_next_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            prev: *mut fwnode_handle,
        ) -> *mut fwnode_handle,
    >,
    pub graph_get_remote_endpoint: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *const fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_get_port_parent: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> *mut fwnode_handle,
    >,
    pub graph_parse_endpoint: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            endpoint: *mut fwnode_endpoint,
        ) -> core::ffi::c_int,
    >,
    pub iomap: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *mut fwnode_handle,
            index: core::ffi::c_int,
        ) -> *mut core::ffi::c_void,
    >,
    pub irq_get: ::core::option::Option<
        unsafe extern "C" fn(
            fwnode: *const fwnode_handle,
            index: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub add_links: ::core::option::Option<
        unsafe extern "C" fn(fwnode: *mut fwnode_handle) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub fn fw_devlink_get_flags() -> u32_;
}
extern "C" {
    pub fn fw_devlink_is_strict() -> bool_;
}
extern "C" {
    pub fn fwnode_link_add(con: *mut fwnode_handle, sup: *mut fwnode_handle) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_links_purge(fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn fw_devlink_purge_absent_suppliers(fwnode: *mut fwnode_handle);
}
pub const LOGIC_PIO_INDIRECT: core::ffi::c_uint = 0;
pub const LOGIC_PIO_CPU_MMIO: core::ffi::c_uint = 1;
pub type _bindgen_ty_99 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct logic_pio_hwaddr {
    pub list: list_head,
    pub fwnode: *mut fwnode_handle,
    pub hw_start: resource_size_t,
    pub io_start: resource_size_t,
    pub size: resource_size_t,
    pub flags: core::ffi::c_ulong,
    pub hostdata: *mut core::ffi::c_void,
    pub ops: *const logic_pio_host_ops,
}
impl Default for logic_pio_hwaddr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct logic_pio_host_ops {
    pub in_: ::core::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut core::ffi::c_void,
            addr: core::ffi::c_ulong,
            dwidth: usize,
        ) -> u32_,
    >,
    pub out: ::core::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut core::ffi::c_void,
            addr: core::ffi::c_ulong,
            val: u32_,
            dwidth: usize,
        ),
    >,
    pub ins: ::core::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut core::ffi::c_void,
            addr: core::ffi::c_ulong,
            buffer: *mut core::ffi::c_void,
            dwidth: usize,
            count: core::ffi::c_uint,
        ) -> u32_,
    >,
    pub outs: ::core::option::Option<
        unsafe extern "C" fn(
            hostdata: *mut core::ffi::c_void,
            addr: core::ffi::c_ulong,
            buffer: *const core::ffi::c_void,
            dwidth: usize,
            count: core::ffi::c_uint,
        ),
    >,
}
extern "C" {
    pub fn find_io_range_by_fwnode(fwnode: *mut fwnode_handle) -> *mut logic_pio_hwaddr;
}
extern "C" {
    pub fn logic_pio_trans_hwaddr(
        fwnode: *mut fwnode_handle,
        hw_addr: resource_size_t,
        size: resource_size_t,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn logic_pio_register_range(newrange: *mut logic_pio_hwaddr) -> core::ffi::c_int;
}
extern "C" {
    pub fn logic_pio_unregister_range(range: *mut logic_pio_hwaddr);
}
extern "C" {
    pub fn logic_pio_to_hwaddr(pio: core::ffi::c_ulong) -> resource_size_t;
}
extern "C" {
    pub fn logic_pio_trans_cpuaddr(hw_addr: resource_size_t) -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_struct {
    pub next: *mut vm_struct,
    pub addr: *mut core::ffi::c_void,
    pub size: core::ffi::c_ulong,
    pub flags: core::ffi::c_ulong,
    pub pages: *mut *mut page,
    pub nr_pages: core::ffi::c_uint,
    pub phys_addr: phys_addr_t,
    pub caller: *const core::ffi::c_void,
}
impl Default for vm_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vmap_area {
    pub va_start: core::ffi::c_ulong,
    pub va_end: core::ffi::c_ulong,
    pub rb_node: rb_node,
    pub list: list_head,
    pub __bindgen_anon_1: vmap_area__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vmap_area__bindgen_ty_1 {
    pub subtree_max_size: core::ffi::c_ulong,
    pub vm: *mut vm_struct,
    _bindgen_union_align: u64,
}
impl Default for vmap_area__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for vmap_area {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn vm_unmap_ram(mem: *const core::ffi::c_void, count: core::ffi::c_uint);
}
extern "C" {
    pub fn vm_map_ram(
        pages: *mut *mut page,
        count: core::ffi::c_uint,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vm_unmap_aliases();
}
extern "C" {
    pub fn vmalloc_init();
}
extern "C" {
    pub fn vmalloc_nr_pages() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn vmalloc(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vzalloc(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_user(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_node(size: core::ffi::c_ulong, node: core::ffi::c_int)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vzalloc_node(size: core::ffi::c_ulong, node: core::ffi::c_int)
        -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_32(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_32_user(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __vmalloc(size: core::ffi::c_ulong, gfp_mask: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __vmalloc_node_range(
        size: core::ffi::c_ulong,
        align: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        gfp_mask: gfp_t,
        prot: pgprot_t,
        vm_flags: core::ffi::c_ulong,
        node: core::ffi::c_int,
        caller: *const core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __vmalloc_node(
        size: core::ffi::c_ulong,
        align: core::ffi::c_ulong,
        gfp_mask: gfp_t,
        node: core::ffi::c_int,
        caller: *const core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_huge(size: core::ffi::c_ulong, gfp_mask: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __vmalloc_array(n: usize, size: usize, flags: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmalloc_array(n: usize, size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __vcalloc(n: usize, size: usize, flags: gfp_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vcalloc(n: usize, size: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vfree(addr: *const core::ffi::c_void);
}
extern "C" {
    pub fn vfree_atomic(addr: *const core::ffi::c_void);
}
extern "C" {
    pub fn vmap(
        pages: *mut *mut page,
        count: core::ffi::c_uint,
        flags: core::ffi::c_ulong,
        prot: pgprot_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmap_pfn(
        pfns: *mut core::ffi::c_ulong,
        count: core::ffi::c_uint,
        prot: pgprot_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vunmap(addr: *const core::ffi::c_void);
}
extern "C" {
    pub fn remap_vmalloc_range_partial(
        vma: *mut vm_area_struct,
        uaddr: core::ffi::c_ulong,
        kaddr: *mut core::ffi::c_void,
        pgoff: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn remap_vmalloc_range(
        vma: *mut vm_area_struct,
        addr: *mut core::ffi::c_void,
        pgoff: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_sync_kernel_mappings(start: core::ffi::c_ulong, end: core::ffi::c_ulong);
}
extern "C" {
    pub fn get_vm_area(size: core::ffi::c_ulong, flags: core::ffi::c_ulong) -> *mut vm_struct;
}
extern "C" {
    pub fn get_vm_area_caller(
        size: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        caller: *const core::ffi::c_void,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn __get_vm_area_caller(
        size: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        caller: *const core::ffi::c_void,
    ) -> *mut vm_struct;
}
extern "C" {
    pub fn free_vm_area(area: *mut vm_struct);
}
extern "C" {
    pub fn remove_vm_area(addr: *const core::ffi::c_void) -> *mut vm_struct;
}
extern "C" {
    pub fn find_vm_area(addr: *const core::ffi::c_void) -> *mut vm_struct;
}
extern "C" {
    pub fn find_vmap_area(addr: core::ffi::c_ulong) -> *mut vmap_area;
}
extern "C" {
    pub fn vunmap_range(addr: core::ffi::c_ulong, end: core::ffi::c_ulong);
}
extern "C" {
    pub fn vread(
        buf: *mut core::ffi::c_char,
        addr: *mut core::ffi::c_char,
        count: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub static mut vmap_area_list: list_head;
}
extern "C" {
    pub fn vm_area_add_early(vm: *mut vm_struct);
}
extern "C" {
    pub fn vm_area_register_early(vm: *mut vm_struct, align: usize);
}
extern "C" {
    pub fn pcpu_get_vm_areas(
        offsets: *const core::ffi::c_ulong,
        sizes: *const usize,
        nr_vms: core::ffi::c_int,
        align: usize,
    ) -> *mut *mut vm_struct;
}
extern "C" {
    pub fn pcpu_free_vm_areas(vms: *mut *mut vm_struct, nr_vms: core::ffi::c_int);
}
extern "C" {
    pub fn register_vmap_purge_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_vmap_purge_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmalloc_dump_obj(object: *mut core::ffi::c_void) -> bool_;
}
extern "C" {
    pub fn ioremap_prot(
        phys_addr: phys_addr_t,
        size: usize,
        prot: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn iounmap(addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devmem_is_allowed(pfn: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn __iowrite32_copy(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        count: usize,
    );
}
extern "C" {
    pub fn __ioread32_copy(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        count: usize,
    );
}
extern "C" {
    pub fn __iowrite64_copy(
        to: *mut core::ffi::c_void,
        from: *const core::ffi::c_void,
        count: usize,
    );
}
extern "C" {
    pub fn ioremap_page_range(
        addr: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        phys_addr: phys_addr_t,
        prot: pgprot_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_ioport_map(
        dev: *mut device,
        port: core::ffi::c_ulong,
        nr: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_ioport_unmap(dev: *mut device, addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devm_ioremap(
        dev: *mut device,
        offset: resource_size_t,
        size: resource_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_ioremap_uc(
        dev: *mut device,
        offset: resource_size_t,
        size: resource_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_ioremap_wc(
        dev: *mut device,
        offset: resource_size_t,
        size: resource_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_iounmap(dev: *mut device, addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn check_signature(
        io_addr: *const core::ffi::c_void,
        signature: *const core::ffi::c_uchar,
        length: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_ioremap_release(dev: *mut device, res: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devm_memremap(
        dev: *mut device,
        offset: resource_size_t,
        size: usize,
        flags: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_memunmap(dev: *mut device, addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devm_arch_phys_wc_add(
        dev: *mut device,
        base: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
pub const MEMREMAP_WB: core::ffi::c_uint = 1;
pub const MEMREMAP_WT: core::ffi::c_uint = 2;
pub const MEMREMAP_WC: core::ffi::c_uint = 4;
pub const MEMREMAP_ENC: core::ffi::c_uint = 8;
pub const MEMREMAP_DEC: core::ffi::c_uint = 16;
pub type _bindgen_ty_100 = core::ffi::c_uint;
extern "C" {
    pub fn memremap(
        offset: resource_size_t,
        size: usize,
        flags: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn memunmap(addr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devm_arch_io_reserve_memtype_wc(
        dev: *mut device,
        start: resource_size_t,
        size: resource_size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn init_IRQ();
}
extern "C" {
    pub static mut __irq_regs: *mut pt_regs;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_msg {
    _unused: [u8; 0],
}
pub const IRQ_TYPE_NONE: core::ffi::c_uint = 0;
pub const IRQ_TYPE_EDGE_RISING: core::ffi::c_uint = 1;
pub const IRQ_TYPE_EDGE_FALLING: core::ffi::c_uint = 2;
pub const IRQ_TYPE_EDGE_BOTH: core::ffi::c_uint = 3;
pub const IRQ_TYPE_LEVEL_HIGH: core::ffi::c_uint = 4;
pub const IRQ_TYPE_LEVEL_LOW: core::ffi::c_uint = 8;
pub const IRQ_TYPE_LEVEL_MASK: core::ffi::c_uint = 12;
pub const IRQ_TYPE_SENSE_MASK: core::ffi::c_uint = 15;
pub const IRQ_TYPE_DEFAULT: core::ffi::c_uint = 15;
pub const IRQ_TYPE_PROBE: core::ffi::c_uint = 16;
pub const IRQ_LEVEL: core::ffi::c_uint = 256;
pub const IRQ_PER_CPU: core::ffi::c_uint = 512;
pub const IRQ_NOPROBE: core::ffi::c_uint = 1024;
pub const IRQ_NOREQUEST: core::ffi::c_uint = 2048;
pub const IRQ_NOAUTOEN: core::ffi::c_uint = 4096;
pub const IRQ_NO_BALANCING: core::ffi::c_uint = 8192;
pub const IRQ_MOVE_PCNTXT: core::ffi::c_uint = 16384;
pub const IRQ_NESTED_THREAD: core::ffi::c_uint = 32768;
pub const IRQ_NOTHREAD: core::ffi::c_uint = 65536;
pub const IRQ_PER_CPU_DEVID: core::ffi::c_uint = 131072;
pub const IRQ_IS_POLLED: core::ffi::c_uint = 262144;
pub const IRQ_DISABLE_UNLAZY: core::ffi::c_uint = 524288;
pub const IRQ_HIDDEN: core::ffi::c_uint = 1048576;
pub const IRQ_NO_DEBUG: core::ffi::c_uint = 2097152;
pub type _bindgen_ty_101 = core::ffi::c_uint;
pub const IRQ_SET_MASK_OK: core::ffi::c_uint = 0;
pub const IRQ_SET_MASK_OK_NOCOPY: core::ffi::c_uint = 1;
pub const IRQ_SET_MASK_OK_DONE: core::ffi::c_uint = 2;
pub type _bindgen_ty_102 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_desc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_common_data {
    pub state_use_accessors: core::ffi::c_uint,
    pub handler_data: *mut core::ffi::c_void,
    pub msi_desc: *mut msi_desc,
    pub affinity: cpumask_var_t,
    pub effective_affinity: cpumask_var_t,
}
impl Default for irq_common_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_data {
    pub mask: u32_,
    pub irq: core::ffi::c_uint,
    pub hwirq: core::ffi::c_ulong,
    pub common: *mut irq_common_data,
    pub chip: *mut irq_chip,
    pub domain: *mut irq_domain,
    pub parent_data: *mut irq_data,
    pub chip_data: *mut core::ffi::c_void,
}
impl Default for irq_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const IRQD_TRIGGER_MASK: core::ffi::c_uint = 15;
pub const IRQD_SETAFFINITY_PENDING: core::ffi::c_uint = 256;
pub const IRQD_ACTIVATED: core::ffi::c_uint = 512;
pub const IRQD_NO_BALANCING: core::ffi::c_uint = 1024;
pub const IRQD_PER_CPU: core::ffi::c_uint = 2048;
pub const IRQD_AFFINITY_SET: core::ffi::c_uint = 4096;
pub const IRQD_LEVEL: core::ffi::c_uint = 8192;
pub const IRQD_WAKEUP_STATE: core::ffi::c_uint = 16384;
pub const IRQD_MOVE_PCNTXT: core::ffi::c_uint = 32768;
pub const IRQD_IRQ_DISABLED: core::ffi::c_uint = 65536;
pub const IRQD_IRQ_MASKED: core::ffi::c_uint = 131072;
pub const IRQD_IRQ_INPROGRESS: core::ffi::c_uint = 262144;
pub const IRQD_WAKEUP_ARMED: core::ffi::c_uint = 524288;
pub const IRQD_FORWARDED_TO_VCPU: core::ffi::c_uint = 1048576;
pub const IRQD_AFFINITY_MANAGED: core::ffi::c_uint = 2097152;
pub const IRQD_IRQ_STARTED: core::ffi::c_uint = 4194304;
pub const IRQD_MANAGED_SHUTDOWN: core::ffi::c_uint = 8388608;
pub const IRQD_SINGLE_TARGET: core::ffi::c_uint = 16777216;
pub const IRQD_DEFAULT_TRIGGER_SET: core::ffi::c_uint = 33554432;
pub const IRQD_CAN_RESERVE: core::ffi::c_uint = 67108864;
pub const IRQD_MSI_NOMASK_QUIRK: core::ffi::c_uint = 134217728;
pub const IRQD_HANDLE_ENFORCE_IRQCTX: core::ffi::c_uint = 268435456;
pub const IRQD_AFFINITY_ON_ACTIVATE: core::ffi::c_uint = 536870912;
pub const IRQD_IRQ_ENABLED_ON_SUSPEND: core::ffi::c_uint = 1073741824;
pub type _bindgen_ty_103 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_chip {
    pub name: *const core::ffi::c_char,
    pub irq_startup:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data) -> core::ffi::c_uint>,
    pub irq_shutdown: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_enable: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_disable: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_ack: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_mask: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_mask_ack: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_unmask: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_eoi: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_set_affinity: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut irq_data,
            dest: *const cpumask,
            force: bool_,
        ) -> core::ffi::c_int,
    >,
    pub irq_retrigger:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data) -> core::ffi::c_int>,
    pub irq_set_type: ::core::option::Option<
        unsafe extern "C" fn(data: *mut irq_data, flow_type: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub irq_set_wake: ::core::option::Option<
        unsafe extern "C" fn(data: *mut irq_data, on: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub irq_bus_lock: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_bus_sync_unlock: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_suspend: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_resume: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_pm_shutdown: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_calc_mask: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_print_chip:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data, p: *mut seq_file)>,
    pub irq_request_resources:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data) -> core::ffi::c_int>,
    pub irq_release_resources: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_compose_msi_msg:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data, msg: *mut msi_msg)>,
    pub irq_write_msi_msg:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data, msg: *mut msi_msg)>,
    pub irq_get_irqchip_state: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut irq_data,
            which: irqchip_irq_state,
            state: *mut bool_,
        ) -> core::ffi::c_int,
    >,
    pub irq_set_irqchip_state: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut irq_data,
            which: irqchip_irq_state,
            state: bool_,
        ) -> core::ffi::c_int,
    >,
    pub irq_set_vcpu_affinity: ::core::option::Option<
        unsafe extern "C" fn(
            data: *mut irq_data,
            vcpu_info: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub ipi_send_single:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data, cpu: core::ffi::c_uint)>,
    pub ipi_send_mask:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data, dest: *const cpumask)>,
    pub irq_nmi_setup:
        ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data) -> core::ffi::c_int>,
    pub irq_nmi_teardown: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub flags: core::ffi::c_ulong,
}
impl Default for irq_chip {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const IRQCHIP_SET_TYPE_MASKED: core::ffi::c_uint = 1;
pub const IRQCHIP_EOI_IF_HANDLED: core::ffi::c_uint = 2;
pub const IRQCHIP_MASK_ON_SUSPEND: core::ffi::c_uint = 4;
pub const IRQCHIP_ONOFFLINE_ENABLED: core::ffi::c_uint = 8;
pub const IRQCHIP_SKIP_SET_WAKE: core::ffi::c_uint = 16;
pub const IRQCHIP_ONESHOT_SAFE: core::ffi::c_uint = 32;
pub const IRQCHIP_EOI_THREADED: core::ffi::c_uint = 64;
pub const IRQCHIP_SUPPORTS_LEVEL_MSI: core::ffi::c_uint = 128;
pub const IRQCHIP_SUPPORTS_NMI: core::ffi::c_uint = 256;
pub const IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND: core::ffi::c_uint = 512;
pub const IRQCHIP_AFFINITY_PRE_STARTUP: core::ffi::c_uint = 1024;
pub const IRQCHIP_IMMUTABLE: core::ffi::c_uint = 2048;
pub type _bindgen_ty_104 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct proc_dir_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct irq_desc {
    pub irq_common_data: irq_common_data,
    pub irq_data: irq_data,
    pub kstat_irqs: *mut core::ffi::c_uint,
    pub handle_irq: irq_flow_handler_t,
    pub action: *mut irqaction,
    pub status_use_accessors: core::ffi::c_uint,
    pub core_internal_state__do_not_mess_with_it: core::ffi::c_uint,
    pub depth: core::ffi::c_uint,
    pub wake_depth: core::ffi::c_uint,
    pub tot_count: core::ffi::c_uint,
    pub irq_count: core::ffi::c_uint,
    pub last_unhandled: core::ffi::c_ulong,
    pub irqs_unhandled: core::ffi::c_uint,
    pub threads_handled: atomic_t,
    pub threads_handled_last: core::ffi::c_int,
    pub lock: raw_spinlock_t,
    pub percpu_enabled: *mut cpumask,
    pub percpu_affinity: *const cpumask,
    pub affinity_hint: *const cpumask,
    pub affinity_notify: *mut irq_affinity_notify,
    pub threads_oneshot: core::ffi::c_ulong,
    pub threads_active: atomic_t,
    pub wait_for_threads: wait_queue_head_t,
    pub dir: *mut proc_dir_entry,
    pub rcu: callback_head,
    pub kobj: kobject,
    pub request_mutex: mutex,
    pub parent_irq: core::ffi::c_int,
    pub owner: *mut module,
    pub name: *const core::ffi::c_char,
}
impl Default for irq_desc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn irq_lock_sparse();
}
extern "C" {
    pub fn irq_unlock_sparse();
}
extern "C" {
    pub fn handle_irq_desc(desc: *mut irq_desc) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_handle_irq(irq: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_handle_irq_safe(irq: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_handle_domain_irq(
        domain: *mut irq_domain,
        hwirq: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_handle_domain_irq_safe(
        domain: *mut irq_domain,
        hwirq: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_handle_domain_nmi(
        domain: *mut irq_domain,
        hwirq: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_check_status_bit(irq: core::ffi::c_uint, bitmask: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn __irq_set_lockdep_class(
        irq: core::ffi::c_uint,
        lock_class: *mut lock_class_key,
        request_class: *mut lock_class_key,
    );
}
extern "C" {
    pub fn setup_percpu_irq(irq: core::ffi::c_uint, new: *mut irqaction) -> core::ffi::c_int;
}
extern "C" {
    pub fn remove_percpu_irq(irq: core::ffi::c_uint, act: *mut irqaction);
}
extern "C" {
    pub fn irq_set_affinity_locked(
        data: *mut irq_data,
        cpumask: *const cpumask,
        force: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_set_vcpu_affinity(
        irq: core::ffi::c_uint,
        vcpu_info: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_migrate_all_off_this_cpu();
}
extern "C" {
    pub fn irq_affinity_online_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub static mut no_irq_affinity: core::ffi::c_int;
}
extern "C" {
    pub fn irq_set_parent(irq: core::ffi::c_int, parent_irq: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn handle_level_irq(desc: *mut irq_desc);
}
extern "C" {
    pub fn handle_fasteoi_irq(desc: *mut irq_desc);
}
extern "C" {
    pub fn handle_edge_irq(desc: *mut irq_desc);
}
extern "C" {
    pub fn handle_edge_eoi_irq(desc: *mut irq_desc);
}
extern "C" {
    pub fn handle_simple_irq(desc: *mut irq_desc);
}
extern "C" {
    pub fn handle_untracked_irq(desc: *mut irq_desc);
}
extern "C" {
    pub fn handle_percpu_irq(desc: *mut irq_desc);
}
extern "C" {
    pub fn handle_percpu_devid_irq(desc: *mut irq_desc);
}
extern "C" {
    pub fn handle_bad_irq(desc: *mut irq_desc);
}
extern "C" {
    pub fn handle_nested_irq(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn handle_fasteoi_nmi(desc: *mut irq_desc);
}
extern "C" {
    pub fn handle_percpu_devid_fasteoi_nmi(desc: *mut irq_desc);
}
extern "C" {
    pub fn irq_chip_compose_msi_msg(data: *mut irq_data, msg: *mut msi_msg) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_chip_pm_get(data: *mut irq_data) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_chip_pm_put(data: *mut irq_data) -> core::ffi::c_int;
}
extern "C" {
    pub fn handle_fasteoi_ack_irq(desc: *mut irq_desc);
}
extern "C" {
    pub fn handle_fasteoi_mask_irq(desc: *mut irq_desc);
}
extern "C" {
    pub fn irq_chip_set_parent_state(
        data: *mut irq_data,
        which: irqchip_irq_state,
        val: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_chip_get_parent_state(
        data: *mut irq_data,
        which: irqchip_irq_state,
        state: *mut bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_chip_enable_parent(data: *mut irq_data);
}
extern "C" {
    pub fn irq_chip_disable_parent(data: *mut irq_data);
}
extern "C" {
    pub fn irq_chip_ack_parent(data: *mut irq_data);
}
extern "C" {
    pub fn irq_chip_retrigger_hierarchy(data: *mut irq_data) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_chip_mask_parent(data: *mut irq_data);
}
extern "C" {
    pub fn irq_chip_mask_ack_parent(data: *mut irq_data);
}
extern "C" {
    pub fn irq_chip_unmask_parent(data: *mut irq_data);
}
extern "C" {
    pub fn irq_chip_eoi_parent(data: *mut irq_data);
}
extern "C" {
    pub fn irq_chip_set_affinity_parent(
        data: *mut irq_data,
        dest: *const cpumask,
        force: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_chip_set_wake_parent(data: *mut irq_data, on: core::ffi::c_uint)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_chip_set_vcpu_affinity_parent(
        data: *mut irq_data,
        vcpu_info: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_chip_set_type_parent(
        data: *mut irq_data,
        type_: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_chip_request_resources_parent(data: *mut irq_data) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_chip_release_resources_parent(data: *mut irq_data);
}
extern "C" {
    pub fn note_interrupt(desc: *mut irq_desc, action_ret: irqreturn_t);
}
extern "C" {
    pub fn noirqdebug_setup(str_: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn can_request_irq(
        irq: core::ffi::c_uint,
        irqflags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut no_irq_chip: irq_chip;
}
extern "C" {
    pub static mut dummy_irq_chip: irq_chip;
}
extern "C" {
    pub fn irq_set_chip_and_handler_name(
        irq: core::ffi::c_uint,
        chip: *const irq_chip,
        handle: irq_flow_handler_t,
        name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn irq_set_percpu_devid(irq: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_set_percpu_devid_partition(
        irq: core::ffi::c_uint,
        affinity: *const cpumask,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_get_percpu_devid_partition(
        irq: core::ffi::c_uint,
        affinity: *mut cpumask,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __irq_set_handler(
        irq: core::ffi::c_uint,
        handle: irq_flow_handler_t,
        is_chained: core::ffi::c_int,
        name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn irq_set_chained_handler_and_data(
        irq: core::ffi::c_uint,
        handle: irq_flow_handler_t,
        data: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn irq_modify_status(
        irq: core::ffi::c_uint,
        clr: core::ffi::c_ulong,
        set: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn irq_set_chip(irq: core::ffi::c_uint, chip: *const irq_chip) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_set_handler_data(
        irq: core::ffi::c_uint,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_set_chip_data(
        irq: core::ffi::c_uint,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_set_irq_type(irq: core::ffi::c_uint, type_: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_set_msi_desc(irq: core::ffi::c_uint, entry: *mut msi_desc) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_set_msi_desc_off(
        irq_base: core::ffi::c_uint,
        irq_offset: core::ffi::c_uint,
        entry: *mut msi_desc,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_get_irq_data(irq: core::ffi::c_uint) -> *mut irq_data;
}
extern "C" {
    pub fn arch_dynirq_lower_bound(from: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __irq_alloc_descs(
        irq: core::ffi::c_int,
        from: core::ffi::c_uint,
        cnt: core::ffi::c_uint,
        node: core::ffi::c_int,
        owner: *mut module,
        affinity: *const irq_affinity_desc,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __devm_irq_alloc_descs(
        dev: *mut device,
        irq: core::ffi::c_int,
        from: core::ffi::c_uint,
        cnt: core::ffi::c_uint,
        node: core::ffi::c_int,
        owner: *mut module,
        affinity: *const irq_affinity_desc,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_free_descs(irq: core::ffi::c_uint, cnt: core::ffi::c_uint);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct irq_chip_regs {
    pub enable: core::ffi::c_ulong,
    pub disable: core::ffi::c_ulong,
    pub mask: core::ffi::c_ulong,
    pub ack: core::ffi::c_ulong,
    pub eoi: core::ffi::c_ulong,
    pub type_: core::ffi::c_ulong,
    pub polarity: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_chip_type {
    pub chip: irq_chip,
    pub regs: irq_chip_regs,
    pub handler: irq_flow_handler_t,
    pub type_: u32_,
    pub mask_cache_priv: u32_,
    pub mask_cache: *mut u32_,
}
impl Default for irq_chip_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct irq_chip_generic {
    pub lock: raw_spinlock_t,
    pub reg_base: *mut core::ffi::c_void,
    pub reg_readl:
        ::core::option::Option<unsafe extern "C" fn(addr: *mut core::ffi::c_void) -> u32_>,
    pub reg_writel:
        ::core::option::Option<unsafe extern "C" fn(val: u32_, addr: *mut core::ffi::c_void)>,
    pub suspend: ::core::option::Option<unsafe extern "C" fn(gc: *mut irq_chip_generic)>,
    pub resume: ::core::option::Option<unsafe extern "C" fn(gc: *mut irq_chip_generic)>,
    pub irq_base: core::ffi::c_uint,
    pub irq_cnt: core::ffi::c_uint,
    pub mask_cache: u32_,
    pub type_cache: u32_,
    pub polarity_cache: u32_,
    pub wake_enabled: u32_,
    pub wake_active: u32_,
    pub num_ct: core::ffi::c_uint,
    pub private: *mut core::ffi::c_void,
    pub installed: core::ffi::c_ulong,
    pub unused: core::ffi::c_ulong,
    pub domain: *mut irq_domain,
    pub list: list_head,
    pub chip_types: __IncompleteArrayField<irq_chip_type>,
}
impl Default for irq_chip_generic {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const irq_gc_flags_IRQ_GC_INIT_MASK_CACHE: irq_gc_flags = 1;
pub const irq_gc_flags_IRQ_GC_INIT_NESTED_LOCK: irq_gc_flags = 2;
pub const irq_gc_flags_IRQ_GC_MASK_CACHE_PER_TYPE: irq_gc_flags = 4;
pub const irq_gc_flags_IRQ_GC_NO_MASK: irq_gc_flags = 8;
pub const irq_gc_flags_IRQ_GC_BE_IO: irq_gc_flags = 16;
pub type irq_gc_flags = core::ffi::c_uint;
#[repr(C)]
pub struct irq_domain_chip_generic {
    pub irqs_per_chip: core::ffi::c_uint,
    pub num_chips: core::ffi::c_uint,
    pub irq_flags_to_clear: core::ffi::c_uint,
    pub irq_flags_to_set: core::ffi::c_uint,
    pub gc_flags: irq_gc_flags,
    pub gc: __IncompleteArrayField<*mut irq_chip_generic>,
}
impl Default for irq_domain_chip_generic {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn irq_gc_noop(d: *mut irq_data);
}
extern "C" {
    pub fn irq_gc_mask_disable_reg(d: *mut irq_data);
}
extern "C" {
    pub fn irq_gc_mask_set_bit(d: *mut irq_data);
}
extern "C" {
    pub fn irq_gc_mask_clr_bit(d: *mut irq_data);
}
extern "C" {
    pub fn irq_gc_unmask_enable_reg(d: *mut irq_data);
}
extern "C" {
    pub fn irq_gc_ack_set_bit(d: *mut irq_data);
}
extern "C" {
    pub fn irq_gc_ack_clr_bit(d: *mut irq_data);
}
extern "C" {
    pub fn irq_gc_mask_disable_and_ack_set(d: *mut irq_data);
}
extern "C" {
    pub fn irq_gc_eoi(d: *mut irq_data);
}
extern "C" {
    pub fn irq_gc_set_wake(d: *mut irq_data, on: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_map_generic_chip(
        d: *mut irq_domain,
        virq: core::ffi::c_uint,
        hw_irq: irq_hw_number_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_unmap_generic_chip(d: *mut irq_domain, virq: core::ffi::c_uint);
}
extern "C" {
    pub fn irq_alloc_generic_chip(
        name: *const core::ffi::c_char,
        nr_ct: core::ffi::c_int,
        irq_base: core::ffi::c_uint,
        reg_base: *mut core::ffi::c_void,
        handler: irq_flow_handler_t,
    ) -> *mut irq_chip_generic;
}
extern "C" {
    pub fn irq_setup_generic_chip(
        gc: *mut irq_chip_generic,
        msk: u32_,
        flags: irq_gc_flags,
        clr: core::ffi::c_uint,
        set: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn irq_setup_alt_chip(d: *mut irq_data, type_: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_remove_generic_chip(
        gc: *mut irq_chip_generic,
        msk: u32_,
        clr: core::ffi::c_uint,
        set: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn devm_irq_alloc_generic_chip(
        dev: *mut device,
        name: *const core::ffi::c_char,
        num_ct: core::ffi::c_int,
        irq_base: core::ffi::c_uint,
        reg_base: *mut core::ffi::c_void,
        handler: irq_flow_handler_t,
    ) -> *mut irq_chip_generic;
}
extern "C" {
    pub fn devm_irq_setup_generic_chip(
        dev: *mut device,
        gc: *mut irq_chip_generic,
        msk: u32_,
        flags: irq_gc_flags,
        clr: core::ffi::c_uint,
        set: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_get_domain_generic_chip(
        d: *mut irq_domain,
        hw_irq: core::ffi::c_uint,
    ) -> *mut irq_chip_generic;
}
extern "C" {
    pub fn __irq_alloc_domain_generic_chips(
        d: *mut irq_domain,
        irqs_per_chip: core::ffi::c_int,
        num_ct: core::ffi::c_int,
        name: *const core::ffi::c_char,
        handler: irq_flow_handler_t,
        clr: core::ffi::c_uint,
        set: core::ffi::c_uint,
        flags: irq_gc_flags,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_matrix {
    _unused: [u8; 0],
}
extern "C" {
    pub fn irq_alloc_matrix(
        matrix_bits: core::ffi::c_uint,
        alloc_start: core::ffi::c_uint,
        alloc_end: core::ffi::c_uint,
    ) -> *mut irq_matrix;
}
extern "C" {
    pub fn irq_matrix_online(m: *mut irq_matrix);
}
extern "C" {
    pub fn irq_matrix_offline(m: *mut irq_matrix);
}
extern "C" {
    pub fn irq_matrix_assign_system(m: *mut irq_matrix, bit: core::ffi::c_uint, replace: bool_);
}
extern "C" {
    pub fn irq_matrix_reserve_managed(m: *mut irq_matrix, msk: *const cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_matrix_remove_managed(m: *mut irq_matrix, msk: *const cpumask);
}
extern "C" {
    pub fn irq_matrix_alloc_managed(
        m: *mut irq_matrix,
        msk: *const cpumask,
        mapped_cpu: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_matrix_reserve(m: *mut irq_matrix);
}
extern "C" {
    pub fn irq_matrix_remove_reserved(m: *mut irq_matrix);
}
extern "C" {
    pub fn irq_matrix_alloc(
        m: *mut irq_matrix,
        msk: *const cpumask,
        reserved: bool_,
        mapped_cpu: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_matrix_free(
        m: *mut irq_matrix,
        cpu: core::ffi::c_uint,
        bit: core::ffi::c_uint,
        managed: bool_,
    );
}
extern "C" {
    pub fn irq_matrix_assign(m: *mut irq_matrix, bit: core::ffi::c_uint);
}
extern "C" {
    pub fn irq_matrix_available(m: *mut irq_matrix, cpudown: bool_) -> core::ffi::c_uint;
}
extern "C" {
    pub fn irq_matrix_allocated(m: *mut irq_matrix) -> core::ffi::c_uint;
}
extern "C" {
    pub fn irq_matrix_reserved(m: *mut irq_matrix) -> core::ffi::c_uint;
}
extern "C" {
    pub fn irq_matrix_debug_show(sf: *mut seq_file, m: *mut irq_matrix, ind: core::ffi::c_int);
}
extern "C" {
    pub fn ipi_get_hwirq(irq: core::ffi::c_uint, cpu: core::ffi::c_uint) -> irq_hw_number_t;
}
extern "C" {
    pub fn __ipi_send_single(desc: *mut irq_desc, cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn __ipi_send_mask(desc: *mut irq_desc, dest: *const cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipi_send_single(virq: core::ffi::c_uint, cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipi_send_mask(virq: core::ffi::c_uint, dest: *const cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_handle_irq(
        handle_irq: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pt_regs)>,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut handle_arch_irq:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pt_regs)>;
}
extern "C" {
    pub fn generic_handle_arch_irq(regs: *mut pt_regs);
}
extern "C" {
    pub fn synchronize_irq(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn synchronize_hardirq(irq: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn irq_enter();
}
extern "C" {
    pub fn irq_enter_rcu();
}
extern "C" {
    pub fn irq_exit();
}
extern "C" {
    pub fn irq_exit_rcu();
}
extern "C" {
    pub static mut _text: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut _stext: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut _etext: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut _data: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut _sdata: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut _edata: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __bss_start: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __bss_stop: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __init_begin: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __init_end: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut _sinittext: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut _einittext: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __start_ro_after_init: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __end_ro_after_init: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut _end: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __per_cpu_load: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __per_cpu_start: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __per_cpu_end: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __kprobes_text_start: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __kprobes_text_end: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __entry_text_start: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __entry_text_end: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __start_rodata: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __end_rodata: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __irqentry_text_start: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __irqentry_text_end: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __softirqentry_text_start: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __softirqentry_text_end: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __start_once: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __end_once: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __ctors_start: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __ctors_end: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __start_opd: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __end_opd: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __noinstr_text_start: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __noinstr_text_end: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static __nosave_begin: core::ffi::c_void;
}
extern "C" {
    pub static __nosave_end: core::ffi::c_void;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct func_desc_t {
    pub addr: core::ffi::c_ulong,
}
extern "C" {
    pub static mut __tracepoint_mmap_lock_start_locking: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_mmap_lock_acquire_returned: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_mmap_lock_released: tracepoint;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct range {
    pub start: u64_,
    pub end: u64_,
}
extern "C" {
    pub fn add_range(
        range: *mut range,
        az: core::ffi::c_int,
        nr_range: core::ffi::c_int,
        start: u64_,
        end: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn add_range_with_merge(
        range: *mut range,
        az: core::ffi::c_int,
        nr_range: core::ffi::c_int,
        start: u64_,
        end: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn subtract_range(range: *mut range, az: core::ffi::c_int, start: u64_, end: u64_);
}
extern "C" {
    pub fn clean_sort_range(range: *mut range, az: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn sort_range(range: *mut range, nr_range: core::ffi::c_int);
}
pub type stack_trace_consume_fn = ::core::option::Option<
    unsafe extern "C" fn(cookie: *mut core::ffi::c_void, addr: core::ffi::c_ulong) -> bool_,
>;
extern "C" {
    pub fn arch_stack_walk(
        consume_entry: stack_trace_consume_fn,
        cookie: *mut core::ffi::c_void,
        task: *mut task_struct,
        regs: *mut pt_regs,
    );
}
extern "C" {
    pub fn arch_stack_walk_reliable(
        consume_entry: stack_trace_consume_fn,
        cookie: *mut core::ffi::c_void,
        task: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_stack_walk_user(
        consume_entry: stack_trace_consume_fn,
        cookie: *mut core::ffi::c_void,
        regs: *const pt_regs,
    );
}
extern "C" {
    pub fn stack_trace_print(
        trace: *const core::ffi::c_ulong,
        nr_entries: core::ffi::c_uint,
        spaces: core::ffi::c_int,
    );
}
extern "C" {
    pub fn stack_trace_snprint(
        buf: *mut core::ffi::c_char,
        size: usize,
        entries: *const core::ffi::c_ulong,
        nr_entries: core::ffi::c_uint,
        spaces: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn stack_trace_save(
        store: *mut core::ffi::c_ulong,
        size: core::ffi::c_uint,
        skipnr: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn stack_trace_save_tsk(
        task: *mut task_struct,
        store: *mut core::ffi::c_ulong,
        size: core::ffi::c_uint,
        skipnr: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn stack_trace_save_regs(
        regs: *mut pt_regs,
        store: *mut core::ffi::c_ulong,
        size: core::ffi::c_uint,
        skipnr: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn stack_trace_save_user(
        store: *mut core::ffi::c_ulong,
        size: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn filter_irq_stacks(
        entries: *mut core::ffi::c_ulong,
        nr_entries: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
pub type depot_stack_handle_t = u32_;
extern "C" {
    pub fn __stack_depot_save(
        entries: *mut core::ffi::c_ulong,
        nr_entries: core::ffi::c_uint,
        extra_bits: core::ffi::c_uint,
        gfp_flags: gfp_t,
        can_alloc: bool_,
    ) -> depot_stack_handle_t;
}
extern "C" {
    pub fn stack_depot_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn stack_depot_want_early_init();
}
extern "C" {
    pub fn stack_depot_early_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn stack_depot_save(
        entries: *mut core::ffi::c_ulong,
        nr_entries: core::ffi::c_uint,
        gfp_flags: gfp_t,
    ) -> depot_stack_handle_t;
}
extern "C" {
    pub fn stack_depot_fetch(
        handle: depot_stack_handle_t,
        entries: *mut *mut core::ffi::c_ulong,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn stack_depot_get_extra_bits(handle: depot_stack_handle_t) -> core::ffi::c_uint;
}
extern "C" {
    pub fn stack_depot_snprint(
        handle: depot_stack_handle_t,
        buf: *mut core::ffi::c_char,
        size: usize,
        spaces: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn stack_depot_print(stack: depot_stack_handle_t);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct page_ext_operations {
    pub offset: usize,
    pub size: usize,
    pub need: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub init: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_ext {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut __tracepoint_page_ref_set: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_mod: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_mod_and_test: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_mod_and_return: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_mod_unless: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_freeze: tracepoint;
}
extern "C" {
    pub static mut __tracepoint_page_ref_unfreeze: tracepoint;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vmem_altmap {
    pub base_pfn: core::ffi::c_ulong,
    pub end_pfn: core::ffi::c_ulong,
    pub reserve: core::ffi::c_ulong,
    pub free: core::ffi::c_ulong,
    pub align: core::ffi::c_ulong,
    pub alloc: core::ffi::c_ulong,
}
pub const memory_type_MEMORY_DEVICE_PRIVATE: memory_type = 1;
pub const memory_type_MEMORY_DEVICE_COHERENT: memory_type = 2;
pub const memory_type_MEMORY_DEVICE_FS_DAX: memory_type = 3;
pub const memory_type_MEMORY_DEVICE_GENERIC: memory_type = 4;
pub const memory_type_MEMORY_DEVICE_PCI_P2PDMA: memory_type = 5;
pub type memory_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pagemap_ops {
    pub page_free: ::core::option::Option<unsafe extern "C" fn(page: *mut page)>,
    pub migrate_to_ram:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub memory_failure: ::core::option::Option<
        unsafe extern "C" fn(
            pgmap: *mut dev_pagemap,
            pfn: core::ffi::c_ulong,
            nr_pages: core::ffi::c_ulong,
            mf_flags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
}
#[repr(C)]
pub struct dev_pagemap {
    pub altmap: vmem_altmap,
    pub ref_: percpu_ref,
    pub done: completion,
    pub type_: memory_type,
    pub flags: core::ffi::c_uint,
    pub vmemmap_shift: core::ffi::c_ulong,
    pub ops: *const dev_pagemap_ops,
    pub owner: *mut core::ffi::c_void,
    pub nr_range: core::ffi::c_int,
    pub __bindgen_anon_1: dev_pagemap__bindgen_ty_1,
}
#[repr(C)]
pub struct dev_pagemap__bindgen_ty_1 {
    pub range: __BindgenUnionField<range>,
    pub ranges: __BindgenUnionField<[range; 0usize]>,
    pub bindgen_union_field: [u64; 2usize],
}
impl Default for dev_pagemap__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for dev_pagemap {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct anon_vma {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct anon_vma_chain {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut sysctl_page_lock_unfairness: core::ffi::c_int;
}
extern "C" {
    pub fn init_mm_internals();
}
extern "C" {
    pub static mut max_mapnr: core::ffi::c_ulong;
}
extern "C" {
    pub static mut _totalram_pages: atomic_long_t;
}
extern "C" {
    pub static mut high_memory: *mut core::ffi::c_void;
}
extern "C" {
    pub static mut page_cluster: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_legacy_va_layout: core::ffi::c_int;
}
extern "C" {
    pub static mmap_rnd_bits_min: core::ffi::c_int;
}
extern "C" {
    pub static mmap_rnd_bits_max: core::ffi::c_int;
}
extern "C" {
    pub static mut mmap_rnd_bits: core::ffi::c_int;
}
extern "C" {
    pub static mmap_rnd_compat_bits_min: core::ffi::c_int;
}
extern "C" {
    pub static mmap_rnd_compat_bits_max: core::ffi::c_int;
}
extern "C" {
    pub static mut mmap_rnd_compat_bits: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_max_map_count: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_user_reserve_kbytes: core::ffi::c_ulong;
}
extern "C" {
    pub static mut sysctl_admin_reserve_kbytes: core::ffi::c_ulong;
}
extern "C" {
    pub static mut sysctl_overcommit_memory: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_overcommit_ratio: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_overcommit_kbytes: core::ffi::c_ulong;
}
extern "C" {
    pub fn overcommit_ratio_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn overcommit_kbytes_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn overcommit_policy_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn setup_initial_init_mm(
        start_code: *mut core::ffi::c_void,
        end_code: *mut core::ffi::c_void,
        end_data: *mut core::ffi::c_void,
        brk: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn vm_area_alloc(arg1: *mut mm_struct) -> *mut vm_area_struct;
}
extern "C" {
    pub fn vm_area_dup(arg1: *mut vm_area_struct) -> *mut vm_area_struct;
}
extern "C" {
    pub fn vm_area_free(arg1: *mut vm_area_struct);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_fault {
    pub __bindgen_anon_1: vm_fault__bindgen_ty_1,
    pub flags: fault_flag,
    pub pmd: *mut pmd_t,
    pub pud: *mut pud_t,
    pub __bindgen_anon_2: vm_fault__bindgen_ty_2,
    pub cow_page: *mut page,
    pub page: *mut page,
    pub pte: *mut pte_t,
    pub ptl: *mut spinlock_t,
    pub prealloc_pte: pgtable_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_fault__bindgen_ty_1 {
    pub vma: *mut vm_area_struct,
    pub gfp_mask: gfp_t,
    pub pgoff: core::ffi::c_ulong,
    pub address: core::ffi::c_ulong,
    pub real_address: core::ffi::c_ulong,
}
impl Default for vm_fault__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vm_fault__bindgen_ty_2 {
    pub orig_pte: pte_t,
    pub orig_pmd: pmd_t,
    _bindgen_union_align: u64,
}
impl Default for vm_fault__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for vm_fault {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const page_entry_size_PE_SIZE_PTE: page_entry_size = 0;
pub const page_entry_size_PE_SIZE_PMD: page_entry_size = 1;
pub const page_entry_size_PE_SIZE_PUD: page_entry_size = 2;
pub type page_entry_size = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_operations_struct {
    pub open: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub close: ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct)>,
    pub may_split: ::core::option::Option<
        unsafe extern "C" fn(
            area: *mut vm_area_struct,
            addr: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub mremap:
        ::core::option::Option<unsafe extern "C" fn(area: *mut vm_area_struct) -> core::ffi::c_int>,
    pub mprotect: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            start: core::ffi::c_ulong,
            end: core::ffi::c_ulong,
            newflags: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub fault: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub huge_fault: ::core::option::Option<
        unsafe extern "C" fn(vmf: *mut vm_fault, pe_size: page_entry_size) -> vm_fault_t,
    >,
    pub map_pages: ::core::option::Option<
        unsafe extern "C" fn(
            vmf: *mut vm_fault,
            start_pgoff: core::ffi::c_ulong,
            end_pgoff: core::ffi::c_ulong,
        ) -> vm_fault_t,
    >,
    pub pagesize: ::core::option::Option<
        unsafe extern "C" fn(area: *mut vm_area_struct) -> core::ffi::c_ulong,
    >,
    pub page_mkwrite:
        ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub pfn_mkwrite: ::core::option::Option<unsafe extern "C" fn(vmf: *mut vm_fault) -> vm_fault_t>,
    pub access: ::core::option::Option<
        unsafe extern "C" fn(
            vma: *mut vm_area_struct,
            addr: core::ffi::c_ulong,
            buf: *mut core::ffi::c_void,
            len: core::ffi::c_int,
            write: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub name: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct) -> *const core::ffi::c_char,
    >,
    pub find_special_page: ::core::option::Option<
        unsafe extern "C" fn(vma: *mut vm_area_struct, addr: core::ffi::c_ulong) -> *mut page,
    >,
}
extern "C" {
    pub fn vma_is_shmem(vma: *mut vm_area_struct) -> bool_;
}
extern "C" {
    pub fn vma_is_stack_for_current(vma: *mut vm_area_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_dumpable(mm: *mut mm_struct, value: core::ffi::c_int);
}
extern "C" {
    pub fn do_huge_pmd_anonymous_page(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub fn copy_huge_pmd(
        dst_mm: *mut mm_struct,
        src_mm: *mut mm_struct,
        dst_pmd: *mut pmd_t,
        src_pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
        dst_vma: *mut vm_area_struct,
        src_vma: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn huge_pmd_set_accessed(vmf: *mut vm_fault);
}
extern "C" {
    pub fn copy_huge_pud(
        dst_mm: *mut mm_struct,
        src_mm: *mut mm_struct,
        dst_pud: *mut pud_t,
        src_pud: *mut pud_t,
        addr: core::ffi::c_ulong,
        vma: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_huge_pmd_wp_page(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub fn follow_trans_huge_pmd(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pmd: *mut pmd_t,
        flags: core::ffi::c_uint,
    ) -> *mut page;
}
extern "C" {
    pub fn madvise_free_huge_pmd(
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
        next: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn zap_huge_pmd(
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn zap_huge_pud(
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        pud: *mut pud_t,
        addr: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn move_huge_pmd(
        vma: *mut vm_area_struct,
        old_addr: core::ffi::c_ulong,
        new_addr: core::ffi::c_ulong,
        old_pmd: *mut pmd_t,
        new_pmd: *mut pmd_t,
    ) -> bool_;
}
extern "C" {
    pub fn change_huge_pmd(
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
        newprot: pgprot_t,
        cp_flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmf_insert_pfn_pmd_prot(
        vmf: *mut vm_fault,
        pfn: pfn_t,
        pgprot: pgprot_t,
        write: bool_,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn vmf_insert_pfn_pud_prot(
        vmf: *mut vm_fault,
        pfn: pfn_t,
        pgprot: pgprot_t,
        write: bool_,
    ) -> vm_fault_t;
}
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_NEVER_DAX: transparent_hugepage_flag = 0;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_FLAG: transparent_hugepage_flag = 1;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_REQ_MADV_FLAG: transparent_hugepage_flag =
    2;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_DIRECT_FLAG:
    transparent_hugepage_flag = 3;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_FLAG:
    transparent_hugepage_flag = 4;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_KSWAPD_OR_MADV_FLAG:
    transparent_hugepage_flag = 5;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_REQ_MADV_FLAG:
    transparent_hugepage_flag = 6;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_DEFRAG_KHUGEPAGED_FLAG:
    transparent_hugepage_flag = 7;
pub const transparent_hugepage_flag_TRANSPARENT_HUGEPAGE_USE_ZERO_PAGE_FLAG:
    transparent_hugepage_flag = 8;
pub type transparent_hugepage_flag = core::ffi::c_uint;
extern "C" {
    pub fn single_hugepage_flag_store(
        kobj: *mut kobject,
        attr: *mut kobj_attribute,
        buf: *const core::ffi::c_char,
        count: usize,
        flag: transparent_hugepage_flag,
    ) -> isize;
}
extern "C" {
    pub fn single_hugepage_flag_show(
        kobj: *mut kobject,
        attr: *mut kobj_attribute,
        buf: *mut core::ffi::c_char,
        flag: transparent_hugepage_flag,
    ) -> isize;
}
extern "C" {
    pub static mut shmem_enabled_attr: kobj_attribute;
}
extern "C" {
    pub fn page_is_ram(pfn: core::ffi::c_ulong) -> core::ffi::c_int;
}
pub const REGION_INTERSECTS: core::ffi::c_uint = 0;
pub const REGION_DISJOINT: core::ffi::c_uint = 1;
pub const REGION_MIXED: core::ffi::c_uint = 2;
pub type _bindgen_ty_105 = core::ffi::c_uint;
extern "C" {
    pub fn region_intersects(
        offset: resource_size_t,
        size: usize,
        flags: core::ffi::c_ulong,
        desc: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmalloc_to_page(addr: *const core::ffi::c_void) -> *mut page;
}
extern "C" {
    pub fn vmalloc_to_pfn(addr: *const core::ffi::c_void) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn is_vmalloc_addr(x: *const core::ffi::c_void) -> bool_;
}
extern "C" {
    pub fn is_vmalloc_or_module_addr(x: *const core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn __page_mapcount(page: *mut page) -> core::ffi::c_int;
}
extern "C" {
    pub fn folio_mapcount(folio: *mut folio) -> core::ffi::c_int;
}
extern "C" {
    pub fn __folio_put(folio: *mut folio);
}
extern "C" {
    pub fn put_pages_list(pages: *mut list_head);
}
extern "C" {
    pub fn split_page(page: *mut page, order: core::ffi::c_uint);
}
extern "C" {
    pub fn folio_copy(dst: *mut folio, src: *mut folio);
}
extern "C" {
    pub fn nr_free_buffer_pages() -> core::ffi::c_ulong;
}
pub type compound_page_dtor = ::core::option::Option<unsafe extern "C" fn(arg1: *mut page)>;
pub const compound_dtor_id_NULL_COMPOUND_DTOR: compound_dtor_id = 0;
pub const compound_dtor_id_COMPOUND_PAGE_DTOR: compound_dtor_id = 1;
pub const compound_dtor_id_HUGETLB_PAGE_DTOR: compound_dtor_id = 2;
pub const compound_dtor_id_NR_COMPOUND_DTORS: compound_dtor_id = 3;
pub type compound_dtor_id = core::ffi::c_uint;
extern "C" {
    pub static compound_page_dtors: [compound_page_dtor; 3usize];
}
extern "C" {
    pub fn destroy_large_folio(folio: *mut folio);
}
extern "C" {
    pub fn free_compound_page(page: *mut page);
}
extern "C" {
    pub fn do_set_pmd(vmf: *mut vm_fault, page: *mut page) -> vm_fault_t;
}
extern "C" {
    pub fn do_set_pte(vmf: *mut vm_fault, page: *mut page, addr: core::ffi::c_ulong);
}
extern "C" {
    pub fn finish_fault(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub fn finish_mkwrite_fault(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub fn try_grab_page(page: *mut page, flags: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn release_pages(pages: *mut *mut page, nr: core::ffi::c_int);
}
extern "C" {
    pub fn unpin_user_page(page: *mut page);
}
extern "C" {
    pub fn unpin_user_pages_dirty_lock(
        pages: *mut *mut page,
        npages: core::ffi::c_ulong,
        make_dirty: bool_,
    );
}
extern "C" {
    pub fn unpin_user_page_range_dirty_lock(
        page: *mut page,
        npages: core::ffi::c_ulong,
        make_dirty: bool_,
    );
}
extern "C" {
    pub fn unpin_user_pages(pages: *mut *mut page, npages: core::ffi::c_ulong);
}
pub const vm_event_item_PGPGIN: vm_event_item = 0;
pub const vm_event_item_PGPGOUT: vm_event_item = 1;
pub const vm_event_item_PSWPIN: vm_event_item = 2;
pub const vm_event_item_PSWPOUT: vm_event_item = 3;
pub const vm_event_item_PGALLOC_DMA32: vm_event_item = 4;
pub const vm_event_item_PGALLOC_NORMAL: vm_event_item = 5;
pub const vm_event_item_PGALLOC_MOVABLE: vm_event_item = 6;
pub const vm_event_item_ALLOCSTALL_DMA32: vm_event_item = 7;
pub const vm_event_item_ALLOCSTALL_NORMAL: vm_event_item = 8;
pub const vm_event_item_ALLOCSTALL_MOVABLE: vm_event_item = 9;
pub const vm_event_item_PGSCAN_SKIP_DMA32: vm_event_item = 10;
pub const vm_event_item_PGSCAN_SKIP_NORMAL: vm_event_item = 11;
pub const vm_event_item_PGSCAN_SKIP_MOVABLE: vm_event_item = 12;
pub const vm_event_item_PGFREE: vm_event_item = 13;
pub const vm_event_item_PGACTIVATE: vm_event_item = 14;
pub const vm_event_item_PGDEACTIVATE: vm_event_item = 15;
pub const vm_event_item_PGLAZYFREE: vm_event_item = 16;
pub const vm_event_item_PGFAULT: vm_event_item = 17;
pub const vm_event_item_PGMAJFAULT: vm_event_item = 18;
pub const vm_event_item_PGLAZYFREED: vm_event_item = 19;
pub const vm_event_item_PGREFILL: vm_event_item = 20;
pub const vm_event_item_PGREUSE: vm_event_item = 21;
pub const vm_event_item_PGSTEAL_KSWAPD: vm_event_item = 22;
pub const vm_event_item_PGSTEAL_DIRECT: vm_event_item = 23;
pub const vm_event_item_PGDEMOTE_KSWAPD: vm_event_item = 24;
pub const vm_event_item_PGDEMOTE_DIRECT: vm_event_item = 25;
pub const vm_event_item_PGSCAN_KSWAPD: vm_event_item = 26;
pub const vm_event_item_PGSCAN_DIRECT: vm_event_item = 27;
pub const vm_event_item_PGSCAN_DIRECT_THROTTLE: vm_event_item = 28;
pub const vm_event_item_PGSCAN_ANON: vm_event_item = 29;
pub const vm_event_item_PGSCAN_FILE: vm_event_item = 30;
pub const vm_event_item_PGSTEAL_ANON: vm_event_item = 31;
pub const vm_event_item_PGSTEAL_FILE: vm_event_item = 32;
pub const vm_event_item_PGINODESTEAL: vm_event_item = 33;
pub const vm_event_item_SLABS_SCANNED: vm_event_item = 34;
pub const vm_event_item_KSWAPD_INODESTEAL: vm_event_item = 35;
pub const vm_event_item_KSWAPD_LOW_WMARK_HIT_QUICKLY: vm_event_item = 36;
pub const vm_event_item_KSWAPD_HIGH_WMARK_HIT_QUICKLY: vm_event_item = 37;
pub const vm_event_item_PAGEOUTRUN: vm_event_item = 38;
pub const vm_event_item_PGROTATED: vm_event_item = 39;
pub const vm_event_item_DROP_PAGECACHE: vm_event_item = 40;
pub const vm_event_item_DROP_SLAB: vm_event_item = 41;
pub const vm_event_item_OOM_KILL: vm_event_item = 42;
pub const vm_event_item_PGMIGRATE_SUCCESS: vm_event_item = 43;
pub const vm_event_item_PGMIGRATE_FAIL: vm_event_item = 44;
pub const vm_event_item_THP_MIGRATION_SUCCESS: vm_event_item = 45;
pub const vm_event_item_THP_MIGRATION_FAIL: vm_event_item = 46;
pub const vm_event_item_THP_MIGRATION_SPLIT: vm_event_item = 47;
pub const vm_event_item_COMPACTMIGRATE_SCANNED: vm_event_item = 48;
pub const vm_event_item_COMPACTFREE_SCANNED: vm_event_item = 49;
pub const vm_event_item_COMPACTISOLATED: vm_event_item = 50;
pub const vm_event_item_COMPACTSTALL: vm_event_item = 51;
pub const vm_event_item_COMPACTFAIL: vm_event_item = 52;
pub const vm_event_item_COMPACTSUCCESS: vm_event_item = 53;
pub const vm_event_item_KCOMPACTD_WAKE: vm_event_item = 54;
pub const vm_event_item_KCOMPACTD_MIGRATE_SCANNED: vm_event_item = 55;
pub const vm_event_item_KCOMPACTD_FREE_SCANNED: vm_event_item = 56;
pub const vm_event_item_HTLB_BUDDY_PGALLOC: vm_event_item = 57;
pub const vm_event_item_HTLB_BUDDY_PGALLOC_FAIL: vm_event_item = 58;
pub const vm_event_item_UNEVICTABLE_PGCULLED: vm_event_item = 59;
pub const vm_event_item_UNEVICTABLE_PGSCANNED: vm_event_item = 60;
pub const vm_event_item_UNEVICTABLE_PGRESCUED: vm_event_item = 61;
pub const vm_event_item_UNEVICTABLE_PGMLOCKED: vm_event_item = 62;
pub const vm_event_item_UNEVICTABLE_PGMUNLOCKED: vm_event_item = 63;
pub const vm_event_item_UNEVICTABLE_PGCLEARED: vm_event_item = 64;
pub const vm_event_item_UNEVICTABLE_PGSTRANDED: vm_event_item = 65;
pub const vm_event_item_BALLOON_INFLATE: vm_event_item = 66;
pub const vm_event_item_BALLOON_DEFLATE: vm_event_item = 67;
pub const vm_event_item_BALLOON_MIGRATE: vm_event_item = 68;
pub const vm_event_item_SWAP_RA: vm_event_item = 69;
pub const vm_event_item_SWAP_RA_HIT: vm_event_item = 70;
pub const vm_event_item_NR_VM_EVENT_ITEMS: vm_event_item = 71;
pub type vm_event_item = core::ffi::c_uint;
extern "C" {
    pub static mut sysctl_stat_interval: core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct reclaim_stat {
    pub nr_dirty: core::ffi::c_uint,
    pub nr_unqueued_dirty: core::ffi::c_uint,
    pub nr_congested: core::ffi::c_uint,
    pub nr_writeback: core::ffi::c_uint,
    pub nr_immediate: core::ffi::c_uint,
    pub nr_pageout: core::ffi::c_uint,
    pub nr_activate: [core::ffi::c_uint; 2usize],
    pub nr_ref_keep: core::ffi::c_uint,
    pub nr_unmap_fail: core::ffi::c_uint,
    pub nr_lazyfree_fail: core::ffi::c_uint,
}
pub const writeback_stat_item_NR_DIRTY_THRESHOLD: writeback_stat_item = 0;
pub const writeback_stat_item_NR_DIRTY_BG_THRESHOLD: writeback_stat_item = 1;
pub const writeback_stat_item_NR_VM_WRITEBACK_STAT_ITEMS: writeback_stat_item = 2;
pub type writeback_stat_item = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vm_event_state {
    pub event: [core::ffi::c_ulong; 71usize],
}
impl Default for vm_event_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut vm_event_states: vm_event_state;
}
extern "C" {
    pub fn all_vm_events(arg1: *mut core::ffi::c_ulong);
}
extern "C" {
    pub fn vm_events_fold_cpu(cpu: core::ffi::c_int);
}
extern "C" {
    pub static mut vm_zone_stat: [atomic_long_t; 10usize];
}
extern "C" {
    pub static mut vm_node_stat: [atomic_long_t; 41usize];
}
extern "C" {
    pub static mut vm_numa_event: [atomic_long_t; 0usize];
}
extern "C" {
    pub fn __mod_zone_page_state(arg1: *mut zone, item: zone_stat_item, arg2: core::ffi::c_long);
}
extern "C" {
    pub fn __inc_zone_page_state(arg1: *mut page, arg2: zone_stat_item);
}
extern "C" {
    pub fn __dec_zone_page_state(arg1: *mut page, arg2: zone_stat_item);
}
extern "C" {
    pub fn __mod_node_page_state(
        arg1: *mut pglist_data,
        item: node_stat_item,
        arg2: core::ffi::c_long,
    );
}
extern "C" {
    pub fn __inc_node_page_state(arg1: *mut page, arg2: node_stat_item);
}
extern "C" {
    pub fn __dec_node_page_state(arg1: *mut page, arg2: node_stat_item);
}
extern "C" {
    pub fn mod_zone_page_state(arg1: *mut zone, arg2: zone_stat_item, arg3: core::ffi::c_long);
}
extern "C" {
    pub fn inc_zone_page_state(arg1: *mut page, arg2: zone_stat_item);
}
extern "C" {
    pub fn dec_zone_page_state(arg1: *mut page, arg2: zone_stat_item);
}
extern "C" {
    pub fn mod_node_page_state(
        arg1: *mut pglist_data,
        arg2: node_stat_item,
        arg3: core::ffi::c_long,
    );
}
extern "C" {
    pub fn inc_node_page_state(arg1: *mut page, arg2: node_stat_item);
}
extern "C" {
    pub fn dec_node_page_state(arg1: *mut page, arg2: node_stat_item);
}
extern "C" {
    pub fn inc_node_state(arg1: *mut pglist_data, arg2: node_stat_item);
}
extern "C" {
    pub fn __inc_zone_state(arg1: *mut zone, arg2: zone_stat_item);
}
extern "C" {
    pub fn __inc_node_state(arg1: *mut pglist_data, arg2: node_stat_item);
}
extern "C" {
    pub fn dec_zone_state(arg1: *mut zone, arg2: zone_stat_item);
}
extern "C" {
    pub fn __dec_zone_state(arg1: *mut zone, arg2: zone_stat_item);
}
extern "C" {
    pub fn __dec_node_state(arg1: *mut pglist_data, arg2: node_stat_item);
}
extern "C" {
    pub fn quiet_vmstat();
}
extern "C" {
    pub fn cpu_vm_stats_fold(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn refresh_zone_stat_thresholds();
}
extern "C" {
    pub fn vmstat_refresh(
        arg1: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn drain_zonestat(zone: *mut zone, arg1: *mut per_cpu_zonestat);
}
extern "C" {
    pub fn calculate_pressure_threshold(zone: *mut zone) -> core::ffi::c_int;
}
extern "C" {
    pub fn calculate_normal_threshold(zone: *mut zone) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_pgdat_percpu_threshold(
        pgdat: *mut pg_data_t,
        calculate_pressure: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut zone) -> core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub static mut vmstat_text: [*const core::ffi::c_char; 0usize];
}
extern "C" {
    pub fn __mod_lruvec_state(lruvec: *mut lruvec, idx: node_stat_item, val: core::ffi::c_int);
}
extern "C" {
    pub fn __mod_lruvec_page_state(page: *mut page, idx: node_stat_item, val: core::ffi::c_int);
}
extern "C" {
    pub fn page_rmapping(page: *mut page) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __page_file_index(page: *mut page) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn page_mapped(page: *mut page) -> bool_;
}
extern "C" {
    pub fn folio_mapped(folio: *mut folio) -> bool_;
}
extern "C" {
    pub fn pagefault_out_of_memory();
}
extern "C" {
    pub fn __show_free_areas(
        flags: core::ffi::c_uint,
        nodemask: *mut nodemask_t,
        max_zone_idx: core::ffi::c_int,
    );
}
extern "C" {
    pub fn can_do_mlock() -> bool_;
}
extern "C" {
    pub fn user_shm_lock(arg1: usize, arg2: *mut ucounts) -> core::ffi::c_int;
}
extern "C" {
    pub fn user_shm_unlock(arg1: usize, arg2: *mut ucounts);
}
extern "C" {
    pub fn vm_normal_page(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pte: pte_t,
    ) -> *mut page;
}
extern "C" {
    pub fn vm_normal_page_pmd(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pmd: pmd_t,
    ) -> *mut page;
}
extern "C" {
    pub fn zap_vma_ptes(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn zap_page_range(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn unmap_vmas(
        tlb: *mut mmu_gather,
        mt: *mut maple_tree,
        start_vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mmu_notifier_range {
    _unused: [u8; 0],
}
extern "C" {
    pub fn free_pgd_range(
        tlb: *mut mmu_gather,
        addr: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        floor: core::ffi::c_ulong,
        ceiling: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn copy_page_range(
        dst_vma: *mut vm_area_struct,
        src_vma: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn follow_pte(
        mm: *mut mm_struct,
        address: core::ffi::c_ulong,
        ptepp: *mut *mut pte_t,
        ptlp: *mut *mut spinlock_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn follow_pfn(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        pfn: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn follow_phys(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        flags: core::ffi::c_uint,
        prot: *mut core::ffi::c_ulong,
        phys: *mut resource_size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_access_phys(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        buf: *mut core::ffi::c_void,
        len: core::ffi::c_int,
        write: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn truncate_pagecache(inode: *mut inode, new: loff_t);
}
extern "C" {
    pub fn truncate_setsize(inode: *mut inode, newsize: loff_t);
}
extern "C" {
    pub fn pagecache_isize_extended(inode: *mut inode, from: loff_t, to: loff_t);
}
extern "C" {
    pub fn truncate_pagecache_range(inode: *mut inode, offset: loff_t, end: loff_t);
}
extern "C" {
    pub fn generic_error_remove_page(
        mapping: *mut address_space,
        page: *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn handle_mm_fault(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        flags: core::ffi::c_uint,
        regs: *mut pt_regs,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn fixup_user_fault(
        mm: *mut mm_struct,
        address: core::ffi::c_ulong,
        fault_flags: core::ffi::c_uint,
        unlocked: *mut bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn unmap_mapping_pages(
        mapping: *mut address_space,
        start: core::ffi::c_ulong,
        nr: core::ffi::c_ulong,
        even_cows: bool_,
    );
}
extern "C" {
    pub fn unmap_mapping_range(
        mapping: *mut address_space,
        holebegin: loff_t,
        holelen: loff_t,
        even_cows: core::ffi::c_int,
    );
}
extern "C" {
    pub fn access_process_vm(
        tsk: *mut task_struct,
        addr: core::ffi::c_ulong,
        buf: *mut core::ffi::c_void,
        len: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn access_remote_vm(
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
        buf: *mut core::ffi::c_void,
        len: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __access_remote_vm(
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
        buf: *mut core::ffi::c_void,
        len: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_user_pages_remote(
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
        vmas: *mut *mut vm_area_struct,
        locked: *mut core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn pin_user_pages_remote(
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
        vmas: *mut *mut vm_area_struct,
        locked: *mut core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn get_user_pages(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
        vmas: *mut *mut vm_area_struct,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn pin_user_pages(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
        vmas: *mut *mut vm_area_struct,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn get_user_pages_unlocked(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        pages: *mut *mut page,
        gup_flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn pin_user_pages_unlocked(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        pages: *mut *mut page,
        gup_flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn get_user_pages_fast(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pin_user_pages_fast(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn account_locked_vm(
        mm: *mut mm_struct,
        pages: core::ffi::c_ulong,
        inc: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __account_locked_vm(
        mm: *mut mm_struct,
        pages: core::ffi::c_ulong,
        inc: bool_,
        task: *mut task_struct,
        bypass_rlim: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_kernel_pages(
        iov: *const kvec,
        nr_pages: core::ffi::c_int,
        write: core::ffi::c_int,
        pages: *mut *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_dump_page(addr: core::ffi::c_ulong) -> *mut page;
}
extern "C" {
    pub fn folio_mark_dirty(folio: *mut folio) -> bool_;
}
extern "C" {
    pub fn set_page_dirty(page: *mut page) -> bool_;
}
extern "C" {
    pub fn set_page_dirty_lock(page: *mut page) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_cmdline(
        task: *mut task_struct,
        buffer: *mut core::ffi::c_char,
        buflen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn move_page_tables(
        vma: *mut vm_area_struct,
        old_addr: core::ffi::c_ulong,
        new_vma: *mut vm_area_struct,
        new_addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        need_rmap_locks: bool_,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn change_protection(
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        newprot: pgprot_t,
        cp_flags: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn mprotect_fixup(
        tlb: *mut mmu_gather,
        vma: *mut vm_area_struct,
        pprev: *mut *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        newflags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_user_pages_fast_only(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pin_user_pages_fast_only(
        start: core::ffi::c_ulong,
        nr_pages: core::ffi::c_int,
        gup_flags: core::ffi::c_uint,
        pages: *mut *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mm_trace_rss_stat(
        mm: *mut mm_struct,
        member: core::ffi::c_int,
        count: core::ffi::c_long,
    );
}
extern "C" {
    pub fn sync_mm_rss(mm: *mut mm_struct);
}
extern "C" {
    pub fn vma_wants_writenotify(
        vma: *mut vm_area_struct,
        vm_page_prot: pgprot_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __get_locked_pte(
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
        ptl: *mut *mut spinlock_t,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn __p4d_alloc(
        mm: *mut mm_struct,
        pgd: *mut pgd_t,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __pud_alloc(
        mm: *mut mm_struct,
        p4d: *mut p4d_t,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __pmd_alloc(
        mm: *mut mm_struct,
        pud: *mut pud_t,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __pte_alloc(mm: *mut mm_struct, pmd: *mut pmd_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __pte_alloc_kernel(pmd: *mut pmd_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn ptlock_cache_init();
}
extern "C" {
    pub fn ptlock_alloc(page: *mut page) -> bool_;
}
extern "C" {
    pub fn ptlock_free(page: *mut page);
}
extern "C" {
    pub fn pagecache_init();
}
extern "C" {
    pub fn free_initmem();
}
extern "C" {
    pub fn free_reserved_area(
        start: *mut core::ffi::c_void,
        end: *mut core::ffi::c_void,
        poison: core::ffi::c_int,
        s: *const core::ffi::c_char,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn adjust_managed_page_count(page: *mut page, count: core::ffi::c_long);
}
extern "C" {
    pub fn mem_init_print_info();
}
extern "C" {
    pub fn reserve_bootmem_region(start: phys_addr_t, end: phys_addr_t);
}
extern "C" {
    pub fn free_area_init(max_zone_pfn: *mut core::ffi::c_ulong);
}
extern "C" {
    pub fn node_map_pfn_alignment() -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __absent_pages_in_range(
        nid: core::ffi::c_int,
        start_pfn: core::ffi::c_ulong,
        end_pfn: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn absent_pages_in_range(
        start_pfn: core::ffi::c_ulong,
        end_pfn: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn get_pfn_range_for_nid(
        nid: core::ffi::c_uint,
        start_pfn: *mut core::ffi::c_ulong,
        end_pfn: *mut core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn set_dma_reserve(new_dma_reserve: core::ffi::c_ulong);
}
extern "C" {
    pub fn memmap_init_range(
        arg1: core::ffi::c_ulong,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
        arg6: meminit_context,
        arg7: *mut vmem_altmap,
        migratetype: core::ffi::c_int,
    );
}
extern "C" {
    pub fn setup_per_zone_wmarks();
}
extern "C" {
    pub fn calculate_min_free_kbytes();
}
extern "C" {
    pub fn init_per_zone_wmark_min() -> core::ffi::c_int;
}
extern "C" {
    pub fn mem_init();
}
extern "C" {
    pub fn mmap_init();
}
extern "C" {
    pub fn __show_mem(
        flags: core::ffi::c_uint,
        nodemask: *mut nodemask_t,
        max_zone_idx: core::ffi::c_int,
    );
}
extern "C" {
    pub fn si_mem_available() -> core::ffi::c_long;
}
extern "C" {
    pub fn si_meminfo(val: *mut sysinfo);
}
extern "C" {
    pub fn si_meminfo_node(val: *mut sysinfo, nid: core::ffi::c_int);
}
extern "C" {
    pub fn warn_alloc(
        gfp_mask: gfp_t,
        nodemask: *mut nodemask_t,
        fmt: *const core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn setup_per_cpu_pageset();
}
extern "C" {
    pub static mut min_free_kbytes: core::ffi::c_int;
}
extern "C" {
    pub static mut watermark_boost_factor: core::ffi::c_int;
}
extern "C" {
    pub static mut watermark_scale_factor: core::ffi::c_int;
}
extern "C" {
    pub fn arch_has_descending_max_zone_pfns() -> bool_;
}
extern "C" {
    pub static mut mmap_pages_allocated: atomic_long_t;
}
extern "C" {
    pub fn nommu_shrink_inode_mappings(
        arg1: *mut inode,
        arg2: usize,
        arg3: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vma_interval_tree_insert(node: *mut vm_area_struct, root: *mut rb_root_cached);
}
extern "C" {
    pub fn vma_interval_tree_insert_after(
        node: *mut vm_area_struct,
        prev: *mut vm_area_struct,
        root: *mut rb_root_cached,
    );
}
extern "C" {
    pub fn vma_interval_tree_remove(node: *mut vm_area_struct, root: *mut rb_root_cached);
}
extern "C" {
    pub fn vma_interval_tree_iter_first(
        root: *mut rb_root_cached,
        start: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn vma_interval_tree_iter_next(
        node: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn anon_vma_interval_tree_insert(node: *mut anon_vma_chain, root: *mut rb_root_cached);
}
extern "C" {
    pub fn anon_vma_interval_tree_remove(node: *mut anon_vma_chain, root: *mut rb_root_cached);
}
extern "C" {
    pub fn anon_vma_interval_tree_iter_first(
        root: *mut rb_root_cached,
        start: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
    ) -> *mut anon_vma_chain;
}
extern "C" {
    pub fn anon_vma_interval_tree_iter_next(
        node: *mut anon_vma_chain,
        start: core::ffi::c_ulong,
        last: core::ffi::c_ulong,
    ) -> *mut anon_vma_chain;
}
extern "C" {
    pub fn __vm_enough_memory(
        mm: *mut mm_struct,
        pages: core::ffi::c_long,
        cap_sys_admin: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __vma_adjust(
        vma: *mut vm_area_struct,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        insert: *mut vm_area_struct,
        expand: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vma_merge(
        arg1: *mut mm_struct,
        prev: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        vm_flags: core::ffi::c_ulong,
        arg2: *mut anon_vma,
        arg3: *mut file,
        arg4: core::ffi::c_ulong,
        arg5: *mut mempolicy,
        arg6: vm_userfaultfd_ctx,
        arg7: *mut anon_vma_name,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn find_mergeable_anon_vma(arg1: *mut vm_area_struct) -> *mut anon_vma;
}
extern "C" {
    pub fn __split_vma(
        arg1: *mut mm_struct,
        arg2: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        new_below: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn split_vma(
        arg1: *mut mm_struct,
        arg2: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        new_below: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn insert_vm_struct(arg1: *mut mm_struct, arg2: *mut vm_area_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn unlink_file_vma(arg1: *mut vm_area_struct);
}
extern "C" {
    pub fn copy_vma(
        arg1: *mut *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        need_rmap_locks: *mut bool_,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn exit_mmap(arg1: *mut mm_struct);
}
extern "C" {
    pub fn vma_mas_store(vma: *mut vm_area_struct, mas: *mut ma_state);
}
extern "C" {
    pub fn vma_mas_remove(vma: *mut vm_area_struct, mas: *mut ma_state);
}
extern "C" {
    pub fn mm_take_all_locks(mm: *mut mm_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn mm_drop_all_locks(mm: *mut mm_struct);
}
extern "C" {
    pub fn set_mm_exe_file(mm: *mut mm_struct, new_exe_file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn replace_mm_exe_file(mm: *mut mm_struct, new_exe_file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_mm_exe_file(mm: *mut mm_struct) -> *mut file;
}
extern "C" {
    pub fn get_task_exe_file(task: *mut task_struct) -> *mut file;
}
extern "C" {
    pub fn may_expand_vm(
        arg1: *mut mm_struct,
        arg2: vm_flags_t,
        npages: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn vm_stat_account(arg1: *mut mm_struct, arg2: vm_flags_t, npages: core::ffi::c_long);
}
extern "C" {
    pub fn vma_is_special_mapping(
        vma: *const vm_area_struct,
        sm: *const vm_special_mapping,
    ) -> bool_;
}
extern "C" {
    pub fn _install_special_mapping(
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        spec: *const vm_special_mapping,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn install_special_mapping(
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        pages: *mut *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn randomize_stack_top(stack_top: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn randomize_page(
        start: core::ffi::c_ulong,
        range: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn get_unmapped_area(
        arg1: *mut file,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn mmap_region(
        file: *mut file,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        vm_flags: vm_flags_t,
        pgoff: core::ffi::c_ulong,
        uf: *mut list_head,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn do_mmap(
        file: *mut file,
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        prot: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
        pgoff: core::ffi::c_ulong,
        populate: *mut core::ffi::c_ulong,
        uf: *mut list_head,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn do_mas_munmap(
        mas: *mut ma_state,
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        len: usize,
        uf: *mut list_head,
        downgrade: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_munmap(
        arg1: *mut mm_struct,
        arg2: core::ffi::c_ulong,
        arg3: usize,
        uf: *mut list_head,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_madvise(
        mm: *mut mm_struct,
        start: core::ffi::c_ulong,
        len_in: usize,
        behavior: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mm_populate(
        addr: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
        ignore_errors: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_brk(arg1: core::ffi::c_ulong, arg2: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_brk_flags(
        arg1: core::ffi::c_ulong,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_munmap(arg1: core::ffi::c_ulong, arg2: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_mmap(
        arg1: *mut file,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
        arg6: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vm_unmapped_area_info {
    pub flags: core::ffi::c_ulong,
    pub length: core::ffi::c_ulong,
    pub low_limit: core::ffi::c_ulong,
    pub high_limit: core::ffi::c_ulong,
    pub align_mask: core::ffi::c_ulong,
    pub align_offset: core::ffi::c_ulong,
}
extern "C" {
    pub fn vm_unmapped_area(info: *mut vm_unmapped_area_info) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn truncate_inode_pages(arg1: *mut address_space, arg2: loff_t);
}
extern "C" {
    pub fn truncate_inode_pages_range(arg1: *mut address_space, lstart: loff_t, lend: loff_t);
}
extern "C" {
    pub fn truncate_inode_pages_final(arg1: *mut address_space);
}
extern "C" {
    pub fn filemap_fault(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub fn filemap_map_pages(
        vmf: *mut vm_fault,
        start_pgoff: core::ffi::c_ulong,
        end_pgoff: core::ffi::c_ulong,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn filemap_page_mkwrite(vmf: *mut vm_fault) -> vm_fault_t;
}
extern "C" {
    pub static mut stack_guard_gap: core::ffi::c_ulong;
}
extern "C" {
    pub fn expand_stack(vma: *mut vm_area_struct, address: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn expand_downwards(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn find_vma(mm: *mut mm_struct, addr: core::ffi::c_ulong) -> *mut vm_area_struct;
}
extern "C" {
    pub fn find_vma_prev(
        mm: *mut mm_struct,
        addr: core::ffi::c_ulong,
        pprev: *mut *mut vm_area_struct,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn find_vma_intersection(
        mm: *mut mm_struct,
        start_addr: core::ffi::c_ulong,
        end_addr: core::ffi::c_ulong,
    ) -> *mut vm_area_struct;
}
extern "C" {
    pub fn vm_get_page_prot(vm_flags: core::ffi::c_ulong) -> pgprot_t;
}
extern "C" {
    pub fn vma_set_page_prot(vma: *mut vm_area_struct);
}
extern "C" {
    pub fn vma_set_file(vma: *mut vm_area_struct, file: *mut file);
}
extern "C" {
    pub fn find_extend_vma(arg1: *mut mm_struct, addr: core::ffi::c_ulong) -> *mut vm_area_struct;
}
extern "C" {
    pub fn remap_pfn_range(
        arg1: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        arg2: pgprot_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn remap_pfn_range_notrack(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        prot: pgprot_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_insert_page(
        arg1: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        arg2: *mut page,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_insert_pages(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pages: *mut *mut page,
        num: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_map_pages(
        vma: *mut vm_area_struct,
        pages: *mut *mut page,
        num: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vm_map_pages_zero(
        vma: *mut vm_area_struct,
        pages: *mut *mut page,
        num: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmf_insert_pfn(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: core::ffi::c_ulong,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn vmf_insert_pfn_prot(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: core::ffi::c_ulong,
        pgprot: pgprot_t,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn vmf_insert_mixed(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: pfn_t,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn vmf_insert_mixed_prot(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: pfn_t,
        pgprot: pgprot_t,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn vmf_insert_mixed_mkwrite(
        vma: *mut vm_area_struct,
        addr: core::ffi::c_ulong,
        pfn: pfn_t,
    ) -> vm_fault_t;
}
extern "C" {
    pub fn vm_iomap_memory(
        vma: *mut vm_area_struct,
        start: phys_addr_t,
        len: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn follow_page(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
        foll_flags: core::ffi::c_uint,
    ) -> *mut page;
}
pub type pte_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        pte: *mut pte_t,
        addr: core::ffi::c_ulong,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn apply_to_page_range(
        mm: *mut mm_struct,
        address: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        fn_: pte_fn_t,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn apply_to_existing_page_range(
        mm: *mut mm_struct,
        address: core::ffi::c_ulong,
        size: core::ffi::c_ulong,
        fn_: pte_fn_t,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn init_mem_debugging_and_hardening();
}
extern "C" {
    pub static mut init_on_alloc: static_key_false;
}
extern "C" {
    pub static mut init_on_free: static_key_false;
}
extern "C" {
    pub static mut _debug_pagealloc_enabled_early: bool_;
}
extern "C" {
    pub static mut _debug_pagealloc_enabled: static_key_false;
}
extern "C" {
    pub fn __kernel_map_pages(
        page: *mut page,
        numpages: core::ffi::c_int,
        enable: core::ffi::c_int,
    );
}
extern "C" {
    pub fn process_shares_mm(p: *mut task_struct, mm: *mut mm_struct) -> bool_;
}
extern "C" {
    pub static mut sysctl_drop_caches: core::ffi::c_int;
}
extern "C" {
    pub fn drop_caches_sysctl_handler(
        arg1: *mut ctl_table,
        arg2: core::ffi::c_int,
        arg3: *mut core::ffi::c_void,
        arg4: *mut usize,
        arg5: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn drop_slab();
}
extern "C" {
    pub static mut randomize_va_space: core::ffi::c_int;
}
extern "C" {
    pub fn arch_vma_name(vma: *mut vm_area_struct) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn print_vma_addr(prefix: *mut core::ffi::c_char, rip: core::ffi::c_ulong);
}
extern "C" {
    pub fn sparse_buffer_alloc(size: core::ffi::c_ulong) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __populate_section_memmap(
        pfn: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        nid: core::ffi::c_int,
        altmap: *mut vmem_altmap,
        pgmap: *mut dev_pagemap,
    ) -> *mut page;
}
extern "C" {
    pub fn vmemmap_pgd_populate(addr: core::ffi::c_ulong, node: core::ffi::c_int) -> *mut pgd_t;
}
extern "C" {
    pub fn vmemmap_p4d_populate(
        pgd: *mut pgd_t,
        addr: core::ffi::c_ulong,
        node: core::ffi::c_int,
    ) -> *mut p4d_t;
}
extern "C" {
    pub fn vmemmap_pud_populate(
        p4d: *mut p4d_t,
        addr: core::ffi::c_ulong,
        node: core::ffi::c_int,
    ) -> *mut pud_t;
}
extern "C" {
    pub fn vmemmap_pmd_populate(
        pud: *mut pud_t,
        addr: core::ffi::c_ulong,
        node: core::ffi::c_int,
    ) -> *mut pmd_t;
}
extern "C" {
    pub fn vmemmap_pte_populate(
        pmd: *mut pmd_t,
        addr: core::ffi::c_ulong,
        node: core::ffi::c_int,
        altmap: *mut vmem_altmap,
        reuse: *mut page,
    ) -> *mut pte_t;
}
extern "C" {
    pub fn vmemmap_alloc_block(
        size: core::ffi::c_ulong,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmemmap_alloc_block_buf(
        size: core::ffi::c_ulong,
        node: core::ffi::c_int,
        altmap: *mut vmem_altmap,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn vmemmap_verify(
        arg1: *mut pte_t,
        arg2: core::ffi::c_int,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn vmemmap_populate_basepages(
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        node: core::ffi::c_int,
        altmap: *mut vmem_altmap,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmemmap_populate(
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        node: core::ffi::c_int,
        altmap: *mut vmem_altmap,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmemmap_populate_print_last();
}
extern "C" {
    pub fn register_page_bootmem_memmap(
        section_nr: core::ffi::c_ulong,
        map: *mut page,
        nr_pages: core::ffi::c_ulong,
    );
}
pub const mf_flags_MF_COUNT_INCREASED: mf_flags = 1;
pub const mf_flags_MF_ACTION_REQUIRED: mf_flags = 2;
pub const mf_flags_MF_MUST_KILL: mf_flags = 4;
pub const mf_flags_MF_SOFT_OFFLINE: mf_flags = 8;
pub const mf_flags_MF_UNPOISON: mf_flags = 16;
pub const mf_flags_MF_SW_SIMULATED: mf_flags = 32;
pub const mf_flags_MF_NO_RETRY: mf_flags = 64;
pub type mf_flags = core::ffi::c_uint;
extern "C" {
    pub fn mf_dax_kill_procs(
        mapping: *mut address_space,
        index: core::ffi::c_ulong,
        count: core::ffi::c_ulong,
        mf_flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn memory_failure(pfn: core::ffi::c_ulong, flags: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn memory_failure_queue(pfn: core::ffi::c_ulong, flags: core::ffi::c_int);
}
extern "C" {
    pub fn memory_failure_queue_kick(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn unpoison_memory(pfn: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_memory_failure_early_kill: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_memory_failure_recovery: core::ffi::c_int;
}
extern "C" {
    pub fn shake_page(p: *mut page);
}
extern "C" {
    pub static mut num_poisoned_pages: atomic_long_t;
}
extern "C" {
    pub fn soft_offline_page(pfn: core::ffi::c_ulong, flags: core::ffi::c_int) -> core::ffi::c_int;
}
pub const mf_result_MF_IGNORED: mf_result = 0;
pub const mf_result_MF_FAILED: mf_result = 1;
pub const mf_result_MF_DELAYED: mf_result = 2;
pub const mf_result_MF_RECOVERED: mf_result = 3;
pub type mf_result = core::ffi::c_uint;
pub const mf_action_page_type_MF_MSG_KERNEL: mf_action_page_type = 0;
pub const mf_action_page_type_MF_MSG_KERNEL_HIGH_ORDER: mf_action_page_type = 1;
pub const mf_action_page_type_MF_MSG_SLAB: mf_action_page_type = 2;
pub const mf_action_page_type_MF_MSG_DIFFERENT_COMPOUND: mf_action_page_type = 3;
pub const mf_action_page_type_MF_MSG_HUGE: mf_action_page_type = 4;
pub const mf_action_page_type_MF_MSG_FREE_HUGE: mf_action_page_type = 5;
pub const mf_action_page_type_MF_MSG_UNMAP_FAILED: mf_action_page_type = 6;
pub const mf_action_page_type_MF_MSG_DIRTY_SWAPCACHE: mf_action_page_type = 7;
pub const mf_action_page_type_MF_MSG_CLEAN_SWAPCACHE: mf_action_page_type = 8;
pub const mf_action_page_type_MF_MSG_DIRTY_MLOCKED_LRU: mf_action_page_type = 9;
pub const mf_action_page_type_MF_MSG_CLEAN_MLOCKED_LRU: mf_action_page_type = 10;
pub const mf_action_page_type_MF_MSG_DIRTY_UNEVICTABLE_LRU: mf_action_page_type = 11;
pub const mf_action_page_type_MF_MSG_CLEAN_UNEVICTABLE_LRU: mf_action_page_type = 12;
pub const mf_action_page_type_MF_MSG_DIRTY_LRU: mf_action_page_type = 13;
pub const mf_action_page_type_MF_MSG_CLEAN_LRU: mf_action_page_type = 14;
pub const mf_action_page_type_MF_MSG_TRUNCATED_LRU: mf_action_page_type = 15;
pub const mf_action_page_type_MF_MSG_BUDDY: mf_action_page_type = 16;
pub const mf_action_page_type_MF_MSG_DAX: mf_action_page_type = 17;
pub const mf_action_page_type_MF_MSG_UNSPLIT_THP: mf_action_page_type = 18;
pub const mf_action_page_type_MF_MSG_UNKNOWN: mf_action_page_type = 19;
pub type mf_action_page_type = core::ffi::c_uint;
extern "C" {
    pub fn clear_huge_page(
        page: *mut page,
        addr_hint: core::ffi::c_ulong,
        pages_per_huge_page: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn copy_user_huge_page(
        dst: *mut page,
        src: *mut page,
        addr_hint: core::ffi::c_ulong,
        vma: *mut vm_area_struct,
        pages_per_huge_page: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn copy_huge_page_from_user(
        dst_page: *mut page,
        usr_src: *const core::ffi::c_void,
        pages_per_huge_page: core::ffi::c_uint,
        allow_pagefault: bool_,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub static mut _debug_guardpage_minorder: core::ffi::c_uint;
}
extern "C" {
    pub static mut _debug_guardpage_enabled: static_key_false;
}
extern "C" {
    pub fn memcmp_pages(page1: *mut page, page2: *mut page) -> core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_nr_trim_pages: core::ffi::c_int;
}
extern "C" {
    pub fn mem_dump_obj(object: *mut core::ffi::c_void);
}
extern "C" {
    pub static mut _start_kernel: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __init_data_begin: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __init_data_end: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __init_text_begin: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __init_text_end: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __alt_start: [core::ffi::c_char; 0usize];
}
extern "C" {
    pub static mut __alt_end: [core::ffi::c_char; 0usize];
}
pub const IRQC_IS_HARDIRQ: core::ffi::c_uint = 0;
pub const IRQC_IS_NESTED: core::ffi::c_uint = 1;
pub type _bindgen_ty_106 = core::ffi::c_uint;
pub type irq_handler_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: core::ffi::c_int, arg2: *mut core::ffi::c_void) -> irqreturn_t,
>;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct irqaction {
    pub handler: irq_handler_t,
    pub dev_id: *mut core::ffi::c_void,
    pub percpu_dev_id: *mut core::ffi::c_void,
    pub next: *mut irqaction,
    pub thread_fn: irq_handler_t,
    pub thread: *mut task_struct,
    pub secondary: *mut irqaction,
    pub irq: core::ffi::c_uint,
    pub flags: core::ffi::c_uint,
    pub thread_flags: core::ffi::c_ulong,
    pub thread_mask: core::ffi::c_ulong,
    pub name: *const core::ffi::c_char,
    pub dir: *mut proc_dir_entry,
}
impl Default for irqaction {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn no_action(cpl: core::ffi::c_int, dev_id: *mut core::ffi::c_void) -> irqreturn_t;
}
extern "C" {
    pub fn request_threaded_irq(
        irq: core::ffi::c_uint,
        handler: irq_handler_t,
        thread_fn: irq_handler_t,
        flags: core::ffi::c_ulong,
        name: *const core::ffi::c_char,
        dev: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn request_any_context_irq(
        irq: core::ffi::c_uint,
        handler: irq_handler_t,
        flags: core::ffi::c_ulong,
        name: *const core::ffi::c_char,
        dev_id: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __request_percpu_irq(
        irq: core::ffi::c_uint,
        handler: irq_handler_t,
        flags: core::ffi::c_ulong,
        devname: *const core::ffi::c_char,
        percpu_dev_id: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn request_nmi(
        irq: core::ffi::c_uint,
        handler: irq_handler_t,
        flags: core::ffi::c_ulong,
        name: *const core::ffi::c_char,
        dev: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn request_percpu_nmi(
        irq: core::ffi::c_uint,
        handler: irq_handler_t,
        devname: *const core::ffi::c_char,
        dev: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn free_irq(
        arg1: core::ffi::c_uint,
        arg2: *mut core::ffi::c_void,
    ) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn free_percpu_irq(arg1: core::ffi::c_uint, arg2: *mut core::ffi::c_void);
}
extern "C" {
    pub fn free_nmi(
        irq: core::ffi::c_uint,
        dev_id: *mut core::ffi::c_void,
    ) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn free_percpu_nmi(irq: core::ffi::c_uint, percpu_dev_id: *mut core::ffi::c_void);
}
extern "C" {
    pub fn devm_request_threaded_irq(
        dev: *mut device,
        irq: core::ffi::c_uint,
        handler: irq_handler_t,
        thread_fn: irq_handler_t,
        irqflags: core::ffi::c_ulong,
        devname: *const core::ffi::c_char,
        dev_id: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_request_any_context_irq(
        dev: *mut device,
        irq: core::ffi::c_uint,
        handler: irq_handler_t,
        irqflags: core::ffi::c_ulong,
        devname: *const core::ffi::c_char,
        dev_id: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_free_irq(dev: *mut device, irq: core::ffi::c_uint, dev_id: *mut core::ffi::c_void);
}
extern "C" {
    pub fn irq_has_action(irq: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn disable_irq_nosync(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn disable_hardirq(irq: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn disable_irq(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn disable_percpu_irq(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn enable_irq(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn enable_percpu_irq(irq: core::ffi::c_uint, type_: core::ffi::c_uint);
}
extern "C" {
    pub fn irq_percpu_is_enabled(irq: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn irq_wake_thread(irq: core::ffi::c_uint, dev_id: *mut core::ffi::c_void);
}
extern "C" {
    pub fn disable_nmi_nosync(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn disable_percpu_nmi(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn enable_nmi(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn enable_percpu_nmi(irq: core::ffi::c_uint, type_: core::ffi::c_uint);
}
extern "C" {
    pub fn prepare_percpu_nmi(irq: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn teardown_percpu_nmi(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn irq_inject_interrupt(irq: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn suspend_device_irqs();
}
extern "C" {
    pub fn resume_device_irqs();
}
extern "C" {
    pub fn rearm_wake_irq(irq: core::ffi::c_uint);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_affinity_notify {
    pub irq: core::ffi::c_uint,
    pub kref: kref,
    pub work: work_struct,
    pub notify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut irq_affinity_notify, mask: *const cpumask_t),
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(ref_: *mut kref)>,
}
impl Default for irq_affinity_notify {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_affinity {
    pub pre_vectors: core::ffi::c_uint,
    pub post_vectors: core::ffi::c_uint,
    pub nr_sets: core::ffi::c_uint,
    pub set_size: [core::ffi::c_uint; 4usize],
    pub calc_sets: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut irq_affinity, nvecs: core::ffi::c_uint),
    >,
    pub priv_: *mut core::ffi::c_void,
}
impl Default for irq_affinity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct irq_affinity_desc {
    pub mask: cpumask,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
impl irq_affinity_desc {
    #[inline]
    pub fn is_managed(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_managed(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_managed: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_managed: u32 = unsafe { ::core::mem::transmute(is_managed) };
            is_managed as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut irq_default_affinity: cpumask_var_t;
}
extern "C" {
    pub fn irq_set_affinity(irq: core::ffi::c_uint, cpumask: *const cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_force_affinity(irq: core::ffi::c_uint, cpumask: *const cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_can_set_affinity(irq: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_select_affinity(irq: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn __irq_apply_affinity_hint(
        irq: core::ffi::c_uint,
        m: *const cpumask,
        setaffinity: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_update_affinity_desc(
        irq: core::ffi::c_uint,
        affinity: *mut irq_affinity_desc,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_set_affinity_notifier(
        irq: core::ffi::c_uint,
        notify: *mut irq_affinity_notify,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_create_affinity_masks(
        nvec: core::ffi::c_uint,
        affd: *mut irq_affinity,
    ) -> *mut irq_affinity_desc;
}
extern "C" {
    pub fn irq_calc_affinity_vectors(
        minvec: core::ffi::c_uint,
        maxvec: core::ffi::c_uint,
        affd: *const irq_affinity,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn irq_set_irq_wake(irq: core::ffi::c_uint, on: core::ffi::c_uint) -> core::ffi::c_int;
}
pub const irqchip_irq_state_IRQCHIP_STATE_PENDING: irqchip_irq_state = 0;
pub const irqchip_irq_state_IRQCHIP_STATE_ACTIVE: irqchip_irq_state = 1;
pub const irqchip_irq_state_IRQCHIP_STATE_MASKED: irqchip_irq_state = 2;
pub const irqchip_irq_state_IRQCHIP_STATE_LINE_LEVEL: irqchip_irq_state = 3;
pub type irqchip_irq_state = i32;
extern "C" {
    pub fn irq_get_irqchip_state(
        irq: core::ffi::c_uint,
        which: irqchip_irq_state,
        state: *mut bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_set_irqchip_state(
        irq: core::ffi::c_uint,
        which: irqchip_irq_state,
        state: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut force_irqthreads_key: static_key_false;
}
pub const HI_SOFTIRQ: core::ffi::c_uint = 0;
pub const TIMER_SOFTIRQ: core::ffi::c_uint = 1;
pub const NET_TX_SOFTIRQ: core::ffi::c_uint = 2;
pub const NET_RX_SOFTIRQ: core::ffi::c_uint = 3;
pub const BLOCK_SOFTIRQ: core::ffi::c_uint = 4;
pub const IRQ_POLL_SOFTIRQ: core::ffi::c_uint = 5;
pub const TASKLET_SOFTIRQ: core::ffi::c_uint = 6;
pub const SCHED_SOFTIRQ: core::ffi::c_uint = 7;
pub const HRTIMER_SOFTIRQ: core::ffi::c_uint = 8;
pub const RCU_SOFTIRQ: core::ffi::c_uint = 9;
pub const NR_SOFTIRQS: core::ffi::c_uint = 10;
pub type _bindgen_ty_107 = core::ffi::c_uint;
extern "C" {
    pub static softirq_to_name: [*const core::ffi::c_char; 10usize];
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct softirq_action {
    pub action: ::core::option::Option<unsafe extern "C" fn(arg1: *mut softirq_action)>,
}
extern "C" {
    pub fn do_softirq();
}
extern "C" {
    pub fn __do_softirq();
}
extern "C" {
    pub fn open_softirq(
        nr: core::ffi::c_int,
        action: ::core::option::Option<unsafe extern "C" fn(arg1: *mut softirq_action)>,
    );
}
extern "C" {
    pub fn softirq_init();
}
extern "C" {
    pub fn __raise_softirq_irqoff(nr: core::ffi::c_uint);
}
extern "C" {
    pub fn raise_softirq_irqoff(nr: core::ffi::c_uint);
}
extern "C" {
    pub fn raise_softirq(nr: core::ffi::c_uint);
}
extern "C" {
    pub static mut ksoftirqd: *mut task_struct;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tasklet_struct {
    pub next: *mut tasklet_struct,
    pub state: core::ffi::c_ulong,
    pub count: atomic_t,
    pub use_callback: bool_,
    pub __bindgen_anon_1: tasklet_struct__bindgen_ty_1,
    pub data: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tasklet_struct__bindgen_ty_1 {
    pub func: ::core::option::Option<unsafe extern "C" fn(data: core::ffi::c_ulong)>,
    pub callback: ::core::option::Option<unsafe extern "C" fn(t: *mut tasklet_struct)>,
    _bindgen_union_align: u64,
}
impl Default for tasklet_struct__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for tasklet_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const TASKLET_STATE_SCHED: core::ffi::c_uint = 0;
pub const TASKLET_STATE_RUN: core::ffi::c_uint = 1;
pub type _bindgen_ty_108 = core::ffi::c_uint;
extern "C" {
    pub fn tasklet_unlock(t: *mut tasklet_struct);
}
extern "C" {
    pub fn tasklet_unlock_wait(t: *mut tasklet_struct);
}
extern "C" {
    pub fn tasklet_unlock_spin_wait(t: *mut tasklet_struct);
}
extern "C" {
    pub fn __tasklet_schedule(t: *mut tasklet_struct);
}
extern "C" {
    pub fn __tasklet_hi_schedule(t: *mut tasklet_struct);
}
extern "C" {
    pub fn tasklet_kill(t: *mut tasklet_struct);
}
extern "C" {
    pub fn tasklet_init(
        t: *mut tasklet_struct,
        func: ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_ulong)>,
        data: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn tasklet_setup(
        t: *mut tasklet_struct,
        callback: ::core::option::Option<unsafe extern "C" fn(arg1: *mut tasklet_struct)>,
    );
}
extern "C" {
    pub fn init_irq_proc();
}
extern "C" {
    pub fn show_interrupts(p: *mut seq_file, v: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_show_interrupts(p: *mut seq_file, prec: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn early_irq_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_probe_nr_irqs() -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_early_irq_init() -> core::ffi::c_int;
}
pub const cpu_usage_stat_CPUTIME_USER: cpu_usage_stat = 0;
pub const cpu_usage_stat_CPUTIME_NICE: cpu_usage_stat = 1;
pub const cpu_usage_stat_CPUTIME_SYSTEM: cpu_usage_stat = 2;
pub const cpu_usage_stat_CPUTIME_SOFTIRQ: cpu_usage_stat = 3;
pub const cpu_usage_stat_CPUTIME_IRQ: cpu_usage_stat = 4;
pub const cpu_usage_stat_CPUTIME_IDLE: cpu_usage_stat = 5;
pub const cpu_usage_stat_CPUTIME_IOWAIT: cpu_usage_stat = 6;
pub const cpu_usage_stat_CPUTIME_STEAL: cpu_usage_stat = 7;
pub const cpu_usage_stat_CPUTIME_GUEST: cpu_usage_stat = 8;
pub const cpu_usage_stat_CPUTIME_GUEST_NICE: cpu_usage_stat = 9;
pub const cpu_usage_stat_NR_STATS: cpu_usage_stat = 10;
pub type cpu_usage_stat = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_cpustat {
    pub cpustat: [u64_; 10usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernel_stat {
    pub irqs_sum: core::ffi::c_ulong,
    pub softirqs: [core::ffi::c_uint; 10usize],
}
extern "C" {
    pub static mut kstat: kernel_stat;
}
extern "C" {
    pub static mut kernel_cpustat: kernel_cpustat;
}
extern "C" {
    pub fn nr_context_switches() -> core::ffi::c_ulonglong;
}
extern "C" {
    pub fn kstat_irqs_cpu(irq: core::ffi::c_uint, cpu: core::ffi::c_int) -> core::ffi::c_uint;
}
extern "C" {
    pub fn kstat_incr_irq_this_cpu(irq: core::ffi::c_uint);
}
extern "C" {
    pub fn kstat_irqs_usr(irq: core::ffi::c_uint) -> core::ffi::c_uint;
}
extern "C" {
    pub fn account_user_time(arg1: *mut task_struct, arg2: u64_);
}
extern "C" {
    pub fn account_guest_time(arg1: *mut task_struct, arg2: u64_);
}
extern "C" {
    pub fn account_system_time(arg1: *mut task_struct, arg2: core::ffi::c_int, arg3: u64_);
}
extern "C" {
    pub fn account_system_index_time(arg1: *mut task_struct, arg2: u64_, arg3: cpu_usage_stat);
}
extern "C" {
    pub fn account_steal_time(arg1: u64_);
}
extern "C" {
    pub fn account_idle_time(arg1: u64_);
}
extern "C" {
    pub fn get_idle_time(kcs: *mut kernel_cpustat, cpu: core::ffi::c_int) -> u64_;
}
extern "C" {
    pub fn account_process_tick(arg1: *mut task_struct, user: core::ffi::c_int);
}
extern "C" {
    pub fn account_idle_ticks(ticks: core::ffi::c_ulong);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u64_stats_sync {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct local_t {
    pub a: atomic_long_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct local64_t {
    pub a: local_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct u64_stats_t {
    pub v: local64_t,
}
pub const cgroup_bpf_attach_type_CGROUP_BPF_ATTACH_TYPE_INVALID: cgroup_bpf_attach_type = -1;
pub const cgroup_bpf_attach_type_CGROUP_INET_INGRESS: cgroup_bpf_attach_type = 0;
pub const cgroup_bpf_attach_type_CGROUP_INET_EGRESS: cgroup_bpf_attach_type = 1;
pub const cgroup_bpf_attach_type_CGROUP_INET_SOCK_CREATE: cgroup_bpf_attach_type = 2;
pub const cgroup_bpf_attach_type_CGROUP_SOCK_OPS: cgroup_bpf_attach_type = 3;
pub const cgroup_bpf_attach_type_CGROUP_DEVICE: cgroup_bpf_attach_type = 4;
pub const cgroup_bpf_attach_type_CGROUP_INET4_BIND: cgroup_bpf_attach_type = 5;
pub const cgroup_bpf_attach_type_CGROUP_INET6_BIND: cgroup_bpf_attach_type = 6;
pub const cgroup_bpf_attach_type_CGROUP_INET4_CONNECT: cgroup_bpf_attach_type = 7;
pub const cgroup_bpf_attach_type_CGROUP_INET6_CONNECT: cgroup_bpf_attach_type = 8;
pub const cgroup_bpf_attach_type_CGROUP_INET4_POST_BIND: cgroup_bpf_attach_type = 9;
pub const cgroup_bpf_attach_type_CGROUP_INET6_POST_BIND: cgroup_bpf_attach_type = 10;
pub const cgroup_bpf_attach_type_CGROUP_UDP4_SENDMSG: cgroup_bpf_attach_type = 11;
pub const cgroup_bpf_attach_type_CGROUP_UDP6_SENDMSG: cgroup_bpf_attach_type = 12;
pub const cgroup_bpf_attach_type_CGROUP_SYSCTL: cgroup_bpf_attach_type = 13;
pub const cgroup_bpf_attach_type_CGROUP_UDP4_RECVMSG: cgroup_bpf_attach_type = 14;
pub const cgroup_bpf_attach_type_CGROUP_UDP6_RECVMSG: cgroup_bpf_attach_type = 15;
pub const cgroup_bpf_attach_type_CGROUP_GETSOCKOPT: cgroup_bpf_attach_type = 16;
pub const cgroup_bpf_attach_type_CGROUP_SETSOCKOPT: cgroup_bpf_attach_type = 17;
pub const cgroup_bpf_attach_type_CGROUP_INET4_GETPEERNAME: cgroup_bpf_attach_type = 18;
pub const cgroup_bpf_attach_type_CGROUP_INET6_GETPEERNAME: cgroup_bpf_attach_type = 19;
pub const cgroup_bpf_attach_type_CGROUP_INET4_GETSOCKNAME: cgroup_bpf_attach_type = 20;
pub const cgroup_bpf_attach_type_CGROUP_INET6_GETSOCKNAME: cgroup_bpf_attach_type = 21;
pub const cgroup_bpf_attach_type_CGROUP_INET_SOCK_RELEASE: cgroup_bpf_attach_type = 22;
pub const cgroup_bpf_attach_type_CGROUP_LSM_START: cgroup_bpf_attach_type = 23;
pub const cgroup_bpf_attach_type_CGROUP_LSM_END: cgroup_bpf_attach_type = 22;
pub const cgroup_bpf_attach_type_MAX_CGROUP_BPF_ATTACH_TYPE: cgroup_bpf_attach_type = 23;
pub type cgroup_bpf_attach_type = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_bpf {
    pub effective: [*mut bpf_prog_array; 23usize],
    pub progs: [hlist_head; 23usize],
    pub flags: [u8_; 23usize],
    pub storages: list_head,
    pub inactive: *mut bpf_prog_array,
    pub refcnt: percpu_ref,
    pub release_work: work_struct,
}
impl Default for cgroup_bpf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kthread_create_on_node(
        threadfn: ::core::option::Option<
            unsafe extern "C" fn(data: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
        node: core::ffi::c_int,
        namefmt: *const core::ffi::c_char,
        ...
    ) -> *mut task_struct;
}
extern "C" {
    pub fn kthread_create_on_cpu(
        threadfn: ::core::option::Option<
            unsafe extern "C" fn(data: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
        cpu: core::ffi::c_uint,
        namefmt: *const core::ffi::c_char,
    ) -> *mut task_struct;
}
extern "C" {
    pub fn get_kthread_comm(buf: *mut core::ffi::c_char, buf_size: usize, tsk: *mut task_struct);
}
extern "C" {
    pub fn set_kthread_struct(p: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn kthread_set_per_cpu(k: *mut task_struct, cpu: core::ffi::c_int);
}
extern "C" {
    pub fn kthread_is_per_cpu(k: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn free_kthread_struct(k: *mut task_struct);
}
extern "C" {
    pub fn kthread_bind(k: *mut task_struct, cpu: core::ffi::c_uint);
}
extern "C" {
    pub fn kthread_bind_mask(k: *mut task_struct, mask: *const cpumask);
}
extern "C" {
    pub fn kthread_stop(k: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn kthread_should_stop() -> bool_;
}
extern "C" {
    pub fn kthread_should_park() -> bool_;
}
extern "C" {
    pub fn __kthread_should_park(k: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn kthread_freezable_should_stop(was_frozen: *mut bool_) -> bool_;
}
extern "C" {
    pub fn kthread_func(k: *mut task_struct) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kthread_data(k: *mut task_struct) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kthread_probe_data(k: *mut task_struct) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn kthread_park(k: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn kthread_unpark(k: *mut task_struct);
}
extern "C" {
    pub fn kthread_parkme();
}
extern "C" {
    pub fn kthread_exit(result: core::ffi::c_long);
}
extern "C" {
    pub fn kthread_complete_and_exit(arg1: *mut completion, arg2: core::ffi::c_long);
}
extern "C" {
    pub fn kthreadd(unused: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub static mut kthreadd_task: *mut task_struct;
}
extern "C" {
    pub fn tsk_fork_get_node(tsk: *mut task_struct) -> core::ffi::c_int;
}
pub type kthread_work_func_t =
    ::core::option::Option<unsafe extern "C" fn(work: *mut kthread_work)>;
extern "C" {
    pub fn kthread_delayed_work_timer_fn(t: *mut timer_list);
}
pub const KTW_FREEZABLE: core::ffi::c_uint = 1;
pub type _bindgen_ty_109 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kthread_worker {
    pub flags: core::ffi::c_uint,
    pub lock: raw_spinlock_t,
    pub work_list: list_head,
    pub delayed_work_list: list_head,
    pub task: *mut task_struct,
    pub current_work: *mut kthread_work,
}
impl Default for kthread_worker {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kthread_work {
    pub node: list_head,
    pub func: kthread_work_func_t,
    pub worker: *mut kthread_worker,
    pub canceling: core::ffi::c_int,
}
impl Default for kthread_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kthread_delayed_work {
    pub work: kthread_work,
    pub timer: timer_list,
}
impl Default for kthread_delayed_work {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __kthread_init_worker(
        worker: *mut kthread_worker,
        name: *const core::ffi::c_char,
        key: *mut lock_class_key,
    );
}
extern "C" {
    pub fn kthread_worker_fn(worker_ptr: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn kthread_create_worker(
        flags: core::ffi::c_uint,
        namefmt: *const core::ffi::c_char,
        ...
    ) -> *mut kthread_worker;
}
extern "C" {
    pub fn kthread_create_worker_on_cpu(
        cpu: core::ffi::c_int,
        flags: core::ffi::c_uint,
        namefmt: *const core::ffi::c_char,
        ...
    ) -> *mut kthread_worker;
}
extern "C" {
    pub fn kthread_queue_work(worker: *mut kthread_worker, work: *mut kthread_work) -> bool_;
}
extern "C" {
    pub fn kthread_queue_delayed_work(
        worker: *mut kthread_worker,
        dwork: *mut kthread_delayed_work,
        delay: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn kthread_mod_delayed_work(
        worker: *mut kthread_worker,
        dwork: *mut kthread_delayed_work,
        delay: core::ffi::c_ulong,
    ) -> bool_;
}
extern "C" {
    pub fn kthread_flush_work(work: *mut kthread_work);
}
extern "C" {
    pub fn kthread_flush_worker(worker: *mut kthread_worker);
}
extern "C" {
    pub fn kthread_cancel_work_sync(work: *mut kthread_work) -> bool_;
}
extern "C" {
    pub fn kthread_cancel_delayed_work_sync(work: *mut kthread_delayed_work) -> bool_;
}
extern "C" {
    pub fn kthread_destroy_worker(worker: *mut kthread_worker);
}
extern "C" {
    pub fn kthread_use_mm(mm: *mut mm_struct);
}
extern "C" {
    pub fn kthread_unuse_mm(mm: *mut mm_struct);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct psi_group {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_taskset {
    _unused: [u8; 0],
}
pub const cgroup_subsys_id_cpuset_cgrp_id: cgroup_subsys_id = 0;
pub const cgroup_subsys_id_cpu_cgrp_id: cgroup_subsys_id = 1;
pub const cgroup_subsys_id_cpuacct_cgrp_id: cgroup_subsys_id = 2;
pub const cgroup_subsys_id_memory_cgrp_id: cgroup_subsys_id = 3;
pub const cgroup_subsys_id_devices_cgrp_id: cgroup_subsys_id = 4;
pub const cgroup_subsys_id_freezer_cgrp_id: cgroup_subsys_id = 5;
pub const cgroup_subsys_id_net_cls_cgrp_id: cgroup_subsys_id = 6;
pub const cgroup_subsys_id_perf_event_cgrp_id: cgroup_subsys_id = 7;
pub const cgroup_subsys_id_net_prio_cgrp_id: cgroup_subsys_id = 8;
pub const cgroup_subsys_id_hugetlb_cgrp_id: cgroup_subsys_id = 9;
pub const cgroup_subsys_id_pids_cgrp_id: cgroup_subsys_id = 10;
pub const cgroup_subsys_id_CGROUP_SUBSYS_COUNT: cgroup_subsys_id = 11;
pub type cgroup_subsys_id = core::ffi::c_uint;
pub const CSS_NO_REF: core::ffi::c_uint = 1;
pub const CSS_ONLINE: core::ffi::c_uint = 2;
pub const CSS_RELEASED: core::ffi::c_uint = 4;
pub const CSS_VISIBLE: core::ffi::c_uint = 8;
pub const CSS_DYING: core::ffi::c_uint = 16;
pub type _bindgen_ty_110 = core::ffi::c_uint;
pub const CGRP_NOTIFY_ON_RELEASE: core::ffi::c_uint = 0;
pub const CGRP_CPUSET_CLONE_CHILDREN: core::ffi::c_uint = 1;
pub const CGRP_FREEZE: core::ffi::c_uint = 2;
pub const CGRP_FROZEN: core::ffi::c_uint = 3;
pub const CGRP_KILL: core::ffi::c_uint = 4;
pub type _bindgen_ty_111 = core::ffi::c_uint;
pub const CGRP_ROOT_NOPREFIX: core::ffi::c_uint = 2;
pub const CGRP_ROOT_XATTR: core::ffi::c_uint = 4;
pub const CGRP_ROOT_NS_DELEGATE: core::ffi::c_uint = 8;
pub const CGRP_ROOT_FAVOR_DYNMODS: core::ffi::c_uint = 16;
pub const CGRP_ROOT_CPUSET_V2_MODE: core::ffi::c_uint = 65536;
pub const CGRP_ROOT_MEMORY_LOCAL_EVENTS: core::ffi::c_uint = 131072;
pub const CGRP_ROOT_MEMORY_RECURSIVE_PROT: core::ffi::c_uint = 262144;
pub type _bindgen_ty_112 = core::ffi::c_uint;
pub const CFTYPE_ONLY_ON_ROOT: core::ffi::c_uint = 1;
pub const CFTYPE_NOT_ON_ROOT: core::ffi::c_uint = 2;
pub const CFTYPE_NS_DELEGATABLE: core::ffi::c_uint = 4;
pub const CFTYPE_NO_PREFIX: core::ffi::c_uint = 8;
pub const CFTYPE_WORLD_WRITABLE: core::ffi::c_uint = 16;
pub const CFTYPE_DEBUG: core::ffi::c_uint = 32;
pub const __CFTYPE_ONLY_ON_DFL: core::ffi::c_uint = 65536;
pub const __CFTYPE_NOT_ON_DFL: core::ffi::c_uint = 131072;
pub const __CFTYPE_ADDED: core::ffi::c_uint = 262144;
pub type _bindgen_ty_113 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_file {
    pub kn: *mut kernfs_node,
    pub notified_at: core::ffi::c_ulong,
    pub notify_timer: timer_list,
}
impl Default for cgroup_file {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_subsys_state {
    pub cgroup: *mut cgroup,
    pub ss: *mut cgroup_subsys,
    pub refcnt: percpu_ref,
    pub sibling: list_head,
    pub children: list_head,
    pub rstat_css_node: list_head,
    pub id: core::ffi::c_int,
    pub flags: core::ffi::c_uint,
    pub serial_nr: u64_,
    pub online_cnt: atomic_t,
    pub destroy_work: work_struct,
    pub destroy_rwork: rcu_work,
    pub parent: *mut cgroup_subsys_state,
}
impl Default for cgroup_subsys_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct css_set {
    pub subsys: [*mut cgroup_subsys_state; 11usize],
    pub refcount: refcount_t,
    pub dom_cset: *mut css_set,
    pub dfl_cgrp: *mut cgroup,
    pub nr_tasks: core::ffi::c_int,
    pub tasks: list_head,
    pub mg_tasks: list_head,
    pub dying_tasks: list_head,
    pub task_iters: list_head,
    pub e_cset_node: [list_head; 11usize],
    pub threaded_csets: list_head,
    pub threaded_csets_node: list_head,
    pub hlist: hlist_node,
    pub cgrp_links: list_head,
    pub mg_src_preload_node: list_head,
    pub mg_dst_preload_node: list_head,
    pub mg_node: list_head,
    pub mg_src_cgrp: *mut cgroup,
    pub mg_dst_cgrp: *mut cgroup,
    pub mg_dst_cset: *mut css_set,
    pub dead: bool_,
    pub callback_head: callback_head,
}
impl Default for css_set {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cgroup_base_stat {
    pub cputime: task_cputime,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_rstat_cpu {
    pub bsync: u64_stats_sync,
    pub bstat: cgroup_base_stat,
    pub last_bstat: cgroup_base_stat,
    pub updated_children: *mut cgroup,
    pub updated_next: *mut cgroup,
}
impl Default for cgroup_rstat_cpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cgroup_freezer_state {
    pub freeze: bool_,
    pub e_freeze: core::ffi::c_int,
    pub nr_frozen_descendants: core::ffi::c_int,
    pub nr_frozen_tasks: core::ffi::c_int,
}
#[repr(C)]
pub struct cgroup {
    pub self_: cgroup_subsys_state,
    pub flags: core::ffi::c_ulong,
    pub level: core::ffi::c_int,
    pub max_depth: core::ffi::c_int,
    pub nr_descendants: core::ffi::c_int,
    pub nr_dying_descendants: core::ffi::c_int,
    pub max_descendants: core::ffi::c_int,
    pub nr_populated_csets: core::ffi::c_int,
    pub nr_populated_domain_children: core::ffi::c_int,
    pub nr_populated_threaded_children: core::ffi::c_int,
    pub nr_threaded_children: core::ffi::c_int,
    pub kn: *mut kernfs_node,
    pub procs_file: cgroup_file,
    pub events_file: cgroup_file,
    pub psi_files: __IncompleteArrayField<cgroup_file>,
    pub subtree_control: u16_,
    pub subtree_ss_mask: u16_,
    pub old_subtree_control: u16_,
    pub old_subtree_ss_mask: u16_,
    pub subsys: [*mut cgroup_subsys_state; 11usize],
    pub root: *mut cgroup_root,
    pub cset_links: list_head,
    pub e_csets: [list_head; 11usize],
    pub dom_cgrp: *mut cgroup,
    pub old_dom_cgrp: *mut cgroup,
    pub rstat_cpu: *mut cgroup_rstat_cpu,
    pub rstat_css_list: list_head,
    pub last_bstat: cgroup_base_stat,
    pub bstat: cgroup_base_stat,
    pub prev_cputime: prev_cputime,
    pub pidlists: list_head,
    pub pidlist_mutex: mutex,
    pub offline_waitq: wait_queue_head_t,
    pub release_agent_work: work_struct,
    pub psi: *mut psi_group,
    pub bpf: cgroup_bpf,
    pub congestion_count: atomic_t,
    pub freezer: cgroup_freezer_state,
    pub ancestors: __IncompleteArrayField<*mut cgroup>,
}
impl Default for cgroup {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct cgroup_root {
    pub kf_root: *mut kernfs_root,
    pub subsys_mask: core::ffi::c_uint,
    pub hierarchy_id: core::ffi::c_int,
    pub cgrp: cgroup,
    pub cgrp_ancestor_storage: *mut cgroup,
    pub nr_cgrps: atomic_t,
    pub root_list: list_head,
    pub flags: core::ffi::c_uint,
    pub release_agent_path: [core::ffi::c_char; 4096usize],
    pub name: [core::ffi::c_char; 64usize],
}
impl Default for cgroup_root {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cftype {
    pub name: [core::ffi::c_char; 64usize],
    pub private: core::ffi::c_ulong,
    pub max_write_len: usize,
    pub flags: core::ffi::c_uint,
    pub file_offset: core::ffi::c_uint,
    pub ss: *mut cgroup_subsys,
    pub node: list_head,
    pub kf_ops: *mut kernfs_ops,
    pub open:
        ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file) -> core::ffi::c_int>,
    pub release: ::core::option::Option<unsafe extern "C" fn(of: *mut kernfs_open_file)>,
    pub read_u64: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cft: *mut cftype) -> u64_,
    >,
    pub read_s64: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cft: *mut cftype) -> s64,
    >,
    pub seq_show: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, v: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub seq_start: ::core::option::Option<
        unsafe extern "C" fn(sf: *mut seq_file, ppos: *mut loff_t) -> *mut core::ffi::c_void,
    >,
    pub seq_next: ::core::option::Option<
        unsafe extern "C" fn(
            sf: *mut seq_file,
            v: *mut core::ffi::c_void,
            ppos: *mut loff_t,
        ) -> *mut core::ffi::c_void,
    >,
    pub seq_stop:
        ::core::option::Option<unsafe extern "C" fn(sf: *mut seq_file, v: *mut core::ffi::c_void)>,
    pub write_u64: ::core::option::Option<
        unsafe extern "C" fn(
            css: *mut cgroup_subsys_state,
            cft: *mut cftype,
            val: u64_,
        ) -> core::ffi::c_int,
    >,
    pub write_s64: ::core::option::Option<
        unsafe extern "C" fn(
            css: *mut cgroup_subsys_state,
            cft: *mut cftype,
            val: s64,
        ) -> core::ffi::c_int,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            of: *mut kernfs_open_file,
            buf: *mut core::ffi::c_char,
            nbytes: usize,
            off: loff_t,
        ) -> isize,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(of: *mut kernfs_open_file, pt: *mut poll_table_struct) -> __poll_t,
    >,
}
impl Default for cftype {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_subsys {
    pub css_alloc: ::core::option::Option<
        unsafe extern "C" fn(parent_css: *mut cgroup_subsys_state) -> *mut cgroup_subsys_state,
    >,
    pub css_online: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state) -> core::ffi::c_int,
    >,
    pub css_offline: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_released: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_free: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_reset: ::core::option::Option<unsafe extern "C" fn(css: *mut cgroup_subsys_state)>,
    pub css_rstat_flush: ::core::option::Option<
        unsafe extern "C" fn(css: *mut cgroup_subsys_state, cpu: core::ffi::c_int),
    >,
    pub css_extra_stat_show: ::core::option::Option<
        unsafe extern "C" fn(seq: *mut seq_file, css: *mut cgroup_subsys_state) -> core::ffi::c_int,
    >,
    pub can_attach:
        ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset) -> core::ffi::c_int>,
    pub cancel_attach: ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset)>,
    pub attach: ::core::option::Option<unsafe extern "C" fn(tset: *mut cgroup_taskset)>,
    pub post_attach: ::core::option::Option<unsafe extern "C" fn()>,
    pub can_fork: ::core::option::Option<
        unsafe extern "C" fn(task: *mut task_struct, cset: *mut css_set) -> core::ffi::c_int,
    >,
    pub cancel_fork:
        ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct, cset: *mut css_set)>,
    pub fork: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub release: ::core::option::Option<unsafe extern "C" fn(task: *mut task_struct)>,
    pub bind: ::core::option::Option<unsafe extern "C" fn(root_css: *mut cgroup_subsys_state)>,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub id: core::ffi::c_int,
    pub name: *const core::ffi::c_char,
    pub legacy_name: *const core::ffi::c_char,
    pub root: *mut cgroup_root,
    pub css_idr: idr,
    pub cfts: list_head,
    pub dfl_cftypes: *mut cftype,
    pub legacy_cftypes: *mut cftype,
    pub depends_on: core::ffi::c_uint,
}
impl Default for cgroup_subsys {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl cgroup_subsys {
    #[inline]
    pub fn early_init(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_early_init(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn implicit_on_dfl(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_implicit_on_dfl(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn threaded(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_threaded(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        early_init: bool_,
        implicit_on_dfl: bool_,
        threaded: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let early_init: u8 = unsafe { ::core::mem::transmute(early_init) };
            early_init as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let implicit_on_dfl: u8 = unsafe { ::core::mem::transmute(implicit_on_dfl) };
            implicit_on_dfl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let threaded: u8 = unsafe { ::core::mem::transmute(threaded) };
            threaded as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static mut cgroup_threadgroup_rwsem: percpu_rw_semaphore;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock_cgroup_data {
    pub cgroup: *mut cgroup,
    pub classid: u32_,
    pub prioidx: u16_,
}
impl Default for sock_cgroup_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct css_task_iter {
    pub ss: *mut cgroup_subsys,
    pub flags: core::ffi::c_uint,
    pub cset_pos: *mut list_head,
    pub cset_head: *mut list_head,
    pub tcset_pos: *mut list_head,
    pub tcset_head: *mut list_head,
    pub task_pos: *mut list_head,
    pub cur_tasks_head: *mut list_head,
    pub cur_cset: *mut css_set,
    pub cur_dcset: *mut css_set,
    pub cur_task: *mut task_struct,
    pub iters_node: list_head,
}
impl Default for css_task_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut cgrp_dfl_root: cgroup_root;
}
extern "C" {
    pub static mut init_css_set: css_set;
}
extern "C" {
    pub static mut cpuset_cgrp_subsys: cgroup_subsys;
}
extern "C" {
    pub static mut cpu_cgrp_subsys: cgroup_subsys;
}
extern "C" {
    pub static mut cpuacct_cgrp_subsys: cgroup_subsys;
}
extern "C" {
    pub static mut memory_cgrp_subsys: cgroup_subsys;
}
extern "C" {
    pub static mut devices_cgrp_subsys: cgroup_subsys;
}
extern "C" {
    pub static mut freezer_cgrp_subsys: cgroup_subsys;
}
extern "C" {
    pub static mut net_cls_cgrp_subsys: cgroup_subsys;
}
extern "C" {
    pub static mut perf_event_cgrp_subsys: cgroup_subsys;
}
extern "C" {
    pub static mut net_prio_cgrp_subsys: cgroup_subsys;
}
extern "C" {
    pub static mut hugetlb_cgrp_subsys: cgroup_subsys;
}
extern "C" {
    pub static mut pids_cgrp_subsys: cgroup_subsys;
}
extern "C" {
    pub static mut cpuset_cgrp_subsys_enabled_key: static_key_true;
}
extern "C" {
    pub static mut cpuset_cgrp_subsys_on_dfl_key: static_key_true;
}
extern "C" {
    pub static mut cpu_cgrp_subsys_enabled_key: static_key_true;
}
extern "C" {
    pub static mut cpu_cgrp_subsys_on_dfl_key: static_key_true;
}
extern "C" {
    pub static mut cpuacct_cgrp_subsys_enabled_key: static_key_true;
}
extern "C" {
    pub static mut cpuacct_cgrp_subsys_on_dfl_key: static_key_true;
}
extern "C" {
    pub static mut memory_cgrp_subsys_enabled_key: static_key_true;
}
extern "C" {
    pub static mut memory_cgrp_subsys_on_dfl_key: static_key_true;
}
extern "C" {
    pub static mut devices_cgrp_subsys_enabled_key: static_key_true;
}
extern "C" {
    pub static mut devices_cgrp_subsys_on_dfl_key: static_key_true;
}
extern "C" {
    pub static mut freezer_cgrp_subsys_enabled_key: static_key_true;
}
extern "C" {
    pub static mut freezer_cgrp_subsys_on_dfl_key: static_key_true;
}
extern "C" {
    pub static mut net_cls_cgrp_subsys_enabled_key: static_key_true;
}
extern "C" {
    pub static mut net_cls_cgrp_subsys_on_dfl_key: static_key_true;
}
extern "C" {
    pub static mut perf_event_cgrp_subsys_enabled_key: static_key_true;
}
extern "C" {
    pub static mut perf_event_cgrp_subsys_on_dfl_key: static_key_true;
}
extern "C" {
    pub static mut net_prio_cgrp_subsys_enabled_key: static_key_true;
}
extern "C" {
    pub static mut net_prio_cgrp_subsys_on_dfl_key: static_key_true;
}
extern "C" {
    pub static mut hugetlb_cgrp_subsys_enabled_key: static_key_true;
}
extern "C" {
    pub static mut hugetlb_cgrp_subsys_on_dfl_key: static_key_true;
}
extern "C" {
    pub static mut pids_cgrp_subsys_enabled_key: static_key_true;
}
extern "C" {
    pub static mut pids_cgrp_subsys_on_dfl_key: static_key_true;
}
extern "C" {
    pub fn css_has_online_children(css: *mut cgroup_subsys_state) -> bool_;
}
extern "C" {
    pub fn css_from_id(id: core::ffi::c_int, ss: *mut cgroup_subsys) -> *mut cgroup_subsys_state;
}
extern "C" {
    pub fn cgroup_e_css(cgroup: *mut cgroup, ss: *mut cgroup_subsys) -> *mut cgroup_subsys_state;
}
extern "C" {
    pub fn cgroup_get_e_css(
        cgroup: *mut cgroup,
        ss: *mut cgroup_subsys,
    ) -> *mut cgroup_subsys_state;
}
extern "C" {
    pub fn css_tryget_online_from_dir(
        dentry: *mut dentry,
        ss: *mut cgroup_subsys,
    ) -> *mut cgroup_subsys_state;
}
extern "C" {
    pub fn cgroup_get_from_path(path: *const core::ffi::c_char) -> *mut cgroup;
}
extern "C" {
    pub fn cgroup_get_from_fd(fd: core::ffi::c_int) -> *mut cgroup;
}
extern "C" {
    pub fn cgroup_attach_task_all(
        from: *mut task_struct,
        arg1: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_transfer_tasks(to: *mut cgroup, from: *mut cgroup) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_add_dfl_cftypes(ss: *mut cgroup_subsys, cfts: *mut cftype) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_add_legacy_cftypes(ss: *mut cgroup_subsys, cfts: *mut cftype)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_rm_cftypes(cfts: *mut cftype) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_file_notify(cfile: *mut cgroup_file);
}
extern "C" {
    pub fn cgroup_file_show(cfile: *mut cgroup_file, show: bool_);
}
extern "C" {
    pub fn task_cgroup_path(
        task: *mut task_struct,
        buf: *mut core::ffi::c_char,
        buflen: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroupstats_build(stats: *mut cgroupstats, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn proc_cgroup_show(
        m: *mut seq_file,
        ns: *mut pid_namespace,
        pid: *mut pid,
        tsk: *mut task_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_fork(p: *mut task_struct);
}
extern "C" {
    pub fn cgroup_can_fork(p: *mut task_struct, kargs: *mut kernel_clone_args) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_cancel_fork(p: *mut task_struct, kargs: *mut kernel_clone_args);
}
extern "C" {
    pub fn cgroup_post_fork(p: *mut task_struct, kargs: *mut kernel_clone_args);
}
extern "C" {
    pub fn cgroup_exit(p: *mut task_struct);
}
extern "C" {
    pub fn cgroup_release(p: *mut task_struct);
}
extern "C" {
    pub fn cgroup_free(p: *mut task_struct);
}
extern "C" {
    pub fn cgroup_init_early() -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_parse_float(
        input: *const core::ffi::c_char,
        dec_shift: core::ffi::c_uint,
        v: *mut s64,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn css_next_child(
        pos: *mut cgroup_subsys_state,
        parent: *mut cgroup_subsys_state,
    ) -> *mut cgroup_subsys_state;
}
extern "C" {
    pub fn css_next_descendant_pre(
        pos: *mut cgroup_subsys_state,
        css: *mut cgroup_subsys_state,
    ) -> *mut cgroup_subsys_state;
}
extern "C" {
    pub fn css_rightmost_descendant(pos: *mut cgroup_subsys_state) -> *mut cgroup_subsys_state;
}
extern "C" {
    pub fn css_next_descendant_post(
        pos: *mut cgroup_subsys_state,
        css: *mut cgroup_subsys_state,
    ) -> *mut cgroup_subsys_state;
}
extern "C" {
    pub fn cgroup_taskset_first(
        tset: *mut cgroup_taskset,
        dst_cssp: *mut *mut cgroup_subsys_state,
    ) -> *mut task_struct;
}
extern "C" {
    pub fn cgroup_taskset_next(
        tset: *mut cgroup_taskset,
        dst_cssp: *mut *mut cgroup_subsys_state,
    ) -> *mut task_struct;
}
extern "C" {
    pub fn css_task_iter_start(
        css: *mut cgroup_subsys_state,
        flags: core::ffi::c_uint,
        it: *mut css_task_iter,
    );
}
extern "C" {
    pub fn css_task_iter_next(it: *mut css_task_iter) -> *mut task_struct;
}
extern "C" {
    pub fn css_task_iter_end(it: *mut css_task_iter);
}
extern "C" {
    pub static mut cgroup_mutex: mutex;
}
extern "C" {
    pub fn of_css(of: *mut kernfs_open_file) -> *mut cgroup_subsys_state;
}
extern "C" {
    pub fn cgroup_psi_enabled() -> bool_;
}
extern "C" {
    pub fn cgroup_path_from_kernfs_id(id: u64_, buf: *mut core::ffi::c_char, buflen: usize);
}
extern "C" {
    pub fn cgroup_get_from_id(id: u64_) -> *mut cgroup;
}
extern "C" {
    pub fn cgroup_rstat_updated(cgrp: *mut cgroup, cpu: core::ffi::c_int);
}
extern "C" {
    pub fn cgroup_rstat_flush(cgrp: *mut cgroup);
}
extern "C" {
    pub fn cgroup_rstat_flush_irqsafe(cgrp: *mut cgroup);
}
extern "C" {
    pub fn cgroup_rstat_flush_hold(cgrp: *mut cgroup);
}
extern "C" {
    pub fn cgroup_rstat_flush_release();
}
extern "C" {
    pub fn cpuacct_charge(tsk: *mut task_struct, cputime: u64_);
}
extern "C" {
    pub fn cpuacct_account_field(tsk: *mut task_struct, index: core::ffi::c_int, val: u64_);
}
extern "C" {
    pub fn __cgroup_account_cputime(cgrp: *mut cgroup, delta_exec: u64_);
}
extern "C" {
    pub fn __cgroup_account_cputime_field(
        cgrp: *mut cgroup,
        index: cpu_usage_stat,
        delta_exec: u64_,
    );
}
extern "C" {
    pub fn cgroup_sk_alloc(skcd: *mut sock_cgroup_data);
}
extern "C" {
    pub fn cgroup_sk_clone(skcd: *mut sock_cgroup_data);
}
extern "C" {
    pub fn cgroup_sk_free(skcd: *mut sock_cgroup_data);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cgroup_namespace {
    pub ns: ns_common,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub root_cset: *mut css_set,
}
impl Default for cgroup_namespace {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut init_cgroup_ns: cgroup_namespace;
}
extern "C" {
    pub fn free_cgroup_ns(ns: *mut cgroup_namespace);
}
extern "C" {
    pub fn copy_cgroup_ns(
        flags: core::ffi::c_ulong,
        user_ns: *mut user_namespace,
        old_ns: *mut cgroup_namespace,
    ) -> *mut cgroup_namespace;
}
extern "C" {
    pub fn cgroup_path_ns(
        cgrp: *mut cgroup,
        buf: *mut core::ffi::c_char,
        buflen: usize,
        ns: *mut cgroup_namespace,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_enter_frozen();
}
extern "C" {
    pub fn cgroup_leave_frozen(always_leave: bool_);
}
extern "C" {
    pub fn cgroup_update_frozen(cgrp: *mut cgroup);
}
extern "C" {
    pub fn cgroup_freeze(cgrp: *mut cgroup, freeze: bool_);
}
extern "C" {
    pub fn cgroup_freezer_migrate_task(task: *mut task_struct, src: *mut cgroup, dst: *mut cgroup);
}
#[repr(C)]
#[repr(align(64))]
pub struct page_counter {
    pub usage: atomic_long_t,
    pub __bindgen_padding_0: [u64; 7usize],
    pub _pad1_: cacheline_padding,
    pub emin: core::ffi::c_ulong,
    pub min_usage: atomic_long_t,
    pub children_min_usage: atomic_long_t,
    pub elow: core::ffi::c_ulong,
    pub low_usage: atomic_long_t,
    pub children_low_usage: atomic_long_t,
    pub watermark: core::ffi::c_ulong,
    pub failcnt: core::ffi::c_ulong,
    pub _pad2_: cacheline_padding,
    pub min: core::ffi::c_ulong,
    pub low: core::ffi::c_ulong,
    pub high: core::ffi::c_ulong,
    pub max: core::ffi::c_ulong,
    pub parent: *mut page_counter,
}
impl Default for page_counter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn page_counter_cancel(counter: *mut page_counter, nr_pages: core::ffi::c_ulong);
}
extern "C" {
    pub fn page_counter_charge(counter: *mut page_counter, nr_pages: core::ffi::c_ulong);
}
extern "C" {
    pub fn page_counter_try_charge(
        counter: *mut page_counter,
        nr_pages: core::ffi::c_ulong,
        fail: *mut *mut page_counter,
    ) -> bool_;
}
extern "C" {
    pub fn page_counter_uncharge(counter: *mut page_counter, nr_pages: core::ffi::c_ulong);
}
extern "C" {
    pub fn page_counter_set_min(counter: *mut page_counter, nr_pages: core::ffi::c_ulong);
}
extern "C" {
    pub fn page_counter_set_low(counter: *mut page_counter, nr_pages: core::ffi::c_ulong);
}
extern "C" {
    pub fn page_counter_set_max(
        counter: *mut page_counter,
        nr_pages: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn page_counter_memparse(
        buf: *const core::ffi::c_char,
        max: *const core::ffi::c_char,
        nr_pages: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct eventfd_ctx {
    _unused: [u8; 0],
}
extern "C" {
    pub fn eventfd_ctx_put(ctx: *mut eventfd_ctx);
}
extern "C" {
    pub fn eventfd_fget(fd: core::ffi::c_int) -> *mut file;
}
extern "C" {
    pub fn eventfd_ctx_fdget(fd: core::ffi::c_int) -> *mut eventfd_ctx;
}
extern "C" {
    pub fn eventfd_ctx_fileget(file: *mut file) -> *mut eventfd_ctx;
}
extern "C" {
    pub fn eventfd_signal(ctx: *mut eventfd_ctx, n: __u64) -> __u64;
}
extern "C" {
    pub fn eventfd_ctx_remove_wait_queue(
        ctx: *mut eventfd_ctx,
        wait: *mut wait_queue_entry_t,
        cnt: *mut __u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn eventfd_ctx_do_read(ctx: *mut eventfd_ctx, cnt: *mut __u64);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vmpressure {
    pub scanned: core::ffi::c_ulong,
    pub reclaimed: core::ffi::c_ulong,
    pub tree_scanned: core::ffi::c_ulong,
    pub tree_reclaimed: core::ffi::c_ulong,
    pub sr_lock: spinlock_t,
    pub events: list_head,
    pub events_lock: mutex,
    pub work: work_struct,
}
impl Default for vmpressure {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn vmpressure(
        gfp: gfp_t,
        memcg: *mut mem_cgroup,
        tree: bool_,
        scanned: core::ffi::c_ulong,
        reclaimed: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn vmpressure_prio(gfp: gfp_t, memcg: *mut mem_cgroup, prio: core::ffi::c_int);
}
extern "C" {
    pub fn vmpressure_init(vmpr: *mut vmpressure);
}
extern "C" {
    pub fn vmpressure_cleanup(vmpr: *mut vmpressure);
}
extern "C" {
    pub fn memcg_to_vmpressure(memcg: *mut mem_cgroup) -> *mut vmpressure;
}
extern "C" {
    pub fn vmpressure_to_memcg(vmpr: *mut vmpressure) -> *mut mem_cgroup;
}
extern "C" {
    pub fn vmpressure_register_event(
        memcg: *mut mem_cgroup,
        eventfd: *mut eventfd_ctx,
        args: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vmpressure_unregister_event(memcg: *mut mem_cgroup, eventfd: *mut eventfd_ctx);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_global {
    pub events: percpu_counter,
    pub period: core::ffi::c_uint,
    pub sequence: seqcount_t,
}
impl Default for fprop_global {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn fprop_global_init(p: *mut fprop_global, gfp: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn fprop_global_destroy(p: *mut fprop_global);
}
extern "C" {
    pub fn fprop_new_period(p: *mut fprop_global, periods: core::ffi::c_int) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_local_single {
    pub events: core::ffi::c_ulong,
    pub period: core::ffi::c_uint,
    pub lock: raw_spinlock_t,
}
impl Default for fprop_local_single {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn fprop_local_init_single(pl: *mut fprop_local_single) -> core::ffi::c_int;
}
extern "C" {
    pub fn fprop_local_destroy_single(pl: *mut fprop_local_single);
}
extern "C" {
    pub fn __fprop_inc_single(p: *mut fprop_global, pl: *mut fprop_local_single);
}
extern "C" {
    pub fn fprop_fraction_single(
        p: *mut fprop_global,
        pl: *mut fprop_local_single,
        numerator: *mut core::ffi::c_ulong,
        denominator: *mut core::ffi::c_ulong,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fprop_local_percpu {
    pub events: percpu_counter,
    pub period: core::ffi::c_uint,
    pub lock: raw_spinlock_t,
}
impl Default for fprop_local_percpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn fprop_local_init_percpu(pl: *mut fprop_local_percpu, gfp: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn fprop_local_destroy_percpu(pl: *mut fprop_local_percpu);
}
extern "C" {
    pub fn __fprop_add_percpu(
        p: *mut fprop_global,
        pl: *mut fprop_local_percpu,
        nr: core::ffi::c_long,
    );
}
extern "C" {
    pub fn __fprop_add_percpu_max(
        p: *mut fprop_global,
        pl: *mut fprop_local_percpu,
        max_frac: core::ffi::c_int,
        nr: core::ffi::c_long,
    );
}
extern "C" {
    pub fn fprop_fraction_percpu(
        p: *mut fprop_global,
        pl: *mut fprop_local_percpu,
        numerator: *mut core::ffi::c_ulong,
        denominator: *mut core::ffi::c_ulong,
    );
}
pub const wb_state_WB_registered: wb_state = 0;
pub const wb_state_WB_writeback_running: wb_state = 1;
pub const wb_state_WB_has_dirty_io: wb_state = 2;
pub const wb_state_WB_start_all: wb_state = 3;
pub type wb_state = core::ffi::c_uint;
pub const wb_stat_item_WB_RECLAIMABLE: wb_stat_item = 0;
pub const wb_stat_item_WB_WRITEBACK: wb_stat_item = 1;
pub const wb_stat_item_WB_DIRTIED: wb_stat_item = 2;
pub const wb_stat_item_WB_WRITTEN: wb_stat_item = 3;
pub const wb_stat_item_NR_WB_STAT_ITEMS: wb_stat_item = 4;
pub type wb_stat_item = core::ffi::c_uint;
pub const wb_reason_WB_REASON_BACKGROUND: wb_reason = 0;
pub const wb_reason_WB_REASON_VMSCAN: wb_reason = 1;
pub const wb_reason_WB_REASON_SYNC: wb_reason = 2;
pub const wb_reason_WB_REASON_PERIODIC: wb_reason = 3;
pub const wb_reason_WB_REASON_LAPTOP_TIMER: wb_reason = 4;
pub const wb_reason_WB_REASON_FS_FREE_SPACE: wb_reason = 5;
pub const wb_reason_WB_REASON_FORKER_THREAD: wb_reason = 6;
pub const wb_reason_WB_REASON_FOREIGN_FLUSH: wb_reason = 7;
pub const wb_reason_WB_REASON_MAX: wb_reason = 8;
pub type wb_reason = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wb_completion {
    pub cnt: atomic_t,
    pub waitq: *mut wait_queue_head_t,
}
impl Default for wb_completion {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bdi_writeback {
    pub bdi: *mut backing_dev_info,
    pub state: core::ffi::c_ulong,
    pub last_old_flush: core::ffi::c_ulong,
    pub b_dirty: list_head,
    pub b_io: list_head,
    pub b_more_io: list_head,
    pub b_dirty_time: list_head,
    pub list_lock: spinlock_t,
    pub writeback_inodes: atomic_t,
    pub stat: [percpu_counter; 4usize],
    pub bw_time_stamp: core::ffi::c_ulong,
    pub dirtied_stamp: core::ffi::c_ulong,
    pub written_stamp: core::ffi::c_ulong,
    pub write_bandwidth: core::ffi::c_ulong,
    pub avg_write_bandwidth: core::ffi::c_ulong,
    pub dirty_ratelimit: core::ffi::c_ulong,
    pub balanced_dirty_ratelimit: core::ffi::c_ulong,
    pub completions: fprop_local_percpu,
    pub dirty_exceeded: core::ffi::c_int,
    pub start_all_reason: wb_reason,
    pub work_lock: spinlock_t,
    pub work_list: list_head,
    pub dwork: delayed_work,
    pub bw_dwork: delayed_work,
    pub dirty_sleep: core::ffi::c_ulong,
    pub bdi_node: list_head,
}
impl Default for bdi_writeback {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct backing_dev_info {
    pub id: u64_,
    pub rb_node: rb_node,
    pub bdi_list: list_head,
    pub ra_pages: core::ffi::c_ulong,
    pub io_pages: core::ffi::c_ulong,
    pub refcnt: kref,
    pub capabilities: core::ffi::c_uint,
    pub min_ratio: core::ffi::c_uint,
    pub max_ratio: core::ffi::c_uint,
    pub max_prop_frac: core::ffi::c_uint,
    pub tot_write_bandwidth: atomic_long_t,
    pub wb: bdi_writeback,
    pub wb_list: list_head,
    pub wb_waitq: wait_queue_head_t,
    pub dev: *mut device,
    pub dev_name: [core::ffi::c_char; 64usize],
    pub owner: *mut device,
    pub laptop_mode_wb_timer: timer_list,
    pub debug_dir: *mut dentry,
}
impl Default for backing_dev_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct wb_lock_cookie {
    pub locked: bool_,
    pub flags: core::ffi::c_ulong,
}
extern "C" {
    pub fn flush_icache_all();
}
extern "C" {
    pub fn flush_icache_mm(mm: *mut mm_struct, local: bool_);
}
extern "C" {
    pub static mut riscv_cbom_block_size: core::ffi::c_uint;
}
extern "C" {
    pub fn flush_dcache_folio(folio: *mut folio);
}
pub const dma_data_direction_DMA_BIDIRECTIONAL: dma_data_direction = 0;
pub const dma_data_direction_DMA_TO_DEVICE: dma_data_direction = 1;
pub const dma_data_direction_DMA_FROM_DEVICE: dma_data_direction = 2;
pub const dma_data_direction_DMA_NONE: dma_data_direction = 3;
pub type dma_data_direction = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct urb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_vec {
    pub bv_page: *mut page,
    pub bv_len: core::ffi::c_uint,
    pub bv_offset: core::ffi::c_uint,
}
impl Default for bio_vec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct bvec_iter {
    pub bi_sector: sector_t,
    pub bi_size: core::ffi::c_uint,
    pub bi_idx: core::ffi::c_uint,
    pub bi_bvec_done: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bvec_iter_all {
    pub bv: bio_vec,
    pub idx: core::ffi::c_int,
    pub done: core::ffi::c_uint,
}
impl Default for bvec_iter_all {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_set {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_integrity_payload {
    _unused: [u8; 0],
}
pub type bio_end_io_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut bio)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bio_crypt_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct block_device {
    pub bd_start_sect: sector_t,
    pub bd_nr_sectors: sector_t,
    pub bd_stats: *mut disk_stats,
    pub bd_stamp: core::ffi::c_ulong,
    pub bd_read_only: bool_,
    pub bd_dev: dev_t,
    pub bd_openers: atomic_t,
    pub bd_inode: *mut inode,
    pub bd_super: *mut super_block,
    pub bd_claiming: *mut core::ffi::c_void,
    pub bd_device: device,
    pub bd_holder: *mut core::ffi::c_void,
    pub bd_holders: core::ffi::c_int,
    pub bd_write_holder: bool_,
    pub bd_holder_dir: *mut kobject,
    pub bd_partno: u8_,
    pub bd_size_lock: spinlock_t,
    pub bd_disk: *mut gendisk,
    pub bd_queue: *mut request_queue,
    pub bd_fsfreeze_count: core::ffi::c_int,
    pub bd_fsfreeze_mutex: mutex,
    pub bd_fsfreeze_sb: *mut super_block,
    pub bd_meta_info: *mut partition_meta_info,
}
impl Default for block_device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type blk_status_t = u8_;
pub type blk_short_t = u16_;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bio_issue {
    pub value: u64_,
}
pub type blk_opf_t = __u32;
pub type blk_qc_t = core::ffi::c_uint;
#[repr(C)]
pub struct bio {
    pub bi_next: *mut bio,
    pub bi_bdev: *mut block_device,
    pub bi_opf: blk_opf_t,
    pub bi_flags: core::ffi::c_ushort,
    pub bi_ioprio: core::ffi::c_ushort,
    pub bi_status: blk_status_t,
    pub __bi_remaining: atomic_t,
    pub bi_iter: bvec_iter,
    pub bi_cookie: blk_qc_t,
    pub bi_end_io: bio_end_io_t,
    pub bi_private: *mut core::ffi::c_void,
    pub __bindgen_anon_1: bio__bindgen_ty_1,
    pub bi_vcnt: core::ffi::c_ushort,
    pub bi_max_vecs: core::ffi::c_ushort,
    pub __bi_cnt: atomic_t,
    pub bi_io_vec: *mut bio_vec,
    pub bi_pool: *mut bio_set,
    pub bi_inline_vecs: __IncompleteArrayField<bio_vec>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bio__bindgen_ty_1 {
    _bindgen_union_align: [u8; 0usize],
}
impl Default for bio__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bio {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const BIO_NO_PAGE_REF: core::ffi::c_uint = 0;
pub const BIO_CLONED: core::ffi::c_uint = 1;
pub const BIO_BOUNCED: core::ffi::c_uint = 2;
pub const BIO_QUIET: core::ffi::c_uint = 3;
pub const BIO_CHAIN: core::ffi::c_uint = 4;
pub const BIO_REFFED: core::ffi::c_uint = 5;
pub const BIO_BPS_THROTTLED: core::ffi::c_uint = 6;
pub const BIO_TRACE_COMPLETION: core::ffi::c_uint = 7;
pub const BIO_CGROUP_ACCT: core::ffi::c_uint = 8;
pub const BIO_QOS_THROTTLED: core::ffi::c_uint = 9;
pub const BIO_QOS_MERGED: core::ffi::c_uint = 10;
pub const BIO_REMAPPED: core::ffi::c_uint = 11;
pub const BIO_ZONE_WRITE_LOCKED: core::ffi::c_uint = 12;
pub const BIO_FLAG_LAST: core::ffi::c_uint = 13;
pub type _bindgen_ty_114 = core::ffi::c_uint;
pub type blk_mq_req_flags_t = __u32;
pub const req_op_REQ_OP_READ: req_op = 0;
pub const req_op_REQ_OP_WRITE: req_op = 1;
pub const req_op_REQ_OP_FLUSH: req_op = 2;
pub const req_op_REQ_OP_DISCARD: req_op = 3;
pub const req_op_REQ_OP_SECURE_ERASE: req_op = 5;
pub const req_op_REQ_OP_WRITE_ZEROES: req_op = 9;
pub const req_op_REQ_OP_ZONE_OPEN: req_op = 10;
pub const req_op_REQ_OP_ZONE_CLOSE: req_op = 11;
pub const req_op_REQ_OP_ZONE_FINISH: req_op = 12;
pub const req_op_REQ_OP_ZONE_APPEND: req_op = 13;
pub const req_op_REQ_OP_ZONE_RESET: req_op = 15;
pub const req_op_REQ_OP_ZONE_RESET_ALL: req_op = 17;
pub const req_op_REQ_OP_DRV_IN: req_op = 34;
pub const req_op_REQ_OP_DRV_OUT: req_op = 35;
pub const req_op_REQ_OP_LAST: req_op = 36;
pub type req_op = core::ffi::c_uint;
pub const req_flag_bits___REQ_FAILFAST_DEV: req_flag_bits = 8;
pub const req_flag_bits___REQ_FAILFAST_TRANSPORT: req_flag_bits = 9;
pub const req_flag_bits___REQ_FAILFAST_DRIVER: req_flag_bits = 10;
pub const req_flag_bits___REQ_SYNC: req_flag_bits = 11;
pub const req_flag_bits___REQ_META: req_flag_bits = 12;
pub const req_flag_bits___REQ_PRIO: req_flag_bits = 13;
pub const req_flag_bits___REQ_NOMERGE: req_flag_bits = 14;
pub const req_flag_bits___REQ_IDLE: req_flag_bits = 15;
pub const req_flag_bits___REQ_INTEGRITY: req_flag_bits = 16;
pub const req_flag_bits___REQ_FUA: req_flag_bits = 17;
pub const req_flag_bits___REQ_PREFLUSH: req_flag_bits = 18;
pub const req_flag_bits___REQ_RAHEAD: req_flag_bits = 19;
pub const req_flag_bits___REQ_BACKGROUND: req_flag_bits = 20;
pub const req_flag_bits___REQ_NOWAIT: req_flag_bits = 21;
pub const req_flag_bits___REQ_CGROUP_PUNT: req_flag_bits = 22;
pub const req_flag_bits___REQ_POLLED: req_flag_bits = 23;
pub const req_flag_bits___REQ_ALLOC_CACHE: req_flag_bits = 24;
pub const req_flag_bits___REQ_SWAP: req_flag_bits = 25;
pub const req_flag_bits___REQ_DRV: req_flag_bits = 26;
pub const req_flag_bits___REQ_NOUNMAP: req_flag_bits = 27;
pub const req_flag_bits___REQ_NR_BITS: req_flag_bits = 28;
pub type req_flag_bits = core::ffi::c_uint;
pub const stat_group_STAT_READ: stat_group = 0;
pub const stat_group_STAT_WRITE: stat_group = 1;
pub const stat_group_STAT_DISCARD: stat_group = 2;
pub const stat_group_STAT_FLUSH: stat_group = 3;
pub const stat_group_NR_STAT_GROUPS: stat_group = 4;
pub type stat_group = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct blk_rq_stat {
    pub mean: u64_,
    pub min: u64_,
    pub max: u64_,
    pub nr_samples: u32_,
    pub batch: u64_,
}
extern "C" {
    pub static mut dirty_throttle_leaks: core::ffi::c_int;
}
pub const writeback_sync_modes_WB_SYNC_NONE: writeback_sync_modes = 0;
pub const writeback_sync_modes_WB_SYNC_ALL: writeback_sync_modes = 1;
pub type writeback_sync_modes = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct writeback_control {
    pub nr_to_write: core::ffi::c_long,
    pub pages_skipped: core::ffi::c_long,
    pub range_start: loff_t,
    pub range_end: loff_t,
    pub sync_mode: writeback_sync_modes,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub swap_plug: *mut *mut swap_iocb,
}
impl Default for writeback_control {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl writeback_control {
    #[inline]
    pub fn for_kupdate(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_kupdate(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_background(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_background(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tagged_writepages(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tagged_writepages(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_reclaim(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_reclaim(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn range_cyclic(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_range_cyclic(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn for_sync(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_for_sync(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unpinned_fscache_wb(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_unpinned_fscache_wb(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_cgroup_owner(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_no_cgroup_owner(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn punt_to_cgroup(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_punt_to_cgroup(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        for_kupdate: core::ffi::c_uint,
        for_background: core::ffi::c_uint,
        tagged_writepages: core::ffi::c_uint,
        for_reclaim: core::ffi::c_uint,
        range_cyclic: core::ffi::c_uint,
        for_sync: core::ffi::c_uint,
        unpinned_fscache_wb: core::ffi::c_uint,
        no_cgroup_owner: core::ffi::c_uint,
        punt_to_cgroup: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let for_kupdate: u32 = unsafe { ::core::mem::transmute(for_kupdate) };
            for_kupdate as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let for_background: u32 = unsafe { ::core::mem::transmute(for_background) };
            for_background as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tagged_writepages: u32 = unsafe { ::core::mem::transmute(tagged_writepages) };
            tagged_writepages as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let for_reclaim: u32 = unsafe { ::core::mem::transmute(for_reclaim) };
            for_reclaim as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let range_cyclic: u32 = unsafe { ::core::mem::transmute(range_cyclic) };
            range_cyclic as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let for_sync: u32 = unsafe { ::core::mem::transmute(for_sync) };
            for_sync as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let unpinned_fscache_wb: u32 = unsafe { ::core::mem::transmute(unpinned_fscache_wb) };
            unpinned_fscache_wb as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let no_cgroup_owner: u32 = unsafe { ::core::mem::transmute(no_cgroup_owner) };
            no_cgroup_owner as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let punt_to_cgroup: u32 = unsafe { ::core::mem::transmute(punt_to_cgroup) };
            punt_to_cgroup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wb_domain {
    pub lock: spinlock_t,
    pub completions: fprop_global,
    pub period_timer: timer_list,
    pub period_time: core::ffi::c_ulong,
    pub dirty_limit_tstamp: core::ffi::c_ulong,
    pub dirty_limit: core::ffi::c_ulong,
}
impl Default for wb_domain {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn writeback_inodes_sb(arg1: *mut super_block, reason: wb_reason);
}
extern "C" {
    pub fn writeback_inodes_sb_nr(
        arg1: *mut super_block,
        nr: core::ffi::c_ulong,
        reason: wb_reason,
    );
}
extern "C" {
    pub fn try_to_writeback_inodes_sb(sb: *mut super_block, reason: wb_reason);
}
extern "C" {
    pub fn sync_inodes_sb(arg1: *mut super_block);
}
extern "C" {
    pub fn wakeup_flusher_threads(reason: wb_reason);
}
extern "C" {
    pub fn wakeup_flusher_threads_bdi(bdi: *mut backing_dev_info, reason: wb_reason);
}
extern "C" {
    pub fn inode_wait_for_writeback(inode: *mut inode);
}
extern "C" {
    pub fn inode_io_list_del(inode: *mut inode);
}
extern "C" {
    pub fn laptop_io_completion(info: *mut backing_dev_info);
}
extern "C" {
    pub fn laptop_sync_completion();
}
extern "C" {
    pub fn laptop_mode_timer_fn(t: *mut timer_list);
}
extern "C" {
    pub fn node_dirty_ok(pgdat: *mut pglist_data) -> bool_;
}
extern "C" {
    pub fn wb_domain_init(dom: *mut wb_domain, gfp: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub static mut global_wb_domain: wb_domain;
}
extern "C" {
    pub static mut dirty_writeback_interval: core::ffi::c_uint;
}
extern "C" {
    pub static mut dirty_expire_interval: core::ffi::c_uint;
}
extern "C" {
    pub static mut dirtytime_expire_interval: core::ffi::c_uint;
}
extern "C" {
    pub static mut laptop_mode: core::ffi::c_int;
}
extern "C" {
    pub fn dirtytime_interval_handler(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn global_dirty_limits(
        pbackground: *mut core::ffi::c_ulong,
        pdirty: *mut core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn wb_calc_thresh(wb: *mut bdi_writeback, thresh: core::ffi::c_ulong)
        -> core::ffi::c_ulong;
}
extern "C" {
    pub fn wb_update_bandwidth(wb: *mut bdi_writeback);
}
extern "C" {
    pub fn balance_dirty_pages_ratelimited(mapping: *mut address_space);
}
extern "C" {
    pub fn balance_dirty_pages_ratelimited_flags(
        mapping: *mut address_space,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn wb_over_bg_thresh(wb: *mut bdi_writeback) -> bool_;
}
pub type writepage_t = ::core::option::Option<
    unsafe extern "C" fn(
        page: *mut page,
        wbc: *mut writeback_control,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn generic_writepages(
        mapping: *mut address_space,
        wbc: *mut writeback_control,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tag_pages_for_writeback(
        mapping: *mut address_space,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn write_cache_pages(
        mapping: *mut address_space,
        wbc: *mut writeback_control,
        writepage: writepage_t,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_writepages(
        mapping: *mut address_space,
        wbc: *mut writeback_control,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn writeback_set_ratelimit();
}
extern "C" {
    pub fn filemap_dirty_folio(mapping: *mut address_space, folio: *mut folio) -> bool_;
}
extern "C" {
    pub fn folio_account_redirty(folio: *mut folio);
}
extern "C" {
    pub fn folio_redirty_for_writepage(arg1: *mut writeback_control, arg2: *mut folio) -> bool_;
}
extern "C" {
    pub fn redirty_page_for_writepage(arg1: *mut writeback_control, arg2: *mut page) -> bool_;
}
extern "C" {
    pub fn sb_mark_inode_writeback(inode: *mut inode);
}
extern "C" {
    pub fn sb_clear_inode_writeback(inode: *mut inode);
}
pub const memcg_stat_item_MEMCG_SWAP: memcg_stat_item = 41;
pub const memcg_stat_item_MEMCG_SOCK: memcg_stat_item = 42;
pub const memcg_stat_item_MEMCG_PERCPU_B: memcg_stat_item = 43;
pub const memcg_stat_item_MEMCG_VMALLOC: memcg_stat_item = 44;
pub const memcg_stat_item_MEMCG_KMEM: memcg_stat_item = 45;
pub const memcg_stat_item_MEMCG_ZSWAP_B: memcg_stat_item = 46;
pub const memcg_stat_item_MEMCG_ZSWAPPED: memcg_stat_item = 47;
pub const memcg_stat_item_MEMCG_NR_STAT: memcg_stat_item = 48;
pub type memcg_stat_item = core::ffi::c_uint;
pub const memcg_memory_event_MEMCG_LOW: memcg_memory_event = 0;
pub const memcg_memory_event_MEMCG_HIGH: memcg_memory_event = 1;
pub const memcg_memory_event_MEMCG_MAX: memcg_memory_event = 2;
pub const memcg_memory_event_MEMCG_OOM: memcg_memory_event = 3;
pub const memcg_memory_event_MEMCG_OOM_KILL: memcg_memory_event = 4;
pub const memcg_memory_event_MEMCG_OOM_GROUP_KILL: memcg_memory_event = 5;
pub const memcg_memory_event_MEMCG_SWAP_HIGH: memcg_memory_event = 6;
pub const memcg_memory_event_MEMCG_SWAP_MAX: memcg_memory_event = 7;
pub const memcg_memory_event_MEMCG_SWAP_FAIL: memcg_memory_event = 8;
pub const memcg_memory_event_MEMCG_NR_MEMORY_EVENTS: memcg_memory_event = 9;
pub type memcg_memory_event = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup_reclaim_cookie {
    pub pgdat: *mut pg_data_t,
    pub generation: core::ffi::c_uint,
}
impl Default for mem_cgroup_reclaim_cookie {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mem_cgroup_id {
    pub id: core::ffi::c_int,
    pub ref_: refcount_t,
}
pub const mem_cgroup_events_target_MEM_CGROUP_TARGET_THRESH: mem_cgroup_events_target = 0;
pub const mem_cgroup_events_target_MEM_CGROUP_TARGET_SOFTLIMIT: mem_cgroup_events_target = 1;
pub const mem_cgroup_events_target_MEM_CGROUP_NTARGETS: mem_cgroup_events_target = 2;
pub type mem_cgroup_events_target = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg_vmstats_percpu {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg_vmstats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup_reclaim_iter {
    pub position: *mut mem_cgroup,
    pub generation: core::ffi::c_uint,
}
impl Default for mem_cgroup_reclaim_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shrinker_info {
    pub rcu: callback_head,
    pub nr_deferred: *mut atomic_long_t,
    pub map: *mut core::ffi::c_ulong,
}
impl Default for shrinker_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec_stats_percpu {
    pub state: [core::ffi::c_long; 41usize],
    pub state_prev: [core::ffi::c_long; 41usize],
}
impl Default for lruvec_stats_percpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lruvec_stats {
    pub state: [core::ffi::c_long; 41usize],
    pub state_pending: [core::ffi::c_long; 41usize],
}
impl Default for lruvec_stats {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup_per_node {
    pub lruvec: lruvec,
    pub lruvec_stats_percpu: *mut lruvec_stats_percpu,
    pub lruvec_stats: lruvec_stats,
    pub lru_zone_size: [[core::ffi::c_ulong; 5usize]; 3usize],
    pub iter: mem_cgroup_reclaim_iter,
    pub shrinker_info: *mut shrinker_info,
    pub tree_node: rb_node,
    pub usage_in_excess: core::ffi::c_ulong,
    pub on_tree: bool_,
    pub memcg: *mut mem_cgroup,
}
impl Default for mem_cgroup_per_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup_threshold {
    pub eventfd: *mut eventfd_ctx,
    pub threshold: core::ffi::c_ulong,
}
impl Default for mem_cgroup_threshold {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct mem_cgroup_threshold_ary {
    pub current_threshold: core::ffi::c_int,
    pub size: core::ffi::c_uint,
    pub entries: __IncompleteArrayField<mem_cgroup_threshold>,
}
impl Default for mem_cgroup_threshold_ary {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mem_cgroup_thresholds {
    pub primary: *mut mem_cgroup_threshold_ary,
    pub spare: *mut mem_cgroup_threshold_ary,
}
impl Default for mem_cgroup_thresholds {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memcg_cgwb_frn {
    pub bdi_id: u64_,
    pub memcg_id: core::ffi::c_int,
    pub at: u64_,
    pub done: wb_completion,
}
impl Default for memcg_cgwb_frn {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct obj_cgroup {
    pub refcnt: percpu_ref,
    pub memcg: *mut mem_cgroup,
    pub nr_charged_bytes: atomic_t,
    pub __bindgen_anon_1: obj_cgroup__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union obj_cgroup__bindgen_ty_1 {
    pub list: list_head,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for obj_cgroup__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for obj_cgroup {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct mem_cgroup {
    pub css: cgroup_subsys_state,
    pub id: mem_cgroup_id,
    pub __bindgen_padding_0: [u64; 6usize],
    pub memory: page_counter,
    pub __bindgen_anon_1: mem_cgroup__bindgen_ty_1,
    pub kmem: page_counter,
    pub tcpmem: page_counter,
    pub high_work: work_struct,
    pub soft_limit: core::ffi::c_ulong,
    pub vmpressure: vmpressure,
    pub oom_group: bool_,
    pub oom_lock: bool_,
    pub under_oom: core::ffi::c_int,
    pub swappiness: core::ffi::c_int,
    pub oom_kill_disable: core::ffi::c_int,
    pub events_file: cgroup_file,
    pub events_local_file: cgroup_file,
    pub swap_events_file: cgroup_file,
    pub thresholds_lock: mutex,
    pub thresholds: mem_cgroup_thresholds,
    pub memsw_thresholds: mem_cgroup_thresholds,
    pub oom_notify: list_head,
    pub move_charge_at_immigrate: core::ffi::c_ulong,
    pub move_lock: spinlock_t,
    pub move_lock_flags: core::ffi::c_ulong,
    pub __bindgen_padding_1: [u64; 4usize],
    pub _pad1_: cacheline_padding,
    pub vmstats: *mut memcg_vmstats,
    pub memory_events: [atomic_long_t; 9usize],
    pub memory_events_local: [atomic_long_t; 9usize],
    pub socket_pressure: core::ffi::c_ulong,
    pub tcpmem_active: bool_,
    pub tcpmem_pressure: core::ffi::c_int,
    pub kmemcg_id: core::ffi::c_int,
    pub objcg: *mut obj_cgroup,
    pub objcg_list: list_head,
    pub __bindgen_padding_2: [u64; 7usize],
    pub _pad2_: cacheline_padding,
    pub moving_account: atomic_t,
    pub move_lock_task: *mut task_struct,
    pub vmstats_percpu: *mut memcg_vmstats_percpu,
    pub event_list: list_head,
    pub event_list_lock: spinlock_t,
    pub nodeinfo: __IncompleteArrayField<*mut mem_cgroup_per_node>,
}
#[repr(C)]
#[repr(align(64))]
pub struct mem_cgroup__bindgen_ty_1 {
    pub swap: __BindgenUnionField<page_counter>,
    pub memsw: __BindgenUnionField<page_counter>,
    pub bindgen_union_field: [u8; 192usize],
}
impl Default for mem_cgroup__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for mem_cgroup {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut root_mem_cgroup: *mut mem_cgroup;
}
pub const page_memcg_data_flags_MEMCG_DATA_OBJCGS: page_memcg_data_flags = 1;
pub const page_memcg_data_flags_MEMCG_DATA_KMEM: page_memcg_data_flags = 2;
pub const page_memcg_data_flags___NR_MEMCG_DATA_FLAGS: page_memcg_data_flags = 4;
pub type page_memcg_data_flags = core::ffi::c_uint;
extern "C" {
    pub fn mem_cgroup_calculate_protection(root: *mut mem_cgroup, memcg: *mut mem_cgroup);
}
extern "C" {
    pub fn __mem_cgroup_charge(
        folio: *mut folio,
        mm: *mut mm_struct,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mem_cgroup_swapin_charge_folio(
        folio: *mut folio,
        mm: *mut mm_struct,
        gfp: gfp_t,
        entry: swp_entry_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mem_cgroup_swapin_uncharge_swap(entry: swp_entry_t);
}
extern "C" {
    pub fn __mem_cgroup_uncharge(folio: *mut folio);
}
extern "C" {
    pub fn __mem_cgroup_uncharge_list(page_list: *mut list_head);
}
extern "C" {
    pub fn mem_cgroup_migrate(old: *mut folio, new: *mut folio);
}
extern "C" {
    pub fn mem_cgroup_from_task(p: *mut task_struct) -> *mut mem_cgroup;
}
extern "C" {
    pub fn get_mem_cgroup_from_mm(mm: *mut mm_struct) -> *mut mem_cgroup;
}
extern "C" {
    pub fn folio_lruvec_lock(folio: *mut folio) -> *mut lruvec;
}
extern "C" {
    pub fn folio_lruvec_lock_irq(folio: *mut folio) -> *mut lruvec;
}
extern "C" {
    pub fn folio_lruvec_lock_irqsave(
        folio: *mut folio,
        flags: *mut core::ffi::c_ulong,
    ) -> *mut lruvec;
}
extern "C" {
    pub fn lruvec_memcg_debug(lruvec: *mut lruvec, folio: *mut folio);
}
extern "C" {
    pub fn mem_cgroup_iter(
        arg1: *mut mem_cgroup,
        arg2: *mut mem_cgroup,
        arg3: *mut mem_cgroup_reclaim_cookie,
    ) -> *mut mem_cgroup;
}
extern "C" {
    pub fn mem_cgroup_iter_break(arg1: *mut mem_cgroup, arg2: *mut mem_cgroup);
}
extern "C" {
    pub fn mem_cgroup_scan_tasks(
        arg1: *mut mem_cgroup,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut task_struct,
                arg2: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg3: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mem_cgroup_from_id(id: core::ffi::c_ushort) -> *mut mem_cgroup;
}
extern "C" {
    pub fn mem_cgroup_css_from_page(page: *mut page) -> *mut cgroup_subsys_state;
}
extern "C" {
    pub fn page_cgroup_ino(page: *mut page) -> ino_t;
}
extern "C" {
    pub fn mem_cgroup_update_lru_size(
        lruvec: *mut lruvec,
        lru: lru_list,
        zid: core::ffi::c_int,
        nr_pages: core::ffi::c_int,
    );
}
extern "C" {
    pub fn mem_cgroup_handle_over_high();
}
extern "C" {
    pub fn mem_cgroup_get_max(memcg: *mut mem_cgroup) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn mem_cgroup_size(memcg: *mut mem_cgroup) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn mem_cgroup_print_oom_context(memcg: *mut mem_cgroup, p: *mut task_struct);
}
extern "C" {
    pub fn mem_cgroup_print_oom_meminfo(memcg: *mut mem_cgroup);
}
extern "C" {
    pub fn mem_cgroup_oom_synchronize(wait: bool_) -> bool_;
}
extern "C" {
    pub fn mem_cgroup_get_oom_group(
        victim: *mut task_struct,
        oom_domain: *mut mem_cgroup,
    ) -> *mut mem_cgroup;
}
extern "C" {
    pub fn mem_cgroup_print_oom_group(memcg: *mut mem_cgroup);
}
extern "C" {
    pub fn folio_memcg_lock(folio: *mut folio);
}
extern "C" {
    pub fn folio_memcg_unlock(folio: *mut folio);
}
extern "C" {
    pub fn lock_page_memcg(page: *mut page);
}
extern "C" {
    pub fn unlock_page_memcg(page: *mut page);
}
extern "C" {
    pub fn __mod_memcg_state(memcg: *mut mem_cgroup, idx: core::ffi::c_int, val: core::ffi::c_int);
}
extern "C" {
    pub fn memcg_page_state(memcg: *mut mem_cgroup, idx: core::ffi::c_int) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn mem_cgroup_flush_stats();
}
extern "C" {
    pub fn mem_cgroup_flush_stats_delayed();
}
extern "C" {
    pub fn __mod_memcg_lruvec_state(
        lruvec: *mut lruvec,
        idx: node_stat_item,
        val: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __mod_lruvec_kmem_state(
        p: *mut core::ffi::c_void,
        idx: node_stat_item,
        val: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __count_memcg_events(
        memcg: *mut mem_cgroup,
        idx: vm_event_item,
        count: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn split_page_memcg(head: *mut page, nr: core::ffi::c_uint);
}
extern "C" {
    pub fn mem_cgroup_soft_limit_reclaim(
        pgdat: *mut pg_data_t,
        order: core::ffi::c_int,
        gfp_mask: gfp_t,
        total_scanned: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn mem_cgroup_charge_skmem(
        memcg: *mut mem_cgroup,
        nr_pages: core::ffi::c_uint,
        gfp_mask: gfp_t,
    ) -> bool_;
}
extern "C" {
    pub fn mem_cgroup_uncharge_skmem(memcg: *mut mem_cgroup, nr_pages: core::ffi::c_uint);
}
extern "C" {
    pub static mut memcg_sockets_enabled_key: static_key_false;
}
extern "C" {
    pub fn mem_cgroup_sk_alloc(sk: *mut sock);
}
extern "C" {
    pub fn mem_cgroup_sk_free(sk: *mut sock);
}
extern "C" {
    pub fn alloc_shrinker_info(memcg: *mut mem_cgroup) -> core::ffi::c_int;
}
extern "C" {
    pub fn free_shrinker_info(memcg: *mut mem_cgroup);
}
extern "C" {
    pub fn set_shrinker_bit(
        memcg: *mut mem_cgroup,
        nid: core::ffi::c_int,
        shrinker_id: core::ffi::c_int,
    );
}
extern "C" {
    pub fn reparent_shrinker_deferred(memcg: *mut mem_cgroup);
}
extern "C" {
    pub fn mem_cgroup_kmem_disabled() -> bool_;
}
extern "C" {
    pub fn __memcg_kmem_charge_page(
        page: *mut page,
        gfp: gfp_t,
        order: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __memcg_kmem_uncharge_page(page: *mut page, order: core::ffi::c_int);
}
extern "C" {
    pub fn get_obj_cgroup_from_current() -> *mut obj_cgroup;
}
extern "C" {
    pub fn get_obj_cgroup_from_page(page: *mut page) -> *mut obj_cgroup;
}
extern "C" {
    pub fn obj_cgroup_charge(objcg: *mut obj_cgroup, gfp: gfp_t, size: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn obj_cgroup_uncharge(objcg: *mut obj_cgroup, size: usize);
}
extern "C" {
    pub static mut memcg_kmem_enabled_key: static_key_false;
}
extern "C" {
    pub fn mem_cgroup_from_obj(p: *mut core::ffi::c_void) -> *mut mem_cgroup;
}
extern "C" {
    pub fn mem_cgroup_from_slab_obj(p: *mut core::ffi::c_void) -> *mut mem_cgroup;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct node_hmem_attrs {
    pub read_bandwidth: core::ffi::c_uint,
    pub write_bandwidth: core::ffi::c_uint,
    pub read_latency: core::ffi::c_uint,
    pub write_latency: core::ffi::c_uint,
}
pub const cache_indexing_NODE_CACHE_DIRECT_MAP: cache_indexing = 0;
pub const cache_indexing_NODE_CACHE_INDEXED: cache_indexing = 1;
pub const cache_indexing_NODE_CACHE_OTHER: cache_indexing = 2;
pub type cache_indexing = core::ffi::c_uint;
pub const cache_write_policy_NODE_CACHE_WRITE_BACK: cache_write_policy = 0;
pub const cache_write_policy_NODE_CACHE_WRITE_THROUGH: cache_write_policy = 1;
pub const cache_write_policy_NODE_CACHE_WRITE_OTHER: cache_write_policy = 2;
pub type cache_write_policy = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct node_cache_attrs {
    pub indexing: cache_indexing,
    pub write_policy: cache_write_policy,
    pub size: u64_,
    pub line_size: u16_,
    pub level: u8_,
}
impl Default for node_cache_attrs {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct node {
    pub dev: device,
    pub access_list: list_head,
}
impl Default for node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct memory_block {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut node_devices: [*mut node; 0usize];
}
extern "C" {
    pub fn unregister_node(node: *mut node);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct folio_batch {
    _unused: [u8; 0],
}
extern "C" {
    pub fn invalidate_mapping_pages(
        mapping: *mut address_space,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn invalidate_inode_pages2(mapping: *mut address_space) -> core::ffi::c_int;
}
extern "C" {
    pub fn invalidate_inode_pages2_range(
        mapping: *mut address_space,
        start: core::ffi::c_ulong,
        end: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn write_inode_now(arg1: *mut inode, sync: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_fdatawrite(arg1: *mut address_space) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_flush(arg1: *mut address_space) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_fdatawait_keep_errors(mapping: *mut address_space) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_fdatawait_range(
        arg1: *mut address_space,
        lstart: loff_t,
        lend: loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_fdatawait_range_keep_errors(
        mapping: *mut address_space,
        start_byte: loff_t,
        end_byte: loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_range_has_page(arg1: *mut address_space, lstart: loff_t, lend: loff_t) -> bool_;
}
extern "C" {
    pub fn filemap_write_and_wait_range(
        mapping: *mut address_space,
        lstart: loff_t,
        lend: loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __filemap_fdatawrite_range(
        mapping: *mut address_space,
        start: loff_t,
        end: loff_t,
        sync_mode: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_fdatawrite_range(
        mapping: *mut address_space,
        start: loff_t,
        end: loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_check_errors(mapping: *mut address_space) -> core::ffi::c_int;
}
extern "C" {
    pub fn __filemap_set_wb_err(mapping: *mut address_space, err: core::ffi::c_int);
}
extern "C" {
    pub fn filemap_fdatawrite_wbc(
        mapping: *mut address_space,
        wbc: *mut writeback_control,
    ) -> core::ffi::c_int;
}
pub const mapping_flags_AS_EIO: mapping_flags = 0;
pub const mapping_flags_AS_ENOSPC: mapping_flags = 1;
pub const mapping_flags_AS_MM_ALL_LOCKS: mapping_flags = 2;
pub const mapping_flags_AS_UNEVICTABLE: mapping_flags = 3;
pub const mapping_flags_AS_EXITING: mapping_flags = 4;
pub const mapping_flags_AS_NO_WRITEBACK_TAGS: mapping_flags = 5;
pub const mapping_flags_AS_LARGE_FOLIO_SUPPORT: mapping_flags = 6;
pub type mapping_flags = core::ffi::c_uint;
extern "C" {
    pub fn page_mapping(arg1: *mut page) -> *mut address_space;
}
extern "C" {
    pub fn folio_mapping(arg1: *mut folio) -> *mut address_space;
}
extern "C" {
    pub fn swapcache_mapping(arg1: *mut folio) -> *mut address_space;
}
pub type filler_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut file, arg2: *mut folio) -> core::ffi::c_int,
>;
extern "C" {
    pub fn page_cache_next_miss(
        mapping: *mut address_space,
        index: core::ffi::c_ulong,
        max_scan: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn page_cache_prev_miss(
        mapping: *mut address_space,
        index: core::ffi::c_ulong,
        max_scan: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __filemap_get_folio(
        mapping: *mut address_space,
        index: core::ffi::c_ulong,
        fgp_flags: core::ffi::c_int,
        gfp: gfp_t,
    ) -> *mut folio;
}
extern "C" {
    pub fn pagecache_get_page(
        mapping: *mut address_space,
        index: core::ffi::c_ulong,
        fgp_flags: core::ffi::c_int,
        gfp: gfp_t,
    ) -> *mut page;
}
extern "C" {
    pub fn filemap_get_folios(
        mapping: *mut address_space,
        start: *mut core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        fbatch: *mut folio_batch,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn filemap_get_folios_contig(
        mapping: *mut address_space,
        start: *mut core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        fbatch: *mut folio_batch,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn find_get_pages_range_tag(
        mapping: *mut address_space,
        index: *mut core::ffi::c_ulong,
        end: core::ffi::c_ulong,
        tag: xa_mark_t,
        nr_pages: core::ffi::c_uint,
        pages: *mut *mut page,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn grab_cache_page_write_begin(
        mapping: *mut address_space,
        index: core::ffi::c_ulong,
    ) -> *mut page;
}
extern "C" {
    pub fn read_cache_folio(
        arg1: *mut address_space,
        index: core::ffi::c_ulong,
        filler: filler_t,
        file: *mut file,
    ) -> *mut folio;
}
extern "C" {
    pub fn read_cache_page(
        arg1: *mut address_space,
        index: core::ffi::c_ulong,
        filler: filler_t,
        file: *mut file,
    ) -> *mut page;
}
extern "C" {
    pub fn read_cache_page_gfp(
        mapping: *mut address_space,
        index: core::ffi::c_ulong,
        gfp_mask: gfp_t,
    ) -> *mut page;
}
extern "C" {
    pub fn hugetlb_basepage_index(page: *mut page) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn linear_hugepage_index(
        vma: *mut vm_area_struct,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_page_key {
    pub folio: *mut folio,
    pub bit_nr: core::ffi::c_int,
    pub page_match: core::ffi::c_int,
}
impl Default for wait_page_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wait_page_queue {
    pub folio: *mut folio,
    pub bit_nr: core::ffi::c_int,
    pub wait: wait_queue_entry_t,
}
impl Default for wait_page_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __folio_lock(folio: *mut folio);
}
extern "C" {
    pub fn __folio_lock_killable(folio: *mut folio) -> core::ffi::c_int;
}
extern "C" {
    pub fn __folio_lock_or_retry(
        folio: *mut folio,
        mm: *mut mm_struct,
        flags: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn unlock_page(page: *mut page);
}
extern "C" {
    pub fn folio_unlock(folio: *mut folio);
}
extern "C" {
    pub fn folio_wait_bit(folio: *mut folio, bit_nr: core::ffi::c_int);
}
extern "C" {
    pub fn folio_wait_bit_killable(folio: *mut folio, bit_nr: core::ffi::c_int)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn wait_on_page_writeback(page: *mut page);
}
extern "C" {
    pub fn folio_wait_writeback(folio: *mut folio);
}
extern "C" {
    pub fn folio_wait_writeback_killable(folio: *mut folio) -> core::ffi::c_int;
}
extern "C" {
    pub fn end_page_writeback(page: *mut page);
}
extern "C" {
    pub fn folio_end_writeback(folio: *mut folio);
}
extern "C" {
    pub fn wait_for_stable_page(page: *mut page);
}
extern "C" {
    pub fn folio_wait_stable(folio: *mut folio);
}
extern "C" {
    pub fn __folio_mark_dirty(folio: *mut folio, arg1: *mut address_space, warn: core::ffi::c_int);
}
extern "C" {
    pub fn folio_account_cleaned(folio: *mut folio, wb: *mut bdi_writeback);
}
extern "C" {
    pub fn __folio_cancel_dirty(folio: *mut folio);
}
extern "C" {
    pub fn folio_clear_dirty_for_io(folio: *mut folio) -> bool_;
}
extern "C" {
    pub fn clear_page_dirty_for_io(page: *mut page) -> bool_;
}
extern "C" {
    pub fn folio_invalidate(folio: *mut folio, offset: usize, length: usize);
}
extern "C" {
    pub fn folio_write_one(folio: *mut folio) -> core::ffi::c_int;
}
extern "C" {
    pub fn __set_page_dirty_nobuffers(page: *mut page) -> core::ffi::c_int;
}
extern "C" {
    pub fn noop_dirty_folio(mapping: *mut address_space, folio: *mut folio) -> bool_;
}
extern "C" {
    pub fn filemap_migrate_folio(
        mapping: *mut address_space,
        dst: *mut folio,
        src: *mut folio,
        mode: migrate_mode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn page_endio(page: *mut page, is_write: bool_, err: core::ffi::c_int);
}
extern "C" {
    pub fn folio_end_private_2(folio: *mut folio);
}
extern "C" {
    pub fn folio_wait_private_2(folio: *mut folio);
}
extern "C" {
    pub fn folio_wait_private_2_killable(folio: *mut folio) -> core::ffi::c_int;
}
extern "C" {
    pub fn folio_add_wait_queue(folio: *mut folio, waiter: *mut wait_queue_entry_t);
}
extern "C" {
    pub fn fault_in_writeable(uaddr: *mut core::ffi::c_char, size: usize) -> usize;
}
extern "C" {
    pub fn fault_in_subpage_writeable(uaddr: *mut core::ffi::c_char, size: usize) -> usize;
}
extern "C" {
    pub fn fault_in_safe_writeable(uaddr: *const core::ffi::c_char, size: usize) -> usize;
}
extern "C" {
    pub fn fault_in_readable(uaddr: *const core::ffi::c_char, size: usize) -> usize;
}
extern "C" {
    pub fn add_to_page_cache_lru(
        page: *mut page,
        mapping: *mut address_space,
        index: core::ffi::c_ulong,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_add_folio(
        mapping: *mut address_space,
        folio: *mut folio,
        index: core::ffi::c_ulong,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_remove_folio(folio: *mut folio);
}
extern "C" {
    pub fn delete_from_page_cache(page: *mut page);
}
extern "C" {
    pub fn __filemap_remove_folio(folio: *mut folio, shadow: *mut core::ffi::c_void);
}
extern "C" {
    pub fn replace_page_cache_page(old: *mut page, new: *mut page);
}
extern "C" {
    pub fn delete_from_page_cache_batch(mapping: *mut address_space, fbatch: *mut folio_batch);
}
extern "C" {
    pub fn try_to_release_page(page: *mut page, gfp: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_release_folio(folio: *mut folio, gfp: gfp_t) -> bool_;
}
extern "C" {
    pub fn mapping_seek_hole_data(
        arg1: *mut address_space,
        start: loff_t,
        end: loff_t,
        whence: core::ffi::c_int,
    ) -> loff_t;
}
extern "C" {
    pub fn __filemap_add_folio(
        mapping: *mut address_space,
        folio: *mut folio,
        index: core::ffi::c_ulong,
        gfp: gfp_t,
        shadowp: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn filemap_range_has_writeback(
        mapping: *mut address_space,
        start_byte: loff_t,
        end_byte: loff_t,
    ) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct readahead_control {
    pub file: *mut file,
    pub mapping: *mut address_space,
    pub ra: *mut file_ra_state,
    pub _index: core::ffi::c_ulong,
    pub _nr_pages: core::ffi::c_uint,
    pub _batch_count: core::ffi::c_uint,
    pub _workingset: bool_,
    pub _pflags: core::ffi::c_ulong,
}
impl Default for readahead_control {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn page_cache_ra_unbounded(
        arg1: *mut readahead_control,
        nr_to_read: core::ffi::c_ulong,
        lookahead_count: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn page_cache_sync_ra(arg1: *mut readahead_control, req_count: core::ffi::c_ulong);
}
extern "C" {
    pub fn page_cache_async_ra(
        arg1: *mut readahead_control,
        arg2: *mut folio,
        req_count: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn readahead_expand(ractl: *mut readahead_control, new_start: loff_t, new_len: usize);
}
pub const MPOL_DEFAULT: core::ffi::c_uint = 0;
pub const MPOL_PREFERRED: core::ffi::c_uint = 1;
pub const MPOL_BIND: core::ffi::c_uint = 2;
pub const MPOL_INTERLEAVE: core::ffi::c_uint = 3;
pub const MPOL_LOCAL: core::ffi::c_uint = 4;
pub const MPOL_PREFERRED_MANY: core::ffi::c_uint = 5;
pub const MPOL_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_115 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pagevec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union swap_header {
    pub magic: swap_header__bindgen_ty_1,
    pub info: swap_header__bindgen_ty_2,
    _bindgen_union_align: [u32; 1024usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_header__bindgen_ty_1 {
    pub reserved: [core::ffi::c_char; 4086usize],
    pub magic: [core::ffi::c_char; 10usize],
}
impl Default for swap_header__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_header__bindgen_ty_2 {
    pub bootbits: [core::ffi::c_char; 1024usize],
    pub version: __u32,
    pub last_page: __u32,
    pub nr_badpages: __u32,
    pub sws_uuid: [core::ffi::c_uchar; 16usize],
    pub sws_volume: [core::ffi::c_uchar; 16usize],
    pub padding: [__u32; 117usize],
    pub badpages: [__u32; 1usize],
}
impl Default for swap_header__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for swap_header {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct reclaim_state {
    pub reclaimed_slab: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct swap_extent {
    pub rb_node: rb_node,
    pub start_page: core::ffi::c_ulong,
    pub nr_pages: core::ffi::c_ulong,
    pub start_block: sector_t,
}
impl Default for swap_extent {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const SWP_USED: core::ffi::c_uint = 1;
pub const SWP_WRITEOK: core::ffi::c_uint = 2;
pub const SWP_DISCARDABLE: core::ffi::c_uint = 4;
pub const SWP_DISCARDING: core::ffi::c_uint = 8;
pub const SWP_SOLIDSTATE: core::ffi::c_uint = 16;
pub const SWP_CONTINUED: core::ffi::c_uint = 32;
pub const SWP_BLKDEV: core::ffi::c_uint = 64;
pub const SWP_ACTIVATED: core::ffi::c_uint = 128;
pub const SWP_FS_OPS: core::ffi::c_uint = 256;
pub const SWP_AREA_DISCARD: core::ffi::c_uint = 512;
pub const SWP_PAGE_DISCARD: core::ffi::c_uint = 1024;
pub const SWP_STABLE_WRITES: core::ffi::c_uint = 2048;
pub const SWP_SYNCHRONOUS_IO: core::ffi::c_uint = 4096;
pub const SWP_SCANNING: core::ffi::c_uint = 16384;
pub type _bindgen_ty_116 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct swap_cluster_info {
    pub lock: spinlock_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_padding_0: u32,
}
impl swap_cluster_info {
    #[inline]
    pub fn data(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_data(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn flags(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        data: core::ffi::c_uint,
        flags: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let data: u32 = unsafe { ::core::mem::transmute(data) };
            data as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let flags: u32 = unsafe { ::core::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct percpu_cluster {
    pub index: swap_cluster_info,
    pub next: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct swap_cluster_list {
    pub head: swap_cluster_info,
    pub tail: swap_cluster_info,
}
#[repr(C)]
pub struct swap_info_struct {
    pub users: percpu_ref,
    pub flags: core::ffi::c_ulong,
    pub prio: core::ffi::c_short,
    pub list: plist_node,
    pub type_: core::ffi::c_schar,
    pub max: core::ffi::c_uint,
    pub swap_map: *mut core::ffi::c_uchar,
    pub cluster_info: *mut swap_cluster_info,
    pub free_clusters: swap_cluster_list,
    pub lowest_bit: core::ffi::c_uint,
    pub highest_bit: core::ffi::c_uint,
    pub pages: core::ffi::c_uint,
    pub inuse_pages: core::ffi::c_uint,
    pub cluster_next: core::ffi::c_uint,
    pub cluster_nr: core::ffi::c_uint,
    pub cluster_next_cpu: *mut core::ffi::c_uint,
    pub percpu_cluster: *mut percpu_cluster,
    pub swap_extent_root: rb_root,
    pub bdev: *mut block_device,
    pub swap_file: *mut file,
    pub old_block_size: core::ffi::c_uint,
    pub comp: completion,
    pub lock: spinlock_t,
    pub cont_lock: spinlock_t,
    pub discard_work: work_struct,
    pub discard_clusters: swap_cluster_list,
    pub avail_lists: __IncompleteArrayField<plist_node>,
}
impl Default for swap_info_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vma_swap_readahead {
    pub win: core::ffi::c_ushort,
    pub offset: core::ffi::c_ushort,
    pub nr_pte: core::ffi::c_ushort,
    pub ptes: *mut pte_t,
}
impl Default for vma_swap_readahead {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn workingset_age_nonresident(lruvec: *mut lruvec, nr_pages: core::ffi::c_ulong);
}
extern "C" {
    pub fn workingset_eviction(
        folio: *mut folio,
        target_memcg: *mut mem_cgroup,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn workingset_refault(folio: *mut folio, shadow: *mut core::ffi::c_void);
}
extern "C" {
    pub fn workingset_activation(folio: *mut folio);
}
extern "C" {
    pub fn workingset_update_node(node: *mut xa_node);
}
extern "C" {
    pub static mut shadow_nodes: list_lru;
}
extern "C" {
    pub static mut totalreserve_pages: core::ffi::c_ulong;
}
extern "C" {
    pub fn lru_note_cost(lruvec: *mut lruvec, file: bool_, nr_pages: core::ffi::c_uint);
}
extern "C" {
    pub fn lru_note_cost_folio(arg1: *mut folio);
}
extern "C" {
    pub fn folio_add_lru(arg1: *mut folio);
}
extern "C" {
    pub fn folio_add_lru_vma(arg1: *mut folio, arg2: *mut vm_area_struct);
}
extern "C" {
    pub fn lru_cache_add(arg1: *mut page);
}
extern "C" {
    pub fn mark_page_accessed(arg1: *mut page);
}
extern "C" {
    pub fn folio_mark_accessed(arg1: *mut folio);
}
extern "C" {
    pub static mut lru_disable_count: atomic_t;
}
extern "C" {
    pub fn lru_cache_disable();
}
extern "C" {
    pub fn lru_add_drain();
}
extern "C" {
    pub fn lru_add_drain_cpu(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn lru_add_drain_cpu_zone(zone: *mut zone);
}
extern "C" {
    pub fn lru_add_drain_all();
}
extern "C" {
    pub fn deactivate_page(page: *mut page);
}
extern "C" {
    pub fn mark_page_lazyfree(page: *mut page);
}
extern "C" {
    pub fn swap_setup();
}
extern "C" {
    pub fn lru_cache_add_inactive_or_unevictable(page: *mut page, vma: *mut vm_area_struct);
}
extern "C" {
    pub fn zone_reclaimable_pages(zone: *mut zone) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn try_to_free_pages(
        zonelist: *mut zonelist,
        order: core::ffi::c_int,
        gfp_mask: gfp_t,
        mask: *mut nodemask_t,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn try_to_free_mem_cgroup_pages(
        memcg: *mut mem_cgroup,
        nr_pages: core::ffi::c_ulong,
        gfp_mask: gfp_t,
        reclaim_options: core::ffi::c_uint,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn mem_cgroup_shrink_node(
        mem: *mut mem_cgroup,
        gfp_mask: gfp_t,
        noswap: bool_,
        pgdat: *mut pg_data_t,
        nr_scanned: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn shrink_all_memory(nr_pages: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub static mut vm_swappiness: core::ffi::c_int;
}
extern "C" {
    pub fn remove_mapping(mapping: *mut address_space, folio: *mut folio) -> core::ffi::c_long;
}
extern "C" {
    pub fn reclaim_pages(page_list: *mut list_head) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn check_move_unevictable_folios(fbatch: *mut folio_batch);
}
extern "C" {
    pub fn check_move_unevictable_pages(pvec: *mut pagevec);
}
extern "C" {
    pub fn kswapd_run(nid: core::ffi::c_int);
}
extern "C" {
    pub fn kswapd_stop(nid: core::ffi::c_int);
}
extern "C" {
    pub fn add_swap_extent(
        sis: *mut swap_info_struct,
        start_page: core::ffi::c_ulong,
        nr_pages: core::ffi::c_ulong,
        start_block: sector_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_swapfile_activate(
        arg1: *mut swap_info_struct,
        arg2: *mut file,
        arg3: *mut sector_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn free_swap_cache(page: *mut page);
}
extern "C" {
    pub fn free_page_and_swap_cache(arg1: *mut page);
}
extern "C" {
    pub fn free_pages_and_swap_cache(arg1: *mut *mut page, arg2: core::ffi::c_int);
}
extern "C" {
    pub static mut nr_swap_pages: atomic_long_t;
}
extern "C" {
    pub static mut total_swap_pages: core::ffi::c_long;
}
extern "C" {
    pub static mut nr_rotate_swap: atomic_t;
}
extern "C" {
    pub fn has_usable_swap() -> bool_;
}
extern "C" {
    pub fn si_swapinfo(arg1: *mut sysinfo);
}
extern "C" {
    pub fn folio_alloc_swap(folio: *mut folio) -> swp_entry_t;
}
extern "C" {
    pub fn folio_free_swap(folio: *mut folio) -> bool_;
}
extern "C" {
    pub fn put_swap_folio(folio: *mut folio, entry: swp_entry_t);
}
extern "C" {
    pub fn get_swap_page_of_type(arg1: core::ffi::c_int) -> swp_entry_t;
}
extern "C" {
    pub fn get_swap_pages(
        n: core::ffi::c_int,
        swp_entries: *mut swp_entry_t,
        entry_size: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn add_swap_count_continuation(arg1: swp_entry_t, arg2: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn swap_shmem_alloc(arg1: swp_entry_t);
}
extern "C" {
    pub fn swap_duplicate(arg1: swp_entry_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn swapcache_prepare(arg1: swp_entry_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn swap_free(arg1: swp_entry_t);
}
extern "C" {
    pub fn swapcache_free_entries(entries: *mut swp_entry_t, n: core::ffi::c_int);
}
extern "C" {
    pub fn free_swap_and_cache(arg1: swp_entry_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn swap_type_of(device: dev_t, offset: sector_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn find_first_swap(device: *mut dev_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn count_swap_pages(arg1: core::ffi::c_int, arg2: core::ffi::c_int) -> core::ffi::c_uint;
}
extern "C" {
    pub fn swapdev_block(arg1: core::ffi::c_int, arg2: core::ffi::c_ulong) -> sector_t;
}
extern "C" {
    pub fn __swap_count(entry: swp_entry_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __swp_swapcount(entry: swp_entry_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn swp_swapcount(entry: swp_entry_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn page_swap_info(arg1: *mut page) -> *mut swap_info_struct;
}
extern "C" {
    pub fn swp_swap_info(entry: swp_entry_t) -> *mut swap_info_struct;
}
extern "C" {
    pub fn init_swap_address_space(
        type_: core::ffi::c_uint,
        nr_pages: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn exit_swap_address_space(type_: core::ffi::c_uint);
}
extern "C" {
    pub fn get_swap_device(entry: swp_entry_t) -> *mut swap_info_struct;
}
extern "C" {
    pub fn swap_page_sector(page: *mut page) -> sector_t;
}
extern "C" {
    pub fn mem_cgroup_swapout(folio: *mut folio, entry: swp_entry_t);
}
extern "C" {
    pub fn __mem_cgroup_try_charge_swap(folio: *mut folio, entry: swp_entry_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn __mem_cgroup_uncharge_swap(entry: swp_entry_t, nr_pages: core::ffi::c_uint);
}
extern "C" {
    pub fn mem_cgroup_get_nr_swap_pages(memcg: *mut mem_cgroup) -> core::ffi::c_long;
}
extern "C" {
    pub fn mem_cgroup_swap_full(folio: *mut folio) -> bool_;
}
extern "C" {
    pub static mut freezer_active: static_key_false;
}
extern "C" {
    pub static mut pm_freezing: bool_;
}
extern "C" {
    pub static mut pm_nosig_freezing: bool_;
}
extern "C" {
    pub static mut freeze_timeout_msecs: core::ffi::c_uint;
}
extern "C" {
    pub fn frozen(p: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn freezing_slow_path(p: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn __thaw_task(t: *mut task_struct);
}
extern "C" {
    pub fn __refrigerator(check_kthr_stop: bool_) -> bool_;
}
extern "C" {
    pub fn freeze_processes() -> core::ffi::c_int;
}
extern "C" {
    pub fn freeze_kernel_threads() -> core::ffi::c_int;
}
extern "C" {
    pub fn thaw_processes();
}
extern "C" {
    pub fn thaw_kernel_threads();
}
extern "C" {
    pub fn freeze_task(p: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn set_freezable() -> bool_;
}
extern "C" {
    pub fn cgroup_freezing(task: *mut task_struct) -> bool_;
}
extern "C" {
    pub fn pm_set_vt_switch(arg1: core::ffi::c_int);
}
pub type suspend_state_t = core::ffi::c_int;
pub const suspend_stat_step_SUSPEND_FREEZE: suspend_stat_step = 1;
pub const suspend_stat_step_SUSPEND_PREPARE: suspend_stat_step = 2;
pub const suspend_stat_step_SUSPEND_SUSPEND: suspend_stat_step = 3;
pub const suspend_stat_step_SUSPEND_SUSPEND_LATE: suspend_stat_step = 4;
pub const suspend_stat_step_SUSPEND_SUSPEND_NOIRQ: suspend_stat_step = 5;
pub const suspend_stat_step_SUSPEND_RESUME_NOIRQ: suspend_stat_step = 6;
pub const suspend_stat_step_SUSPEND_RESUME_EARLY: suspend_stat_step = 7;
pub const suspend_stat_step_SUSPEND_RESUME: suspend_stat_step = 8;
pub type suspend_stat_step = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct suspend_stats {
    pub success: core::ffi::c_int,
    pub fail: core::ffi::c_int,
    pub failed_freeze: core::ffi::c_int,
    pub failed_prepare: core::ffi::c_int,
    pub failed_suspend: core::ffi::c_int,
    pub failed_suspend_late: core::ffi::c_int,
    pub failed_suspend_noirq: core::ffi::c_int,
    pub failed_resume: core::ffi::c_int,
    pub failed_resume_early: core::ffi::c_int,
    pub failed_resume_noirq: core::ffi::c_int,
    pub last_failed_dev: core::ffi::c_int,
    pub failed_devs: [[core::ffi::c_char; 40usize]; 2usize],
    pub last_failed_errno: core::ffi::c_int,
    pub errno: [core::ffi::c_int; 2usize],
    pub last_failed_step: core::ffi::c_int,
    pub failed_steps: [suspend_stat_step; 2usize],
}
impl Default for suspend_stats {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut suspend_stats: suspend_stats;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct platform_suspend_ops {
    pub valid:
        ::core::option::Option<unsafe extern "C" fn(state: suspend_state_t) -> core::ffi::c_int>,
    pub begin:
        ::core::option::Option<unsafe extern "C" fn(state: suspend_state_t) -> core::ffi::c_int>,
    pub prepare: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub prepare_late: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub enter:
        ::core::option::Option<unsafe extern "C" fn(state: suspend_state_t) -> core::ffi::c_int>,
    pub wake: ::core::option::Option<unsafe extern "C" fn()>,
    pub finish: ::core::option::Option<unsafe extern "C" fn()>,
    pub suspend_again: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub end: ::core::option::Option<unsafe extern "C" fn()>,
    pub recover: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct platform_s2idle_ops {
    pub begin: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub prepare: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub prepare_late: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub check: ::core::option::Option<unsafe extern "C" fn()>,
    pub wake: ::core::option::Option<unsafe extern "C" fn() -> bool_>,
    pub restore_early: ::core::option::Option<unsafe extern "C" fn()>,
    pub restore: ::core::option::Option<unsafe extern "C" fn()>,
    pub end: ::core::option::Option<unsafe extern "C" fn()>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pbe {
    pub address: *mut core::ffi::c_void,
    pub orig_address: *mut core::ffi::c_void,
    pub next: *mut pbe,
}
impl Default for pbe {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mark_free_pages(zone: *mut zone);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct platform_hibernation_ops {
    pub begin:
        ::core::option::Option<unsafe extern "C" fn(stage: pm_message_t) -> core::ffi::c_int>,
    pub end: ::core::option::Option<unsafe extern "C" fn()>,
    pub pre_snapshot: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub finish: ::core::option::Option<unsafe extern "C" fn()>,
    pub prepare: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub enter: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub leave: ::core::option::Option<unsafe extern "C" fn()>,
    pub pre_restore: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>,
    pub restore_cleanup: ::core::option::Option<unsafe extern "C" fn()>,
    pub recover: ::core::option::Option<unsafe extern "C" fn()>,
}
extern "C" {
    pub static mut system_transition_mutex: mutex;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct regmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct regulator_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pre_voltage_change_data {
    pub old_uV: core::ffi::c_ulong,
    pub min_uV: core::ffi::c_ulong,
    pub max_uV: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct regulator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct regulator_bulk_data {
    pub supply: *const core::ffi::c_char,
    pub init_load_uA: core::ffi::c_int,
    pub consumer: *mut regulator,
    pub ret: core::ffi::c_int,
}
impl Default for regulator_bulk_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amba_cs_uci_id {
    pub devarch: core::ffi::c_uint,
    pub devarch_mask: core::ffi::c_uint,
    pub devtype: core::ffi::c_uint,
    pub data: *mut core::ffi::c_void,
}
impl Default for amba_cs_uci_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amba_device {
    pub dev: device,
    pub res: resource,
    pub pclk: *mut clk,
    pub dma_parms: device_dma_parameters,
    pub periphid: core::ffi::c_uint,
    pub periphid_lock: mutex,
    pub cid: core::ffi::c_uint,
    pub uci: amba_cs_uci_id,
    pub irq: [core::ffi::c_uint; 9usize],
    pub driver_override: *const core::ffi::c_char,
}
impl Default for amba_device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct amba_driver {
    pub drv: device_driver,
    pub probe: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut amba_device, arg2: *const amba_id) -> core::ffi::c_int,
    >,
    pub remove: ::core::option::Option<unsafe extern "C" fn(arg1: *mut amba_device)>,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut amba_device)>,
    pub id_table: *const amba_id,
    pub driver_managed_dma: bool_,
}
impl Default for amba_driver {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const amba_vendor_AMBA_VENDOR_ARM: amba_vendor = 65;
pub const amba_vendor_AMBA_VENDOR_ST: amba_vendor = 128;
pub const amba_vendor_AMBA_VENDOR_QCOM: amba_vendor = 81;
pub const amba_vendor_AMBA_VENDOR_LSI: amba_vendor = 182;
pub type amba_vendor = core::ffi::c_uint;
extern "C" {
    pub static mut amba_bustype: bus_type;
}
extern "C" {
    pub fn amba_device_alloc(
        arg1: *const core::ffi::c_char,
        arg2: resource_size_t,
        arg3: usize,
    ) -> *mut amba_device;
}
extern "C" {
    pub fn amba_device_put(arg1: *mut amba_device);
}
extern "C" {
    pub fn amba_device_add(arg1: *mut amba_device, arg2: *mut resource) -> core::ffi::c_int;
}
extern "C" {
    pub fn amba_device_register(arg1: *mut amba_device, arg2: *mut resource) -> core::ffi::c_int;
}
extern "C" {
    pub fn amba_device_unregister(arg1: *mut amba_device);
}
extern "C" {
    pub fn amba_request_regions(
        arg1: *mut amba_device,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn amba_release_regions(arg1: *mut amba_device);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cdev {
    pub kobj: kobject,
    pub owner: *mut module,
    pub ops: *const file_operations,
    pub list: list_head,
    pub dev: dev_t,
    pub count: core::ffi::c_uint,
}
impl Default for cdev {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn cdev_init(arg1: *mut cdev, arg2: *const file_operations);
}
extern "C" {
    pub fn cdev_alloc() -> *mut cdev;
}
extern "C" {
    pub fn cdev_put(p: *mut cdev);
}
extern "C" {
    pub fn cdev_add(arg1: *mut cdev, arg2: dev_t, arg3: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn cdev_set_parent(p: *mut cdev, kobj: *mut kobject);
}
extern "C" {
    pub fn cdev_device_add(cdev: *mut cdev, dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn cdev_device_del(cdev: *mut cdev, dev: *mut device);
}
extern "C" {
    pub fn cdev_del(arg1: *mut cdev);
}
extern "C" {
    pub fn cd_forget(arg1: *mut inode);
}
extern "C" {
    pub fn errname(err: core::ffi::c_int) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn fput(arg1: *mut file);
}
extern "C" {
    pub fn alloc_file_pseudo(
        arg1: *mut inode,
        arg2: *mut vfsmount,
        arg3: *const core::ffi::c_char,
        flags: core::ffi::c_int,
        arg4: *const file_operations,
    ) -> *mut file;
}
extern "C" {
    pub fn alloc_file_clone(
        arg1: *mut file,
        flags: core::ffi::c_int,
        arg2: *const file_operations,
    ) -> *mut file;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd {
    pub file: *mut file,
    pub flags: core::ffi::c_uint,
}
impl Default for fd {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn fget(fd: core::ffi::c_uint) -> *mut file;
}
extern "C" {
    pub fn fget_raw(fd: core::ffi::c_uint) -> *mut file;
}
extern "C" {
    pub fn fget_task(task: *mut task_struct, fd: core::ffi::c_uint) -> *mut file;
}
extern "C" {
    pub fn __fdget(fd: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __fdget_raw(fd: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __fdget_pos(fd: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __f_unlock_pos(arg1: *mut file);
}
extern "C" {
    pub fn f_dupfd(
        from: core::ffi::c_uint,
        file: *mut file,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn replace_fd(
        fd: core::ffi::c_uint,
        file: *mut file,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_close_on_exec(fd: core::ffi::c_uint, flag: core::ffi::c_int);
}
extern "C" {
    pub fn get_close_on_exec(fd: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn __get_unused_fd_flags(
        flags: core::ffi::c_uint,
        nofile: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_unused_fd_flags(flags: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_unused_fd(fd: core::ffi::c_uint);
}
extern "C" {
    pub fn fd_install(fd: core::ffi::c_uint, file: *mut file);
}
extern "C" {
    pub fn __receive_fd(
        file: *mut file,
        ufd: *mut core::ffi::c_int,
        o_flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn receive_fd(file: *mut file, o_flags: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn receive_fd_replace(
        new_fd: core::ffi::c_int,
        file: *mut file,
        o_flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn flush_delayed_fput();
}
extern "C" {
    pub fn __fput_sync(arg1: *mut file);
}
extern "C" {
    pub static mut sysctl_nr_open_min: core::ffi::c_uint;
}
extern "C" {
    pub static mut sysctl_nr_open_max: core::ffi::c_uint;
}
pub const kernel_read_file_id_READING_UNKNOWN: kernel_read_file_id = 0;
pub const kernel_read_file_id_READING_FIRMWARE: kernel_read_file_id = 1;
pub const kernel_read_file_id_READING_MODULE: kernel_read_file_id = 2;
pub const kernel_read_file_id_READING_KEXEC_IMAGE: kernel_read_file_id = 3;
pub const kernel_read_file_id_READING_KEXEC_INITRAMFS: kernel_read_file_id = 4;
pub const kernel_read_file_id_READING_POLICY: kernel_read_file_id = 5;
pub const kernel_read_file_id_READING_X509_CERTIFICATE: kernel_read_file_id = 6;
pub const kernel_read_file_id_READING_MAX_ID: kernel_read_file_id = 7;
pub type kernel_read_file_id = core::ffi::c_uint;
extern "C" {
    pub static kernel_read_file_str: [*const core::ffi::c_char; 8usize];
}
extern "C" {
    pub fn kernel_read_file(
        file: *mut file,
        offset: loff_t,
        buf: *mut *mut core::ffi::c_void,
        buf_size: usize,
        file_size: *mut usize,
        id: kernel_read_file_id,
    ) -> isize;
}
extern "C" {
    pub fn kernel_read_file_from_path(
        path: *const core::ffi::c_char,
        offset: loff_t,
        buf: *mut *mut core::ffi::c_void,
        buf_size: usize,
        file_size: *mut usize,
        id: kernel_read_file_id,
    ) -> isize;
}
extern "C" {
    pub fn kernel_read_file_from_path_initns(
        path: *const core::ffi::c_char,
        offset: loff_t,
        buf: *mut *mut core::ffi::c_void,
        buf_size: usize,
        file_size: *mut usize,
        id: kernel_read_file_id,
    ) -> isize;
}
extern "C" {
    pub fn kernel_read_file_from_fd(
        fd: core::ffi::c_int,
        offset: loff_t,
        buf: *mut *mut core::ffi::c_void,
        buf_size: usize,
        file_size: *mut usize,
        id: kernel_read_file_id,
    ) -> isize;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msg_msg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct watch_notification {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct audit_krule {
    _unused: [u8; 0],
}
pub const lsm_event_LSM_POLICY_CHANGE: lsm_event = 0;
pub type lsm_event = core::ffi::c_uint;
pub const lockdown_reason_LOCKDOWN_NONE: lockdown_reason = 0;
pub const lockdown_reason_LOCKDOWN_MODULE_SIGNATURE: lockdown_reason = 1;
pub const lockdown_reason_LOCKDOWN_DEV_MEM: lockdown_reason = 2;
pub const lockdown_reason_LOCKDOWN_EFI_TEST: lockdown_reason = 3;
pub const lockdown_reason_LOCKDOWN_KEXEC: lockdown_reason = 4;
pub const lockdown_reason_LOCKDOWN_HIBERNATION: lockdown_reason = 5;
pub const lockdown_reason_LOCKDOWN_PCI_ACCESS: lockdown_reason = 6;
pub const lockdown_reason_LOCKDOWN_IOPORT: lockdown_reason = 7;
pub const lockdown_reason_LOCKDOWN_MSR: lockdown_reason = 8;
pub const lockdown_reason_LOCKDOWN_ACPI_TABLES: lockdown_reason = 9;
pub const lockdown_reason_LOCKDOWN_DEVICE_TREE: lockdown_reason = 10;
pub const lockdown_reason_LOCKDOWN_PCMCIA_CIS: lockdown_reason = 11;
pub const lockdown_reason_LOCKDOWN_TIOCSSERIAL: lockdown_reason = 12;
pub const lockdown_reason_LOCKDOWN_MODULE_PARAMETERS: lockdown_reason = 13;
pub const lockdown_reason_LOCKDOWN_MMIOTRACE: lockdown_reason = 14;
pub const lockdown_reason_LOCKDOWN_DEBUGFS: lockdown_reason = 15;
pub const lockdown_reason_LOCKDOWN_XMON_WR: lockdown_reason = 16;
pub const lockdown_reason_LOCKDOWN_BPF_WRITE_USER: lockdown_reason = 17;
pub const lockdown_reason_LOCKDOWN_DBG_WRITE_KERNEL: lockdown_reason = 18;
pub const lockdown_reason_LOCKDOWN_RTAS_ERROR_INJECTION: lockdown_reason = 19;
pub const lockdown_reason_LOCKDOWN_INTEGRITY_MAX: lockdown_reason = 20;
pub const lockdown_reason_LOCKDOWN_KCORE: lockdown_reason = 21;
pub const lockdown_reason_LOCKDOWN_KPROBES: lockdown_reason = 22;
pub const lockdown_reason_LOCKDOWN_BPF_READ_KERNEL: lockdown_reason = 23;
pub const lockdown_reason_LOCKDOWN_DBG_READ_KERNEL: lockdown_reason = 24;
pub const lockdown_reason_LOCKDOWN_PERF: lockdown_reason = 25;
pub const lockdown_reason_LOCKDOWN_TRACEFS: lockdown_reason = 26;
pub const lockdown_reason_LOCKDOWN_XMON_RW: lockdown_reason = 27;
pub const lockdown_reason_LOCKDOWN_XFRM_SECRET: lockdown_reason = 28;
pub const lockdown_reason_LOCKDOWN_CONFIDENTIALITY_MAX: lockdown_reason = 29;
pub type lockdown_reason = core::ffi::c_uint;
extern "C" {
    pub static lockdown_reasons: [*const core::ffi::c_char; 30usize];
}
extern "C" {
    pub fn cap_capable(
        cred: *const cred,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
        opts: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_settime(ts: *const timespec64, tz: *const timezone) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_ptrace_access_check(
        child: *mut task_struct,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_ptrace_traceme(parent: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_capget(
        target: *mut task_struct,
        effective: *mut kernel_cap_t,
        inheritable: *mut kernel_cap_t,
        permitted: *mut kernel_cap_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_capset(
        new: *mut cred,
        old: *const cred,
        effective: *const kernel_cap_t,
        inheritable: *const kernel_cap_t,
        permitted: *const kernel_cap_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_bprm_creds_from_file(bprm: *mut linux_binprm, file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_inode_setxattr(
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_inode_removexattr(
        mnt_userns: *mut user_namespace,
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_inode_need_killpriv(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_inode_killpriv(
        mnt_userns: *mut user_namespace,
        dentry: *mut dentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_inode_getsecurity(
        mnt_userns: *mut user_namespace,
        inode: *mut inode,
        name: *const core::ffi::c_char,
        buffer: *mut *mut core::ffi::c_void,
        alloc: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_mmap_addr(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_mmap_file(
        file: *mut file,
        reqprot: core::ffi::c_ulong,
        prot: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_task_fix_setuid(
        new: *mut cred,
        old: *const cred,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_task_prctl(
        option: core::ffi::c_int,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_task_setscheduler(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_task_setioprio(p: *mut task_struct, ioprio: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_task_setnice(p: *mut task_struct, nice: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn cap_vm_enough_memory(mm: *mut mm_struct, pages: core::ffi::c_long) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_association {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut mmap_min_addr: core::ffi::c_ulong;
}
extern "C" {
    pub static mut dac_mmap_min_addr: core::ffi::c_ulong;
}
extern "C" {
    pub fn mmap_min_addr_handler(
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
pub type initxattrs = ::core::option::Option<
    unsafe extern "C" fn(
        inode: *mut inode,
        xattr_array: *const xattr,
        fs_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
pub const kernel_load_data_id_LOADING_UNKNOWN: kernel_load_data_id = 0;
pub const kernel_load_data_id_LOADING_FIRMWARE: kernel_load_data_id = 1;
pub const kernel_load_data_id_LOADING_MODULE: kernel_load_data_id = 2;
pub const kernel_load_data_id_LOADING_KEXEC_IMAGE: kernel_load_data_id = 3;
pub const kernel_load_data_id_LOADING_KEXEC_INITRAMFS: kernel_load_data_id = 4;
pub const kernel_load_data_id_LOADING_POLICY: kernel_load_data_id = 5;
pub const kernel_load_data_id_LOADING_X509_CERTIFICATE: kernel_load_data_id = 6;
pub const kernel_load_data_id_LOADING_MAX_ID: kernel_load_data_id = 7;
pub type kernel_load_data_id = core::ffi::c_uint;
extern "C" {
    pub static kernel_load_data_str: [*const core::ffi::c_char; 8usize];
}
extern "C" {
    pub fn call_blocking_lsm_notifier(
        event: lsm_event,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn register_blocking_lsm_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_blocking_lsm_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn early_security_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn security_binder_set_context_mgr(mgr: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_binder_transaction(from: *const cred, to: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_binder_transfer_binder(from: *const cred, to: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_binder_transfer_file(
        from: *const cred,
        to: *const cred,
        file: *mut file,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ptrace_access_check(
        child: *mut task_struct,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ptrace_traceme(parent: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_capget(
        target: *mut task_struct,
        effective: *mut kernel_cap_t,
        inheritable: *mut kernel_cap_t,
        permitted: *mut kernel_cap_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_capset(
        new: *mut cred,
        old: *const cred,
        effective: *const kernel_cap_t,
        inheritable: *const kernel_cap_t,
        permitted: *const kernel_cap_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_capable(
        cred: *const cred,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
        opts: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_quotactl(
        cmds: core::ffi::c_int,
        type_: core::ffi::c_int,
        id: core::ffi::c_int,
        sb: *mut super_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_quota_on(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_syslog(type_: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_settime64(ts: *const timespec64, tz: *const timezone) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_vm_enough_memory_mm(
        mm: *mut mm_struct,
        pages: core::ffi::c_long,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bprm_creds_for_exec(bprm: *mut linux_binprm) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bprm_creds_from_file(
        bprm: *mut linux_binprm,
        file: *mut file,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bprm_check(bprm: *mut linux_binprm) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bprm_committing_creds(bprm: *mut linux_binprm);
}
extern "C" {
    pub fn security_bprm_committed_creds(bprm: *mut linux_binprm);
}
extern "C" {
    pub fn security_fs_context_dup(
        fc: *mut fs_context,
        src_fc: *mut fs_context,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_fs_context_parse_param(
        fc: *mut fs_context,
        param: *mut fs_parameter,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_alloc(sb: *mut super_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_delete(sb: *mut super_block);
}
extern "C" {
    pub fn security_sb_free(sb: *mut super_block);
}
extern "C" {
    pub fn security_free_mnt_opts(mnt_opts: *mut *mut core::ffi::c_void);
}
extern "C" {
    pub fn security_sb_eat_lsm_opts(
        options: *mut core::ffi::c_char,
        mnt_opts: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_mnt_opts_compat(
        sb: *mut super_block,
        mnt_opts: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_remount(
        sb: *mut super_block,
        mnt_opts: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_kern_mount(sb: *mut super_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_show_options(m: *mut seq_file, sb: *mut super_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_statfs(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_mount(
        dev_name: *const core::ffi::c_char,
        path: *const path,
        type_: *const core::ffi::c_char,
        flags: core::ffi::c_ulong,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_umount(mnt: *mut vfsmount, flags: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_pivotroot(old_path: *const path, new_path: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_set_mnt_opts(
        sb: *mut super_block,
        mnt_opts: *mut core::ffi::c_void,
        kern_flags: core::ffi::c_ulong,
        set_kern_flags: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sb_clone_mnt_opts(
        oldsb: *const super_block,
        newsb: *mut super_block,
        kern_flags: core::ffi::c_ulong,
        set_kern_flags: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_move_mount(from_path: *const path, to_path: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_dentry_init_security(
        dentry: *mut dentry,
        mode: core::ffi::c_int,
        name: *const qstr,
        xattr_name: *mut *const core::ffi::c_char,
        ctx: *mut *mut core::ffi::c_void,
        ctxlen: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_dentry_create_files_as(
        dentry: *mut dentry,
        mode: core::ffi::c_int,
        name: *mut qstr,
        old: *const cred,
        new: *mut cred,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_notify(
        path: *const path,
        mask: u64_,
        obj_type: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_alloc(inode: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_free(inode: *mut inode);
}
extern "C" {
    pub fn security_inode_init_security(
        inode: *mut inode,
        dir: *mut inode,
        qstr: *const qstr,
        initxattrs: initxattrs,
        fs_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_init_security_anon(
        inode: *mut inode,
        name: *const qstr,
        context_inode: *const inode,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_old_inode_init_security(
        inode: *mut inode,
        dir: *mut inode,
        qstr: *const qstr,
        name: *mut *const core::ffi::c_char,
        value: *mut *mut core::ffi::c_void,
        len: *mut usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_create(
        dir: *mut inode,
        dentry: *mut dentry,
        mode: umode_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_link(
        old_dentry: *mut dentry,
        dir: *mut inode,
        new_dentry: *mut dentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_unlink(dir: *mut inode, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_symlink(
        dir: *mut inode,
        dentry: *mut dentry,
        old_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_mkdir(
        dir: *mut inode,
        dentry: *mut dentry,
        mode: umode_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_rmdir(dir: *mut inode, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_mknod(
        dir: *mut inode,
        dentry: *mut dentry,
        mode: umode_t,
        dev: dev_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_rename(
        old_dir: *mut inode,
        old_dentry: *mut dentry,
        new_dir: *mut inode,
        new_dentry: *mut dentry,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_readlink(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_follow_link(
        dentry: *mut dentry,
        inode: *mut inode,
        rcu: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_permission(inode: *mut inode, mask: core::ffi::c_int)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_setattr(
        mnt_userns: *mut user_namespace,
        dentry: *mut dentry,
        attr: *mut iattr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_getattr(path: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_setxattr(
        mnt_userns: *mut user_namespace,
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_post_setxattr(
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_int,
    );
}
extern "C" {
    pub fn security_inode_getxattr(
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_listxattr(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_removexattr(
        mnt_userns: *mut user_namespace,
        dentry: *mut dentry,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_need_killpriv(dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_killpriv(
        mnt_userns: *mut user_namespace,
        dentry: *mut dentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_getsecurity(
        mnt_userns: *mut user_namespace,
        inode: *mut inode,
        name: *const core::ffi::c_char,
        buffer: *mut *mut core::ffi::c_void,
        alloc: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_setsecurity(
        inode: *mut inode,
        name: *const core::ffi::c_char,
        value: *const core::ffi::c_void,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_listsecurity(
        inode: *mut inode,
        buffer: *mut core::ffi::c_char,
        buffer_size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_getsecid(inode: *mut inode, secid: *mut u32_);
}
extern "C" {
    pub fn security_inode_copy_up(src: *mut dentry, new: *mut *mut cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_copy_up_xattr(name: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernfs_init_security(
        kn_dir: *mut kernfs_node,
        kn: *mut kernfs_node,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_permission(file: *mut file, mask: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_alloc(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_free(file: *mut file);
}
extern "C" {
    pub fn security_file_ioctl(
        file: *mut file,
        cmd: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_mmap_file(
        file: *mut file,
        prot: core::ffi::c_ulong,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_mmap_addr(addr: core::ffi::c_ulong) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_mprotect(
        vma: *mut vm_area_struct,
        reqprot: core::ffi::c_ulong,
        prot: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_lock(file: *mut file, cmd: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_fcntl(
        file: *mut file,
        cmd: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_set_fowner(file: *mut file);
}
extern "C" {
    pub fn security_file_send_sigiotask(
        tsk: *mut task_struct,
        fown: *mut fown_struct,
        sig: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_receive(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_file_open(file: *mut file) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_alloc(
        task: *mut task_struct,
        clone_flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_free(task: *mut task_struct);
}
extern "C" {
    pub fn security_cred_alloc_blank(cred: *mut cred, gfp: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_cred_free(cred: *mut cred);
}
extern "C" {
    pub fn security_prepare_creds(new: *mut cred, old: *const cred, gfp: gfp_t)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn security_transfer_creds(new: *mut cred, old: *const cred);
}
extern "C" {
    pub fn security_cred_getsecid(c: *const cred, secid: *mut u32_);
}
extern "C" {
    pub fn security_kernel_act_as(new: *mut cred, secid: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_create_files_as(new: *mut cred, inode: *mut inode) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_module_request(kmod_name: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_load_data(id: kernel_load_data_id, contents: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_post_load_data(
        buf: *mut core::ffi::c_char,
        size: loff_t,
        id: kernel_load_data_id,
        description: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_read_file(
        file: *mut file,
        id: kernel_read_file_id,
        contents: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_kernel_post_read_file(
        file: *mut file,
        buf: *mut core::ffi::c_char,
        size: loff_t,
        id: kernel_read_file_id,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_fix_setuid(
        new: *mut cred,
        old: *const cred,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_fix_setgid(
        new: *mut cred,
        old: *const cred,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_fix_setgroups(new: *mut cred, old: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_setpgid(p: *mut task_struct, pgid: pid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_getpgid(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_getsid(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_current_getsecid_subj(secid: *mut u32_);
}
extern "C" {
    pub fn security_task_getsecid_obj(p: *mut task_struct, secid: *mut u32_);
}
extern "C" {
    pub fn security_task_setnice(p: *mut task_struct, nice: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_setioprio(
        p: *mut task_struct,
        ioprio: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_getioprio(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_prlimit(
        cred: *const cred,
        tcred: *const cred,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_setrlimit(
        p: *mut task_struct,
        resource: core::ffi::c_uint,
        new_rlim: *mut rlimit,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_setscheduler(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_getscheduler(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_movememory(p: *mut task_struct) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_kill(
        p: *mut task_struct,
        info: *mut kernel_siginfo,
        sig: core::ffi::c_int,
        cred: *const cred,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_prctl(
        option: core::ffi::c_int,
        arg2: core::ffi::c_ulong,
        arg3: core::ffi::c_ulong,
        arg4: core::ffi::c_ulong,
        arg5: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_task_to_inode(p: *mut task_struct, inode: *mut inode);
}
extern "C" {
    pub fn security_create_user_ns(cred: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ipc_permission(
        ipcp: *mut kern_ipc_perm,
        flag: core::ffi::c_short,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ipc_getsecid(ipcp: *mut kern_ipc_perm, secid: *mut u32_);
}
extern "C" {
    pub fn security_msg_msg_alloc(msg: *mut msg_msg) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_msg_msg_free(msg: *mut msg_msg);
}
extern "C" {
    pub fn security_msg_queue_alloc(msq: *mut kern_ipc_perm) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_msg_queue_free(msq: *mut kern_ipc_perm);
}
extern "C" {
    pub fn security_msg_queue_associate(
        msq: *mut kern_ipc_perm,
        msqflg: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_msg_queue_msgctl(
        msq: *mut kern_ipc_perm,
        cmd: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_msg_queue_msgsnd(
        msq: *mut kern_ipc_perm,
        msg: *mut msg_msg,
        msqflg: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_msg_queue_msgrcv(
        msq: *mut kern_ipc_perm,
        msg: *mut msg_msg,
        target: *mut task_struct,
        type_: core::ffi::c_long,
        mode: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_shm_alloc(shp: *mut kern_ipc_perm) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_shm_free(shp: *mut kern_ipc_perm);
}
extern "C" {
    pub fn security_shm_associate(
        shp: *mut kern_ipc_perm,
        shmflg: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_shm_shmctl(shp: *mut kern_ipc_perm, cmd: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_shm_shmat(
        shp: *mut kern_ipc_perm,
        shmaddr: *mut core::ffi::c_char,
        shmflg: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sem_alloc(sma: *mut kern_ipc_perm) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sem_free(sma: *mut kern_ipc_perm);
}
extern "C" {
    pub fn security_sem_associate(
        sma: *mut kern_ipc_perm,
        semflg: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sem_semctl(sma: *mut kern_ipc_perm, cmd: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sem_semop(
        sma: *mut kern_ipc_perm,
        sops: *mut sembuf,
        nsops: core::ffi::c_uint,
        alter: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_d_instantiate(dentry: *mut dentry, inode: *mut inode);
}
extern "C" {
    pub fn security_getprocattr(
        p: *mut task_struct,
        lsm: *const core::ffi::c_char,
        name: *const core::ffi::c_char,
        value: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_setprocattr(
        lsm: *const core::ffi::c_char,
        name: *const core::ffi::c_char,
        value: *mut core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_netlink_send(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_ismaclabel(name: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_secid_to_secctx(
        secid: u32_,
        secdata: *mut *mut core::ffi::c_char,
        seclen: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_secctx_to_secid(
        secdata: *const core::ffi::c_char,
        seclen: u32_,
        secid: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_release_secctx(secdata: *mut core::ffi::c_char, seclen: u32_);
}
extern "C" {
    pub fn security_inode_invalidate_secctx(inode: *mut inode);
}
extern "C" {
    pub fn security_inode_notifysecctx(
        inode: *mut inode,
        ctx: *mut core::ffi::c_void,
        ctxlen: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_setsecctx(
        dentry: *mut dentry,
        ctx: *mut core::ffi::c_void,
        ctxlen: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inode_getsecctx(
        inode: *mut inode,
        ctx: *mut *mut core::ffi::c_void,
        ctxlen: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_locked_down(what: lockdown_reason) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_unix_stream_connect(
        sock: *mut sock,
        other: *mut sock,
        newsk: *mut sock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_unix_may_send(sock: *mut socket, other: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_create(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        protocol: core::ffi::c_int,
        kern: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_post_create(
        sock: *mut socket,
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        protocol: core::ffi::c_int,
        kern: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_socketpair(socka: *mut socket, sockb: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_bind(
        sock: *mut socket,
        address: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_connect(
        sock: *mut socket,
        address: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_listen(sock: *mut socket, backlog: core::ffi::c_int)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_accept(sock: *mut socket, newsock: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_sendmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        size: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_recvmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        size: core::ffi::c_int,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_getsockname(sock: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_getpeername(sock: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_getsockopt(
        sock: *mut socket,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_setsockopt(
        sock: *mut socket,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_shutdown(sock: *mut socket, how: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sock_rcv_skb(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_getpeersec_stream(
        sock: *mut socket,
        optval: *mut core::ffi::c_char,
        optlen: *mut core::ffi::c_int,
        len: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_socket_getpeersec_dgram(
        sock: *mut socket,
        skb: *mut sk_buff,
        secid: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sk_alloc(
        sk: *mut sock,
        family: core::ffi::c_int,
        priority: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sk_free(sk: *mut sock);
}
extern "C" {
    pub fn security_sk_clone(sk: *const sock, newsk: *mut sock);
}
extern "C" {
    pub fn security_sk_classify_flow(sk: *mut sock, flic: *mut flowi_common);
}
extern "C" {
    pub fn security_req_classify_flow(req: *const request_sock, flic: *mut flowi_common);
}
extern "C" {
    pub fn security_sock_graft(sk: *mut sock, parent: *mut socket);
}
extern "C" {
    pub fn security_inet_conn_request(
        sk: *const sock,
        skb: *mut sk_buff,
        req: *mut request_sock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_inet_csk_clone(newsk: *mut sock, req: *const request_sock);
}
extern "C" {
    pub fn security_inet_conn_established(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn security_secmark_relabel_packet(secid: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_secmark_refcount_inc();
}
extern "C" {
    pub fn security_secmark_refcount_dec();
}
extern "C" {
    pub fn security_tun_dev_alloc_security(
        security: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_tun_dev_free_security(security: *mut core::ffi::c_void);
}
extern "C" {
    pub fn security_tun_dev_create() -> core::ffi::c_int;
}
extern "C" {
    pub fn security_tun_dev_attach_queue(security: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_tun_dev_attach(
        sk: *mut sock,
        security: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_tun_dev_open(security: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sctp_assoc_request(
        asoc: *mut sctp_association,
        skb: *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sctp_bind_connect(
        sk: *mut sock,
        optname: core::ffi::c_int,
        address: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_sctp_sk_clone(asoc: *mut sctp_association, sk: *mut sock, newsk: *mut sock);
}
extern "C" {
    pub fn security_sctp_assoc_established(
        asoc: *mut sctp_association,
        skb: *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_unlink(dir: *const path, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_mkdir(
        dir: *const path,
        dentry: *mut dentry,
        mode: umode_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_rmdir(dir: *const path, dentry: *mut dentry) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_mknod(
        dir: *const path,
        dentry: *mut dentry,
        mode: umode_t,
        dev: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_truncate(path: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_symlink(
        dir: *const path,
        dentry: *mut dentry,
        old_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_link(
        old_dentry: *mut dentry,
        new_dir: *const path,
        new_dentry: *mut dentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_rename(
        old_dir: *const path,
        old_dentry: *mut dentry,
        new_dir: *const path,
        new_dentry: *mut dentry,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_chmod(path: *const path, mode: umode_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_chown(path: *const path, uid: kuid_t, gid: kgid_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_path_chroot(path: *const path) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_key_alloc(
        key: *mut key,
        cred: *const cred,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_key_free(key: *mut key);
}
extern "C" {
    pub fn security_key_permission(
        key_ref: key_ref_t,
        cred: *const cred,
        need_perm: key_need_perm,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_key_getsecurity(
        key: *mut key,
        _buffer: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_audit_rule_init(
        field: u32_,
        op: u32_,
        rulestr: *mut core::ffi::c_char,
        lsmrule: *mut *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_audit_rule_known(krule: *mut audit_krule) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_audit_rule_match(
        secid: u32_,
        field: u32_,
        op: u32_,
        lsmrule: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_audit_rule_free(lsmrule: *mut core::ffi::c_void);
}
extern "C" {
    pub fn securityfs_create_file(
        name: *const core::ffi::c_char,
        mode: umode_t,
        parent: *mut dentry,
        data: *mut core::ffi::c_void,
        fops: *const file_operations,
    ) -> *mut dentry;
}
extern "C" {
    pub fn securityfs_create_dir(
        name: *const core::ffi::c_char,
        parent: *mut dentry,
    ) -> *mut dentry;
}
extern "C" {
    pub fn securityfs_create_symlink(
        name: *const core::ffi::c_char,
        parent: *mut dentry,
        target: *const core::ffi::c_char,
        iops: *const inode_operations,
    ) -> *mut dentry;
}
extern "C" {
    pub fn securityfs_remove(dentry: *mut dentry);
}
extern "C" {
    pub fn security_bpf(
        cmd: core::ffi::c_int,
        attr: *mut bpf_attr,
        size: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bpf_map(map: *mut bpf_map, fmode: fmode_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bpf_prog(prog: *mut bpf_prog) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bpf_map_alloc(map: *mut bpf_map) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bpf_map_free(map: *mut bpf_map);
}
extern "C" {
    pub fn security_bpf_prog_alloc(aux: *mut bpf_prog_aux) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_bpf_prog_free(aux: *mut bpf_prog_aux);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct perf_event {
    _unused: [u8; 0],
}
extern "C" {
    pub fn security_perf_event_open(
        attr: *mut perf_event_attr,
        type_: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_perf_event_alloc(event: *mut perf_event) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_perf_event_free(event: *mut perf_event);
}
extern "C" {
    pub fn security_perf_event_read(event: *mut perf_event) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_perf_event_write(event: *mut perf_event) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_uring_override_creds(new: *const cred) -> core::ffi::c_int;
}
extern "C" {
    pub fn security_uring_sqpoll() -> core::ffi::c_int;
}
extern "C" {
    pub fn security_uring_cmd(ioucmd: *mut io_uring_cmd) -> core::ffi::c_int;
}
pub const fs_context_purpose_FS_CONTEXT_FOR_MOUNT: fs_context_purpose = 0;
pub const fs_context_purpose_FS_CONTEXT_FOR_SUBMOUNT: fs_context_purpose = 1;
pub const fs_context_purpose_FS_CONTEXT_FOR_RECONFIGURE: fs_context_purpose = 2;
pub type fs_context_purpose = core::ffi::c_uint;
pub const fs_context_phase_FS_CONTEXT_CREATE_PARAMS: fs_context_phase = 0;
pub const fs_context_phase_FS_CONTEXT_CREATING: fs_context_phase = 1;
pub const fs_context_phase_FS_CONTEXT_AWAITING_MOUNT: fs_context_phase = 2;
pub const fs_context_phase_FS_CONTEXT_AWAITING_RECONF: fs_context_phase = 3;
pub const fs_context_phase_FS_CONTEXT_RECONF_PARAMS: fs_context_phase = 4;
pub const fs_context_phase_FS_CONTEXT_RECONFIGURING: fs_context_phase = 5;
pub const fs_context_phase_FS_CONTEXT_FAILED: fs_context_phase = 6;
pub type fs_context_phase = core::ffi::c_uint;
pub const fs_value_type_fs_value_is_undefined: fs_value_type = 0;
pub const fs_value_type_fs_value_is_flag: fs_value_type = 1;
pub const fs_value_type_fs_value_is_string: fs_value_type = 2;
pub const fs_value_type_fs_value_is_blob: fs_value_type = 3;
pub const fs_value_type_fs_value_is_filename: fs_value_type = 4;
pub const fs_value_type_fs_value_is_file: fs_value_type = 5;
pub type fs_value_type = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parameter {
    pub key: *const core::ffi::c_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_anon_1: fs_parameter__bindgen_ty_1,
    pub size: usize,
    pub dirfd: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fs_parameter__bindgen_ty_1 {
    pub string: *mut core::ffi::c_char,
    pub blob: *mut core::ffi::c_void,
    pub name: *mut filename,
    pub file: *mut file,
    _bindgen_union_align: u64,
}
impl Default for fs_parameter__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for fs_parameter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl fs_parameter {
    #[inline]
    pub fn type_(&self) -> fs_value_type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: fs_value_type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(type_: fs_value_type) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct p_log {
    pub prefix: *const core::ffi::c_char,
    pub log: *mut fc_log,
}
impl Default for p_log {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_context {
    pub ops: *const fs_context_operations,
    pub uapi_mutex: mutex,
    pub fs_type: *mut file_system_type,
    pub fs_private: *mut core::ffi::c_void,
    pub sget_key: *mut core::ffi::c_void,
    pub root: *mut dentry,
    pub user_ns: *mut user_namespace,
    pub net_ns: *mut net,
    pub cred: *const cred,
    pub log: p_log,
    pub source: *const core::ffi::c_char,
    pub security: *mut core::ffi::c_void,
    pub s_fs_info: *mut core::ffi::c_void,
    pub sb_flags: core::ffi::c_uint,
    pub sb_flags_mask: core::ffi::c_uint,
    pub s_iflags: core::ffi::c_uint,
    pub lsm_flags: core::ffi::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}
impl Default for fs_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl fs_context {
    #[inline]
    pub fn purpose(&self) -> fs_context_purpose {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_purpose(&mut self, val: fs_context_purpose) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn phase(&self) -> fs_context_phase {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_phase(&mut self, val: fs_context_phase) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn need_free(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_need_free(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn global(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_global(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn oldapi(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_oldapi(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        purpose: fs_context_purpose,
        phase: fs_context_phase,
        need_free: bool_,
        global: bool_,
        oldapi: bool_,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let purpose: u32 = unsafe { ::core::mem::transmute(purpose) };
            purpose as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let phase: u32 = unsafe { ::core::mem::transmute(phase) };
            phase as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let need_free: u8 = unsafe { ::core::mem::transmute(need_free) };
            need_free as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let global: u8 = unsafe { ::core::mem::transmute(global) };
            global as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let oldapi: u8 = unsafe { ::core::mem::transmute(oldapi) };
            oldapi as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fs_context_operations {
    pub free: ::core::option::Option<unsafe extern "C" fn(fc: *mut fs_context)>,
    pub dup: ::core::option::Option<
        unsafe extern "C" fn(fc: *mut fs_context, src_fc: *mut fs_context) -> core::ffi::c_int,
    >,
    pub parse_param: ::core::option::Option<
        unsafe extern "C" fn(fc: *mut fs_context, param: *mut fs_parameter) -> core::ffi::c_int,
    >,
    pub parse_monolithic: ::core::option::Option<
        unsafe extern "C" fn(fc: *mut fs_context, data: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub get_tree:
        ::core::option::Option<unsafe extern "C" fn(fc: *mut fs_context) -> core::ffi::c_int>,
    pub reconfigure:
        ::core::option::Option<unsafe extern "C" fn(fc: *mut fs_context) -> core::ffi::c_int>,
}
extern "C" {
    pub fn fs_context_for_mount(
        fs_type: *mut file_system_type,
        sb_flags: core::ffi::c_uint,
    ) -> *mut fs_context;
}
extern "C" {
    pub fn fs_context_for_reconfigure(
        dentry: *mut dentry,
        sb_flags: core::ffi::c_uint,
        sb_flags_mask: core::ffi::c_uint,
    ) -> *mut fs_context;
}
extern "C" {
    pub fn fs_context_for_submount(
        fs_type: *mut file_system_type,
        reference: *mut dentry,
    ) -> *mut fs_context;
}
extern "C" {
    pub fn vfs_dup_fs_context(fc: *mut fs_context) -> *mut fs_context;
}
extern "C" {
    pub fn vfs_parse_fs_param(fc: *mut fs_context, param: *mut fs_parameter) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_parse_fs_string(
        fc: *mut fs_context,
        key: *const core::ffi::c_char,
        value: *const core::ffi::c_char,
        v_size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_parse_monolithic(
        fc: *mut fs_context,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vfs_get_tree(fc: *mut fs_context) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_fs_context(fc: *mut fs_context);
}
extern "C" {
    pub fn vfs_parse_fs_param_source(
        fc: *mut fs_context,
        param: *mut fs_parameter,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fc_drop_locked(fc: *mut fs_context);
}
extern "C" {
    pub fn reconfigure_single(
        s: *mut super_block,
        flags: core::ffi::c_int,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
pub const vfs_get_super_keying_vfs_get_single_super: vfs_get_super_keying = 0;
pub const vfs_get_super_keying_vfs_get_single_reconf_super: vfs_get_super_keying = 1;
pub const vfs_get_super_keying_vfs_get_keyed_super: vfs_get_super_keying = 2;
pub const vfs_get_super_keying_vfs_get_independent_super: vfs_get_super_keying = 3;
pub type vfs_get_super_keying = core::ffi::c_uint;
extern "C" {
    pub fn vfs_get_super(
        fc: *mut fs_context,
        keying: vfs_get_super_keying,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, fc: *mut fs_context) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_tree_nodev(
        fc: *mut fs_context,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, fc: *mut fs_context) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_tree_single(
        fc: *mut fs_context,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, fc: *mut fs_context) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_tree_single_reconf(
        fc: *mut fs_context,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, fc: *mut fs_context) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_tree_keyed(
        fc: *mut fs_context,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, fc: *mut fs_context) -> core::ffi::c_int,
        >,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_tree_bdev(
        fc: *mut fs_context,
        fill_super: ::core::option::Option<
            unsafe extern "C" fn(sb: *mut super_block, fc: *mut fs_context) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static fscontext_fops: file_operations;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fc_log {
    pub usage: refcount_t,
    pub head: u8_,
    pub tail: u8_,
    pub need_free: u8_,
    pub owner: *mut module,
    pub buffer: [*mut core::ffi::c_char; 8usize],
}
impl Default for fc_log {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn logfc(
        log: *mut fc_log,
        prefix: *const core::ffi::c_char,
        level: core::ffi::c_char,
        fmt: *const core::ffi::c_char,
        ...
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct constant_table {
    pub name: *const core::ffi::c_char,
    pub value: core::ffi::c_int,
}
impl Default for constant_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type fs_param_type = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn fs_param_is_bool(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_param_is_u32(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_param_is_s32(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_param_is_u64(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_param_is_enum(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_param_is_string(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_param_is_blob(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_param_is_blockdev(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_param_is_path(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_param_is_fd(
        arg1: *mut p_log,
        arg2: *const fs_parameter_spec,
        arg3: *mut fs_parameter,
        arg4: *mut fs_parse_result,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parameter_spec {
    pub name: *const core::ffi::c_char,
    pub type_: fs_param_type,
    pub opt: u8_,
    pub flags: core::ffi::c_ushort,
    pub data: *const core::ffi::c_void,
}
impl Default for fs_parameter_spec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fs_parse_result {
    pub negated: bool_,
    pub __bindgen_anon_1: fs_parse_result__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fs_parse_result__bindgen_ty_1 {
    pub boolean: bool_,
    pub int_32: core::ffi::c_int,
    pub uint_32: core::ffi::c_uint,
    pub uint_64: u64_,
    _bindgen_union_align: u64,
}
impl Default for fs_parse_result__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for fs_parse_result {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __fs_parse(
        log: *mut p_log,
        desc: *const fs_parameter_spec,
        value: *mut fs_parameter,
        result: *mut fs_parse_result,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fs_lookup_param(
        fc: *mut fs_context,
        param: *mut fs_parameter,
        want_bdev: bool_,
        _path: *mut path,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lookup_constant(
        tbl: *const constant_table,
        name: *const core::ffi::c_char,
        not_found: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
pub const dev_prop_type_DEV_PROP_U8: dev_prop_type = 0;
pub const dev_prop_type_DEV_PROP_U16: dev_prop_type = 1;
pub const dev_prop_type_DEV_PROP_U32: dev_prop_type = 2;
pub const dev_prop_type_DEV_PROP_U64: dev_prop_type = 3;
pub const dev_prop_type_DEV_PROP_STRING: dev_prop_type = 4;
pub const dev_prop_type_DEV_PROP_REF: dev_prop_type = 5;
pub type dev_prop_type = core::ffi::c_uint;
pub const dev_dma_attr_DEV_DMA_NOT_SUPPORTED: dev_dma_attr = 0;
pub const dev_dma_attr_DEV_DMA_NON_COHERENT: dev_dma_attr = 1;
pub const dev_dma_attr_DEV_DMA_COHERENT: dev_dma_attr = 2;
pub type dev_dma_attr = i32;
extern "C" {
    pub fn dev_fwnode(dev: *const device) -> *mut fwnode_handle;
}
extern "C" {
    pub fn device_property_present(dev: *mut device, propname: *const core::ffi::c_char) -> bool_;
}
extern "C" {
    pub fn device_property_read_u8_array(
        dev: *mut device,
        propname: *const core::ffi::c_char,
        val: *mut u8_,
        nval: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_property_read_u16_array(
        dev: *mut device,
        propname: *const core::ffi::c_char,
        val: *mut u16_,
        nval: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_property_read_u32_array(
        dev: *mut device,
        propname: *const core::ffi::c_char,
        val: *mut u32_,
        nval: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_property_read_u64_array(
        dev: *mut device,
        propname: *const core::ffi::c_char,
        val: *mut u64_,
        nval: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_property_read_string_array(
        dev: *mut device,
        propname: *const core::ffi::c_char,
        val: *mut *const core::ffi::c_char,
        nval: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_property_read_string(
        dev: *mut device,
        propname: *const core::ffi::c_char,
        val: *mut *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_property_match_string(
        dev: *mut device,
        propname: *const core::ffi::c_char,
        string: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_device_is_available(fwnode: *const fwnode_handle) -> bool_;
}
extern "C" {
    pub fn fwnode_property_present(
        fwnode: *const fwnode_handle,
        propname: *const core::ffi::c_char,
    ) -> bool_;
}
extern "C" {
    pub fn fwnode_property_read_u8_array(
        fwnode: *const fwnode_handle,
        propname: *const core::ffi::c_char,
        val: *mut u8_,
        nval: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_property_read_u16_array(
        fwnode: *const fwnode_handle,
        propname: *const core::ffi::c_char,
        val: *mut u16_,
        nval: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_property_read_u32_array(
        fwnode: *const fwnode_handle,
        propname: *const core::ffi::c_char,
        val: *mut u32_,
        nval: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_property_read_u64_array(
        fwnode: *const fwnode_handle,
        propname: *const core::ffi::c_char,
        val: *mut u64_,
        nval: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_property_read_string_array(
        fwnode: *const fwnode_handle,
        propname: *const core::ffi::c_char,
        val: *mut *const core::ffi::c_char,
        nval: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_property_read_string(
        fwnode: *const fwnode_handle,
        propname: *const core::ffi::c_char,
        val: *mut *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_property_match_string(
        fwnode: *const fwnode_handle,
        propname: *const core::ffi::c_char,
        string: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_property_get_reference_args(
        fwnode: *const fwnode_handle,
        prop: *const core::ffi::c_char,
        nargs_prop: *const core::ffi::c_char,
        nargs: core::ffi::c_uint,
        index: core::ffi::c_uint,
        args: *mut fwnode_reference_args,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_find_reference(
        fwnode: *const fwnode_handle,
        name: *const core::ffi::c_char,
        index: core::ffi::c_uint,
    ) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_get_name(fwnode: *const fwnode_handle) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn fwnode_get_name_prefix(fwnode: *const fwnode_handle) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn fwnode_get_parent(fwnode: *const fwnode_handle) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_get_next_parent(fwnode: *mut fwnode_handle) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_get_next_parent_dev(fwnode: *mut fwnode_handle) -> *mut device;
}
extern "C" {
    pub fn fwnode_count_parents(fwn: *const fwnode_handle) -> core::ffi::c_uint;
}
extern "C" {
    pub fn fwnode_get_nth_parent(
        fwn: *mut fwnode_handle,
        depth: core::ffi::c_uint,
    ) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_is_ancestor_of(ancestor: *mut fwnode_handle, child: *mut fwnode_handle) -> bool_;
}
extern "C" {
    pub fn fwnode_get_next_child_node(
        fwnode: *const fwnode_handle,
        child: *mut fwnode_handle,
    ) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_get_next_available_child_node(
        fwnode: *const fwnode_handle,
        child: *mut fwnode_handle,
    ) -> *mut fwnode_handle;
}
extern "C" {
    pub fn device_get_next_child_node(
        dev: *mut device,
        child: *mut fwnode_handle,
    ) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_get_named_child_node(
        fwnode: *const fwnode_handle,
        childname: *const core::ffi::c_char,
    ) -> *mut fwnode_handle;
}
extern "C" {
    pub fn device_get_named_child_node(
        dev: *mut device,
        childname: *const core::ffi::c_char,
    ) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_handle_get(fwnode: *mut fwnode_handle) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_handle_put(fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn fwnode_irq_get(
        fwnode: *const fwnode_handle,
        index: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_irq_get_byname(
        fwnode: *const fwnode_handle,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_get_child_node_count(dev: *mut device) -> core::ffi::c_uint;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct software_node_ref_args {
    pub node: *const software_node,
    pub nargs: core::ffi::c_uint,
    pub args: [u64_; 8usize],
}
impl Default for software_node_ref_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct property_entry {
    pub name: *const core::ffi::c_char,
    pub length: usize,
    pub is_inline: bool_,
    pub type_: dev_prop_type,
    pub __bindgen_anon_1: property_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union property_entry__bindgen_ty_1 {
    pub pointer: *const core::ffi::c_void,
    pub value: property_entry__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union property_entry__bindgen_ty_1__bindgen_ty_1 {
    pub u8_data: [u8_; 8usize],
    pub u16_data: [u16_; 4usize],
    pub u32_data: [u32_; 2usize],
    pub u64_data: [u64_; 1usize],
    pub str_: [*const core::ffi::c_char; 1usize],
    _bindgen_union_align: u64,
}
impl Default for property_entry__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for property_entry__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for property_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn property_entries_dup(properties: *const property_entry) -> *mut property_entry;
}
extern "C" {
    pub fn property_entries_free(properties: *const property_entry);
}
extern "C" {
    pub fn device_dma_supported(dev: *mut device) -> bool_;
}
extern "C" {
    pub fn device_get_dma_attr(dev: *mut device) -> dev_dma_attr;
}
extern "C" {
    pub fn device_get_match_data(dev: *const device) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn device_get_phy_mode(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_get_phy_mode(fwnode: *mut fwnode_handle) -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_iomap(
        fwnode: *mut fwnode_handle,
        index: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn fwnode_graph_get_next_endpoint(
        fwnode: *const fwnode_handle,
        prev: *mut fwnode_handle,
    ) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_graph_get_port_parent(fwnode: *const fwnode_handle) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_graph_get_remote_port_parent(fwnode: *const fwnode_handle) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_graph_get_remote_port(fwnode: *const fwnode_handle) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_graph_get_remote_endpoint(fwnode: *const fwnode_handle) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_graph_get_endpoint_by_id(
        fwnode: *const fwnode_handle,
        port: u32_,
        endpoint: u32_,
        flags: core::ffi::c_ulong,
    ) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_graph_get_endpoint_count(
        fwnode: *mut fwnode_handle,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn fwnode_graph_parse_endpoint(
        fwnode: *const fwnode_handle,
        endpoint: *mut fwnode_endpoint,
    ) -> core::ffi::c_int;
}
pub type devcon_match_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        fwnode: *mut fwnode_handle,
        id: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void,
>;
extern "C" {
    pub fn fwnode_connection_find_match(
        fwnode: *mut fwnode_handle,
        con_id: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        match_: devcon_match_fn_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn fwnode_connection_find_matches(
        fwnode: *mut fwnode_handle,
        con_id: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        match_: devcon_match_fn_t,
        matches: *mut *mut core::ffi::c_void,
        matches_len: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct software_node {
    pub name: *const core::ffi::c_char,
    pub parent: *const software_node,
    pub properties: *const property_entry,
}
impl Default for software_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn is_software_node(fwnode: *const fwnode_handle) -> bool_;
}
extern "C" {
    pub fn to_software_node(fwnode: *const fwnode_handle) -> *const software_node;
}
extern "C" {
    pub fn software_node_fwnode(node: *const software_node) -> *mut fwnode_handle;
}
extern "C" {
    pub fn software_node_find_by_name(
        parent: *const software_node,
        name: *const core::ffi::c_char,
    ) -> *const software_node;
}
extern "C" {
    pub fn software_node_register_nodes(nodes: *const software_node) -> core::ffi::c_int;
}
extern "C" {
    pub fn software_node_unregister_nodes(nodes: *const software_node);
}
extern "C" {
    pub fn software_node_register_node_group(
        node_group: *mut *const software_node,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn software_node_unregister_node_group(node_group: *mut *const software_node);
}
extern "C" {
    pub fn software_node_register(node: *const software_node) -> core::ffi::c_int;
}
extern "C" {
    pub fn software_node_unregister(node: *const software_node);
}
extern "C" {
    pub fn fwnode_create_software_node(
        properties: *const property_entry,
        parent: *const fwnode_handle,
    ) -> *mut fwnode_handle;
}
extern "C" {
    pub fn fwnode_remove_software_node(fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn device_add_software_node(
        dev: *mut device,
        node: *const software_node,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_remove_software_node(dev: *mut device);
}
extern "C" {
    pub fn device_create_managed_software_node(
        dev: *mut device,
        properties: *const property_entry,
        parent: *const software_node,
    ) -> core::ffi::c_int;
}
pub type phandle = u32_;
pub type ihandle = u32_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct property {
    pub name: *mut core::ffi::c_char,
    pub length: core::ffi::c_int,
    pub value: *mut core::ffi::c_void,
    pub next: *mut property,
    pub attr: bin_attribute,
}
impl Default for property {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct device_node {
    pub name: *const core::ffi::c_char,
    pub phandle: phandle,
    pub full_name: *const core::ffi::c_char,
    pub fwnode: fwnode_handle,
    pub properties: *mut property,
    pub deadprops: *mut property,
    pub parent: *mut device_node,
    pub child: *mut device_node,
    pub sibling: *mut device_node,
    pub kobj: kobject,
    pub _flags: core::ffi::c_ulong,
    pub data: *mut core::ffi::c_void,
}
impl Default for device_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_phandle_args {
    pub np: *mut device_node,
    pub args_count: core::ffi::c_int,
    pub args: [u32; 16usize],
}
impl Default for of_phandle_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_phandle_iterator {
    pub cells_name: *const core::ffi::c_char,
    pub cell_count: core::ffi::c_int,
    pub parent: *const device_node,
    pub list_end: *const __be32,
    pub phandle_end: *const __be32,
    pub cur: *const __be32,
    pub cur_count: u32,
    pub phandle: phandle,
    pub node: *mut device_node,
}
impl Default for of_phandle_iterator {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_reconfig_data {
    pub dn: *mut device_node,
    pub prop: *mut property,
    pub old_prop: *mut property,
}
impl Default for of_reconfig_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut of_node_ktype: kobj_type;
}
extern "C" {
    pub static of_fwnode_ops: fwnode_operations;
}
extern "C" {
    pub static mut of_root: *mut device_node;
}
extern "C" {
    pub static mut of_chosen: *mut device_node;
}
extern "C" {
    pub static mut of_aliases: *mut device_node;
}
extern "C" {
    pub static mut of_stdout: *mut device_node;
}
extern "C" {
    pub static mut devtree_lock: raw_spinlock_t;
}
extern "C" {
    pub fn of_core_init();
}
extern "C" {
    pub fn __of_find_all_nodes(prev: *mut device_node) -> *mut device_node;
}
extern "C" {
    pub fn of_find_all_nodes(prev: *mut device_node) -> *mut device_node;
}
extern "C" {
    pub fn of_node_name_eq(np: *const device_node, name: *const core::ffi::c_char) -> bool_;
}
extern "C" {
    pub fn of_node_name_prefix(np: *const device_node, prefix: *const core::ffi::c_char) -> bool_;
}
extern "C" {
    pub fn of_find_node_by_name(
        from: *mut device_node,
        name: *const core::ffi::c_char,
    ) -> *mut device_node;
}
extern "C" {
    pub fn of_find_node_by_type(
        from: *mut device_node,
        type_: *const core::ffi::c_char,
    ) -> *mut device_node;
}
extern "C" {
    pub fn of_find_compatible_node(
        from: *mut device_node,
        type_: *const core::ffi::c_char,
        compat: *const core::ffi::c_char,
    ) -> *mut device_node;
}
extern "C" {
    pub fn of_find_matching_node_and_match(
        from: *mut device_node,
        matches: *const of_device_id,
        match_: *mut *const of_device_id,
    ) -> *mut device_node;
}
extern "C" {
    pub fn of_find_node_opts_by_path(
        path: *const core::ffi::c_char,
        opts: *mut *const core::ffi::c_char,
    ) -> *mut device_node;
}
extern "C" {
    pub fn of_find_node_by_phandle(handle: phandle) -> *mut device_node;
}
extern "C" {
    pub fn of_get_parent(node: *const device_node) -> *mut device_node;
}
extern "C" {
    pub fn of_get_next_parent(node: *mut device_node) -> *mut device_node;
}
extern "C" {
    pub fn of_get_next_child(node: *const device_node, prev: *mut device_node) -> *mut device_node;
}
extern "C" {
    pub fn of_get_next_available_child(
        node: *const device_node,
        prev: *mut device_node,
    ) -> *mut device_node;
}
extern "C" {
    pub fn of_get_compatible_child(
        parent: *const device_node,
        compatible: *const core::ffi::c_char,
    ) -> *mut device_node;
}
extern "C" {
    pub fn of_get_child_by_name(
        node: *const device_node,
        name: *const core::ffi::c_char,
    ) -> *mut device_node;
}
extern "C" {
    pub fn of_find_next_cache_node(arg1: *const device_node) -> *mut device_node;
}
extern "C" {
    pub fn of_find_last_cache_level(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_find_node_with_property(
        from: *mut device_node,
        prop_name: *const core::ffi::c_char,
    ) -> *mut device_node;
}
extern "C" {
    pub fn of_find_property(
        np: *const device_node,
        name: *const core::ffi::c_char,
        lenp: *mut core::ffi::c_int,
    ) -> *mut property;
}
extern "C" {
    pub fn of_property_count_elems_of_size(
        np: *const device_node,
        propname: *const core::ffi::c_char,
        elem_size: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_property_read_u32_index(
        np: *const device_node,
        propname: *const core::ffi::c_char,
        index: u32_,
        out_value: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_property_read_u64_index(
        np: *const device_node,
        propname: *const core::ffi::c_char,
        index: u32_,
        out_value: *mut u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_property_read_variable_u8_array(
        np: *const device_node,
        propname: *const core::ffi::c_char,
        out_values: *mut u8_,
        sz_min: usize,
        sz_max: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_property_read_variable_u16_array(
        np: *const device_node,
        propname: *const core::ffi::c_char,
        out_values: *mut u16_,
        sz_min: usize,
        sz_max: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_property_read_variable_u32_array(
        np: *const device_node,
        propname: *const core::ffi::c_char,
        out_values: *mut u32_,
        sz_min: usize,
        sz_max: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_property_read_u64(
        np: *const device_node,
        propname: *const core::ffi::c_char,
        out_value: *mut u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_property_read_variable_u64_array(
        np: *const device_node,
        propname: *const core::ffi::c_char,
        out_values: *mut u64_,
        sz_min: usize,
        sz_max: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_property_read_string(
        np: *const device_node,
        propname: *const core::ffi::c_char,
        out_string: *mut *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_property_match_string(
        np: *const device_node,
        propname: *const core::ffi::c_char,
        string: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_property_read_string_helper(
        np: *const device_node,
        propname: *const core::ffi::c_char,
        out_strs: *mut *const core::ffi::c_char,
        sz: usize,
        index: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_device_is_compatible(
        device: *const device_node,
        arg1: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_device_compatible_match(
        device: *const device_node,
        compat: *const *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_device_is_available(device: *const device_node) -> bool_;
}
extern "C" {
    pub fn of_device_is_big_endian(device: *const device_node) -> bool_;
}
extern "C" {
    pub fn of_get_property(
        node: *const device_node,
        name: *const core::ffi::c_char,
        lenp: *mut core::ffi::c_int,
    ) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn of_get_cpu_node(
        cpu: core::ffi::c_int,
        thread: *mut core::ffi::c_uint,
    ) -> *mut device_node;
}
extern "C" {
    pub fn of_get_next_cpu_node(prev: *mut device_node) -> *mut device_node;
}
extern "C" {
    pub fn of_get_cpu_state_node(
        cpu_node: *mut device_node,
        index: core::ffi::c_int,
    ) -> *mut device_node;
}
extern "C" {
    pub fn of_get_cpu_hwid(cpun: *mut device_node, thread: core::ffi::c_uint) -> u64_;
}
extern "C" {
    pub fn of_n_addr_cells(np: *mut device_node) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_n_size_cells(np: *mut device_node) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_match_node(
        matches: *const of_device_id,
        node: *const device_node,
    ) -> *const of_device_id;
}
extern "C" {
    pub fn of_modalias_node(
        node: *mut device_node,
        modalias: *mut core::ffi::c_char,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_print_phandle_args(msg: *const core::ffi::c_char, args: *const of_phandle_args);
}
extern "C" {
    pub fn __of_parse_phandle_with_args(
        np: *const device_node,
        list_name: *const core::ffi::c_char,
        cells_name: *const core::ffi::c_char,
        cell_count: core::ffi::c_int,
        index: core::ffi::c_int,
        out_args: *mut of_phandle_args,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_parse_phandle_with_args_map(
        np: *const device_node,
        list_name: *const core::ffi::c_char,
        stem_name: *const core::ffi::c_char,
        index: core::ffi::c_int,
        out_args: *mut of_phandle_args,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_count_phandle_with_args(
        np: *const device_node,
        list_name: *const core::ffi::c_char,
        cells_name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_phandle_iterator_init(
        it: *mut of_phandle_iterator,
        np: *const device_node,
        list_name: *const core::ffi::c_char,
        cells_name: *const core::ffi::c_char,
        cell_count: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_phandle_iterator_next(it: *mut of_phandle_iterator) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_phandle_iterator_args(
        it: *mut of_phandle_iterator,
        args: *mut u32,
        size: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_alias_scan(
        dt_alloc: ::core::option::Option<
            unsafe extern "C" fn(size: u64_, align: u64_) -> *mut core::ffi::c_void,
        >,
    );
}
extern "C" {
    pub fn of_alias_get_id(
        np: *mut device_node,
        stem: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_alias_get_highest_id(stem: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_machine_is_compatible(compat: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_add_property(np: *mut device_node, prop: *mut property) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_remove_property(np: *mut device_node, prop: *mut property) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_update_property(np: *mut device_node, newprop: *mut property) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_attach_node(arg1: *mut device_node) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_detach_node(arg1: *mut device_node) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_prop_next_u32(
        prop: *mut property,
        cur: *const __be32,
        pu: *mut u32_,
    ) -> *const __be32;
}
extern "C" {
    pub fn of_prop_next_string(
        prop: *mut property,
        cur: *const core::ffi::c_char,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn of_console_check(
        dn: *mut device_node,
        name: *mut core::ffi::c_char,
        index: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn of_cpu_node_to_id(np: *mut device_node) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_map_id(
        np: *mut device_node,
        id: u32_,
        map_name: *const core::ffi::c_char,
        map_mask_name: *const core::ffi::c_char,
        target: *mut *mut device_node,
        id_out: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_dma_get_max_cpu_address(np: *mut device_node) -> phys_addr_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kimage {
    _unused: [u8; 0],
}
extern "C" {
    pub fn of_kexec_alloc_and_setup_fdt(
        image: *const kimage,
        initrd_load_addr: core::ffi::c_ulong,
        initrd_len: core::ffi::c_ulong,
        cmdline: *const core::ffi::c_char,
        extra_fdt_size: usize,
    ) -> *mut core::ffi::c_void;
}
pub type of_init_fn_2 = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut device_node, arg2: *mut device_node) -> core::ffi::c_int,
>;
pub type of_init_fn_1_ret =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut device_node) -> core::ffi::c_int>;
pub type of_init_fn_1 = ::core::option::Option<unsafe extern "C" fn(arg1: *mut device_node)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_changeset_entry {
    pub node: list_head,
    pub action: core::ffi::c_ulong,
    pub np: *mut device_node,
    pub prop: *mut property,
    pub old_prop: *mut property,
}
impl Default for of_changeset_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_changeset {
    pub entries: list_head,
}
impl Default for of_changeset {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const of_reconfig_change_OF_RECONFIG_NO_CHANGE: of_reconfig_change = 0;
pub const of_reconfig_change_OF_RECONFIG_CHANGE_ADD: of_reconfig_change = 1;
pub const of_reconfig_change_OF_RECONFIG_CHANGE_REMOVE: of_reconfig_change = 2;
pub type of_reconfig_change = core::ffi::c_uint;
pub const of_overlay_notify_action_OF_OVERLAY_INIT: of_overlay_notify_action = 0;
pub const of_overlay_notify_action_OF_OVERLAY_PRE_APPLY: of_overlay_notify_action = 1;
pub const of_overlay_notify_action_OF_OVERLAY_POST_APPLY: of_overlay_notify_action = 2;
pub const of_overlay_notify_action_OF_OVERLAY_PRE_REMOVE: of_overlay_notify_action = 3;
pub const of_overlay_notify_action_OF_OVERLAY_POST_REMOVE: of_overlay_notify_action = 4;
pub type of_overlay_notify_action = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_overlay_notify_data {
    pub overlay: *mut device_node,
    pub target: *mut device_node,
}
impl Default for of_overlay_notify_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct irq_fwspec {
    pub fwnode: *mut fwnode_handle,
    pub param_count: core::ffi::c_int,
    pub param: [u32_; 16usize],
}
impl Default for irq_fwspec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn of_phandle_args_to_fwspec(
        np: *mut device_node,
        args: *const u32_,
        count: core::ffi::c_uint,
        fwspec: *mut irq_fwspec,
    );
}
pub const irq_domain_bus_token_DOMAIN_BUS_ANY: irq_domain_bus_token = 0;
pub const irq_domain_bus_token_DOMAIN_BUS_WIRED: irq_domain_bus_token = 1;
pub const irq_domain_bus_token_DOMAIN_BUS_GENERIC_MSI: irq_domain_bus_token = 2;
pub const irq_domain_bus_token_DOMAIN_BUS_PCI_MSI: irq_domain_bus_token = 3;
pub const irq_domain_bus_token_DOMAIN_BUS_PLATFORM_MSI: irq_domain_bus_token = 4;
pub const irq_domain_bus_token_DOMAIN_BUS_NEXUS: irq_domain_bus_token = 5;
pub const irq_domain_bus_token_DOMAIN_BUS_IPI: irq_domain_bus_token = 6;
pub const irq_domain_bus_token_DOMAIN_BUS_FSL_MC_MSI: irq_domain_bus_token = 7;
pub const irq_domain_bus_token_DOMAIN_BUS_TI_SCI_INTA_MSI: irq_domain_bus_token = 8;
pub const irq_domain_bus_token_DOMAIN_BUS_WAKEUP: irq_domain_bus_token = 9;
pub const irq_domain_bus_token_DOMAIN_BUS_VMD_MSI: irq_domain_bus_token = 10;
pub type irq_domain_bus_token = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct irq_domain_ops {
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(
            d: *mut irq_domain,
            node: *mut device_node,
            bus_token: irq_domain_bus_token,
        ) -> core::ffi::c_int,
    >,
    pub select: ::core::option::Option<
        unsafe extern "C" fn(
            d: *mut irq_domain,
            fwspec: *mut irq_fwspec,
            bus_token: irq_domain_bus_token,
        ) -> core::ffi::c_int,
    >,
    pub map: ::core::option::Option<
        unsafe extern "C" fn(
            d: *mut irq_domain,
            virq: core::ffi::c_uint,
            hw: irq_hw_number_t,
        ) -> core::ffi::c_int,
    >,
    pub unmap:
        ::core::option::Option<unsafe extern "C" fn(d: *mut irq_domain, virq: core::ffi::c_uint)>,
    pub xlate: ::core::option::Option<
        unsafe extern "C" fn(
            d: *mut irq_domain,
            node: *mut device_node,
            intspec: *const u32_,
            intsize: core::ffi::c_uint,
            out_hwirq: *mut core::ffi::c_ulong,
            out_type: *mut core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(
            d: *mut irq_domain,
            virq: core::ffi::c_uint,
            nr_irqs: core::ffi::c_uint,
            arg: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub free: ::core::option::Option<
        unsafe extern "C" fn(
            d: *mut irq_domain,
            virq: core::ffi::c_uint,
            nr_irqs: core::ffi::c_uint,
        ),
    >,
    pub activate: ::core::option::Option<
        unsafe extern "C" fn(
            d: *mut irq_domain,
            irqd: *mut irq_data,
            reserve: bool_,
        ) -> core::ffi::c_int,
    >,
    pub deactivate:
        ::core::option::Option<unsafe extern "C" fn(d: *mut irq_domain, irq_data: *mut irq_data)>,
    pub translate: ::core::option::Option<
        unsafe extern "C" fn(
            d: *mut irq_domain,
            fwspec: *mut irq_fwspec,
            out_hwirq: *mut core::ffi::c_ulong,
            out_type: *mut core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub static irq_generic_chip_ops: irq_domain_ops;
}
#[repr(C)]
pub struct irq_domain {
    pub link: list_head,
    pub name: *const core::ffi::c_char,
    pub ops: *const irq_domain_ops,
    pub host_data: *mut core::ffi::c_void,
    pub flags: core::ffi::c_uint,
    pub mapcount: core::ffi::c_uint,
    pub fwnode: *mut fwnode_handle,
    pub bus_token: irq_domain_bus_token,
    pub gc: *mut irq_domain_chip_generic,
    pub dev: *mut device,
    pub parent: *mut irq_domain,
    pub hwirq_max: irq_hw_number_t,
    pub revmap_size: core::ffi::c_uint,
    pub revmap_tree: xarray,
    pub revmap_mutex: mutex,
    pub revmap: __IncompleteArrayField<*mut irq_data>,
}
impl Default for irq_domain {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const IRQ_DOMAIN_FLAG_HIERARCHY: core::ffi::c_uint = 1;
pub const IRQ_DOMAIN_NAME_ALLOCATED: core::ffi::c_uint = 2;
pub const IRQ_DOMAIN_FLAG_IPI_PER_CPU: core::ffi::c_uint = 4;
pub const IRQ_DOMAIN_FLAG_IPI_SINGLE: core::ffi::c_uint = 8;
pub const IRQ_DOMAIN_FLAG_MSI: core::ffi::c_uint = 16;
pub const IRQ_DOMAIN_FLAG_MSI_REMAP: core::ffi::c_uint = 32;
pub const IRQ_DOMAIN_MSI_NOMASK_QUIRK: core::ffi::c_uint = 64;
pub const IRQ_DOMAIN_FLAG_NO_MAP: core::ffi::c_uint = 128;
pub const IRQ_DOMAIN_FLAG_NONCORE: core::ffi::c_uint = 65536;
pub type _bindgen_ty_117 = core::ffi::c_uint;
extern "C" {
    pub fn __irq_domain_alloc_fwnode(
        type_: core::ffi::c_uint,
        id: core::ffi::c_int,
        name: *const core::ffi::c_char,
        pa: *mut phys_addr_t,
    ) -> *mut fwnode_handle;
}
pub const IRQCHIP_FWNODE_REAL: core::ffi::c_uint = 0;
pub const IRQCHIP_FWNODE_NAMED: core::ffi::c_uint = 1;
pub const IRQCHIP_FWNODE_NAMED_ID: core::ffi::c_uint = 2;
pub type _bindgen_ty_118 = core::ffi::c_uint;
extern "C" {
    pub fn irq_domain_free_fwnode(fwnode: *mut fwnode_handle);
}
extern "C" {
    pub fn __irq_domain_add(
        fwnode: *mut fwnode_handle,
        size: core::ffi::c_uint,
        hwirq_max: irq_hw_number_t,
        direct_max: core::ffi::c_int,
        ops: *const irq_domain_ops,
        host_data: *mut core::ffi::c_void,
    ) -> *mut irq_domain;
}
extern "C" {
    pub fn irq_domain_create_simple(
        fwnode: *mut fwnode_handle,
        size: core::ffi::c_uint,
        first_irq: core::ffi::c_uint,
        ops: *const irq_domain_ops,
        host_data: *mut core::ffi::c_void,
    ) -> *mut irq_domain;
}
extern "C" {
    pub fn irq_domain_add_legacy(
        of_node: *mut device_node,
        size: core::ffi::c_uint,
        first_irq: core::ffi::c_uint,
        first_hwirq: irq_hw_number_t,
        ops: *const irq_domain_ops,
        host_data: *mut core::ffi::c_void,
    ) -> *mut irq_domain;
}
extern "C" {
    pub fn irq_domain_create_legacy(
        fwnode: *mut fwnode_handle,
        size: core::ffi::c_uint,
        first_irq: core::ffi::c_uint,
        first_hwirq: irq_hw_number_t,
        ops: *const irq_domain_ops,
        host_data: *mut core::ffi::c_void,
    ) -> *mut irq_domain;
}
extern "C" {
    pub fn irq_find_matching_fwspec(
        fwspec: *mut irq_fwspec,
        bus_token: irq_domain_bus_token,
    ) -> *mut irq_domain;
}
extern "C" {
    pub fn irq_domain_check_msi_remap() -> bool_;
}
extern "C" {
    pub fn irq_set_default_host(host: *mut irq_domain);
}
extern "C" {
    pub fn irq_get_default_host() -> *mut irq_domain;
}
extern "C" {
    pub fn irq_domain_alloc_descs(
        virq: core::ffi::c_int,
        nr_irqs: core::ffi::c_uint,
        hwirq: irq_hw_number_t,
        node: core::ffi::c_int,
        affinity: *const irq_affinity_desc,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static irqchip_fwnode_ops: fwnode_operations;
}
extern "C" {
    pub fn irq_domain_update_bus_token(domain: *mut irq_domain, bus_token: irq_domain_bus_token);
}
extern "C" {
    pub fn irq_domain_remove(host: *mut irq_domain);
}
extern "C" {
    pub fn irq_domain_associate(
        domain: *mut irq_domain,
        irq: core::ffi::c_uint,
        hwirq: irq_hw_number_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_associate_many(
        domain: *mut irq_domain,
        irq_base: core::ffi::c_uint,
        hwirq_base: irq_hw_number_t,
        count: core::ffi::c_int,
    );
}
extern "C" {
    pub fn irq_create_mapping_affinity(
        host: *mut irq_domain,
        hwirq: irq_hw_number_t,
        affinity: *const irq_affinity_desc,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn irq_create_fwspec_mapping(fwspec: *mut irq_fwspec) -> core::ffi::c_uint;
}
extern "C" {
    pub fn irq_dispose_mapping(virq: core::ffi::c_uint);
}
extern "C" {
    pub fn __irq_resolve_mapping(
        domain: *mut irq_domain,
        hwirq: irq_hw_number_t,
        irq: *mut core::ffi::c_uint,
    ) -> *mut irq_desc;
}
extern "C" {
    pub static irq_domain_simple_ops: irq_domain_ops;
}
extern "C" {
    pub fn irq_domain_xlate_onecell(
        d: *mut irq_domain,
        ctrlr: *mut device_node,
        intspec: *const u32_,
        intsize: core::ffi::c_uint,
        out_hwirq: *mut irq_hw_number_t,
        out_type: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_xlate_twocell(
        d: *mut irq_domain,
        ctrlr: *mut device_node,
        intspec: *const u32_,
        intsize: core::ffi::c_uint,
        out_hwirq: *mut irq_hw_number_t,
        out_type: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_xlate_onetwocell(
        d: *mut irq_domain,
        ctrlr: *mut device_node,
        intspec: *const u32_,
        intsize: core::ffi::c_uint,
        out_hwirq: *mut irq_hw_number_t,
        out_type: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_translate_twocell(
        d: *mut irq_domain,
        fwspec: *mut irq_fwspec,
        out_hwirq: *mut core::ffi::c_ulong,
        out_type: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_translate_onecell(
        d: *mut irq_domain,
        fwspec: *mut irq_fwspec,
        out_hwirq: *mut core::ffi::c_ulong,
        out_type: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_reserve_ipi(domain: *mut irq_domain, dest: *const cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_destroy_ipi(irq: core::ffi::c_uint, dest: *const cpumask) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_get_irq_data(
        domain: *mut irq_domain,
        virq: core::ffi::c_uint,
    ) -> *mut irq_data;
}
extern "C" {
    pub fn irq_domain_set_info(
        domain: *mut irq_domain,
        virq: core::ffi::c_uint,
        hwirq: irq_hw_number_t,
        chip: *const irq_chip,
        chip_data: *mut core::ffi::c_void,
        handler: irq_flow_handler_t,
        handler_data: *mut core::ffi::c_void,
        handler_name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn irq_domain_reset_irq_data(irq_data: *mut irq_data);
}
extern "C" {
    pub fn irq_domain_create_hierarchy(
        parent: *mut irq_domain,
        flags: core::ffi::c_uint,
        size: core::ffi::c_uint,
        fwnode: *mut fwnode_handle,
        ops: *const irq_domain_ops,
        host_data: *mut core::ffi::c_void,
    ) -> *mut irq_domain;
}
extern "C" {
    pub fn __irq_domain_alloc_irqs(
        domain: *mut irq_domain,
        irq_base: core::ffi::c_int,
        nr_irqs: core::ffi::c_uint,
        node: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
        realloc: bool_,
        affinity: *const irq_affinity_desc,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_free_irqs(virq: core::ffi::c_uint, nr_irqs: core::ffi::c_uint);
}
extern "C" {
    pub fn irq_domain_activate_irq(irq_data: *mut irq_data, early: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_deactivate_irq(irq_data: *mut irq_data);
}
extern "C" {
    pub fn irq_domain_alloc_irqs_hierarchy(
        domain: *mut irq_domain,
        irq_base: core::ffi::c_uint,
        nr_irqs: core::ffi::c_uint,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_set_hwirq_and_chip(
        domain: *mut irq_domain,
        virq: core::ffi::c_uint,
        hwirq: irq_hw_number_t,
        chip: *const irq_chip,
        chip_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_free_irqs_common(
        domain: *mut irq_domain,
        virq: core::ffi::c_uint,
        nr_irqs: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn irq_domain_free_irqs_top(
        domain: *mut irq_domain,
        virq: core::ffi::c_uint,
        nr_irqs: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn irq_domain_push_irq(
        domain: *mut irq_domain,
        virq: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_pop_irq(domain: *mut irq_domain, virq: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_alloc_irqs_parent(
        domain: *mut irq_domain,
        irq_base: core::ffi::c_uint,
        nr_irqs: core::ffi::c_uint,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_free_irqs_parent(
        domain: *mut irq_domain,
        irq_base: core::ffi::c_uint,
        nr_irqs: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn irq_domain_disconnect_hierarchy(
        domain: *mut irq_domain,
        virq: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn irq_domain_hierarchical_is_msi_remap(domain: *mut irq_domain) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinctrl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinctrl_state {
    _unused: [u8; 0],
}
extern "C" {
    pub fn pinctrl_gpio_can_use_line(gpio: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn pinctrl_gpio_request(gpio: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinctrl_gpio_free(gpio: core::ffi::c_uint);
}
extern "C" {
    pub fn pinctrl_gpio_direction_input(gpio: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinctrl_gpio_direction_output(gpio: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinctrl_gpio_set_config(
        gpio: core::ffi::c_uint,
        config: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinctrl_get(dev: *mut device) -> *mut pinctrl;
}
extern "C" {
    pub fn pinctrl_put(p: *mut pinctrl);
}
extern "C" {
    pub fn pinctrl_lookup_state(
        p: *mut pinctrl,
        name: *const core::ffi::c_char,
    ) -> *mut pinctrl_state;
}
extern "C" {
    pub fn pinctrl_select_state(p: *mut pinctrl, s: *mut pinctrl_state) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_pinctrl_get(dev: *mut device) -> *mut pinctrl;
}
extern "C" {
    pub fn devm_pinctrl_put(p: *mut pinctrl);
}
extern "C" {
    pub fn pinctrl_select_default_state(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinctrl_pm_select_default_state(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinctrl_pm_select_sleep_state(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinctrl_pm_select_idle_state(dev: *mut device) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dev_pin_info {
    pub p: *mut pinctrl,
    pub default_state: *mut pinctrl_state,
    pub init_state: *mut pinctrl_state,
    pub sleep_state: *mut pinctrl_state,
    pub idle_state: *mut pinctrl_state,
}
impl Default for dev_pin_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn pinctrl_bind_pins(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinctrl_init_done(dev: *mut device) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinctrl_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinmux_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinconf_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pingroup {
    pub name: *const core::ffi::c_char,
    pub pins: *const core::ffi::c_uint,
    pub npins: usize,
}
impl Default for pingroup {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinctrl_pin_desc {
    pub number: core::ffi::c_uint,
    pub name: *const core::ffi::c_char,
    pub drv_data: *mut core::ffi::c_void,
}
impl Default for pinctrl_pin_desc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinctrl_gpio_range {
    pub node: list_head,
    pub name: *const core::ffi::c_char,
    pub id: core::ffi::c_uint,
    pub base: core::ffi::c_uint,
    pub pin_base: core::ffi::c_uint,
    pub npins: core::ffi::c_uint,
    pub pins: *const core::ffi::c_uint,
    pub gc: *mut gpio_chip,
}
impl Default for pinctrl_gpio_range {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pinctrl_ops {
    pub get_groups_count:
        ::core::option::Option<unsafe extern "C" fn(pctldev: *mut pinctrl_dev) -> core::ffi::c_int>,
    pub get_group_name: ::core::option::Option<
        unsafe extern "C" fn(
            pctldev: *mut pinctrl_dev,
            selector: core::ffi::c_uint,
        ) -> *const core::ffi::c_char,
    >,
    pub get_group_pins: ::core::option::Option<
        unsafe extern "C" fn(
            pctldev: *mut pinctrl_dev,
            selector: core::ffi::c_uint,
            pins: *mut *const core::ffi::c_uint,
            num_pins: *mut core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub pin_dbg_show: ::core::option::Option<
        unsafe extern "C" fn(
            pctldev: *mut pinctrl_dev,
            s: *mut seq_file,
            offset: core::ffi::c_uint,
        ),
    >,
    pub dt_node_to_map: ::core::option::Option<
        unsafe extern "C" fn(
            pctldev: *mut pinctrl_dev,
            np_config: *mut device_node,
            map: *mut *mut pinctrl_map,
            num_maps: *mut core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub dt_free_map: ::core::option::Option<
        unsafe extern "C" fn(
            pctldev: *mut pinctrl_dev,
            map: *mut pinctrl_map,
            num_maps: core::ffi::c_uint,
        ),
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinctrl_desc {
    pub name: *const core::ffi::c_char,
    pub pins: *const pinctrl_pin_desc,
    pub npins: core::ffi::c_uint,
    pub pctlops: *const pinctrl_ops,
    pub pmxops: *const pinmux_ops,
    pub confops: *const pinconf_ops,
    pub owner: *mut module,
    pub num_custom_params: core::ffi::c_uint,
    pub custom_params: *const pinconf_generic_params,
    pub custom_conf_items: *const pin_config_item,
    pub link_consumers: bool_,
}
impl Default for pinctrl_desc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn pinctrl_register_and_init(
        pctldesc: *mut pinctrl_desc,
        dev: *mut device,
        driver_data: *mut core::ffi::c_void,
        pctldev: *mut *mut pinctrl_dev,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinctrl_enable(pctldev: *mut pinctrl_dev) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinctrl_register(
        pctldesc: *mut pinctrl_desc,
        dev: *mut device,
        driver_data: *mut core::ffi::c_void,
    ) -> *mut pinctrl_dev;
}
extern "C" {
    pub fn pinctrl_unregister(pctldev: *mut pinctrl_dev);
}
extern "C" {
    pub fn devm_pinctrl_register_and_init(
        dev: *mut device,
        pctldesc: *mut pinctrl_desc,
        driver_data: *mut core::ffi::c_void,
        pctldev: *mut *mut pinctrl_dev,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_pinctrl_register(
        dev: *mut device,
        pctldesc: *mut pinctrl_desc,
        driver_data: *mut core::ffi::c_void,
    ) -> *mut pinctrl_dev;
}
extern "C" {
    pub fn devm_pinctrl_unregister(dev: *mut device, pctldev: *mut pinctrl_dev);
}
extern "C" {
    pub fn pinctrl_add_gpio_range(pctldev: *mut pinctrl_dev, range: *mut pinctrl_gpio_range);
}
extern "C" {
    pub fn pinctrl_add_gpio_ranges(
        pctldev: *mut pinctrl_dev,
        ranges: *mut pinctrl_gpio_range,
        nranges: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn pinctrl_remove_gpio_range(pctldev: *mut pinctrl_dev, range: *mut pinctrl_gpio_range);
}
extern "C" {
    pub fn pinctrl_find_and_add_gpio_range(
        devname: *const core::ffi::c_char,
        range: *mut pinctrl_gpio_range,
    ) -> *mut pinctrl_dev;
}
extern "C" {
    pub fn pinctrl_find_gpio_range_from_pin(
        pctldev: *mut pinctrl_dev,
        pin: core::ffi::c_uint,
    ) -> *mut pinctrl_gpio_range;
}
extern "C" {
    pub fn pinctrl_get_group_pins(
        pctldev: *mut pinctrl_dev,
        pin_group: *const core::ffi::c_char,
        pins: *mut *const core::ffi::c_uint,
        num_pins: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_pinctrl_get(np: *mut device_node) -> *mut pinctrl_dev;
}
extern "C" {
    pub fn pinctrl_dev_get_name(pctldev: *mut pinctrl_dev) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn pinctrl_dev_get_devname(pctldev: *mut pinctrl_dev) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn pinctrl_dev_get_drvdata(pctldev: *mut pinctrl_dev) -> *mut core::ffi::c_void;
}
pub const pinctrl_map_type_PIN_MAP_TYPE_INVALID: pinctrl_map_type = 0;
pub const pinctrl_map_type_PIN_MAP_TYPE_DUMMY_STATE: pinctrl_map_type = 1;
pub const pinctrl_map_type_PIN_MAP_TYPE_MUX_GROUP: pinctrl_map_type = 2;
pub const pinctrl_map_type_PIN_MAP_TYPE_CONFIGS_PIN: pinctrl_map_type = 3;
pub const pinctrl_map_type_PIN_MAP_TYPE_CONFIGS_GROUP: pinctrl_map_type = 4;
pub type pinctrl_map_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinctrl_map_mux {
    pub group: *const core::ffi::c_char,
    pub function: *const core::ffi::c_char,
}
impl Default for pinctrl_map_mux {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinctrl_map_configs {
    pub group_or_pin: *const core::ffi::c_char,
    pub configs: *mut core::ffi::c_ulong,
    pub num_configs: core::ffi::c_uint,
}
impl Default for pinctrl_map_configs {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinctrl_map {
    pub dev_name: *const core::ffi::c_char,
    pub name: *const core::ffi::c_char,
    pub type_: pinctrl_map_type,
    pub ctrl_dev_name: *const core::ffi::c_char,
    pub data: pinctrl_map__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pinctrl_map__bindgen_ty_1 {
    pub mux: pinctrl_map_mux,
    pub configs: pinctrl_map_configs,
    _bindgen_union_align: [u64; 3usize],
}
impl Default for pinctrl_map__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for pinctrl_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn pinctrl_register_mappings(
        map: *const pinctrl_map,
        num_maps: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinctrl_unregister_mappings(map: *const pinctrl_map);
}
extern "C" {
    pub fn pinctrl_provide_dummies();
}
pub const pin_config_param_PIN_CONFIG_BIAS_BUS_HOLD: pin_config_param = 0;
pub const pin_config_param_PIN_CONFIG_BIAS_DISABLE: pin_config_param = 1;
pub const pin_config_param_PIN_CONFIG_BIAS_HIGH_IMPEDANCE: pin_config_param = 2;
pub const pin_config_param_PIN_CONFIG_BIAS_PULL_DOWN: pin_config_param = 3;
pub const pin_config_param_PIN_CONFIG_BIAS_PULL_PIN_DEFAULT: pin_config_param = 4;
pub const pin_config_param_PIN_CONFIG_BIAS_PULL_UP: pin_config_param = 5;
pub const pin_config_param_PIN_CONFIG_DRIVE_OPEN_DRAIN: pin_config_param = 6;
pub const pin_config_param_PIN_CONFIG_DRIVE_OPEN_SOURCE: pin_config_param = 7;
pub const pin_config_param_PIN_CONFIG_DRIVE_PUSH_PULL: pin_config_param = 8;
pub const pin_config_param_PIN_CONFIG_DRIVE_STRENGTH: pin_config_param = 9;
pub const pin_config_param_PIN_CONFIG_DRIVE_STRENGTH_UA: pin_config_param = 10;
pub const pin_config_param_PIN_CONFIG_INPUT_DEBOUNCE: pin_config_param = 11;
pub const pin_config_param_PIN_CONFIG_INPUT_ENABLE: pin_config_param = 12;
pub const pin_config_param_PIN_CONFIG_INPUT_SCHMITT: pin_config_param = 13;
pub const pin_config_param_PIN_CONFIG_INPUT_SCHMITT_ENABLE: pin_config_param = 14;
pub const pin_config_param_PIN_CONFIG_MODE_LOW_POWER: pin_config_param = 15;
pub const pin_config_param_PIN_CONFIG_MODE_PWM: pin_config_param = 16;
pub const pin_config_param_PIN_CONFIG_OUTPUT: pin_config_param = 17;
pub const pin_config_param_PIN_CONFIG_OUTPUT_ENABLE: pin_config_param = 18;
pub const pin_config_param_PIN_CONFIG_OUTPUT_IMPEDANCE_OHMS: pin_config_param = 19;
pub const pin_config_param_PIN_CONFIG_PERSIST_STATE: pin_config_param = 20;
pub const pin_config_param_PIN_CONFIG_POWER_SOURCE: pin_config_param = 21;
pub const pin_config_param_PIN_CONFIG_SKEW_DELAY: pin_config_param = 22;
pub const pin_config_param_PIN_CONFIG_SLEEP_HARDWARE_STATE: pin_config_param = 23;
pub const pin_config_param_PIN_CONFIG_SLEW_RATE: pin_config_param = 24;
pub const pin_config_param_PIN_CONFIG_END: pin_config_param = 127;
pub const pin_config_param_PIN_CONFIG_MAX: pin_config_param = 255;
pub type pin_config_param = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pin_config_item {
    pub param: pin_config_param,
    pub display: *const core::ffi::c_char,
    pub format: *const core::ffi::c_char,
    pub has_arg: bool_,
}
impl Default for pin_config_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pinconf_generic_params {
    pub property: *const core::ffi::c_char,
    pub param: pin_config_param,
    pub default_value: u32_,
}
impl Default for pinconf_generic_params {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn pinconf_generic_dt_subnode_to_map(
        pctldev: *mut pinctrl_dev,
        np: *mut device_node,
        map: *mut *mut pinctrl_map,
        reserved_maps: *mut core::ffi::c_uint,
        num_maps: *mut core::ffi::c_uint,
        type_: pinctrl_map_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinconf_generic_dt_node_to_map(
        pctldev: *mut pinctrl_dev,
        np_config: *mut device_node,
        map: *mut *mut pinctrl_map,
        num_maps: *mut core::ffi::c_uint,
        type_: pinctrl_map_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pinconf_generic_dt_free_map(
        pctldev: *mut pinctrl_dev,
        map: *mut pinctrl_map,
        num_maps: core::ffi::c_uint,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct msi_alloc_info {
    pub desc: *mut msi_desc,
    pub hwirq: irq_hw_number_t,
    pub flags: core::ffi::c_ulong,
    pub scratchpad: [msi_alloc_info__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union msi_alloc_info__bindgen_ty_1 {
    pub ul: core::ffi::c_ulong,
    pub ptr: *mut core::ffi::c_void,
    _bindgen_union_align: u64,
}
impl Default for msi_alloc_info__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for msi_alloc_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type msi_alloc_info_t = msi_alloc_info;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_desc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_device {
    _unused: [u8; 0],
}
pub type gpiod_flags = i32;
pub type gpio_lookup_flags = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_irq_fwspec {
    pub fwspec: irq_fwspec,
    pub msiinfo: msi_alloc_info_t,
    _bindgen_union_align: [u64; 10usize],
}
impl Default for gpio_irq_fwspec {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_irq_chip {
    pub chip: *mut irq_chip,
    pub domain: *mut irq_domain,
    pub domain_ops: *const irq_domain_ops,
    pub fwnode: *mut fwnode_handle,
    pub parent_domain: *mut irq_domain,
    pub child_to_parent_hwirq: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            child_hwirq: core::ffi::c_uint,
            child_type: core::ffi::c_uint,
            parent_hwirq: *mut core::ffi::c_uint,
            parent_type: *mut core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub populate_parent_alloc_arg: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            fwspec: *mut gpio_irq_fwspec,
            parent_hwirq: core::ffi::c_uint,
            parent_type: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub child_offset_to_irq: ::core::option::Option<
        unsafe extern "C" fn(gc: *mut gpio_chip, pin: core::ffi::c_uint) -> core::ffi::c_uint,
    >,
    pub child_irq_domain_ops: irq_domain_ops,
    pub handler: irq_flow_handler_t,
    pub default_type: core::ffi::c_uint,
    pub lock_key: *mut lock_class_key,
    pub request_key: *mut lock_class_key,
    pub parent_handler: irq_flow_handler_t,
    pub __bindgen_anon_1: gpio_irq_chip__bindgen_ty_1,
    pub num_parents: core::ffi::c_uint,
    pub parents: *mut core::ffi::c_uint,
    pub map: *mut core::ffi::c_uint,
    pub threaded: bool_,
    pub per_parent_data: bool_,
    pub initialized: bool_,
    pub init_hw:
        ::core::option::Option<unsafe extern "C" fn(gc: *mut gpio_chip) -> core::ffi::c_int>,
    pub init_valid_mask: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            valid_mask: *mut core::ffi::c_ulong,
            ngpios: core::ffi::c_uint,
        ),
    >,
    pub valid_mask: *mut core::ffi::c_ulong,
    pub first: core::ffi::c_uint,
    pub irq_enable: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_disable: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_unmask: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
    pub irq_mask: ::core::option::Option<unsafe extern "C" fn(data: *mut irq_data)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union gpio_irq_chip__bindgen_ty_1 {
    pub parent_handler_data: *mut core::ffi::c_void,
    pub parent_handler_data_array: *mut *mut core::ffi::c_void,
    _bindgen_union_align: u64,
}
impl Default for gpio_irq_chip__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for gpio_irq_chip {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_chip {
    pub label: *const core::ffi::c_char,
    pub gpiodev: *mut gpio_device,
    pub parent: *mut device,
    pub fwnode: *mut fwnode_handle,
    pub owner: *mut module,
    pub request: ::core::option::Option<
        unsafe extern "C" fn(gc: *mut gpio_chip, offset: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub free:
        ::core::option::Option<unsafe extern "C" fn(gc: *mut gpio_chip, offset: core::ffi::c_uint)>,
    pub get_direction: ::core::option::Option<
        unsafe extern "C" fn(gc: *mut gpio_chip, offset: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub direction_input: ::core::option::Option<
        unsafe extern "C" fn(gc: *mut gpio_chip, offset: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub direction_output: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            offset: core::ffi::c_uint,
            value: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(gc: *mut gpio_chip, offset: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub get_multiple: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            mask: *mut core::ffi::c_ulong,
            bits: *mut core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            offset: core::ffi::c_uint,
            value: core::ffi::c_int,
        ),
    >,
    pub set_multiple: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            mask: *mut core::ffi::c_ulong,
            bits: *mut core::ffi::c_ulong,
        ),
    >,
    pub set_config: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            offset: core::ffi::c_uint,
            config: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub to_irq: ::core::option::Option<
        unsafe extern "C" fn(gc: *mut gpio_chip, offset: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub dbg_show:
        ::core::option::Option<unsafe extern "C" fn(s: *mut seq_file, gc: *mut gpio_chip)>,
    pub init_valid_mask: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            valid_mask: *mut core::ffi::c_ulong,
            ngpios: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub add_pin_ranges:
        ::core::option::Option<unsafe extern "C" fn(gc: *mut gpio_chip) -> core::ffi::c_int>,
    pub en_hw_timestamp: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            offset: u32_,
            flags: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub dis_hw_timestamp: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            offset: u32_,
            flags: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub base: core::ffi::c_int,
    pub ngpio: u16_,
    pub offset: u16_,
    pub names: *const *const core::ffi::c_char,
    pub can_sleep: bool_,
    pub read_reg: ::core::option::Option<
        unsafe extern "C" fn(reg: *mut core::ffi::c_void) -> core::ffi::c_ulong,
    >,
    pub write_reg: ::core::option::Option<
        unsafe extern "C" fn(reg: *mut core::ffi::c_void, data: core::ffi::c_ulong),
    >,
    pub be_bits: bool_,
    pub reg_dat: *mut core::ffi::c_void,
    pub reg_set: *mut core::ffi::c_void,
    pub reg_clr: *mut core::ffi::c_void,
    pub reg_dir_out: *mut core::ffi::c_void,
    pub reg_dir_in: *mut core::ffi::c_void,
    pub bgpio_dir_unreadable: bool_,
    pub bgpio_bits: core::ffi::c_int,
    pub bgpio_lock: raw_spinlock_t,
    pub bgpio_data: core::ffi::c_ulong,
    pub bgpio_dir: core::ffi::c_ulong,
    pub irq: gpio_irq_chip,
    pub valid_mask: *mut core::ffi::c_ulong,
    pub of_node: *mut device_node,
    pub of_gpio_n_cells: core::ffi::c_uint,
    pub of_xlate: ::core::option::Option<
        unsafe extern "C" fn(
            gc: *mut gpio_chip,
            gpiospec: *const of_phandle_args,
            flags: *mut u32_,
        ) -> core::ffi::c_int,
    >,
    pub of_gpio_ranges_fallback: ::core::option::Option<
        unsafe extern "C" fn(gc: *mut gpio_chip, np: *mut device_node) -> core::ffi::c_int,
    >,
}
impl Default for gpio_chip {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn gpiochip_is_requested(
        gc: *mut gpio_chip,
        offset: core::ffi::c_uint,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn gpiochip_add_data_with_key(
        gc: *mut gpio_chip,
        data: *mut core::ffi::c_void,
        lock_key: *mut lock_class_key,
        request_key: *mut lock_class_key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_remove(gc: *mut gpio_chip);
}
extern "C" {
    pub fn devm_gpiochip_add_data_with_key(
        dev: *mut device,
        gc: *mut gpio_chip,
        data: *mut core::ffi::c_void,
        lock_key: *mut lock_class_key,
        request_key: *mut lock_class_key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_find(
        data: *mut core::ffi::c_void,
        match_: ::core::option::Option<
            unsafe extern "C" fn(
                gc: *mut gpio_chip,
                data: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
    ) -> *mut gpio_chip;
}
extern "C" {
    pub fn gpiochip_line_is_irq(gc: *mut gpio_chip, offset: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn gpiochip_reqres_irq(gc: *mut gpio_chip, offset: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_relres_irq(gc: *mut gpio_chip, offset: core::ffi::c_uint);
}
extern "C" {
    pub fn gpiochip_disable_irq(gc: *mut gpio_chip, offset: core::ffi::c_uint);
}
extern "C" {
    pub fn gpiochip_enable_irq(gc: *mut gpio_chip, offset: core::ffi::c_uint);
}
extern "C" {
    pub fn gpiochip_irq_reqres(data: *mut irq_data) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_irq_relres(data: *mut irq_data);
}
extern "C" {
    pub fn gpiochip_line_is_open_drain(gc: *mut gpio_chip, offset: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn gpiochip_line_is_open_source(gc: *mut gpio_chip, offset: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn gpiochip_line_is_persistent(gc: *mut gpio_chip, offset: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn gpiochip_line_is_valid(gc: *const gpio_chip, offset: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn gpiochip_get_data(gc: *mut gpio_chip) -> *mut core::ffi::c_void;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bgpio_pdata {
    pub label: *const core::ffi::c_char,
    pub base: core::ffi::c_int,
    pub ngpio: core::ffi::c_int,
}
impl Default for bgpio_pdata {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn gpiochip_populate_parent_fwspec_twocell(
        gc: *mut gpio_chip,
        gfwspec: *mut gpio_irq_fwspec,
        parent_hwirq: core::ffi::c_uint,
        parent_type: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_populate_parent_fwspec_fourcell(
        gc: *mut gpio_chip,
        gfwspec: *mut gpio_irq_fwspec,
        parent_hwirq: core::ffi::c_uint,
        parent_type: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bgpio_init(
        gc: *mut gpio_chip,
        dev: *mut device,
        sz: core::ffi::c_ulong,
        dat: *mut core::ffi::c_void,
        set: *mut core::ffi::c_void,
        clr: *mut core::ffi::c_void,
        dirout: *mut core::ffi::c_void,
        dirin: *mut core::ffi::c_void,
        flags: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_irq_map(
        d: *mut irq_domain,
        irq: core::ffi::c_uint,
        hwirq: irq_hw_number_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_irq_unmap(d: *mut irq_domain, irq: core::ffi::c_uint);
}
extern "C" {
    pub fn gpiochip_irq_domain_activate(
        domain: *mut irq_domain,
        data: *mut irq_data,
        reserve: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_irq_domain_deactivate(domain: *mut irq_domain, data: *mut irq_data);
}
extern "C" {
    pub fn gpiochip_irqchip_irq_valid(gc: *const gpio_chip, offset: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn gpiochip_irqchip_add_domain(
        gc: *mut gpio_chip,
        domain: *mut irq_domain,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_generic_request(
        gc: *mut gpio_chip,
        offset: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_generic_free(gc: *mut gpio_chip, offset: core::ffi::c_uint);
}
extern "C" {
    pub fn gpiochip_generic_config(
        gc: *mut gpio_chip,
        offset: core::ffi::c_uint,
        config: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gpio_pin_range {
    pub node: list_head,
    pub pctldev: *mut pinctrl_dev,
    pub range: pinctrl_gpio_range,
}
impl Default for gpio_pin_range {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn gpiochip_add_pin_range(
        gc: *mut gpio_chip,
        pinctl_name: *const core::ffi::c_char,
        gpio_offset: core::ffi::c_uint,
        pin_offset: core::ffi::c_uint,
        npins: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_add_pingroup_range(
        gc: *mut gpio_chip,
        pctldev: *mut pinctrl_dev,
        gpio_offset: core::ffi::c_uint,
        pin_group: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_remove_pin_ranges(gc: *mut gpio_chip);
}
extern "C" {
    pub fn gpiochip_request_own_desc(
        gc: *mut gpio_chip,
        hwnum: core::ffi::c_uint,
        label: *const core::ffi::c_char,
        lflags: gpio_lookup_flags,
        dflags: gpiod_flags,
    ) -> *mut gpio_desc;
}
extern "C" {
    pub fn gpiochip_free_own_desc(desc: *mut gpio_desc);
}
extern "C" {
    pub fn gpiochip_lock_as_irq(gc: *mut gpio_chip, offset: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn gpiochip_unlock_as_irq(gc: *mut gpio_chip, offset: core::ffi::c_uint);
}
extern "C" {
    pub fn gpiod_to_chip(desc: *const gpio_desc) -> *mut gpio_chip;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hwrng {
    pub name: *const core::ffi::c_char,
    pub init: ::core::option::Option<unsafe extern "C" fn(rng: *mut hwrng) -> core::ffi::c_int>,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(rng: *mut hwrng)>,
    pub data_present: ::core::option::Option<
        unsafe extern "C" fn(rng: *mut hwrng, wait: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub data_read: ::core::option::Option<
        unsafe extern "C" fn(rng: *mut hwrng, data: *mut u32_) -> core::ffi::c_int,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            rng: *mut hwrng,
            data: *mut core::ffi::c_void,
            max: usize,
            wait: bool_,
        ) -> core::ffi::c_int,
    >,
    pub priv_: core::ffi::c_ulong,
    pub quality: core::ffi::c_ushort,
    pub list: list_head,
    pub ref_: kref,
    pub cleanup_done: completion,
    pub dying: completion,
}
impl Default for hwrng {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn hwrng_register(rng: *mut hwrng) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_hwrng_register(dev: *mut device, rng: *mut hwrng) -> core::ffi::c_int;
}
extern "C" {
    pub fn hwrng_unregister(rng: *mut hwrng);
}
extern "C" {
    pub fn devm_hwrng_unregister(dve: *mut device, rng: *mut hwrng);
}
extern "C" {
    pub fn hwrng_msleep(rng: *mut hwrng, msecs: core::ffi::c_uint) -> core::ffi::c_long;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct miscdevice {
    pub minor: core::ffi::c_int,
    pub name: *const core::ffi::c_char,
    pub fops: *const file_operations,
    pub list: list_head,
    pub parent: *mut device,
    pub this_device: *mut device,
    pub groups: *mut *const attribute_group,
    pub nodename: *const core::ffi::c_char,
    pub mode: umode_t,
}
impl Default for miscdevice {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn misc_register(misc: *mut miscdevice) -> core::ffi::c_int;
}
extern "C" {
    pub fn misc_deregister(misc: *mut miscdevice);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockptr_t {
    pub __bindgen_anon_1: sockptr_t__bindgen_ty_1,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sockptr_t__bindgen_ty_1 {
    pub kernel: *mut core::ffi::c_void,
    pub user: *mut core::ffi::c_void,
    _bindgen_union_align: u64,
}
impl Default for sockptr_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sockptr_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sockptr_t {
    #[inline]
    pub fn is_kernel(&self) -> bool_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_kernel(&mut self, val: bool_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_kernel: bool_) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_kernel: u8 = unsafe { ::core::mem::transmute(is_kernel) };
            is_kernel as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const socket_state_SS_FREE: socket_state = 0;
pub const socket_state_SS_UNCONNECTED: socket_state = 1;
pub const socket_state_SS_CONNECTING: socket_state = 2;
pub const socket_state_SS_CONNECTED: socket_state = 3;
pub const socket_state_SS_DISCONNECTING: socket_state = 4;
pub type socket_state = core::ffi::c_uint;
pub const sock_type_SOCK_STREAM: sock_type = 1;
pub const sock_type_SOCK_DGRAM: sock_type = 2;
pub const sock_type_SOCK_RAW: sock_type = 3;
pub const sock_type_SOCK_RDM: sock_type = 4;
pub const sock_type_SOCK_SEQPACKET: sock_type = 5;
pub const sock_type_SOCK_DCCP: sock_type = 6;
pub const sock_type_SOCK_PACKET: sock_type = 10;
pub type sock_type = core::ffi::c_uint;
pub const sock_shutdown_cmd_SHUT_RD: sock_shutdown_cmd = 0;
pub const sock_shutdown_cmd_SHUT_WR: sock_shutdown_cmd = 1;
pub const sock_shutdown_cmd_SHUT_RDWR: sock_shutdown_cmd = 2;
pub type sock_shutdown_cmd = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct socket_wq {
    pub wait: wait_queue_head_t,
    pub fasync_list: *mut fasync_struct,
    pub flags: core::ffi::c_ulong,
    pub rcu: callback_head,
}
impl Default for socket_wq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct socket {
    pub state: socket_state,
    pub type_: core::ffi::c_short,
    pub flags: core::ffi::c_ulong,
    pub file: *mut file,
    pub sk: *mut sock,
    pub ops: *const proto_ops,
    pub __bindgen_padding_0: [u64; 3usize],
    pub wq: socket_wq,
}
impl Default for socket {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct read_descriptor_t {
    pub written: usize,
    pub count: usize,
    pub arg: read_descriptor_t__bindgen_ty_1,
    pub error: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union read_descriptor_t__bindgen_ty_1 {
    pub buf: *mut core::ffi::c_char,
    pub data: *mut core::ffi::c_void,
    _bindgen_union_align: u64,
}
impl Default for read_descriptor_t__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for read_descriptor_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type sk_read_actor_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut read_descriptor_t,
        arg2: *mut sk_buff,
        arg3: core::ffi::c_uint,
        arg4: usize,
    ) -> core::ffi::c_int,
>;
pub type skb_read_actor_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut sock, arg2: *mut sk_buff) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct proto_ops {
    pub family: core::ffi::c_int,
    pub owner: *mut module,
    pub release:
        ::core::option::Option<unsafe extern "C" fn(sock: *mut socket) -> core::ffi::c_int>,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            myaddr: *mut sockaddr,
            sockaddr_len: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            vaddr: *mut sockaddr,
            sockaddr_len: core::ffi::c_int,
            flags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub socketpair: ::core::option::Option<
        unsafe extern "C" fn(sock1: *mut socket, sock2: *mut socket) -> core::ffi::c_int,
    >,
    pub accept: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            newsock: *mut socket,
            flags: core::ffi::c_int,
            kern: bool_,
        ) -> core::ffi::c_int,
    >,
    pub getname: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            addr: *mut sockaddr,
            peer: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            sock: *mut socket,
            wait: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            cmd: core::ffi::c_uint,
            arg: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            cmd: core::ffi::c_uint,
            arg: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub gettstamp: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            userstamp: *mut core::ffi::c_void,
            timeval: bool_,
            time32: bool_,
        ) -> core::ffi::c_int,
    >,
    pub listen: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, len: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub shutdown: ::core::option::Option<
        unsafe extern "C" fn(sock: *mut socket, flags: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            level: core::ffi::c_int,
            optname: core::ffi::c_int,
            optval: sockptr_t,
            optlen: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            level: core::ffi::c_int,
            optname: core::ffi::c_int,
            optval: *mut core::ffi::c_char,
            optlen: *mut core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(m: *mut seq_file, sock: *mut socket)>,
    pub sendmsg: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            m: *mut msghdr,
            total_len: usize,
        ) -> core::ffi::c_int,
    >,
    pub recvmsg: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            m: *mut msghdr,
            total_len: usize,
            flags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub mmap: ::core::option::Option<
        unsafe extern "C" fn(
            file: *mut file,
            sock: *mut socket,
            vma: *mut vm_area_struct,
        ) -> core::ffi::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            page: *mut page,
            offset: core::ffi::c_int,
            size: usize,
            flags: core::ffi::c_int,
        ) -> isize,
    >,
    pub splice_read: ::core::option::Option<
        unsafe extern "C" fn(
            sock: *mut socket,
            ppos: *mut loff_t,
            pipe: *mut pipe_inode_info,
            len: usize,
            flags: core::ffi::c_uint,
        ) -> isize,
    >,
    pub set_peek_off: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub peek_len:
        ::core::option::Option<unsafe extern "C" fn(sock: *mut socket) -> core::ffi::c_int>,
    pub read_sock: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            desc: *mut read_descriptor_t,
            recv_actor: sk_read_actor_t,
        ) -> core::ffi::c_int,
    >,
    pub read_skb: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, recv_actor: skb_read_actor_t) -> core::ffi::c_int,
    >,
    pub sendpage_locked: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            page: *mut page,
            offset: core::ffi::c_int,
            size: usize,
            flags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub sendmsg_locked: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, msg: *mut msghdr, size: usize) -> core::ffi::c_int,
    >,
    pub set_rcvlowat: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int,
    >,
}
impl Default for proto_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_proto_family {
    pub family: core::ffi::c_int,
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            sock: *mut socket,
            protocol: core::ffi::c_int,
            kern: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub owner: *mut module,
}
impl Default for net_proto_family {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const SOCK_WAKE_IO: core::ffi::c_uint = 0;
pub const SOCK_WAKE_WAITD: core::ffi::c_uint = 1;
pub const SOCK_WAKE_SPACE: core::ffi::c_uint = 2;
pub const SOCK_WAKE_URG: core::ffi::c_uint = 3;
pub type _bindgen_ty_119 = core::ffi::c_uint;
extern "C" {
    pub fn sock_wake_async(
        sk_wq: *mut socket_wq,
        how: core::ffi::c_int,
        band: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_register(fam: *const net_proto_family) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_unregister(family: core::ffi::c_int);
}
extern "C" {
    pub fn sock_is_registered(family: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn __sock_create(
        net: *mut net,
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        proto: core::ffi::c_int,
        res: *mut *mut socket,
        kern: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_create(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        proto: core::ffi::c_int,
        res: *mut *mut socket,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_create_kern(
        net: *mut net,
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        proto: core::ffi::c_int,
        res: *mut *mut socket,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_create_lite(
        family: core::ffi::c_int,
        type_: core::ffi::c_int,
        proto: core::ffi::c_int,
        res: *mut *mut socket,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_alloc() -> *mut socket;
}
extern "C" {
    pub fn sock_release(sock: *mut socket);
}
extern "C" {
    pub fn sock_sendmsg(sock: *mut socket, msg: *mut msghdr) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_recvmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_alloc_file(
        sock: *mut socket,
        flags: core::ffi::c_int,
        dname: *const core::ffi::c_char,
    ) -> *mut file;
}
extern "C" {
    pub fn sockfd_lookup(fd: core::ffi::c_int, err: *mut core::ffi::c_int) -> *mut socket;
}
extern "C" {
    pub fn sock_from_file(file: *mut file) -> *mut socket;
}
extern "C" {
    pub fn net_ratelimit() -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_sendmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        vec: *mut kvec,
        num: usize,
        len: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_sendmsg_locked(
        sk: *mut sock,
        msg: *mut msghdr,
        vec: *mut kvec,
        num: usize,
        len: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_recvmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        vec: *mut kvec,
        num: usize,
        len: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_bind(
        sock: *mut socket,
        addr: *mut sockaddr,
        addrlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_listen(sock: *mut socket, backlog: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_accept(
        sock: *mut socket,
        newsock: *mut *mut socket,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_connect(
        sock: *mut socket,
        addr: *mut sockaddr,
        addrlen: core::ffi::c_int,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_getsockname(sock: *mut socket, addr: *mut sockaddr) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_getpeername(sock: *mut socket, addr: *mut sockaddr) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_sendpage(
        sock: *mut socket,
        page: *mut page,
        offset: core::ffi::c_int,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_sendpage_locked(
        sk: *mut sock,
        page: *mut page,
        offset: core::ffi::c_int,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_sock_shutdown(sock: *mut socket, how: sock_shutdown_cmd) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_sock_ip_overhead(sk: *mut sock) -> u32_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ts_state {
    pub offset: core::ffi::c_uint,
    pub cb: [core::ffi::c_char; 48usize],
}
impl Default for ts_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ts_ops {
    pub name: *const core::ffi::c_char,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const core::ffi::c_void,
            arg2: core::ffi::c_uint,
            arg3: gfp_t,
            arg4: core::ffi::c_int,
        ) -> *mut ts_config,
    >,
    pub find: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ts_config, arg2: *mut ts_state) -> core::ffi::c_uint,
    >,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ts_config)>,
    pub get_pattern: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ts_config) -> *mut core::ffi::c_void,
    >,
    pub get_pattern_len:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ts_config) -> core::ffi::c_uint>,
    pub owner: *mut module,
    pub list: list_head,
}
impl Default for ts_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ts_config {
    pub ops: *mut ts_ops,
    pub flags: core::ffi::c_int,
    pub get_next_block: ::core::option::Option<
        unsafe extern "C" fn(
            consumed: core::ffi::c_uint,
            dst: *mut *const u8_,
            conf: *mut ts_config,
            state: *mut ts_state,
        ) -> core::ffi::c_uint,
    >,
    pub finish:
        ::core::option::Option<unsafe extern "C" fn(conf: *mut ts_config, state: *mut ts_state)>,
}
impl Default for ts_config {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn textsearch_register(arg1: *mut ts_ops) -> core::ffi::c_int;
}
extern "C" {
    pub fn textsearch_unregister(arg1: *mut ts_ops) -> core::ffi::c_int;
}
extern "C" {
    pub fn textsearch_prepare(
        arg1: *const core::ffi::c_char,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
        arg4: gfp_t,
        arg5: core::ffi::c_int,
    ) -> *mut ts_config;
}
extern "C" {
    pub fn textsearch_destroy(conf: *mut ts_config);
}
extern "C" {
    pub fn textsearch_find_continuous(
        arg1: *mut ts_config,
        arg2: *mut ts_state,
        arg3: *const core::ffi::c_void,
        arg4: core::ffi::c_uint,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn csum_partial(
        buff: *const core::ffi::c_void,
        len: core::ffi::c_int,
        sum: __wsum,
    ) -> __wsum;
}
extern "C" {
    pub fn ip_fast_csum(iph: *const core::ffi::c_void, ihl: core::ffi::c_uint) -> __sum16;
}
extern "C" {
    pub fn csum_tcpudp_nofold(
        saddr: __be32,
        daddr: __be32,
        len: __u32,
        proto: __u8,
        sum: __wsum,
    ) -> __wsum;
}
extern "C" {
    pub fn ip_compute_csum(buff: *const core::ffi::c_void, len: core::ffi::c_int) -> __sum16;
}
extern "C" {
    pub fn inet_proto_csum_replace4(
        sum: *mut __sum16,
        skb: *mut sk_buff,
        from: __be32,
        to: __be32,
        pseudohdr: bool_,
    );
}
extern "C" {
    pub fn inet_proto_csum_replace16(
        sum: *mut __sum16,
        skb: *mut sk_buff,
        from: *const __be32,
        to: *const __be32,
        pseudohdr: bool_,
    );
}
extern "C" {
    pub fn inet_proto_csum_replace_by_diff(
        sum: *mut __sum16,
        skb: *mut sk_buff,
        diff: __wsum,
        pseudohdr: bool_,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scatterlist {
    pub page_link: core::ffi::c_ulong,
    pub offset: core::ffi::c_uint,
    pub length: core::ffi::c_uint,
    pub dma_address: dma_addr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_table {
    pub sgl: *mut scatterlist,
    pub nents: core::ffi::c_uint,
    pub orig_nents: core::ffi::c_uint,
}
impl Default for sg_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_append_table {
    pub sgt: sg_table,
    pub prv: *mut scatterlist,
    pub total_nents: core::ffi::c_uint,
}
impl Default for sg_append_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn sg_nents(sg: *mut scatterlist) -> core::ffi::c_int;
}
extern "C" {
    pub fn sg_nents_for_len(sg: *mut scatterlist, len: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn sg_next(arg1: *mut scatterlist) -> *mut scatterlist;
}
extern "C" {
    pub fn sg_last(s: *mut scatterlist, arg1: core::ffi::c_uint) -> *mut scatterlist;
}
extern "C" {
    pub fn sg_init_table(arg1: *mut scatterlist, arg2: core::ffi::c_uint);
}
extern "C" {
    pub fn sg_init_one(
        arg1: *mut scatterlist,
        arg2: *const core::ffi::c_void,
        arg3: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn sg_split(
        in_: *mut scatterlist,
        in_mapped_nents: core::ffi::c_int,
        skip: off_t,
        nb_splits: core::ffi::c_int,
        split_sizes: *const usize,
        out: *mut *mut scatterlist,
        out_mapped_nents: *mut core::ffi::c_int,
        gfp_mask: gfp_t,
    ) -> core::ffi::c_int;
}
pub type sg_alloc_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: core::ffi::c_uint, arg2: gfp_t) -> *mut scatterlist,
>;
pub type sg_free_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut scatterlist, arg2: core::ffi::c_uint)>;
extern "C" {
    pub fn __sg_free_table(
        arg1: *mut sg_table,
        arg2: core::ffi::c_uint,
        arg3: core::ffi::c_uint,
        arg4: sg_free_fn,
        arg5: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn sg_free_table(arg1: *mut sg_table);
}
extern "C" {
    pub fn sg_free_append_table(sgt: *mut sg_append_table);
}
extern "C" {
    pub fn __sg_alloc_table(
        arg1: *mut sg_table,
        arg2: core::ffi::c_uint,
        arg3: core::ffi::c_uint,
        arg4: *mut scatterlist,
        arg5: core::ffi::c_uint,
        arg6: gfp_t,
        arg7: sg_alloc_fn,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sg_alloc_table(
        arg1: *mut sg_table,
        arg2: core::ffi::c_uint,
        arg3: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sg_alloc_append_table_from_pages(
        sgt: *mut sg_append_table,
        pages: *mut *mut page,
        n_pages: core::ffi::c_uint,
        offset: core::ffi::c_uint,
        size: core::ffi::c_ulong,
        max_segment: core::ffi::c_uint,
        left_pages: core::ffi::c_uint,
        gfp_mask: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sg_alloc_table_from_pages_segment(
        sgt: *mut sg_table,
        pages: *mut *mut page,
        n_pages: core::ffi::c_uint,
        offset: core::ffi::c_uint,
        size: core::ffi::c_ulong,
        max_segment: core::ffi::c_uint,
        gfp_mask: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sgl_alloc_order(
        length: core::ffi::c_ulonglong,
        order: core::ffi::c_uint,
        chainable: bool_,
        gfp: gfp_t,
        nent_p: *mut core::ffi::c_uint,
    ) -> *mut scatterlist;
}
extern "C" {
    pub fn sgl_alloc(
        length: core::ffi::c_ulonglong,
        gfp: gfp_t,
        nent_p: *mut core::ffi::c_uint,
    ) -> *mut scatterlist;
}
extern "C" {
    pub fn sgl_free_n_order(
        sgl: *mut scatterlist,
        nents: core::ffi::c_int,
        order: core::ffi::c_int,
    );
}
extern "C" {
    pub fn sgl_free_order(sgl: *mut scatterlist, order: core::ffi::c_int);
}
extern "C" {
    pub fn sgl_free(sgl: *mut scatterlist);
}
extern "C" {
    pub fn sg_copy_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buf: *mut core::ffi::c_void,
        buflen: usize,
        skip: off_t,
        to_buffer: bool_,
    ) -> usize;
}
extern "C" {
    pub fn sg_copy_from_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buf: *const core::ffi::c_void,
        buflen: usize,
    ) -> usize;
}
extern "C" {
    pub fn sg_copy_to_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buf: *mut core::ffi::c_void,
        buflen: usize,
    ) -> usize;
}
extern "C" {
    pub fn sg_pcopy_from_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buf: *const core::ffi::c_void,
        buflen: usize,
        skip: off_t,
    ) -> usize;
}
extern "C" {
    pub fn sg_pcopy_to_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buf: *mut core::ffi::c_void,
        buflen: usize,
        skip: off_t,
    ) -> usize;
}
extern "C" {
    pub fn sg_zero_buffer(
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        buflen: usize,
        skip: off_t,
    ) -> usize;
}
extern "C" {
    pub fn sg_free_table_chained(table: *mut sg_table, nents_first_chunk: core::ffi::c_uint);
}
extern "C" {
    pub fn sg_alloc_table_chained(
        table: *mut sg_table,
        nents: core::ffi::c_int,
        first_chunk: *mut scatterlist,
        nents_first_chunk: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_page_iter {
    pub sg: *mut scatterlist,
    pub sg_pgoffset: core::ffi::c_uint,
    pub __nents: core::ffi::c_uint,
    pub __pg_advance: core::ffi::c_int,
}
impl Default for sg_page_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_dma_page_iter {
    pub base: sg_page_iter,
}
impl Default for sg_dma_page_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __sg_page_iter_next(piter: *mut sg_page_iter) -> bool_;
}
extern "C" {
    pub fn __sg_page_iter_dma_next(dma_iter: *mut sg_dma_page_iter) -> bool_;
}
extern "C" {
    pub fn __sg_page_iter_start(
        piter: *mut sg_page_iter,
        sglist: *mut scatterlist,
        nents: core::ffi::c_uint,
        pgoffset: core::ffi::c_ulong,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sg_mapping_iter {
    pub page: *mut page,
    pub addr: *mut core::ffi::c_void,
    pub length: usize,
    pub consumed: usize,
    pub piter: sg_page_iter,
    pub __offset: core::ffi::c_uint,
    pub __remaining: core::ffi::c_uint,
    pub __flags: core::ffi::c_uint,
}
impl Default for sg_mapping_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn sg_miter_start(
        miter: *mut sg_mapping_iter,
        sgl: *mut scatterlist,
        nents: core::ffi::c_uint,
        flags: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn sg_miter_skip(miter: *mut sg_mapping_iter, offset: off_t) -> bool_;
}
extern "C" {
    pub fn sg_miter_next(miter: *mut sg_mapping_iter) -> bool_;
}
extern "C" {
    pub fn sg_miter_stop(miter: *mut sg_mapping_iter);
}
extern "C" {
    pub fn dma_map_page_attrs(
        dev: *mut device,
        page: *mut page,
        offset: usize,
        size: usize,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    ) -> dma_addr_t;
}
extern "C" {
    pub fn dma_unmap_page_attrs(
        dev: *mut device,
        addr: dma_addr_t,
        size: usize,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn dma_map_sg_attrs(
        dev: *mut device,
        sg: *mut scatterlist,
        nents: core::ffi::c_int,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn dma_unmap_sg_attrs(
        dev: *mut device,
        sg: *mut scatterlist,
        nents: core::ffi::c_int,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn dma_map_sgtable(
        dev: *mut device,
        sgt: *mut sg_table,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_map_resource(
        dev: *mut device,
        phys_addr: phys_addr_t,
        size: usize,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    ) -> dma_addr_t;
}
extern "C" {
    pub fn dma_unmap_resource(
        dev: *mut device,
        addr: dma_addr_t,
        size: usize,
        dir: dma_data_direction,
        attrs: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn dma_sync_single_for_cpu(
        dev: *mut device,
        addr: dma_addr_t,
        size: usize,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_sync_single_for_device(
        dev: *mut device,
        addr: dma_addr_t,
        size: usize,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_sync_sg_for_cpu(
        dev: *mut device,
        sg: *mut scatterlist,
        nelems: core::ffi::c_int,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_sync_sg_for_device(
        dev: *mut device,
        sg: *mut scatterlist,
        nelems: core::ffi::c_int,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_alloc_attrs(
        dev: *mut device,
        size: usize,
        dma_handle: *mut dma_addr_t,
        flag: gfp_t,
        attrs: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn dma_free_attrs(
        dev: *mut device,
        size: usize,
        cpu_addr: *mut core::ffi::c_void,
        dma_handle: dma_addr_t,
        attrs: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn dmam_alloc_attrs(
        dev: *mut device,
        size: usize,
        dma_handle: *mut dma_addr_t,
        gfp: gfp_t,
        attrs: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn dmam_free_coherent(
        dev: *mut device,
        size: usize,
        vaddr: *mut core::ffi::c_void,
        dma_handle: dma_addr_t,
    );
}
extern "C" {
    pub fn dma_get_sgtable_attrs(
        dev: *mut device,
        sgt: *mut sg_table,
        cpu_addr: *mut core::ffi::c_void,
        dma_addr: dma_addr_t,
        size: usize,
        attrs: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_mmap_attrs(
        dev: *mut device,
        vma: *mut vm_area_struct,
        cpu_addr: *mut core::ffi::c_void,
        dma_addr: dma_addr_t,
        size: usize,
        attrs: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_can_mmap(dev: *mut device) -> bool_;
}
extern "C" {
    pub fn dma_pci_p2pdma_supported(dev: *mut device) -> bool_;
}
extern "C" {
    pub fn dma_set_mask(dev: *mut device, mask: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_set_coherent_mask(dev: *mut device, mask: u64_) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_get_required_mask(dev: *mut device) -> u64_;
}
extern "C" {
    pub fn dma_max_mapping_size(dev: *mut device) -> usize;
}
extern "C" {
    pub fn dma_opt_mapping_size(dev: *mut device) -> usize;
}
extern "C" {
    pub fn dma_need_sync(dev: *mut device, dma_addr: dma_addr_t) -> bool_;
}
extern "C" {
    pub fn dma_get_merge_boundary(dev: *mut device) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn dma_alloc_noncontiguous(
        dev: *mut device,
        size: usize,
        dir: dma_data_direction,
        gfp: gfp_t,
        attrs: core::ffi::c_ulong,
    ) -> *mut sg_table;
}
extern "C" {
    pub fn dma_free_noncontiguous(
        dev: *mut device,
        size: usize,
        sgt: *mut sg_table,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_vmap_noncontiguous(
        dev: *mut device,
        size: usize,
        sgt: *mut sg_table,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn dma_vunmap_noncontiguous(dev: *mut device, vaddr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn dma_mmap_noncontiguous(
        dev: *mut device,
        vma: *mut vm_area_struct,
        size: usize,
        sgt: *mut sg_table,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dma_alloc_pages(
        dev: *mut device,
        size: usize,
        dma_handle: *mut dma_addr_t,
        dir: dma_data_direction,
        gfp: gfp_t,
    ) -> *mut page;
}
extern "C" {
    pub fn dma_free_pages(
        dev: *mut device,
        size: usize,
        page: *mut page,
        dma_handle: dma_addr_t,
        dir: dma_data_direction,
    );
}
extern "C" {
    pub fn dma_mmap_pages(
        dev: *mut device,
        vma: *mut vm_area_struct,
        size: usize,
        page: *mut page,
    ) -> core::ffi::c_int;
}
pub type netdev_features_t = u64_;
pub const NETIF_F_SG_BIT: core::ffi::c_uint = 0;
pub const NETIF_F_IP_CSUM_BIT: core::ffi::c_uint = 1;
pub const __UNUSED_NETIF_F_1: core::ffi::c_uint = 2;
pub const NETIF_F_HW_CSUM_BIT: core::ffi::c_uint = 3;
pub const NETIF_F_IPV6_CSUM_BIT: core::ffi::c_uint = 4;
pub const NETIF_F_HIGHDMA_BIT: core::ffi::c_uint = 5;
pub const NETIF_F_FRAGLIST_BIT: core::ffi::c_uint = 6;
pub const NETIF_F_HW_VLAN_CTAG_TX_BIT: core::ffi::c_uint = 7;
pub const NETIF_F_HW_VLAN_CTAG_RX_BIT: core::ffi::c_uint = 8;
pub const NETIF_F_HW_VLAN_CTAG_FILTER_BIT: core::ffi::c_uint = 9;
pub const NETIF_F_VLAN_CHALLENGED_BIT: core::ffi::c_uint = 10;
pub const NETIF_F_GSO_BIT: core::ffi::c_uint = 11;
pub const NETIF_F_LLTX_BIT: core::ffi::c_uint = 12;
pub const NETIF_F_NETNS_LOCAL_BIT: core::ffi::c_uint = 13;
pub const NETIF_F_GRO_BIT: core::ffi::c_uint = 14;
pub const NETIF_F_LRO_BIT: core::ffi::c_uint = 15;
pub const NETIF_F_GSO_SHIFT: core::ffi::c_uint = 16;
pub const NETIF_F_TSO_BIT: core::ffi::c_uint = 16;
pub const NETIF_F_GSO_ROBUST_BIT: core::ffi::c_uint = 17;
pub const NETIF_F_TSO_ECN_BIT: core::ffi::c_uint = 18;
pub const NETIF_F_TSO_MANGLEID_BIT: core::ffi::c_uint = 19;
pub const NETIF_F_TSO6_BIT: core::ffi::c_uint = 20;
pub const NETIF_F_FSO_BIT: core::ffi::c_uint = 21;
pub const NETIF_F_GSO_GRE_BIT: core::ffi::c_uint = 22;
pub const NETIF_F_GSO_GRE_CSUM_BIT: core::ffi::c_uint = 23;
pub const NETIF_F_GSO_IPXIP4_BIT: core::ffi::c_uint = 24;
pub const NETIF_F_GSO_IPXIP6_BIT: core::ffi::c_uint = 25;
pub const NETIF_F_GSO_UDP_TUNNEL_BIT: core::ffi::c_uint = 26;
pub const NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT: core::ffi::c_uint = 27;
pub const NETIF_F_GSO_PARTIAL_BIT: core::ffi::c_uint = 28;
pub const NETIF_F_GSO_TUNNEL_REMCSUM_BIT: core::ffi::c_uint = 29;
pub const NETIF_F_GSO_SCTP_BIT: core::ffi::c_uint = 30;
pub const NETIF_F_GSO_ESP_BIT: core::ffi::c_uint = 31;
pub const NETIF_F_GSO_UDP_BIT: core::ffi::c_uint = 32;
pub const NETIF_F_GSO_UDP_L4_BIT: core::ffi::c_uint = 33;
pub const NETIF_F_GSO_FRAGLIST_BIT: core::ffi::c_uint = 34;
pub const NETIF_F_GSO_LAST: core::ffi::c_uint = 34;
pub const NETIF_F_FCOE_CRC_BIT: core::ffi::c_uint = 35;
pub const NETIF_F_SCTP_CRC_BIT: core::ffi::c_uint = 36;
pub const NETIF_F_FCOE_MTU_BIT: core::ffi::c_uint = 37;
pub const NETIF_F_NTUPLE_BIT: core::ffi::c_uint = 38;
pub const NETIF_F_RXHASH_BIT: core::ffi::c_uint = 39;
pub const NETIF_F_RXCSUM_BIT: core::ffi::c_uint = 40;
pub const NETIF_F_NOCACHE_COPY_BIT: core::ffi::c_uint = 41;
pub const NETIF_F_LOOPBACK_BIT: core::ffi::c_uint = 42;
pub const NETIF_F_RXFCS_BIT: core::ffi::c_uint = 43;
pub const NETIF_F_RXALL_BIT: core::ffi::c_uint = 44;
pub const NETIF_F_HW_VLAN_STAG_TX_BIT: core::ffi::c_uint = 45;
pub const NETIF_F_HW_VLAN_STAG_RX_BIT: core::ffi::c_uint = 46;
pub const NETIF_F_HW_VLAN_STAG_FILTER_BIT: core::ffi::c_uint = 47;
pub const NETIF_F_HW_L2FW_DOFFLOAD_BIT: core::ffi::c_uint = 48;
pub const NETIF_F_HW_TC_BIT: core::ffi::c_uint = 49;
pub const NETIF_F_HW_ESP_BIT: core::ffi::c_uint = 50;
pub const NETIF_F_HW_ESP_TX_CSUM_BIT: core::ffi::c_uint = 51;
pub const NETIF_F_RX_UDP_TUNNEL_PORT_BIT: core::ffi::c_uint = 52;
pub const NETIF_F_HW_TLS_TX_BIT: core::ffi::c_uint = 53;
pub const NETIF_F_HW_TLS_RX_BIT: core::ffi::c_uint = 54;
pub const NETIF_F_GRO_HW_BIT: core::ffi::c_uint = 55;
pub const NETIF_F_HW_TLS_RECORD_BIT: core::ffi::c_uint = 56;
pub const NETIF_F_GRO_FRAGLIST_BIT: core::ffi::c_uint = 57;
pub const NETIF_F_HW_MACSEC_BIT: core::ffi::c_uint = 58;
pub const NETIF_F_GRO_UDP_FWD_BIT: core::ffi::c_uint = 59;
pub const NETIF_F_HW_HSR_TAG_INS_BIT: core::ffi::c_uint = 60;
pub const NETIF_F_HW_HSR_TAG_RM_BIT: core::ffi::c_uint = 61;
pub const NETIF_F_HW_HSR_FWD_BIT: core::ffi::c_uint = 62;
pub const NETIF_F_HW_HSR_DUP_BIT: core::ffi::c_uint = 63;
pub const NETDEV_FEATURE_COUNT: core::ffi::c_uint = 64;
pub type _bindgen_ty_120 = core::ffi::c_uint;
extern "C" {
    pub fn sched_clock() -> core::ffi::c_ulonglong;
}
extern "C" {
    pub fn running_clock() -> u64_;
}
extern "C" {
    pub fn sched_clock_cpu(cpu: core::ffi::c_int) -> u64_;
}
extern "C" {
    pub fn sched_clock_init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub u6_addr8: [__u8; 16usize],
    pub u6_addr16: [__be16; 8usize],
    pub u6_addr32: [__be32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for in6_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: core::ffi::c_ushort,
    pub sin6_port: __be16,
    pub sin6_flowinfo: __be32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __u32,
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_ifindex: core::ffi::c_int,
}
impl Default for ipv6_mreq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_flowlabel_req {
    pub flr_dst: in6_addr,
    pub flr_label: __be32,
    pub flr_action: __u8,
    pub flr_share: __u8,
    pub flr_flags: __u16,
    pub flr_expires: __u16,
    pub flr_linger: __u16,
    pub __flr_pad: __u32,
}
impl Default for in6_flowlabel_req {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static in6addr_any: in6_addr;
}
extern "C" {
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_interfacelocal_allnodes: in6_addr;
}
extern "C" {
    pub static in6addr_interfacelocal_allrouters: in6_addr;
}
extern "C" {
    pub static in6addr_sitelocal_allrouters: in6_addr;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct siphash_key_t {
    pub key: [u64_; 2usize],
}
extern "C" {
    pub fn __siphash_aligned(
        data: *const core::ffi::c_void,
        len: usize,
        key: *const siphash_key_t,
    ) -> u64_;
}
extern "C" {
    pub fn __siphash_unaligned(
        data: *const core::ffi::c_void,
        len: usize,
        key: *const siphash_key_t,
    ) -> u64_;
}
extern "C" {
    pub fn siphash_1u64(a: u64_, key: *const siphash_key_t) -> u64_;
}
extern "C" {
    pub fn siphash_2u64(a: u64_, b: u64_, key: *const siphash_key_t) -> u64_;
}
extern "C" {
    pub fn siphash_3u64(a: u64_, b: u64_, c: u64_, key: *const siphash_key_t) -> u64_;
}
extern "C" {
    pub fn siphash_4u64(a: u64_, b: u64_, c: u64_, d: u64_, key: *const siphash_key_t) -> u64_;
}
extern "C" {
    pub fn siphash_1u32(a: u32_, key: *const siphash_key_t) -> u64_;
}
extern "C" {
    pub fn siphash_3u32(a: u32_, b: u32_, c: u32_, key: *const siphash_key_t) -> u64_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hsiphash_key_t {
    pub key: [core::ffi::c_ulong; 2usize],
}
extern "C" {
    pub fn __hsiphash_aligned(
        data: *const core::ffi::c_void,
        len: usize,
        key: *const hsiphash_key_t,
    ) -> u32_;
}
extern "C" {
    pub fn __hsiphash_unaligned(
        data: *const core::ffi::c_void,
        len: usize,
        key: *const hsiphash_key_t,
    ) -> u32_;
}
extern "C" {
    pub fn hsiphash_1u32(a: u32_, key: *const hsiphash_key_t) -> u32_;
}
extern "C" {
    pub fn hsiphash_2u32(a: u32_, b: u32_, key: *const hsiphash_key_t) -> u32_;
}
extern "C" {
    pub fn hsiphash_3u32(a: u32_, b: u32_, c: u32_, key: *const hsiphash_key_t) -> u32_;
}
extern "C" {
    pub fn hsiphash_4u32(a: u32_, b: u32_, c: u32_, d: u32_, key: *const hsiphash_key_t) -> u32_;
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct ethhdr {
    pub h_dest: [core::ffi::c_uchar; 6usize],
    pub h_source: [core::ffi::c_uchar; 6usize],
    pub h_proto: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_control {
    pub thoff: u16_,
    pub addr_type: u16_,
    pub flags: u32_,
}
pub const flow_dissect_ret_FLOW_DISSECT_RET_OUT_GOOD: flow_dissect_ret = 0;
pub const flow_dissect_ret_FLOW_DISSECT_RET_OUT_BAD: flow_dissect_ret = 1;
pub const flow_dissect_ret_FLOW_DISSECT_RET_PROTO_AGAIN: flow_dissect_ret = 2;
pub const flow_dissect_ret_FLOW_DISSECT_RET_IPPROTO_AGAIN: flow_dissect_ret = 3;
pub const flow_dissect_ret_FLOW_DISSECT_RET_CONTINUE: flow_dissect_ret = 4;
pub type flow_dissect_ret = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_basic {
    pub n_proto: __be16,
    pub ip_proto: u8_,
    pub padding: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_tags {
    pub flow_label: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_vlan {
    pub __bindgen_anon_1: flow_dissector_key_vlan__bindgen_ty_1,
    pub vlan_tpid: __be16,
    pub vlan_eth_type: __be16,
    pub padding: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_vlan__bindgen_ty_1 {
    pub __bindgen_anon_1: flow_dissector_key_vlan__bindgen_ty_1__bindgen_ty_1,
    pub vlan_tci: __be16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_vlan__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
impl flow_dissector_key_vlan__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn vlan_id(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_vlan_id(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn vlan_dei(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_vlan_dei(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn vlan_priority(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_vlan_priority(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        vlan_id: u16_,
        vlan_dei: u16_,
        vlan_priority: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let vlan_id: u16 = unsafe { ::core::mem::transmute(vlan_id) };
            vlan_id as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let vlan_dei: u16 = unsafe { ::core::mem::transmute(vlan_dei) };
            vlan_dei as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let vlan_priority: u16 = unsafe { ::core::mem::transmute(vlan_priority) };
            vlan_priority as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for flow_dissector_key_vlan__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for flow_dissector_key_vlan {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_mpls_lse {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl flow_dissector_mpls_lse {
    #[inline]
    pub fn mpls_ttl(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_ttl(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn mpls_bos(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_bos(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mpls_tc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_tc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn mpls_label(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mpls_label(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mpls_ttl: u32_,
        mpls_bos: u32_,
        mpls_tc: u32_,
        mpls_label: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let mpls_ttl: u32 = unsafe { ::core::mem::transmute(mpls_ttl) };
            mpls_ttl as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let mpls_bos: u32 = unsafe { ::core::mem::transmute(mpls_bos) };
            mpls_bos as u64
        });
        __bindgen_bitfield_unit.set(9usize, 3u8, {
            let mpls_tc: u32 = unsafe { ::core::mem::transmute(mpls_tc) };
            mpls_tc as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let mpls_label: u32 = unsafe { ::core::mem::transmute(mpls_label) };
            mpls_label as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_mpls {
    pub ls: [flow_dissector_mpls_lse; 7usize],
    pub used_lses: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_enc_opts {
    pub data: [u8_; 255usize],
    pub len: u8_,
    pub dst_opt_type: __be16,
}
impl Default for flow_dissector_key_enc_opts {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_keyid {
    pub keyid: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ipv4_addrs {
    pub src: __be32,
    pub dst: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ipv6_addrs {
    pub src: in6_addr,
    pub dst: in6_addr,
}
impl Default for flow_dissector_key_ipv6_addrs {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_tipc {
    pub key: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_addrs {
    pub __bindgen_anon_1: flow_dissector_key_addrs__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_addrs__bindgen_ty_1 {
    pub v4addrs: flow_dissector_key_ipv4_addrs,
    pub v6addrs: flow_dissector_key_ipv6_addrs,
    pub tipckey: flow_dissector_key_tipc,
    _bindgen_union_align: [u32; 8usize],
}
impl Default for flow_dissector_key_addrs__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for flow_dissector_key_addrs {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_arp {
    pub sip: __u32,
    pub tip: __u32,
    pub op: __u8,
    pub sha: [core::ffi::c_uchar; 6usize],
    pub tha: [core::ffi::c_uchar; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ports {
    pub __bindgen_anon_1: flow_dissector_key_ports__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_ports__bindgen_ty_1 {
    pub ports: __be32,
    pub __bindgen_anon_1: flow_dissector_key_ports__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ports__bindgen_ty_1__bindgen_ty_1 {
    pub src: __be16,
    pub dst: __be16,
}
impl Default for flow_dissector_key_ports__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for flow_dissector_key_ports {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ports_range {
    pub __bindgen_anon_1: flow_dissector_key_ports_range__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_dissector_key_ports_range__bindgen_ty_1 {
    pub tp: flow_dissector_key_ports,
    pub __bindgen_anon_1: flow_dissector_key_ports_range__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key_ports_range__bindgen_ty_1__bindgen_ty_1 {
    pub tp_min: flow_dissector_key_ports,
    pub tp_max: flow_dissector_key_ports,
}
impl Default for flow_dissector_key_ports_range__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for flow_dissector_key_ports_range__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for flow_dissector_key_ports_range {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_icmp {
    pub __bindgen_anon_1: flow_dissector_key_icmp__bindgen_ty_1,
    pub id: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_icmp__bindgen_ty_1 {
    pub type_: u8_,
    pub code: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_eth_addrs {
    pub dst: [core::ffi::c_uchar; 6usize],
    pub src: [core::ffi::c_uchar; 6usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_tcp {
    pub flags: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ip {
    pub tos: __u8,
    pub ttl: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_meta {
    pub ingress_ifindex: core::ffi::c_int,
    pub ingress_iftype: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_ct {
    pub ct_state: u16_,
    pub ct_zone: u16_,
    pub ct_mark: u32_,
    pub ct_labels: [u32_; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_hash {
    pub hash: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_num_of_vlans {
    pub num_of_vlans: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_pppoe {
    pub session_id: __be16,
    pub ppp_proto: __be16,
    pub type_: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector_key_l2tpv3 {
    pub session_id: __be32,
}
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_CONTROL: flow_dissector_key_id = 0;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_BASIC: flow_dissector_key_id = 1;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_IPV4_ADDRS: flow_dissector_key_id = 2;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_IPV6_ADDRS: flow_dissector_key_id = 3;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_PORTS: flow_dissector_key_id = 4;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_PORTS_RANGE: flow_dissector_key_id = 5;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ICMP: flow_dissector_key_id = 6;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ETH_ADDRS: flow_dissector_key_id = 7;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_TIPC: flow_dissector_key_id = 8;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ARP: flow_dissector_key_id = 9;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_VLAN: flow_dissector_key_id = 10;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_FLOW_LABEL: flow_dissector_key_id = 11;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_GRE_KEYID: flow_dissector_key_id = 12;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_MPLS_ENTROPY: flow_dissector_key_id = 13;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_KEYID: flow_dissector_key_id = 14;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS: flow_dissector_key_id = 15;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS: flow_dissector_key_id = 16;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_CONTROL: flow_dissector_key_id = 17;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_PORTS: flow_dissector_key_id = 18;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_MPLS: flow_dissector_key_id = 19;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_TCP: flow_dissector_key_id = 20;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_IP: flow_dissector_key_id = 21;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_CVLAN: flow_dissector_key_id = 22;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_IP: flow_dissector_key_id = 23;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_ENC_OPTS: flow_dissector_key_id = 24;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_META: flow_dissector_key_id = 25;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_CT: flow_dissector_key_id = 26;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_HASH: flow_dissector_key_id = 27;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_NUM_OF_VLANS: flow_dissector_key_id = 28;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_PPPOE: flow_dissector_key_id = 29;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_L2TPV3: flow_dissector_key_id = 30;
pub const flow_dissector_key_id_FLOW_DISSECTOR_KEY_MAX: flow_dissector_key_id = 31;
pub type flow_dissector_key_id = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_dissector_key {
    pub key_id: flow_dissector_key_id,
    pub offset: usize,
}
impl Default for flow_dissector_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_dissector {
    pub used_keys: core::ffi::c_uint,
    pub offset: [core::ffi::c_ushort; 31usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_keys_basic {
    pub control: flow_dissector_key_control,
    pub basic: flow_dissector_key_basic,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct flow_keys {
    pub control: flow_dissector_key_control,
    pub basic: flow_dissector_key_basic,
    pub tags: flow_dissector_key_tags,
    pub vlan: flow_dissector_key_vlan,
    pub cvlan: flow_dissector_key_vlan,
    pub keyid: flow_dissector_key_keyid,
    pub ports: flow_dissector_key_ports,
    pub icmp: flow_dissector_key_icmp,
    pub addrs: flow_dissector_key_addrs,
}
impl Default for flow_keys {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn flow_get_u32_src(flow: *const flow_keys) -> __be32;
}
extern "C" {
    pub fn flow_get_u32_dst(flow: *const flow_keys) -> __be32;
}
extern "C" {
    pub static mut flow_keys_dissector: flow_dissector;
}
extern "C" {
    pub static mut flow_keys_basic_dissector: flow_dissector;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_keys_digest {
    pub data: [u8_; 16usize],
}
extern "C" {
    pub fn make_flow_keys_digest(digest: *mut flow_keys_digest, flow: *const flow_keys);
}
extern "C" {
    pub fn flow_hash_from_keys(keys: *mut flow_keys) -> u32_;
}
extern "C" {
    pub fn skb_flow_get_icmp_tci(
        skb: *const sk_buff,
        key_icmp: *mut flow_dissector_key_icmp,
        data: *const core::ffi::c_void,
        thoff: core::ffi::c_int,
        hlen: core::ffi::c_int,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_flow_dissector {
    pub flow_keys: *mut bpf_flow_keys,
    pub skb: *const sk_buff,
    pub data: *const core::ffi::c_void,
    pub data_end: *const core::ffi::c_void,
}
impl Default for bpf_flow_dissector {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn flow_dissector_bpf_prog_attach_check(
        net: *mut net,
        prog: *mut bpf_prog,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pipe_buffer {
    pub page: *mut page,
    pub offset: core::ffi::c_uint,
    pub len: core::ffi::c_uint,
    pub ops: *const pipe_buf_operations,
    pub flags: core::ffi::c_uint,
    pub private: core::ffi::c_ulong,
}
impl Default for pipe_buffer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pipe_inode_info {
    pub mutex: mutex,
    pub rd_wait: wait_queue_head_t,
    pub wr_wait: wait_queue_head_t,
    pub head: core::ffi::c_uint,
    pub tail: core::ffi::c_uint,
    pub max_usage: core::ffi::c_uint,
    pub ring_size: core::ffi::c_uint,
    pub nr_accounted: core::ffi::c_uint,
    pub readers: core::ffi::c_uint,
    pub writers: core::ffi::c_uint,
    pub files: core::ffi::c_uint,
    pub r_counter: core::ffi::c_uint,
    pub w_counter: core::ffi::c_uint,
    pub poll_usage: bool_,
    pub tmp_page: *mut page,
    pub fasync_readers: *mut fasync_struct,
    pub fasync_writers: *mut fasync_struct,
    pub bufs: *mut pipe_buffer,
    pub user: *mut user_struct,
}
impl Default for pipe_inode_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pipe_buf_operations {
    pub confirm: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut pipe_inode_info,
            arg2: *mut pipe_buffer,
        ) -> core::ffi::c_int,
    >,
    pub release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer),
    >,
    pub try_steal: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_,
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_,
    >,
}
extern "C" {
    pub fn pipe_lock(arg1: *mut pipe_inode_info);
}
extern "C" {
    pub fn pipe_unlock(arg1: *mut pipe_inode_info);
}
extern "C" {
    pub fn pipe_double_lock(arg1: *mut pipe_inode_info, arg2: *mut pipe_inode_info);
}
extern "C" {
    pub fn pipe_wait_readable(arg1: *mut pipe_inode_info);
}
extern "C" {
    pub fn pipe_wait_writable(arg1: *mut pipe_inode_info);
}
extern "C" {
    pub fn alloc_pipe_info() -> *mut pipe_inode_info;
}
extern "C" {
    pub fn free_pipe_info(arg1: *mut pipe_inode_info);
}
extern "C" {
    pub fn generic_pipe_buf_get(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_;
}
extern "C" {
    pub fn generic_pipe_buf_try_steal(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> bool_;
}
extern "C" {
    pub fn generic_pipe_buf_release(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer);
}
extern "C" {
    pub static nosteal_pipe_buf_ops: pipe_buf_operations;
}
extern "C" {
    pub fn pipe_fcntl(
        arg1: *mut file,
        arg2: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn get_pipe_info(file: *mut file, for_splice: bool_) -> *mut pipe_inode_info;
}
extern "C" {
    pub fn create_pipe_files(arg1: *mut *mut file, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn round_pipe_size(size: core::ffi::c_ulong) -> core::ffi::c_uint;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct splice_desc {
    pub total_len: usize,
    pub len: core::ffi::c_uint,
    pub flags: core::ffi::c_uint,
    pub u: splice_desc__bindgen_ty_1,
    pub pos: loff_t,
    pub opos: *mut loff_t,
    pub num_spliced: usize,
    pub need_wakeup: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union splice_desc__bindgen_ty_1 {
    pub userptr: *mut core::ffi::c_void,
    pub file: *mut file,
    pub data: *mut core::ffi::c_void,
    _bindgen_union_align: u64,
}
impl Default for splice_desc__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for splice_desc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct partial_page {
    pub offset: core::ffi::c_uint,
    pub len: core::ffi::c_uint,
    pub private: core::ffi::c_ulong,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct splice_pipe_desc {
    pub pages: *mut *mut page,
    pub partial: *mut partial_page,
    pub nr_pages: core::ffi::c_int,
    pub nr_pages_max: core::ffi::c_uint,
    pub ops: *const pipe_buf_operations,
    pub spd_release: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut splice_pipe_desc, arg2: core::ffi::c_uint),
    >,
}
impl Default for splice_pipe_desc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type splice_actor = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut pipe_inode_info,
        arg2: *mut pipe_buffer,
        arg3: *mut splice_desc,
    ) -> core::ffi::c_int,
>;
pub type splice_direct_actor = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut pipe_inode_info, arg2: *mut splice_desc) -> core::ffi::c_int,
>;
extern "C" {
    pub fn splice_from_pipe(
        arg1: *mut pipe_inode_info,
        arg2: *mut file,
        arg3: *mut loff_t,
        arg4: usize,
        arg5: core::ffi::c_uint,
        arg6: splice_actor,
    ) -> isize;
}
extern "C" {
    pub fn __splice_from_pipe(
        arg1: *mut pipe_inode_info,
        arg2: *mut splice_desc,
        arg3: splice_actor,
    ) -> isize;
}
extern "C" {
    pub fn splice_to_pipe(arg1: *mut pipe_inode_info, arg2: *mut splice_pipe_desc) -> isize;
}
extern "C" {
    pub fn add_to_pipe(arg1: *mut pipe_inode_info, arg2: *mut pipe_buffer) -> isize;
}
extern "C" {
    pub fn splice_direct_to_actor(
        arg1: *mut file,
        arg2: *mut splice_desc,
        arg3: splice_direct_actor,
    ) -> isize;
}
extern "C" {
    pub fn do_splice(
        in_: *mut file,
        off_in: *mut loff_t,
        out: *mut file,
        off_out: *mut loff_t,
        len: usize,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn do_tee(
        in_: *mut file,
        out: *mut file,
        len: usize,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_long;
}
extern "C" {
    pub fn splice_grow_spd(
        arg1: *const pipe_inode_info,
        arg2: *mut splice_pipe_desc,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn splice_shrink_spd(arg1: *mut splice_pipe_desc);
}
extern "C" {
    pub static page_cache_pipe_buf_ops: pipe_buf_operations;
}
extern "C" {
    pub static default_pipe_buf_ops: pipe_buf_operations;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr_pkt {
    pub spkt_family: core::ffi::c_ushort,
    pub spkt_device: [core::ffi::c_uchar; 14usize],
    pub spkt_protocol: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr_ll {
    pub sll_family: core::ffi::c_ushort,
    pub sll_protocol: __be16,
    pub sll_ifindex: core::ffi::c_int,
    pub sll_hatype: core::ffi::c_ushort,
    pub sll_pkttype: core::ffi::c_uchar,
    pub sll_halen: core::ffi::c_uchar,
    pub sll_addr: [core::ffi::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_stats {
    pub tp_packets: core::ffi::c_uint,
    pub tp_drops: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_stats_v3 {
    pub tp_packets: core::ffi::c_uint,
    pub tp_drops: core::ffi::c_uint,
    pub tp_freeze_q_cnt: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_rollover_stats {
    pub tp_all: __u64,
    pub tp_huge: __u64,
    pub tp_failed: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_stats_u {
    pub stats1: tpacket_stats,
    pub stats3: tpacket_stats_v3,
    _bindgen_union_align: [u32; 3usize],
}
impl Default for tpacket_stats_u {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_auxdata {
    pub tp_status: __u32,
    pub tp_len: __u32,
    pub tp_snaplen: __u32,
    pub tp_mac: __u16,
    pub tp_net: __u16,
    pub tp_vlan_tci: __u16,
    pub tp_vlan_tpid: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_hdr {
    pub tp_status: core::ffi::c_ulong,
    pub tp_len: core::ffi::c_uint,
    pub tp_snaplen: core::ffi::c_uint,
    pub tp_mac: core::ffi::c_ushort,
    pub tp_net: core::ffi::c_ushort,
    pub tp_sec: core::ffi::c_uint,
    pub tp_usec: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket2_hdr {
    pub tp_status: __u32,
    pub tp_len: __u32,
    pub tp_snaplen: __u32,
    pub tp_mac: __u16,
    pub tp_net: __u16,
    pub tp_sec: __u32,
    pub tp_nsec: __u32,
    pub tp_vlan_tci: __u16,
    pub tp_vlan_tpid: __u16,
    pub tp_padding: [__u8; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_hdr_variant1 {
    pub tp_rxhash: __u32,
    pub tp_vlan_tci: __u32,
    pub tp_vlan_tpid: __u16,
    pub tp_padding: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket3_hdr {
    pub tp_next_offset: __u32,
    pub tp_sec: __u32,
    pub tp_nsec: __u32,
    pub tp_snaplen: __u32,
    pub tp_len: __u32,
    pub tp_status: __u32,
    pub tp_mac: __u16,
    pub tp_net: __u16,
    pub __bindgen_anon_1: tpacket3_hdr__bindgen_ty_1,
    pub tp_padding: [__u8; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket3_hdr__bindgen_ty_1 {
    pub hv1: tpacket_hdr_variant1,
    _bindgen_union_align: [u32; 3usize],
}
impl Default for tpacket3_hdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for tpacket3_hdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket_bd_ts {
    pub ts_sec: core::ffi::c_uint,
    pub __bindgen_anon_1: tpacket_bd_ts__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_bd_ts__bindgen_ty_1 {
    pub ts_usec: core::ffi::c_uint,
    pub ts_nsec: core::ffi::c_uint,
    _bindgen_union_align: u32,
}
impl Default for tpacket_bd_ts__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for tpacket_bd_ts {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket_hdr_v1 {
    pub block_status: __u32,
    pub num_pkts: __u32,
    pub offset_to_first_pkt: __u32,
    pub blk_len: __u32,
    pub seq_num: __u64,
    pub ts_first_pkt: tpacket_bd_ts,
    pub ts_last_pkt: tpacket_bd_ts,
}
impl Default for tpacket_hdr_v1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_bd_header_u {
    pub bh1: tpacket_hdr_v1,
    _bindgen_union_align: [u64; 5usize],
}
impl Default for tpacket_bd_header_u {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tpacket_block_desc {
    pub version: __u32,
    pub offset_to_priv: __u32,
    pub hdr: tpacket_bd_header_u,
}
impl Default for tpacket_block_desc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const tpacket_versions_TPACKET_V1: tpacket_versions = 0;
pub const tpacket_versions_TPACKET_V2: tpacket_versions = 1;
pub const tpacket_versions_TPACKET_V3: tpacket_versions = 2;
pub type tpacket_versions = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_req {
    pub tp_block_size: core::ffi::c_uint,
    pub tp_block_nr: core::ffi::c_uint,
    pub tp_frame_size: core::ffi::c_uint,
    pub tp_frame_nr: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tpacket_req3 {
    pub tp_block_size: core::ffi::c_uint,
    pub tp_block_nr: core::ffi::c_uint,
    pub tp_frame_size: core::ffi::c_uint,
    pub tp_frame_nr: core::ffi::c_uint,
    pub tp_retire_blk_tov: core::ffi::c_uint,
    pub tp_sizeof_priv: core::ffi::c_uint,
    pub tp_feature_req_word: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tpacket_req_u {
    pub req: tpacket_req,
    pub req3: tpacket_req3,
    _bindgen_union_align: [u32; 7usize],
}
impl Default for tpacket_req_u {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct packet_mreq {
    pub mr_ifindex: core::ffi::c_int,
    pub mr_type: core::ffi::c_ushort,
    pub mr_alen: core::ffi::c_ushort,
    pub mr_address: [core::ffi::c_uchar; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fanout_args {
    pub id: __u16,
    pub type_flags: __u16,
    pub max_num_members: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_tunnel {
    pub tun_id: __be64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_common {
    pub flowic_oif: core::ffi::c_int,
    pub flowic_iif: core::ffi::c_int,
    pub flowic_l3mdev: core::ffi::c_int,
    pub flowic_mark: __u32,
    pub flowic_tos: __u8,
    pub flowic_scope: __u8,
    pub flowic_proto: __u8,
    pub flowic_flags: __u8,
    pub flowic_secid: __u32,
    pub flowic_uid: kuid_t,
    pub flowic_tun_key: flowi_tunnel,
    pub flowic_multipath_hash: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi_uli {
    pub ports: flowi_uli__bindgen_ty_1,
    pub icmpt: flowi_uli__bindgen_ty_2,
    pub gre_key: __be32,
    pub mht: flowi_uli__bindgen_ty_3,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_1 {
    pub dport: __be16,
    pub sport: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_2 {
    pub type_: __u8,
    pub code: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flowi_uli__bindgen_ty_3 {
    pub type_: __u8,
}
impl Default for flowi_uli {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi4 {
    pub __fl_common: flowi_common,
    pub saddr: __be32,
    pub daddr: __be32,
    pub uli: flowi_uli,
}
impl Default for flowi4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi6 {
    pub __fl_common: flowi_common,
    pub daddr: in6_addr,
    pub saddr: in6_addr,
    pub flowlabel: __be32,
    pub uli: flowi_uli,
    pub mp_hash: __u32,
}
impl Default for flowi6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flowi {
    pub u: flowi__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flowi__bindgen_ty_1 {
    pub __fl_common: flowi_common,
    pub ip4: flowi4,
    pub ip6: flowi6,
    _bindgen_union_align: [u64; 12usize],
}
impl Default for flowi__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for flowi {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __get_hash_from_flowi6(fl6: *const flowi6, keys: *mut flow_keys) -> __u32;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct ptr_ring {
    pub producer: core::ffi::c_int,
    pub producer_lock: spinlock_t,
    pub __bindgen_padding_0: [u32; 8usize],
    pub consumer_head: core::ffi::c_int,
    pub consumer_tail: core::ffi::c_int,
    pub consumer_lock: spinlock_t,
    pub __bindgen_padding_1: [u32; 8usize],
    pub size: core::ffi::c_int,
    pub batch: core::ffi::c_int,
    pub queue: *mut *mut core::ffi::c_void,
}
impl Default for ptr_ring {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pp_alloc_cache {
    pub count: u32_,
    pub cache: [*mut page; 128usize],
}
impl Default for pp_alloc_cache {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct page_pool_params {
    pub flags: core::ffi::c_uint,
    pub order: core::ffi::c_uint,
    pub pool_size: core::ffi::c_uint,
    pub nid: core::ffi::c_int,
    pub dev: *mut device,
    pub dma_dir: dma_data_direction,
    pub max_len: core::ffi::c_uint,
    pub offset: core::ffi::c_uint,
    pub init_callback:
        ::core::option::Option<unsafe extern "C" fn(page: *mut page, arg: *mut core::ffi::c_void)>,
    pub init_arg: *mut core::ffi::c_void,
}
impl Default for page_pool_params {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct page_pool {
    pub p: page_pool_params,
    pub release_dw: delayed_work,
    pub disconnect: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
    pub defer_start: core::ffi::c_ulong,
    pub defer_warn: core::ffi::c_ulong,
    pub pages_state_hold_cnt: u32_,
    pub frag_offset: core::ffi::c_uint,
    pub frag_page: *mut page,
    pub frag_users: core::ffi::c_long,
    pub xdp_mem_id: u32_,
    pub __bindgen_padding_0: [u64; 7usize],
    pub alloc: pp_alloc_cache,
    pub __bindgen_padding_1: [u64; 7usize],
    pub ring: ptr_ring,
    pub pages_state_release_cnt: atomic_t,
    pub user_cnt: refcount_t,
    pub destroy_cnt: u64_,
}
impl Default for page_pool {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn page_pool_alloc_pages(pool: *mut page_pool, gfp: gfp_t) -> *mut page;
}
extern "C" {
    pub fn page_pool_alloc_frag(
        pool: *mut page_pool,
        offset: *mut core::ffi::c_uint,
        size: core::ffi::c_uint,
        gfp: gfp_t,
    ) -> *mut page;
}
extern "C" {
    pub fn page_pool_return_skb_page(page: *mut page) -> bool_;
}
extern "C" {
    pub fn page_pool_create(params: *const page_pool_params) -> *mut page_pool;
}
extern "C" {
    pub fn page_pool_destroy(pool: *mut page_pool);
}
extern "C" {
    pub fn page_pool_use_xdp_mem(
        pool: *mut page_pool,
        disconnect: ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>,
        mem: *mut xdp_mem_info,
    );
}
extern "C" {
    pub fn page_pool_release_page(pool: *mut page_pool, page: *mut page);
}
extern "C" {
    pub fn page_pool_put_page_bulk(
        pool: *mut page_pool,
        data: *mut *mut core::ffi::c_void,
        count: core::ffi::c_int,
    );
}
extern "C" {
    pub fn page_pool_put_defragged_page(
        pool: *mut page_pool,
        page: *mut page,
        dma_sync_size: core::ffi::c_uint,
        allow_direct: bool_,
    );
}
extern "C" {
    pub fn page_pool_update_nid(pool: *mut page_pool, new_nid: core::ffi::c_int);
}
pub const ip_conntrack_info_IP_CT_ESTABLISHED: ip_conntrack_info = 0;
pub const ip_conntrack_info_IP_CT_RELATED: ip_conntrack_info = 1;
pub const ip_conntrack_info_IP_CT_NEW: ip_conntrack_info = 2;
pub const ip_conntrack_info_IP_CT_IS_REPLY: ip_conntrack_info = 3;
pub const ip_conntrack_info_IP_CT_ESTABLISHED_REPLY: ip_conntrack_info = 3;
pub const ip_conntrack_info_IP_CT_RELATED_REPLY: ip_conntrack_info = 4;
pub const ip_conntrack_info_IP_CT_NUMBER: ip_conntrack_info = 5;
pub const ip_conntrack_info_IP_CT_UNTRACKED: ip_conntrack_info = 7;
pub type ip_conntrack_info = core::ffi::c_uint;
pub const ip_conntrack_status_IPS_EXPECTED_BIT: ip_conntrack_status = 0;
pub const ip_conntrack_status_IPS_EXPECTED: ip_conntrack_status = 1;
pub const ip_conntrack_status_IPS_SEEN_REPLY_BIT: ip_conntrack_status = 1;
pub const ip_conntrack_status_IPS_SEEN_REPLY: ip_conntrack_status = 2;
pub const ip_conntrack_status_IPS_ASSURED_BIT: ip_conntrack_status = 2;
pub const ip_conntrack_status_IPS_ASSURED: ip_conntrack_status = 4;
pub const ip_conntrack_status_IPS_CONFIRMED_BIT: ip_conntrack_status = 3;
pub const ip_conntrack_status_IPS_CONFIRMED: ip_conntrack_status = 8;
pub const ip_conntrack_status_IPS_SRC_NAT_BIT: ip_conntrack_status = 4;
pub const ip_conntrack_status_IPS_SRC_NAT: ip_conntrack_status = 16;
pub const ip_conntrack_status_IPS_DST_NAT_BIT: ip_conntrack_status = 5;
pub const ip_conntrack_status_IPS_DST_NAT: ip_conntrack_status = 32;
pub const ip_conntrack_status_IPS_NAT_MASK: ip_conntrack_status = 48;
pub const ip_conntrack_status_IPS_SEQ_ADJUST_BIT: ip_conntrack_status = 6;
pub const ip_conntrack_status_IPS_SEQ_ADJUST: ip_conntrack_status = 64;
pub const ip_conntrack_status_IPS_SRC_NAT_DONE_BIT: ip_conntrack_status = 7;
pub const ip_conntrack_status_IPS_SRC_NAT_DONE: ip_conntrack_status = 128;
pub const ip_conntrack_status_IPS_DST_NAT_DONE_BIT: ip_conntrack_status = 8;
pub const ip_conntrack_status_IPS_DST_NAT_DONE: ip_conntrack_status = 256;
pub const ip_conntrack_status_IPS_NAT_DONE_MASK: ip_conntrack_status = 384;
pub const ip_conntrack_status_IPS_DYING_BIT: ip_conntrack_status = 9;
pub const ip_conntrack_status_IPS_DYING: ip_conntrack_status = 512;
pub const ip_conntrack_status_IPS_FIXED_TIMEOUT_BIT: ip_conntrack_status = 10;
pub const ip_conntrack_status_IPS_FIXED_TIMEOUT: ip_conntrack_status = 1024;
pub const ip_conntrack_status_IPS_TEMPLATE_BIT: ip_conntrack_status = 11;
pub const ip_conntrack_status_IPS_TEMPLATE: ip_conntrack_status = 2048;
pub const ip_conntrack_status_IPS_UNTRACKED_BIT: ip_conntrack_status = 12;
pub const ip_conntrack_status_IPS_UNTRACKED: ip_conntrack_status = 4096;
pub const ip_conntrack_status_IPS_NAT_CLASH_BIT: ip_conntrack_status = 12;
pub const ip_conntrack_status_IPS_NAT_CLASH: ip_conntrack_status = 4096;
pub const ip_conntrack_status_IPS_HELPER_BIT: ip_conntrack_status = 13;
pub const ip_conntrack_status_IPS_HELPER: ip_conntrack_status = 8192;
pub const ip_conntrack_status_IPS_OFFLOAD_BIT: ip_conntrack_status = 14;
pub const ip_conntrack_status_IPS_OFFLOAD: ip_conntrack_status = 16384;
pub const ip_conntrack_status_IPS_HW_OFFLOAD_BIT: ip_conntrack_status = 15;
pub const ip_conntrack_status_IPS_HW_OFFLOAD: ip_conntrack_status = 32768;
pub const ip_conntrack_status_IPS_UNCHANGEABLE_MASK: ip_conntrack_status = 56313;
pub const ip_conntrack_status___IPS_MAX_BIT: ip_conntrack_status = 16;
pub type ip_conntrack_status = core::ffi::c_uint;
pub const ip_conntrack_events_IPCT_NEW: ip_conntrack_events = 0;
pub const ip_conntrack_events_IPCT_RELATED: ip_conntrack_events = 1;
pub const ip_conntrack_events_IPCT_DESTROY: ip_conntrack_events = 2;
pub const ip_conntrack_events_IPCT_REPLY: ip_conntrack_events = 3;
pub const ip_conntrack_events_IPCT_ASSURED: ip_conntrack_events = 4;
pub const ip_conntrack_events_IPCT_PROTOINFO: ip_conntrack_events = 5;
pub const ip_conntrack_events_IPCT_HELPER: ip_conntrack_events = 6;
pub const ip_conntrack_events_IPCT_MARK: ip_conntrack_events = 7;
pub const ip_conntrack_events_IPCT_SEQADJ: ip_conntrack_events = 8;
pub const ip_conntrack_events_IPCT_NATSEQADJ: ip_conntrack_events = 8;
pub const ip_conntrack_events_IPCT_SECMARK: ip_conntrack_events = 9;
pub const ip_conntrack_events_IPCT_LABEL: ip_conntrack_events = 10;
pub const ip_conntrack_events_IPCT_SYNPROXY: ip_conntrack_events = 11;
pub const ip_conntrack_events___IPCT_MAX: ip_conntrack_events = 12;
pub type ip_conntrack_events = core::ffi::c_uint;
pub const ip_conntrack_expect_events_IPEXP_NEW: ip_conntrack_expect_events = 0;
pub const ip_conntrack_expect_events_IPEXP_DESTROY: ip_conntrack_expect_events = 1;
pub type ip_conntrack_expect_events = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_conntrack_stat {
    pub found: core::ffi::c_uint,
    pub invalid: core::ffi::c_uint,
    pub insert: core::ffi::c_uint,
    pub insert_failed: core::ffi::c_uint,
    pub clash_resolve: core::ffi::c_uint,
    pub drop: core::ffi::c_uint,
    pub early_drop: core::ffi::c_uint,
    pub error: core::ffi::c_uint,
    pub expect_new: core::ffi::c_uint,
    pub expect_create: core::ffi::c_uint,
    pub expect_delete: core::ffi::c_uint,
    pub search_restart: core::ffi::c_uint,
    pub chaintoolong: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_conntrack {
    pub use_: refcount_t,
}
extern "C" {
    pub fn nf_conntrack_destroy(nfct: *mut nf_conntrack);
}
extern "C" {
    pub fn netdev_printk(
        level: *const core::ffi::c_char,
        dev: *const net_device,
        format: *const core::ffi::c_char,
        ...
    );
}
extern "C" {
    pub fn netdev_emerg(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_alert(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_crit(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_err(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_warn(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_notice(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
extern "C" {
    pub fn netdev_info(dev: *const net_device, format: *const core::ffi::c_char, ...);
}
pub const skb_drop_reason_SKB_NOT_DROPPED_YET: skb_drop_reason = 0;
pub const skb_drop_reason_SKB_DROP_REASON_NOT_SPECIFIED: skb_drop_reason = 1;
pub const skb_drop_reason_SKB_DROP_REASON_NO_SOCKET: skb_drop_reason = 2;
pub const skb_drop_reason_SKB_DROP_REASON_PKT_TOO_SMALL: skb_drop_reason = 3;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_CSUM: skb_drop_reason = 4;
pub const skb_drop_reason_SKB_DROP_REASON_SOCKET_FILTER: skb_drop_reason = 5;
pub const skb_drop_reason_SKB_DROP_REASON_UDP_CSUM: skb_drop_reason = 6;
pub const skb_drop_reason_SKB_DROP_REASON_NETFILTER_DROP: skb_drop_reason = 7;
pub const skb_drop_reason_SKB_DROP_REASON_OTHERHOST: skb_drop_reason = 8;
pub const skb_drop_reason_SKB_DROP_REASON_IP_CSUM: skb_drop_reason = 9;
pub const skb_drop_reason_SKB_DROP_REASON_IP_INHDR: skb_drop_reason = 10;
pub const skb_drop_reason_SKB_DROP_REASON_IP_RPFILTER: skb_drop_reason = 11;
pub const skb_drop_reason_SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST: skb_drop_reason = 12;
pub const skb_drop_reason_SKB_DROP_REASON_XFRM_POLICY: skb_drop_reason = 13;
pub const skb_drop_reason_SKB_DROP_REASON_IP_NOPROTO: skb_drop_reason = 14;
pub const skb_drop_reason_SKB_DROP_REASON_SOCKET_RCVBUFF: skb_drop_reason = 15;
pub const skb_drop_reason_SKB_DROP_REASON_PROTO_MEM: skb_drop_reason = 16;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_MD5NOTFOUND: skb_drop_reason = 17;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_MD5UNEXPECTED: skb_drop_reason = 18;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_MD5FAILURE: skb_drop_reason = 19;
pub const skb_drop_reason_SKB_DROP_REASON_SOCKET_BACKLOG: skb_drop_reason = 20;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_FLAGS: skb_drop_reason = 21;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_ZEROWINDOW: skb_drop_reason = 22;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OLD_DATA: skb_drop_reason = 23;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OVERWINDOW: skb_drop_reason = 24;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OFOMERGE: skb_drop_reason = 25;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_RFC7323_PAWS: skb_drop_reason = 26;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_INVALID_SEQUENCE: skb_drop_reason = 27;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_RESET: skb_drop_reason = 28;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_INVALID_SYN: skb_drop_reason = 29;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_CLOSE: skb_drop_reason = 30;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_FASTOPEN: skb_drop_reason = 31;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OLD_ACK: skb_drop_reason = 32;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_TOO_OLD_ACK: skb_drop_reason = 33;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_ACK_UNSENT_DATA: skb_drop_reason = 34;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE: skb_drop_reason = 35;
pub const skb_drop_reason_SKB_DROP_REASON_TCP_OFO_DROP: skb_drop_reason = 36;
pub const skb_drop_reason_SKB_DROP_REASON_IP_OUTNOROUTES: skb_drop_reason = 37;
pub const skb_drop_reason_SKB_DROP_REASON_BPF_CGROUP_EGRESS: skb_drop_reason = 38;
pub const skb_drop_reason_SKB_DROP_REASON_IPV6DISABLED: skb_drop_reason = 39;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_CREATEFAIL: skb_drop_reason = 40;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_FAILED: skb_drop_reason = 41;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_QUEUEFULL: skb_drop_reason = 42;
pub const skb_drop_reason_SKB_DROP_REASON_NEIGH_DEAD: skb_drop_reason = 43;
pub const skb_drop_reason_SKB_DROP_REASON_TC_EGRESS: skb_drop_reason = 44;
pub const skb_drop_reason_SKB_DROP_REASON_QDISC_DROP: skb_drop_reason = 45;
pub const skb_drop_reason_SKB_DROP_REASON_CPU_BACKLOG: skb_drop_reason = 46;
pub const skb_drop_reason_SKB_DROP_REASON_XDP: skb_drop_reason = 47;
pub const skb_drop_reason_SKB_DROP_REASON_TC_INGRESS: skb_drop_reason = 48;
pub const skb_drop_reason_SKB_DROP_REASON_UNHANDLED_PROTO: skb_drop_reason = 49;
pub const skb_drop_reason_SKB_DROP_REASON_SKB_CSUM: skb_drop_reason = 50;
pub const skb_drop_reason_SKB_DROP_REASON_SKB_GSO_SEG: skb_drop_reason = 51;
pub const skb_drop_reason_SKB_DROP_REASON_SKB_UCOPY_FAULT: skb_drop_reason = 52;
pub const skb_drop_reason_SKB_DROP_REASON_DEV_HDR: skb_drop_reason = 53;
pub const skb_drop_reason_SKB_DROP_REASON_DEV_READY: skb_drop_reason = 54;
pub const skb_drop_reason_SKB_DROP_REASON_FULL_RING: skb_drop_reason = 55;
pub const skb_drop_reason_SKB_DROP_REASON_NOMEM: skb_drop_reason = 56;
pub const skb_drop_reason_SKB_DROP_REASON_HDR_TRUNC: skb_drop_reason = 57;
pub const skb_drop_reason_SKB_DROP_REASON_TAP_FILTER: skb_drop_reason = 58;
pub const skb_drop_reason_SKB_DROP_REASON_TAP_TXFILTER: skb_drop_reason = 59;
pub const skb_drop_reason_SKB_DROP_REASON_ICMP_CSUM: skb_drop_reason = 60;
pub const skb_drop_reason_SKB_DROP_REASON_INVALID_PROTO: skb_drop_reason = 61;
pub const skb_drop_reason_SKB_DROP_REASON_IP_INADDRERRORS: skb_drop_reason = 62;
pub const skb_drop_reason_SKB_DROP_REASON_IP_INNOROUTES: skb_drop_reason = 63;
pub const skb_drop_reason_SKB_DROP_REASON_PKT_TOO_BIG: skb_drop_reason = 64;
pub const skb_drop_reason_SKB_DROP_REASON_MAX: skb_drop_reason = 65;
pub type skb_drop_reason = core::ffi::c_uint;
extern "C" {
    pub static mut drop_reasons: [*const core::ffi::c_char; 0usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ahash_request {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_bridge_info {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub frag_max_size: __u16,
    pub physindev: *mut net_device,
    pub physoutdev: *mut net_device,
    pub __bindgen_anon_1: nf_bridge_info__bindgen_ty_2,
}
pub const nf_bridge_info_BRNF_PROTO_UNCHANGED: core::ffi::c_uint = 0;
pub const nf_bridge_info_BRNF_PROTO_8021Q: core::ffi::c_uint = 1;
pub const nf_bridge_info_BRNF_PROTO_PPPOE: core::ffi::c_uint = 2;
pub type nf_bridge_info__bindgen_ty_1 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_bridge_info__bindgen_ty_2 {
    pub ipv4_daddr: __be32,
    pub ipv6_daddr: in6_addr,
    pub neigh_header: [core::ffi::c_char; 8usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for nf_bridge_info__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for nf_bridge_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl nf_bridge_info {
    #[inline]
    pub fn orig_proto(&self) -> nf_bridge_info__bindgen_ty_1 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_orig_proto(&mut self, val: nf_bridge_info__bindgen_ty_1) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn pkt_otherhost(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_otherhost(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_prerouting(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_prerouting(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bridged_dnat(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bridged_dnat(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        orig_proto: nf_bridge_info__bindgen_ty_1,
        pkt_otherhost: u8_,
        in_prerouting: u8_,
        bridged_dnat: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let orig_proto: u32 = unsafe { ::core::mem::transmute(orig_proto) };
            orig_proto as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let pkt_otherhost: u8 = unsafe { ::core::mem::transmute(pkt_otherhost) };
            pkt_otherhost as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let in_prerouting: u8 = unsafe { ::core::mem::transmute(in_prerouting) };
            in_prerouting as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let bridged_dnat: u8 = unsafe { ::core::mem::transmute(bridged_dnat) };
            bridged_dnat as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head {
    pub __bindgen_anon_1: sk_buff_head__bindgen_ty_1,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff_head__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff_head__bindgen_ty_1__bindgen_ty_1,
    pub list: sk_buff_head__bindgen_ty_1_sk_buff_list,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
}
impl Default for sk_buff_head__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff_head__bindgen_ty_1_sk_buff_list {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
}
impl Default for sk_buff_head__bindgen_ty_1_sk_buff_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sk_buff_head__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sk_buff_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut sysctl_max_skb_frags: core::ffi::c_int;
}
pub type skb_frag_t = bio_vec;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skb_shared_hwtstamps {
    pub __bindgen_anon_1: skb_shared_hwtstamps__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skb_shared_hwtstamps__bindgen_ty_1 {
    pub hwtstamp: ktime_t,
    pub netdev_data: *mut core::ffi::c_void,
    _bindgen_union_align: u64,
}
impl Default for skb_shared_hwtstamps__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for skb_shared_hwtstamps {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const SKBTX_HW_TSTAMP: core::ffi::c_uint = 1;
pub const SKBTX_SW_TSTAMP: core::ffi::c_uint = 2;
pub const SKBTX_IN_PROGRESS: core::ffi::c_uint = 4;
pub const SKBTX_HW_TSTAMP_USE_CYCLES: core::ffi::c_uint = 8;
pub const SKBTX_WIFI_STATUS: core::ffi::c_uint = 16;
pub const SKBTX_HW_TSTAMP_NETDEV: core::ffi::c_uint = 32;
pub const SKBTX_SCHED_TSTAMP: core::ffi::c_uint = 64;
pub type _bindgen_ty_121 = core::ffi::c_uint;
pub const SKBFL_ZEROCOPY_ENABLE: core::ffi::c_uint = 1;
pub const SKBFL_SHARED_FRAG: core::ffi::c_uint = 2;
pub const SKBFL_PURE_ZEROCOPY: core::ffi::c_uint = 4;
pub const SKBFL_DONT_ORPHAN: core::ffi::c_uint = 8;
pub const SKBFL_MANAGED_FRAG_REFS: core::ffi::c_uint = 16;
pub type _bindgen_ty_122 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ubuf_info {
    pub callback: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut ubuf_info, zerocopy_success: bool_),
    >,
    pub refcnt: refcount_t,
    pub flags: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ubuf_info_msgzc {
    pub ubuf: ubuf_info,
    pub __bindgen_anon_1: ubuf_info_msgzc__bindgen_ty_1,
    pub mmp: ubuf_info_msgzc_mmpin,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ubuf_info_msgzc__bindgen_ty_1 {
    pub __bindgen_anon_1: ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_1 {
    pub desc: core::ffi::c_ulong,
    pub ctx: *mut core::ffi::c_void,
}
impl Default for ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_2 {
    pub id: u32_,
    pub len: u16_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub bytelen: u32_,
}
impl ubuf_info_msgzc__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn zerocopy(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_zerocopy(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(zerocopy: u16_) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let zerocopy: u16 = unsafe { ::core::mem::transmute(zerocopy) };
            zerocopy as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for ubuf_info_msgzc__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ubuf_info_msgzc_mmpin {
    pub user: *mut user_struct,
    pub num_pg: core::ffi::c_uint,
}
impl Default for ubuf_info_msgzc_mmpin {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for ubuf_info_msgzc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mm_account_pinned_pages(
        mmp: *mut ubuf_info_msgzc_mmpin,
        size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn mm_unaccount_pinned_pages(mmp: *mut ubuf_info_msgzc_mmpin);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skb_shared_info {
    pub flags: __u8,
    pub meta_len: __u8,
    pub nr_frags: __u8,
    pub tx_flags: __u8,
    pub gso_size: core::ffi::c_ushort,
    pub gso_segs: core::ffi::c_ushort,
    pub frag_list: *mut sk_buff,
    pub hwtstamps: skb_shared_hwtstamps,
    pub gso_type: core::ffi::c_uint,
    pub tskey: u32_,
    pub dataref: atomic_t,
    pub xdp_frags_size: core::ffi::c_uint,
    pub destructor_arg: *mut core::ffi::c_void,
    pub frags: [skb_frag_t; 17usize],
}
impl Default for skb_shared_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const SKB_FCLONE_UNAVAILABLE: core::ffi::c_uint = 0;
pub const SKB_FCLONE_ORIG: core::ffi::c_uint = 1;
pub const SKB_FCLONE_CLONE: core::ffi::c_uint = 2;
pub type _bindgen_ty_123 = core::ffi::c_uint;
pub const SKB_GSO_TCPV4: core::ffi::c_uint = 1;
pub const SKB_GSO_DODGY: core::ffi::c_uint = 2;
pub const SKB_GSO_TCP_ECN: core::ffi::c_uint = 4;
pub const SKB_GSO_TCP_FIXEDID: core::ffi::c_uint = 8;
pub const SKB_GSO_TCPV6: core::ffi::c_uint = 16;
pub const SKB_GSO_FCOE: core::ffi::c_uint = 32;
pub const SKB_GSO_GRE: core::ffi::c_uint = 64;
pub const SKB_GSO_GRE_CSUM: core::ffi::c_uint = 128;
pub const SKB_GSO_IPXIP4: core::ffi::c_uint = 256;
pub const SKB_GSO_IPXIP6: core::ffi::c_uint = 512;
pub const SKB_GSO_UDP_TUNNEL: core::ffi::c_uint = 1024;
pub const SKB_GSO_UDP_TUNNEL_CSUM: core::ffi::c_uint = 2048;
pub const SKB_GSO_PARTIAL: core::ffi::c_uint = 4096;
pub const SKB_GSO_TUNNEL_REMCSUM: core::ffi::c_uint = 8192;
pub const SKB_GSO_SCTP: core::ffi::c_uint = 16384;
pub const SKB_GSO_ESP: core::ffi::c_uint = 32768;
pub const SKB_GSO_UDP: core::ffi::c_uint = 65536;
pub const SKB_GSO_UDP_L4: core::ffi::c_uint = 131072;
pub const SKB_GSO_FRAGLIST: core::ffi::c_uint = 262144;
pub type _bindgen_ty_124 = core::ffi::c_uint;
pub type sk_buff_data_t = core::ffi::c_uint;
#[repr(C)]
pub struct sk_buff {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_2,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_3,
    pub cb: [core::ffi::c_char; 48usize],
    pub __bindgen_anon_4: sk_buff__bindgen_ty_4,
    pub _nfct: core::ffi::c_ulong,
    pub len: core::ffi::c_uint,
    pub data_len: core::ffi::c_uint,
    pub mac_len: __u16,
    pub hdr_len: __u16,
    pub queue_mapping: __u16,
    pub __cloned_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub active_extensions: __u8,
    pub __bindgen_anon_5: sk_buff__bindgen_ty_5,
    pub tail: sk_buff_data_t,
    pub end: sk_buff_data_t,
    pub head: *mut core::ffi::c_uchar,
    pub data: *mut core::ffi::c_uchar,
    pub truesize: core::ffi::c_uint,
    pub users: refcount_t,
    pub extensions: *mut skb_ext,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1,
    pub rbnode: rb_node,
    pub list: list_head,
    pub ll_node: llist_node,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_buff__bindgen_ty_1__bindgen_ty_1 {
    pub next: *mut sk_buff,
    pub prev: *mut sk_buff,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub dev: *mut net_device,
    pub dev_scratch: core::ffi::c_ulong,
    _bindgen_union_align: u64,
}
impl Default for sk_buff__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sk_buff__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sk_buff__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_2 {
    pub sk: *mut sock,
    pub ip_defrag_offset: core::ffi::c_int,
    _bindgen_union_align: u64,
}
impl Default for sk_buff__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_3 {
    pub tstamp: ktime_t,
    pub skb_mstamp_ns: u64_,
    _bindgen_union_align: u64,
}
impl Default for sk_buff__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_4 {
    pub __bindgen_anon_1: sk_buff__bindgen_ty_4__bindgen_ty_1,
    pub tcp_tsorted_anchor: list_head,
    pub _sk_redir: core::ffi::c_ulong,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_4__bindgen_ty_1 {
    pub _skb_refdst: core::ffi::c_ulong,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
}
impl Default for sk_buff__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_5 {
    pub __bindgen_anon_1: __BindgenUnionField<sk_buff__bindgen_ty_5__bindgen_ty_1>,
    pub headers: __BindgenUnionField<sk_buff__bindgen_ty_5__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 15usize],
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_1 {
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __pkt_vlan_present_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub tc_index: __u16,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1,
    pub priority: __u32,
    pub skb_iif: core::ffi::c_int,
    pub hash: __u32,
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2,
    pub alloc_cpu: u16_,
    pub secmark: __u32,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
impl Default for sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    pub napi_id: core::ffi::c_uint,
    pub sender_cpu: core::ffi::c_uint,
    _bindgen_union_align: u32,
}
impl Default for sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
    _bindgen_union_align: u32,
}
impl Default for sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
    _bindgen_union_align: u16,
}
impl Default for sk_buff__bindgen_ty_5__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sk_buff__bindgen_ty_5__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_buff__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_trace(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_trace(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pkt_type: __u8,
        ignore_df: __u8,
        nf_trace: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nf_trace: u8 = unsafe { ::core::mem::transmute(nf_trace) };
            nf_trace as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn vlan_present(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vlan_present(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mono_delivery_time(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mono_delivery_time(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirected(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slow_gro(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slow_gro(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_not_inet(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_not_inet(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scm_io_uring(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scm_io_uring(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        vlan_present: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        dst_pending_confirm: __u8,
        mono_delivery_time: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        inner_protocol_type: __u8,
        remcsum_offload: __u8,
        redirected: __u8,
        slow_gro: __u8,
        csum_not_inet: __u8,
        scm_io_uring: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vlan_present: u8 = unsafe { ::core::mem::transmute(vlan_present) };
            vlan_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::core::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mono_delivery_time: u8 = unsafe { ::core::mem::transmute(mono_delivery_time) };
            mono_delivery_time as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::core::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
            redirected as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let slow_gro: u8 = unsafe { ::core::mem::transmute(slow_gro) };
            slow_gro as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let csum_not_inet: u8 = unsafe { ::core::mem::transmute(csum_not_inet) };
            csum_not_inet as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scm_io_uring: u8 = unsafe { ::core::mem::transmute(scm_io_uring) };
            scm_io_uring as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_2 {
    pub __pkt_type_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __pkt_vlan_present_offset: __IncompleteArrayField<__u8>,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub tc_index: __u16,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1,
    pub priority: __u32,
    pub skb_iif: core::ffi::c_int,
    pub hash: __u32,
    pub vlan_proto: __be16,
    pub vlan_tci: __u16,
    pub __bindgen_anon_2: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2,
    pub alloc_cpu: u16_,
    pub secmark: __u32,
    pub __bindgen_anon_3: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3,
    pub __bindgen_anon_4: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4,
    pub inner_transport_header: __u16,
    pub inner_network_header: __u16,
    pub inner_mac_header: __u16,
    pub protocol: __be16,
    pub transport_header: __u16,
    pub network_header: __u16,
    pub mac_header: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1 {
    pub csum: __wsum,
    pub __bindgen_anon_1: sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub csum_start: __u16,
    pub csum_offset: __u16,
}
impl Default for sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2 {
    pub napi_id: core::ffi::c_uint,
    pub sender_cpu: core::ffi::c_uint,
    _bindgen_union_align: u32,
}
impl Default for sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3 {
    pub mark: __u32,
    pub reserved_tailroom: __u32,
    _bindgen_union_align: u32,
}
impl Default for sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4 {
    pub inner_protocol: __be16,
    pub inner_ipproto: __u8,
    _bindgen_union_align: u16,
}
impl Default for sk_buff__bindgen_ty_5__bindgen_ty_2__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sk_buff__bindgen_ty_5__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_buff__bindgen_ty_5__bindgen_ty_2 {
    #[inline]
    pub fn pkt_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_pkt_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ignore_df(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ignore_df(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nf_trace(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nf_trace(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ip_summed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ip_summed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ooo_okay(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ooo_okay(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn l4_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_l4_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sw_hash(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sw_hash(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wifi_acked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_wifi_acked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_fcs(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_fcs(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encapsulation(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulation(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_hdr_csum(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_hdr_csum(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_valid(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_valid(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        pkt_type: __u8,
        ignore_df: __u8,
        nf_trace: __u8,
        ip_summed: __u8,
        ooo_okay: __u8,
        l4_hash: __u8,
        sw_hash: __u8,
        wifi_acked_valid: __u8,
        wifi_acked: __u8,
        no_fcs: __u8,
        encapsulation: __u8,
        encap_hdr_csum: __u8,
        csum_valid: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let pkt_type: u8 = unsafe { ::core::mem::transmute(pkt_type) };
            pkt_type as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ignore_df: u8 = unsafe { ::core::mem::transmute(ignore_df) };
            ignore_df as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let nf_trace: u8 = unsafe { ::core::mem::transmute(nf_trace) };
            nf_trace as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let ip_summed: u8 = unsafe { ::core::mem::transmute(ip_summed) };
            ip_summed as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ooo_okay: u8 = unsafe { ::core::mem::transmute(ooo_okay) };
            ooo_okay as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let l4_hash: u8 = unsafe { ::core::mem::transmute(l4_hash) };
            l4_hash as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sw_hash: u8 = unsafe { ::core::mem::transmute(sw_hash) };
            sw_hash as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wifi_acked_valid: u8 = unsafe { ::core::mem::transmute(wifi_acked_valid) };
            wifi_acked_valid as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let wifi_acked: u8 = unsafe { ::core::mem::transmute(wifi_acked) };
            wifi_acked as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let no_fcs: u8 = unsafe { ::core::mem::transmute(no_fcs) };
            no_fcs as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let encapsulation: u8 = unsafe { ::core::mem::transmute(encapsulation) };
            encapsulation as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let encap_hdr_csum: u8 = unsafe { ::core::mem::transmute(encap_hdr_csum) };
            encap_hdr_csum as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let csum_valid: u8 = unsafe { ::core::mem::transmute(csum_valid) };
            csum_valid as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn vlan_present(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_vlan_present(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_complete_sw(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_complete_sw(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_level(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_csum_level(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_pending_confirm(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dst_pending_confirm(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mono_delivery_time(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mono_delivery_time(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ndisc_nodetype(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_ndisc_nodetype(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ipvs_property(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ipvs_property(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inner_protocol_type(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inner_protocol_type(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remcsum_offload(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remcsum_offload(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn redirected(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_redirected(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slow_gro(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slow_gro(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_not_inet(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_not_inet(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scm_io_uring(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_scm_io_uring(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        vlan_present: __u8,
        csum_complete_sw: __u8,
        csum_level: __u8,
        dst_pending_confirm: __u8,
        mono_delivery_time: __u8,
        ndisc_nodetype: __u8,
        ipvs_property: __u8,
        inner_protocol_type: __u8,
        remcsum_offload: __u8,
        redirected: __u8,
        slow_gro: __u8,
        csum_not_inet: __u8,
        scm_io_uring: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let vlan_present: u8 = unsafe { ::core::mem::transmute(vlan_present) };
            vlan_present as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let csum_complete_sw: u8 = unsafe { ::core::mem::transmute(csum_complete_sw) };
            csum_complete_sw as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let csum_level: u8 = unsafe { ::core::mem::transmute(csum_level) };
            csum_level as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_pending_confirm: u8 = unsafe { ::core::mem::transmute(dst_pending_confirm) };
            dst_pending_confirm as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mono_delivery_time: u8 = unsafe { ::core::mem::transmute(mono_delivery_time) };
            mono_delivery_time as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let ndisc_nodetype: u8 = unsafe { ::core::mem::transmute(ndisc_nodetype) };
            ndisc_nodetype as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ipvs_property: u8 = unsafe { ::core::mem::transmute(ipvs_property) };
            ipvs_property as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let inner_protocol_type: u8 = unsafe { ::core::mem::transmute(inner_protocol_type) };
            inner_protocol_type as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let remcsum_offload: u8 = unsafe { ::core::mem::transmute(remcsum_offload) };
            remcsum_offload as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let redirected: u8 = unsafe { ::core::mem::transmute(redirected) };
            redirected as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let slow_gro: u8 = unsafe { ::core::mem::transmute(slow_gro) };
            slow_gro as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let csum_not_inet: u8 = unsafe { ::core::mem::transmute(csum_not_inet) };
            csum_not_inet as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scm_io_uring: u8 = unsafe { ::core::mem::transmute(scm_io_uring) };
            scm_io_uring as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for sk_buff__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sk_buff {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_buff {
    #[inline]
    pub fn cloned(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cloned(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nohdr(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nohdr(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fclone(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fclone(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn peeked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_peeked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn head_frag(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_head_frag(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pfmemalloc(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pfmemalloc(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pp_recycle(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pp_recycle(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cloned: __u8,
        nohdr: __u8,
        fclone: __u8,
        peeked: __u8,
        head_frag: __u8,
        pfmemalloc: __u8,
        pp_recycle: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cloned: u8 = unsafe { ::core::mem::transmute(cloned) };
            cloned as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let nohdr: u8 = unsafe { ::core::mem::transmute(nohdr) };
            nohdr as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let fclone: u8 = unsafe { ::core::mem::transmute(fclone) };
            fclone as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let peeked: u8 = unsafe { ::core::mem::transmute(peeked) };
            peeked as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let head_frag: u8 = unsafe { ::core::mem::transmute(head_frag) };
            head_frag as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let pfmemalloc: u8 = unsafe { ::core::mem::transmute(pfmemalloc) };
            pfmemalloc as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let pp_recycle: u8 = unsafe { ::core::mem::transmute(pp_recycle) };
            pp_recycle as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn kfree_skb_reason(skb: *mut sk_buff, reason: skb_drop_reason);
}
extern "C" {
    pub fn skb_release_head_state(skb: *mut sk_buff);
}
extern "C" {
    pub fn kfree_skb_list_reason(segs: *mut sk_buff, reason: skb_drop_reason);
}
extern "C" {
    pub fn skb_dump(level: *const core::ffi::c_char, skb: *const sk_buff, full_pkt: bool_);
}
extern "C" {
    pub fn skb_tx_error(skb: *mut sk_buff);
}
extern "C" {
    pub fn __consume_stateless_skb(skb: *mut sk_buff);
}
extern "C" {
    pub fn __kfree_skb(skb: *mut sk_buff);
}
extern "C" {
    pub static mut skbuff_head_cache: *mut kmem_cache;
}
extern "C" {
    pub fn kfree_skb_partial(skb: *mut sk_buff, head_stolen: bool_);
}
extern "C" {
    pub fn skb_try_coalesce(
        to: *mut sk_buff,
        from: *mut sk_buff,
        fragstolen: *mut bool_,
        delta_truesize: *mut core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn __alloc_skb(
        size: core::ffi::c_uint,
        priority: gfp_t,
        flags: core::ffi::c_int,
        node: core::ffi::c_int,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn __build_skb(data: *mut core::ffi::c_void, frag_size: core::ffi::c_uint) -> *mut sk_buff;
}
extern "C" {
    pub fn build_skb(data: *mut core::ffi::c_void, frag_size: core::ffi::c_uint) -> *mut sk_buff;
}
extern "C" {
    pub fn build_skb_around(
        skb: *mut sk_buff,
        data: *mut core::ffi::c_void,
        frag_size: core::ffi::c_uint,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_attempt_defer_free(skb: *mut sk_buff);
}
extern "C" {
    pub fn napi_build_skb(
        data: *mut core::ffi::c_void,
        frag_size: core::ffi::c_uint,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn alloc_skb_with_frags(
        header_len: core::ffi::c_ulong,
        data_len: core::ffi::c_ulong,
        max_page_order: core::ffi::c_int,
        errcode: *mut core::ffi::c_int,
        gfp_mask: gfp_t,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn alloc_skb_for_msg(first: *mut sk_buff) -> *mut sk_buff;
}
#[repr(C)]
pub struct sk_buff_fclones {
    pub skb1: sk_buff,
    pub skb2: sk_buff,
    pub fclone_ref: refcount_t,
}
impl Default for sk_buff_fclones {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn skb_morph(dst: *mut sk_buff, src: *mut sk_buff) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_headers_offset_update(skb: *mut sk_buff, off: core::ffi::c_int);
}
extern "C" {
    pub fn skb_copy_ubufs(skb: *mut sk_buff, gfp_mask: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_clone(skb: *mut sk_buff, priority: gfp_t) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_copy_header(new: *mut sk_buff, old: *const sk_buff);
}
extern "C" {
    pub fn skb_copy(skb: *const sk_buff, priority: gfp_t) -> *mut sk_buff;
}
extern "C" {
    pub fn __pskb_copy_fclone(
        skb: *mut sk_buff,
        headroom: core::ffi::c_int,
        gfp_mask: gfp_t,
        fclone: bool_,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn pskb_expand_head(
        skb: *mut sk_buff,
        nhead: core::ffi::c_int,
        ntail: core::ffi::c_int,
        gfp_mask: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_realloc_headroom(skb: *mut sk_buff, headroom: core::ffi::c_uint) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_expand_head(skb: *mut sk_buff, headroom: core::ffi::c_uint) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_copy_expand(
        skb: *const sk_buff,
        newheadroom: core::ffi::c_int,
        newtailroom: core::ffi::c_int,
        priority: gfp_t,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_to_sgvec_nomark(
        skb: *mut sk_buff,
        sg: *mut scatterlist,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_to_sgvec(
        skb: *mut sk_buff,
        sg: *mut scatterlist,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_cow_data(
        skb: *mut sk_buff,
        tailbits: core::ffi::c_int,
        trailer: *mut *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __skb_pad(
        skb: *mut sk_buff,
        pad: core::ffi::c_int,
        free_on_error: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_append_pagefrags(
        skb: *mut sk_buff,
        page: *mut page,
        offset: core::ffi::c_int,
        size: usize,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skb_seq_state {
    pub lower_offset: __u32,
    pub upper_offset: __u32,
    pub frag_idx: __u32,
    pub stepped_offset: __u32,
    pub root_skb: *mut sk_buff,
    pub cur_skb: *mut sk_buff,
    pub frag_data: *mut __u8,
    pub frag_off: __u32,
}
impl Default for skb_seq_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn skb_prepare_seq_read(
        skb: *mut sk_buff,
        from: core::ffi::c_uint,
        to: core::ffi::c_uint,
        st: *mut skb_seq_state,
    );
}
extern "C" {
    pub fn skb_seq_read(
        consumed: core::ffi::c_uint,
        data: *mut *const u8_,
        st: *mut skb_seq_state,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn skb_abort_seq_read(st: *mut skb_seq_state);
}
extern "C" {
    pub fn skb_find_text(
        skb: *mut sk_buff,
        from: core::ffi::c_uint,
        to: core::ffi::c_uint,
        config: *mut ts_config,
    ) -> core::ffi::c_uint;
}
pub const pkt_hash_types_PKT_HASH_TYPE_NONE: pkt_hash_types = 0;
pub const pkt_hash_types_PKT_HASH_TYPE_L2: pkt_hash_types = 1;
pub const pkt_hash_types_PKT_HASH_TYPE_L3: pkt_hash_types = 2;
pub const pkt_hash_types_PKT_HASH_TYPE_L4: pkt_hash_types = 3;
pub type pkt_hash_types = core::ffi::c_uint;
extern "C" {
    pub fn __skb_get_hash(skb: *mut sk_buff);
}
extern "C" {
    pub fn __skb_get_hash_symmetric(skb: *const sk_buff) -> u32_;
}
extern "C" {
    pub fn skb_get_poff(skb: *const sk_buff) -> u32_;
}
extern "C" {
    pub fn __skb_get_poff(
        skb: *const sk_buff,
        data: *const core::ffi::c_void,
        keys: *const flow_keys_basic,
        hlen: core::ffi::c_int,
    ) -> u32_;
}
extern "C" {
    pub fn __skb_flow_get_ports(
        skb: *const sk_buff,
        thoff: core::ffi::c_int,
        ip_proto: u8_,
        data: *const core::ffi::c_void,
        hlen_proto: core::ffi::c_int,
    ) -> __be32;
}
extern "C" {
    pub fn skb_flow_dissector_init(
        flow_dissector: *mut flow_dissector,
        key: *const flow_dissector_key,
        key_count: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn bpf_flow_dissect(
        prog: *mut bpf_prog,
        ctx: *mut bpf_flow_dissector,
        proto: __be16,
        nhoff: core::ffi::c_int,
        hlen: core::ffi::c_int,
        flags: core::ffi::c_uint,
    ) -> u32_;
}
extern "C" {
    pub fn __skb_flow_dissect(
        net: *const net,
        skb: *const sk_buff,
        flow_dissector: *mut flow_dissector,
        target_container: *mut core::ffi::c_void,
        data: *const core::ffi::c_void,
        proto: __be16,
        nhoff: core::ffi::c_int,
        hlen: core::ffi::c_int,
        flags: core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn skb_flow_dissect_meta(
        skb: *const sk_buff,
        flow_dissector: *mut flow_dissector,
        target_container: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn skb_flow_dissect_ct(
        skb: *const sk_buff,
        flow_dissector: *mut flow_dissector,
        target_container: *mut core::ffi::c_void,
        ctinfo_map: *mut u16_,
        mapsize: usize,
        post_ct: bool_,
        zone: u16_,
    );
}
extern "C" {
    pub fn skb_flow_dissect_tunnel_info(
        skb: *const sk_buff,
        flow_dissector: *mut flow_dissector,
        target_container: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn skb_flow_dissect_hash(
        skb: *const sk_buff,
        flow_dissector: *mut flow_dissector,
        target_container: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn skb_get_hash_perturb(skb: *const sk_buff, perturb: *const siphash_key_t) -> __u32;
}
extern "C" {
    pub fn msg_zerocopy_realloc(sk: *mut sock, size: usize, uarg: *mut ubuf_info)
        -> *mut ubuf_info;
}
extern "C" {
    pub fn msg_zerocopy_put_abort(uarg: *mut ubuf_info, have_uref: bool_);
}
extern "C" {
    pub fn msg_zerocopy_callback(skb: *mut sk_buff, uarg: *mut ubuf_info, success: bool_);
}
extern "C" {
    pub fn __zerocopy_sg_from_iter(
        msg: *mut msghdr,
        sk: *mut sock,
        skb: *mut sk_buff,
        from: *mut iov_iter,
        length: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_zerocopy_iter_stream(
        sk: *mut sock,
        skb: *mut sk_buff,
        msg: *mut msghdr,
        len: core::ffi::c_int,
        uarg: *mut ubuf_info,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __skb_zcopy_downgrade_managed(skb: *mut sk_buff);
}
extern "C" {
    pub fn __skb_unclone_keeptruesize(skb: *mut sk_buff, pri: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_append(old: *mut sk_buff, newsk: *mut sk_buff, list: *mut sk_buff_head);
}
extern "C" {
    pub fn skb_queue_head(list: *mut sk_buff_head, newsk: *mut sk_buff);
}
extern "C" {
    pub fn skb_queue_tail(list: *mut sk_buff_head, newsk: *mut sk_buff);
}
extern "C" {
    pub fn skb_unlink(skb: *mut sk_buff, list: *mut sk_buff_head);
}
extern "C" {
    pub fn skb_dequeue(list: *mut sk_buff_head) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_dequeue_tail(list: *mut sk_buff_head) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_add_rx_frag(
        skb: *mut sk_buff,
        i: core::ffi::c_int,
        page: *mut page,
        off: core::ffi::c_int,
        size: core::ffi::c_int,
        truesize: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn skb_coalesce_rx_frag(
        skb: *mut sk_buff,
        i: core::ffi::c_int,
        size: core::ffi::c_int,
        truesize: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn pskb_put(
        skb: *mut sk_buff,
        tail: *mut sk_buff,
        len: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_put(skb: *mut sk_buff, len: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_push(skb: *mut sk_buff, len: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_pull(skb: *mut sk_buff, len: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_pull_data(skb: *mut sk_buff, len: usize) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __pskb_pull_tail(skb: *mut sk_buff, delta: core::ffi::c_int) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_condense(skb: *mut sk_buff);
}
extern "C" {
    pub fn ___pskb_trim(skb: *mut sk_buff, len: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_trim(skb: *mut sk_buff, len: core::ffi::c_uint);
}
extern "C" {
    pub fn skb_queue_purge(list: *mut sk_buff_head);
}
extern "C" {
    pub fn skb_rbtree_purge(root: *mut rb_root) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __netdev_alloc_frag_align(
        fragsz: core::ffi::c_uint,
        align_mask: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __netdev_alloc_skb(
        dev: *mut net_device,
        length: core::ffi::c_uint,
        gfp_mask: gfp_t,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn __napi_alloc_frag_align(
        fragsz: core::ffi::c_uint,
        align_mask: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __napi_alloc_skb(
        napi: *mut napi_struct,
        length: core::ffi::c_uint,
        gfp_mask: gfp_t,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn napi_consume_skb(skb: *mut sk_buff, budget: core::ffi::c_int);
}
extern "C" {
    pub fn napi_skb_free_stolen_head(skb: *mut sk_buff);
}
extern "C" {
    pub fn __kfree_skb_defer(skb: *mut sk_buff);
}
extern "C" {
    pub fn skb_page_frag_refill(sz: core::ffi::c_uint, pfrag: *mut page_frag, prio: gfp_t)
        -> bool_;
}
extern "C" {
    pub fn skb_pull_rcsum(skb: *mut sk_buff, len: core::ffi::c_uint) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn pskb_trim_rcsum_slow(skb: *mut sk_buff, len: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn __skb_wait_for_more_packets(
        sk: *mut sock,
        queue: *mut sk_buff_head,
        err: *mut core::ffi::c_int,
        timeo_p: *mut core::ffi::c_long,
        skb: *const sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __skb_try_recv_from_queue(
        sk: *mut sock,
        queue: *mut sk_buff_head,
        flags: core::ffi::c_uint,
        off: *mut core::ffi::c_int,
        err: *mut core::ffi::c_int,
        last: *mut *mut sk_buff,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn __skb_try_recv_datagram(
        sk: *mut sock,
        queue: *mut sk_buff_head,
        flags: core::ffi::c_uint,
        off: *mut core::ffi::c_int,
        err: *mut core::ffi::c_int,
        last: *mut *mut sk_buff,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn __skb_recv_datagram(
        sk: *mut sock,
        sk_queue: *mut sk_buff_head,
        flags: core::ffi::c_uint,
        off: *mut core::ffi::c_int,
        err: *mut core::ffi::c_int,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_recv_datagram(
        sk: *mut sock,
        flags: core::ffi::c_uint,
        err: *mut core::ffi::c_int,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn datagram_poll(
        file: *mut file,
        sock: *mut socket,
        wait: *mut poll_table_struct,
    ) -> __poll_t;
}
extern "C" {
    pub fn skb_copy_datagram_iter(
        from: *const sk_buff,
        offset: core::ffi::c_int,
        to: *mut iov_iter,
        size: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_and_csum_datagram_msg(
        skb: *mut sk_buff,
        hlen: core::ffi::c_int,
        msg: *mut msghdr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_and_hash_datagram_iter(
        skb: *const sk_buff,
        offset: core::ffi::c_int,
        to: *mut iov_iter,
        len: core::ffi::c_int,
        hash: *mut ahash_request,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_datagram_from_iter(
        skb: *mut sk_buff,
        offset: core::ffi::c_int,
        from: *mut iov_iter,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn zerocopy_sg_from_iter(skb: *mut sk_buff, frm: *mut iov_iter) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_free_datagram(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn __skb_free_datagram_locked(sk: *mut sock, skb: *mut sk_buff, len: core::ffi::c_int);
}
extern "C" {
    pub fn skb_kill_datagram(
        sk: *mut sock,
        skb: *mut sk_buff,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_bits(
        skb: *const sk_buff,
        offset: core::ffi::c_int,
        to: *mut core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_store_bits(
        skb: *mut sk_buff,
        offset: core::ffi::c_int,
        from: *const core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_and_csum_bits(
        skb: *const sk_buff,
        offset: core::ffi::c_int,
        to: *mut u8_,
        len: core::ffi::c_int,
    ) -> __wsum;
}
extern "C" {
    pub fn skb_splice_bits(
        skb: *mut sk_buff,
        sk: *mut sock,
        offset: core::ffi::c_uint,
        pipe: *mut pipe_inode_info,
        len: core::ffi::c_uint,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_send_sock_locked(
        sk: *mut sock,
        skb: *mut sk_buff,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_send_sock(
        sk: *mut sock,
        skb: *mut sk_buff,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_copy_and_csum_dev(skb: *const sk_buff, to: *mut u8_);
}
extern "C" {
    pub fn skb_zerocopy_headlen(from: *const sk_buff) -> core::ffi::c_uint;
}
extern "C" {
    pub fn skb_zerocopy(
        to: *mut sk_buff,
        from: *mut sk_buff,
        len: core::ffi::c_int,
        hlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_split(skb: *mut sk_buff, skb1: *mut sk_buff, len: u32_);
}
extern "C" {
    pub fn skb_shift(
        tgt: *mut sk_buff,
        skb: *mut sk_buff,
        shiftlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_scrub_packet(skb: *mut sk_buff, xnet: bool_);
}
extern "C" {
    pub fn skb_gso_validate_network_len(skb: *const sk_buff, mtu: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn skb_gso_validate_mac_len(skb: *const sk_buff, len: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn skb_segment(skb: *mut sk_buff, features: netdev_features_t) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_segment_list(
        skb: *mut sk_buff,
        features: netdev_features_t,
        offset: core::ffi::c_uint,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_vlan_untag(skb: *mut sk_buff) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_ensure_writable(skb: *mut sk_buff, write_len: core::ffi::c_uint)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn __skb_vlan_pop(skb: *mut sk_buff, vlan_tci: *mut u16_) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_vlan_pop(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_vlan_push(skb: *mut sk_buff, vlan_proto: __be16, vlan_tci: u16_)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_eth_pop(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_eth_push(
        skb: *mut sk_buff,
        dst: *const core::ffi::c_uchar,
        src: *const core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_mpls_push(
        skb: *mut sk_buff,
        mpls_lse: __be32,
        mpls_proto: __be16,
        mac_len: core::ffi::c_int,
        ethernet: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_mpls_pop(
        skb: *mut sk_buff,
        next_proto: __be16,
        mac_len: core::ffi::c_int,
        ethernet: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_mpls_update_lse(skb: *mut sk_buff, mpls_lse: __be32) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_mpls_dec_ttl(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn pskb_extract(
        skb: *mut sk_buff,
        off: core::ffi::c_int,
        to_copy: core::ffi::c_int,
        gfp: gfp_t,
    ) -> *mut sk_buff;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct skb_checksum_ops {
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            mem: *const core::ffi::c_void,
            len: core::ffi::c_int,
            wsum: __wsum,
        ) -> __wsum,
    >,
    pub combine: ::core::option::Option<
        unsafe extern "C" fn(
            csum: __wsum,
            csum2: __wsum,
            offset: core::ffi::c_int,
            len: core::ffi::c_int,
        ) -> __wsum,
    >,
}
extern "C" {
    pub static mut crc32c_csum_stub: *const skb_checksum_ops;
}
extern "C" {
    pub fn __skb_checksum(
        skb: *const sk_buff,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
        csum: __wsum,
        ops: *const skb_checksum_ops,
    ) -> __wsum;
}
extern "C" {
    pub fn skb_checksum(
        skb: *const sk_buff,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
        csum: __wsum,
    ) -> __wsum;
}
extern "C" {
    pub fn skb_init();
}
extern "C" {
    pub static mut netstamp_needed_key: static_key_false;
}
extern "C" {
    pub fn skb_clone_sk(skb: *mut sk_buff) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_complete_tx_timestamp(skb: *mut sk_buff, hwtstamps: *mut skb_shared_hwtstamps);
}
extern "C" {
    pub fn __skb_tstamp_tx(
        orig_skb: *mut sk_buff,
        ack_skb: *const sk_buff,
        hwtstamps: *mut skb_shared_hwtstamps,
        sk: *mut sock,
        tstype: core::ffi::c_int,
    );
}
extern "C" {
    pub fn skb_tstamp_tx(orig_skb: *mut sk_buff, hwtstamps: *mut skb_shared_hwtstamps);
}
extern "C" {
    pub fn skb_complete_wifi_ack(skb: *mut sk_buff, acked: bool_);
}
extern "C" {
    pub fn __skb_checksum_complete_head(skb: *mut sk_buff, len: core::ffi::c_int) -> __sum16;
}
extern "C" {
    pub fn __skb_checksum_complete(skb: *mut sk_buff) -> __sum16;
}
pub const skb_ext_id_SKB_EXT_BRIDGE_NF: skb_ext_id = 0;
pub const skb_ext_id_SKB_EXT_SEC_PATH: skb_ext_id = 1;
pub const skb_ext_id_SKB_EXT_NUM: skb_ext_id = 2;
pub type skb_ext_id = core::ffi::c_uint;
#[repr(C)]
#[repr(align(8))]
#[derive(Default)]
pub struct skb_ext {
    pub refcnt: refcount_t,
    pub offset: [u8_; 2usize],
    pub chunks: u8_,
    pub __bindgen_padding_0: u8,
    pub data: __IncompleteArrayField<core::ffi::c_char>,
}
extern "C" {
    pub fn __skb_ext_alloc(flags: gfp_t) -> *mut skb_ext;
}
extern "C" {
    pub fn __skb_ext_set(
        skb: *mut sk_buff,
        id: skb_ext_id,
        ext: *mut skb_ext,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn skb_ext_add(skb: *mut sk_buff, id: skb_ext_id) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __skb_ext_del(skb: *mut sk_buff, id: skb_ext_id);
}
extern "C" {
    pub fn __skb_ext_put(ext: *mut skb_ext);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sec_path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct skb_gso_cb {
    pub __bindgen_anon_1: skb_gso_cb__bindgen_ty_1,
    pub encap_level: core::ffi::c_int,
    pub csum: __wsum,
    pub csum_start: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union skb_gso_cb__bindgen_ty_1 {
    pub mac_offset: core::ffi::c_int,
    pub data_offset: core::ffi::c_int,
    _bindgen_union_align: u32,
}
impl Default for skb_gso_cb__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for skb_gso_cb {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __skb_warn_lro_forwarding(skb: *const sk_buff);
}
extern "C" {
    pub fn skb_partial_csum_set(skb: *mut sk_buff, start: u16_, off: u16_) -> bool_;
}
extern "C" {
    pub fn skb_checksum_setup(skb: *mut sk_buff, recalculate: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_checksum_trimmed(
        skb: *mut sk_buff,
        transport_len: core::ffi::c_uint,
        skb_chkf: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff) -> __sum16>,
    ) -> *mut sk_buff;
}
pub const IPPROTO_IP: core::ffi::c_uint = 0;
pub const IPPROTO_ICMP: core::ffi::c_uint = 1;
pub const IPPROTO_IGMP: core::ffi::c_uint = 2;
pub const IPPROTO_IPIP: core::ffi::c_uint = 4;
pub const IPPROTO_TCP: core::ffi::c_uint = 6;
pub const IPPROTO_EGP: core::ffi::c_uint = 8;
pub const IPPROTO_PUP: core::ffi::c_uint = 12;
pub const IPPROTO_UDP: core::ffi::c_uint = 17;
pub const IPPROTO_IDP: core::ffi::c_uint = 22;
pub const IPPROTO_TP: core::ffi::c_uint = 29;
pub const IPPROTO_DCCP: core::ffi::c_uint = 33;
pub const IPPROTO_IPV6: core::ffi::c_uint = 41;
pub const IPPROTO_RSVP: core::ffi::c_uint = 46;
pub const IPPROTO_GRE: core::ffi::c_uint = 47;
pub const IPPROTO_ESP: core::ffi::c_uint = 50;
pub const IPPROTO_AH: core::ffi::c_uint = 51;
pub const IPPROTO_MTP: core::ffi::c_uint = 92;
pub const IPPROTO_BEETPH: core::ffi::c_uint = 94;
pub const IPPROTO_ENCAP: core::ffi::c_uint = 98;
pub const IPPROTO_PIM: core::ffi::c_uint = 103;
pub const IPPROTO_COMP: core::ffi::c_uint = 108;
pub const IPPROTO_L2TP: core::ffi::c_uint = 115;
pub const IPPROTO_SCTP: core::ffi::c_uint = 132;
pub const IPPROTO_UDPLITE: core::ffi::c_uint = 136;
pub const IPPROTO_MPLS: core::ffi::c_uint = 137;
pub const IPPROTO_ETHERNET: core::ffi::c_uint = 143;
pub const IPPROTO_RAW: core::ffi::c_uint = 255;
pub const IPPROTO_MPTCP: core::ffi::c_uint = 262;
pub const IPPROTO_MAX: core::ffi::c_uint = 263;
pub type _bindgen_ty_125 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: __be32,
    pub imr_interface: __be32,
    pub imr_sourceaddr: __be32,
}
#[repr(C)]
pub struct ip_msfilter {
    pub imsf_multiaddr: __be32,
    pub imsf_interface: __be32,
    pub imsf_fmode: __u32,
    pub imsf_numsrc: __u32,
    pub __bindgen_anon_1: ip_msfilter__bindgen_ty_1,
}
#[repr(C)]
pub struct ip_msfilter__bindgen_ty_1 {
    pub imsf_slist: __BindgenUnionField<[__be32; 1usize]>,
    pub __bindgen_anon_1: __BindgenUnionField<ip_msfilter__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Default)]
pub struct ip_msfilter__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_imsf_slist_flex: ip_msfilter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub imsf_slist_flex: __IncompleteArrayField<__be32>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_msfilter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
impl Default for ip_msfilter__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for ip_msfilter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_req {
    pub gr_interface: __u32,
    pub gr_group: __kernel_sockaddr_storage,
}
impl Default for group_req {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_source_req {
    pub gsr_interface: __u32,
    pub gsr_group: __kernel_sockaddr_storage,
    pub gsr_source: __kernel_sockaddr_storage,
}
impl Default for group_source_req {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct group_filter {
    pub __bindgen_anon_1: group_filter__bindgen_ty_1,
}
#[repr(C)]
pub struct group_filter__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<group_filter__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<group_filter__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 34usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_filter__bindgen_ty_1__bindgen_ty_1 {
    pub gf_interface_aux: __u32,
    pub gf_group_aux: __kernel_sockaddr_storage,
    pub gf_fmode_aux: __u32,
    pub gf_numsrc_aux: __u32,
    pub gf_slist: [__kernel_sockaddr_storage; 1usize],
}
impl Default for group_filter__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct group_filter__bindgen_ty_1__bindgen_ty_2 {
    pub gf_interface: __u32,
    pub gf_group: __kernel_sockaddr_storage,
    pub gf_fmode: __u32,
    pub gf_numsrc: __u32,
    pub gf_slist_flex: __IncompleteArrayField<__kernel_sockaddr_storage>,
}
impl Default for group_filter__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for group_filter__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for group_filter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: core::ffi::c_int,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: __kernel_sa_family_t,
    pub sin_port: __be16,
    pub sin_addr: in_addr,
    pub __pad: [core::ffi::c_uchar; 8usize],
}
pub const nf_inet_hooks_NF_INET_PRE_ROUTING: nf_inet_hooks = 0;
pub const nf_inet_hooks_NF_INET_LOCAL_IN: nf_inet_hooks = 1;
pub const nf_inet_hooks_NF_INET_FORWARD: nf_inet_hooks = 2;
pub const nf_inet_hooks_NF_INET_LOCAL_OUT: nf_inet_hooks = 3;
pub const nf_inet_hooks_NF_INET_POST_ROUTING: nf_inet_hooks = 4;
pub const nf_inet_hooks_NF_INET_NUMHOOKS: nf_inet_hooks = 5;
pub const nf_inet_hooks_NF_INET_INGRESS: nf_inet_hooks = 5;
pub type nf_inet_hooks = core::ffi::c_uint;
pub const nf_dev_hooks_NF_NETDEV_INGRESS: nf_dev_hooks = 0;
pub const nf_dev_hooks_NF_NETDEV_EGRESS: nf_dev_hooks = 1;
pub const nf_dev_hooks_NF_NETDEV_NUMHOOKS: nf_dev_hooks = 2;
pub type nf_dev_hooks = core::ffi::c_uint;
pub const NFPROTO_UNSPEC: core::ffi::c_uint = 0;
pub const NFPROTO_INET: core::ffi::c_uint = 1;
pub const NFPROTO_IPV4: core::ffi::c_uint = 2;
pub const NFPROTO_ARP: core::ffi::c_uint = 3;
pub const NFPROTO_NETDEV: core::ffi::c_uint = 5;
pub const NFPROTO_BRIDGE: core::ffi::c_uint = 7;
pub const NFPROTO_IPV6: core::ffi::c_uint = 10;
pub const NFPROTO_NUMPROTO: core::ffi::c_uint = 11;
pub type _bindgen_ty_126 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_inet_addr {
    pub all: [__u32; 4usize],
    pub ip: __be32,
    pub ip6: [__be32; 4usize],
    pub in_: in_addr,
    pub in6: in6_addr,
    _bindgen_union_align: [u32; 4usize],
}
impl Default for nf_inet_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut loops_per_jiffy: core::ffi::c_ulong;
}
extern "C" {
    pub static mut riscv_timebase: core::ffi::c_ulong;
}
extern "C" {
    pub fn udelay(usecs: core::ffi::c_ulong);
}
extern "C" {
    pub fn ndelay(nsecs: core::ffi::c_ulong);
}
extern "C" {
    pub fn __delay(cycles: core::ffi::c_ulong);
}
extern "C" {
    pub static mut lpj_fine: core::ffi::c_ulong;
}
extern "C" {
    pub fn calibrate_delay();
}
extern "C" {
    pub fn calibration_delay_done();
}
extern "C" {
    pub fn msleep(msecs: core::ffi::c_uint);
}
extern "C" {
    pub fn msleep_interruptible(msecs: core::ffi::c_uint) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn usleep_range_state(
        min: core::ffi::c_ulong,
        max: core::ffi::c_ulong,
        state: core::ffi::c_uint,
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dql {
    pub num_queued: core::ffi::c_uint,
    pub adj_limit: core::ffi::c_uint,
    pub last_obj_cnt: core::ffi::c_uint,
    pub __bindgen_padding_0: [u32; 13usize],
    pub limit: core::ffi::c_uint,
    pub num_completed: core::ffi::c_uint,
    pub prev_ovlimit: core::ffi::c_uint,
    pub prev_num_queued: core::ffi::c_uint,
    pub prev_last_obj_cnt: core::ffi::c_uint,
    pub lowest_slack: core::ffi::c_uint,
    pub slack_start_time: core::ffi::c_ulong,
    pub max_limit: core::ffi::c_uint,
    pub min_limit: core::ffi::c_uint,
    pub slack_hold_time: core::ffi::c_uint,
}
impl Default for dql {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn dql_completed(dql: *mut dql, count: core::ffi::c_uint);
}
extern "C" {
    pub fn dql_reset(dql: *mut dql);
}
extern "C" {
    pub fn dql_init(dql: *mut dql, hold_time: core::ffi::c_uint);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_core {
    pub sysctl_hdr: *mut ctl_table_header,
    pub sysctl_somaxconn: core::ffi::c_int,
    pub sysctl_txrehash: u8_,
    pub prot_inuse: *mut prot_inuse,
}
impl Default for netns_core {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const IPSTATS_MIB_NUM: core::ffi::c_uint = 0;
pub const IPSTATS_MIB_INPKTS: core::ffi::c_uint = 1;
pub const IPSTATS_MIB_INOCTETS: core::ffi::c_uint = 2;
pub const IPSTATS_MIB_INDELIVERS: core::ffi::c_uint = 3;
pub const IPSTATS_MIB_OUTFORWDATAGRAMS: core::ffi::c_uint = 4;
pub const IPSTATS_MIB_OUTPKTS: core::ffi::c_uint = 5;
pub const IPSTATS_MIB_OUTOCTETS: core::ffi::c_uint = 6;
pub const IPSTATS_MIB_INHDRERRORS: core::ffi::c_uint = 7;
pub const IPSTATS_MIB_INTOOBIGERRORS: core::ffi::c_uint = 8;
pub const IPSTATS_MIB_INNOROUTES: core::ffi::c_uint = 9;
pub const IPSTATS_MIB_INADDRERRORS: core::ffi::c_uint = 10;
pub const IPSTATS_MIB_INUNKNOWNPROTOS: core::ffi::c_uint = 11;
pub const IPSTATS_MIB_INTRUNCATEDPKTS: core::ffi::c_uint = 12;
pub const IPSTATS_MIB_INDISCARDS: core::ffi::c_uint = 13;
pub const IPSTATS_MIB_OUTDISCARDS: core::ffi::c_uint = 14;
pub const IPSTATS_MIB_OUTNOROUTES: core::ffi::c_uint = 15;
pub const IPSTATS_MIB_REASMTIMEOUT: core::ffi::c_uint = 16;
pub const IPSTATS_MIB_REASMREQDS: core::ffi::c_uint = 17;
pub const IPSTATS_MIB_REASMOKS: core::ffi::c_uint = 18;
pub const IPSTATS_MIB_REASMFAILS: core::ffi::c_uint = 19;
pub const IPSTATS_MIB_FRAGOKS: core::ffi::c_uint = 20;
pub const IPSTATS_MIB_FRAGFAILS: core::ffi::c_uint = 21;
pub const IPSTATS_MIB_FRAGCREATES: core::ffi::c_uint = 22;
pub const IPSTATS_MIB_INMCASTPKTS: core::ffi::c_uint = 23;
pub const IPSTATS_MIB_OUTMCASTPKTS: core::ffi::c_uint = 24;
pub const IPSTATS_MIB_INBCASTPKTS: core::ffi::c_uint = 25;
pub const IPSTATS_MIB_OUTBCASTPKTS: core::ffi::c_uint = 26;
pub const IPSTATS_MIB_INMCASTOCTETS: core::ffi::c_uint = 27;
pub const IPSTATS_MIB_OUTMCASTOCTETS: core::ffi::c_uint = 28;
pub const IPSTATS_MIB_INBCASTOCTETS: core::ffi::c_uint = 29;
pub const IPSTATS_MIB_OUTBCASTOCTETS: core::ffi::c_uint = 30;
pub const IPSTATS_MIB_CSUMERRORS: core::ffi::c_uint = 31;
pub const IPSTATS_MIB_NOECTPKTS: core::ffi::c_uint = 32;
pub const IPSTATS_MIB_ECT1PKTS: core::ffi::c_uint = 33;
pub const IPSTATS_MIB_ECT0PKTS: core::ffi::c_uint = 34;
pub const IPSTATS_MIB_CEPKTS: core::ffi::c_uint = 35;
pub const IPSTATS_MIB_REASM_OVERLAPS: core::ffi::c_uint = 36;
pub const __IPSTATS_MIB_MAX: core::ffi::c_uint = 37;
pub type _bindgen_ty_127 = core::ffi::c_uint;
pub const ICMP_MIB_NUM: core::ffi::c_uint = 0;
pub const ICMP_MIB_INMSGS: core::ffi::c_uint = 1;
pub const ICMP_MIB_INERRORS: core::ffi::c_uint = 2;
pub const ICMP_MIB_INDESTUNREACHS: core::ffi::c_uint = 3;
pub const ICMP_MIB_INTIMEEXCDS: core::ffi::c_uint = 4;
pub const ICMP_MIB_INPARMPROBS: core::ffi::c_uint = 5;
pub const ICMP_MIB_INSRCQUENCHS: core::ffi::c_uint = 6;
pub const ICMP_MIB_INREDIRECTS: core::ffi::c_uint = 7;
pub const ICMP_MIB_INECHOS: core::ffi::c_uint = 8;
pub const ICMP_MIB_INECHOREPS: core::ffi::c_uint = 9;
pub const ICMP_MIB_INTIMESTAMPS: core::ffi::c_uint = 10;
pub const ICMP_MIB_INTIMESTAMPREPS: core::ffi::c_uint = 11;
pub const ICMP_MIB_INADDRMASKS: core::ffi::c_uint = 12;
pub const ICMP_MIB_INADDRMASKREPS: core::ffi::c_uint = 13;
pub const ICMP_MIB_OUTMSGS: core::ffi::c_uint = 14;
pub const ICMP_MIB_OUTERRORS: core::ffi::c_uint = 15;
pub const ICMP_MIB_OUTDESTUNREACHS: core::ffi::c_uint = 16;
pub const ICMP_MIB_OUTTIMEEXCDS: core::ffi::c_uint = 17;
pub const ICMP_MIB_OUTPARMPROBS: core::ffi::c_uint = 18;
pub const ICMP_MIB_OUTSRCQUENCHS: core::ffi::c_uint = 19;
pub const ICMP_MIB_OUTREDIRECTS: core::ffi::c_uint = 20;
pub const ICMP_MIB_OUTECHOS: core::ffi::c_uint = 21;
pub const ICMP_MIB_OUTECHOREPS: core::ffi::c_uint = 22;
pub const ICMP_MIB_OUTTIMESTAMPS: core::ffi::c_uint = 23;
pub const ICMP_MIB_OUTTIMESTAMPREPS: core::ffi::c_uint = 24;
pub const ICMP_MIB_OUTADDRMASKS: core::ffi::c_uint = 25;
pub const ICMP_MIB_OUTADDRMASKREPS: core::ffi::c_uint = 26;
pub const ICMP_MIB_CSUMERRORS: core::ffi::c_uint = 27;
pub const __ICMP_MIB_MAX: core::ffi::c_uint = 28;
pub type _bindgen_ty_128 = core::ffi::c_uint;
pub const ICMP6_MIB_NUM: core::ffi::c_uint = 0;
pub const ICMP6_MIB_INMSGS: core::ffi::c_uint = 1;
pub const ICMP6_MIB_INERRORS: core::ffi::c_uint = 2;
pub const ICMP6_MIB_OUTMSGS: core::ffi::c_uint = 3;
pub const ICMP6_MIB_OUTERRORS: core::ffi::c_uint = 4;
pub const ICMP6_MIB_CSUMERRORS: core::ffi::c_uint = 5;
pub const __ICMP6_MIB_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_129 = core::ffi::c_uint;
pub const TCP_MIB_NUM: core::ffi::c_uint = 0;
pub const TCP_MIB_RTOALGORITHM: core::ffi::c_uint = 1;
pub const TCP_MIB_RTOMIN: core::ffi::c_uint = 2;
pub const TCP_MIB_RTOMAX: core::ffi::c_uint = 3;
pub const TCP_MIB_MAXCONN: core::ffi::c_uint = 4;
pub const TCP_MIB_ACTIVEOPENS: core::ffi::c_uint = 5;
pub const TCP_MIB_PASSIVEOPENS: core::ffi::c_uint = 6;
pub const TCP_MIB_ATTEMPTFAILS: core::ffi::c_uint = 7;
pub const TCP_MIB_ESTABRESETS: core::ffi::c_uint = 8;
pub const TCP_MIB_CURRESTAB: core::ffi::c_uint = 9;
pub const TCP_MIB_INSEGS: core::ffi::c_uint = 10;
pub const TCP_MIB_OUTSEGS: core::ffi::c_uint = 11;
pub const TCP_MIB_RETRANSSEGS: core::ffi::c_uint = 12;
pub const TCP_MIB_INERRS: core::ffi::c_uint = 13;
pub const TCP_MIB_OUTRSTS: core::ffi::c_uint = 14;
pub const TCP_MIB_CSUMERRORS: core::ffi::c_uint = 15;
pub const __TCP_MIB_MAX: core::ffi::c_uint = 16;
pub type _bindgen_ty_130 = core::ffi::c_uint;
pub const UDP_MIB_NUM: core::ffi::c_uint = 0;
pub const UDP_MIB_INDATAGRAMS: core::ffi::c_uint = 1;
pub const UDP_MIB_NOPORTS: core::ffi::c_uint = 2;
pub const UDP_MIB_INERRORS: core::ffi::c_uint = 3;
pub const UDP_MIB_OUTDATAGRAMS: core::ffi::c_uint = 4;
pub const UDP_MIB_RCVBUFERRORS: core::ffi::c_uint = 5;
pub const UDP_MIB_SNDBUFERRORS: core::ffi::c_uint = 6;
pub const UDP_MIB_CSUMERRORS: core::ffi::c_uint = 7;
pub const UDP_MIB_IGNOREDMULTI: core::ffi::c_uint = 8;
pub const UDP_MIB_MEMERRORS: core::ffi::c_uint = 9;
pub const __UDP_MIB_MAX: core::ffi::c_uint = 10;
pub type _bindgen_ty_131 = core::ffi::c_uint;
pub const LINUX_MIB_NUM: core::ffi::c_uint = 0;
pub const LINUX_MIB_SYNCOOKIESSENT: core::ffi::c_uint = 1;
pub const LINUX_MIB_SYNCOOKIESRECV: core::ffi::c_uint = 2;
pub const LINUX_MIB_SYNCOOKIESFAILED: core::ffi::c_uint = 3;
pub const LINUX_MIB_EMBRYONICRSTS: core::ffi::c_uint = 4;
pub const LINUX_MIB_PRUNECALLED: core::ffi::c_uint = 5;
pub const LINUX_MIB_RCVPRUNED: core::ffi::c_uint = 6;
pub const LINUX_MIB_OFOPRUNED: core::ffi::c_uint = 7;
pub const LINUX_MIB_OUTOFWINDOWICMPS: core::ffi::c_uint = 8;
pub const LINUX_MIB_LOCKDROPPEDICMPS: core::ffi::c_uint = 9;
pub const LINUX_MIB_ARPFILTER: core::ffi::c_uint = 10;
pub const LINUX_MIB_TIMEWAITED: core::ffi::c_uint = 11;
pub const LINUX_MIB_TIMEWAITRECYCLED: core::ffi::c_uint = 12;
pub const LINUX_MIB_TIMEWAITKILLED: core::ffi::c_uint = 13;
pub const LINUX_MIB_PAWSACTIVEREJECTED: core::ffi::c_uint = 14;
pub const LINUX_MIB_PAWSESTABREJECTED: core::ffi::c_uint = 15;
pub const LINUX_MIB_DELAYEDACKS: core::ffi::c_uint = 16;
pub const LINUX_MIB_DELAYEDACKLOCKED: core::ffi::c_uint = 17;
pub const LINUX_MIB_DELAYEDACKLOST: core::ffi::c_uint = 18;
pub const LINUX_MIB_LISTENOVERFLOWS: core::ffi::c_uint = 19;
pub const LINUX_MIB_LISTENDROPS: core::ffi::c_uint = 20;
pub const LINUX_MIB_TCPHPHITS: core::ffi::c_uint = 21;
pub const LINUX_MIB_TCPPUREACKS: core::ffi::c_uint = 22;
pub const LINUX_MIB_TCPHPACKS: core::ffi::c_uint = 23;
pub const LINUX_MIB_TCPRENORECOVERY: core::ffi::c_uint = 24;
pub const LINUX_MIB_TCPSACKRECOVERY: core::ffi::c_uint = 25;
pub const LINUX_MIB_TCPSACKRENEGING: core::ffi::c_uint = 26;
pub const LINUX_MIB_TCPSACKREORDER: core::ffi::c_uint = 27;
pub const LINUX_MIB_TCPRENOREORDER: core::ffi::c_uint = 28;
pub const LINUX_MIB_TCPTSREORDER: core::ffi::c_uint = 29;
pub const LINUX_MIB_TCPFULLUNDO: core::ffi::c_uint = 30;
pub const LINUX_MIB_TCPPARTIALUNDO: core::ffi::c_uint = 31;
pub const LINUX_MIB_TCPDSACKUNDO: core::ffi::c_uint = 32;
pub const LINUX_MIB_TCPLOSSUNDO: core::ffi::c_uint = 33;
pub const LINUX_MIB_TCPLOSTRETRANSMIT: core::ffi::c_uint = 34;
pub const LINUX_MIB_TCPRENOFAILURES: core::ffi::c_uint = 35;
pub const LINUX_MIB_TCPSACKFAILURES: core::ffi::c_uint = 36;
pub const LINUX_MIB_TCPLOSSFAILURES: core::ffi::c_uint = 37;
pub const LINUX_MIB_TCPFASTRETRANS: core::ffi::c_uint = 38;
pub const LINUX_MIB_TCPSLOWSTARTRETRANS: core::ffi::c_uint = 39;
pub const LINUX_MIB_TCPTIMEOUTS: core::ffi::c_uint = 40;
pub const LINUX_MIB_TCPLOSSPROBES: core::ffi::c_uint = 41;
pub const LINUX_MIB_TCPLOSSPROBERECOVERY: core::ffi::c_uint = 42;
pub const LINUX_MIB_TCPRENORECOVERYFAIL: core::ffi::c_uint = 43;
pub const LINUX_MIB_TCPSACKRECOVERYFAIL: core::ffi::c_uint = 44;
pub const LINUX_MIB_TCPRCVCOLLAPSED: core::ffi::c_uint = 45;
pub const LINUX_MIB_TCPDSACKOLDSENT: core::ffi::c_uint = 46;
pub const LINUX_MIB_TCPDSACKOFOSENT: core::ffi::c_uint = 47;
pub const LINUX_MIB_TCPDSACKRECV: core::ffi::c_uint = 48;
pub const LINUX_MIB_TCPDSACKOFORECV: core::ffi::c_uint = 49;
pub const LINUX_MIB_TCPABORTONDATA: core::ffi::c_uint = 50;
pub const LINUX_MIB_TCPABORTONCLOSE: core::ffi::c_uint = 51;
pub const LINUX_MIB_TCPABORTONMEMORY: core::ffi::c_uint = 52;
pub const LINUX_MIB_TCPABORTONTIMEOUT: core::ffi::c_uint = 53;
pub const LINUX_MIB_TCPABORTONLINGER: core::ffi::c_uint = 54;
pub const LINUX_MIB_TCPABORTFAILED: core::ffi::c_uint = 55;
pub const LINUX_MIB_TCPMEMORYPRESSURES: core::ffi::c_uint = 56;
pub const LINUX_MIB_TCPMEMORYPRESSURESCHRONO: core::ffi::c_uint = 57;
pub const LINUX_MIB_TCPSACKDISCARD: core::ffi::c_uint = 58;
pub const LINUX_MIB_TCPDSACKIGNOREDOLD: core::ffi::c_uint = 59;
pub const LINUX_MIB_TCPDSACKIGNOREDNOUNDO: core::ffi::c_uint = 60;
pub const LINUX_MIB_TCPSPURIOUSRTOS: core::ffi::c_uint = 61;
pub const LINUX_MIB_TCPMD5NOTFOUND: core::ffi::c_uint = 62;
pub const LINUX_MIB_TCPMD5UNEXPECTED: core::ffi::c_uint = 63;
pub const LINUX_MIB_TCPMD5FAILURE: core::ffi::c_uint = 64;
pub const LINUX_MIB_SACKSHIFTED: core::ffi::c_uint = 65;
pub const LINUX_MIB_SACKMERGED: core::ffi::c_uint = 66;
pub const LINUX_MIB_SACKSHIFTFALLBACK: core::ffi::c_uint = 67;
pub const LINUX_MIB_TCPBACKLOGDROP: core::ffi::c_uint = 68;
pub const LINUX_MIB_PFMEMALLOCDROP: core::ffi::c_uint = 69;
pub const LINUX_MIB_TCPMINTTLDROP: core::ffi::c_uint = 70;
pub const LINUX_MIB_TCPDEFERACCEPTDROP: core::ffi::c_uint = 71;
pub const LINUX_MIB_IPRPFILTER: core::ffi::c_uint = 72;
pub const LINUX_MIB_TCPTIMEWAITOVERFLOW: core::ffi::c_uint = 73;
pub const LINUX_MIB_TCPREQQFULLDOCOOKIES: core::ffi::c_uint = 74;
pub const LINUX_MIB_TCPREQQFULLDROP: core::ffi::c_uint = 75;
pub const LINUX_MIB_TCPRETRANSFAIL: core::ffi::c_uint = 76;
pub const LINUX_MIB_TCPRCVCOALESCE: core::ffi::c_uint = 77;
pub const LINUX_MIB_TCPBACKLOGCOALESCE: core::ffi::c_uint = 78;
pub const LINUX_MIB_TCPOFOQUEUE: core::ffi::c_uint = 79;
pub const LINUX_MIB_TCPOFODROP: core::ffi::c_uint = 80;
pub const LINUX_MIB_TCPOFOMERGE: core::ffi::c_uint = 81;
pub const LINUX_MIB_TCPCHALLENGEACK: core::ffi::c_uint = 82;
pub const LINUX_MIB_TCPSYNCHALLENGE: core::ffi::c_uint = 83;
pub const LINUX_MIB_TCPFASTOPENACTIVE: core::ffi::c_uint = 84;
pub const LINUX_MIB_TCPFASTOPENACTIVEFAIL: core::ffi::c_uint = 85;
pub const LINUX_MIB_TCPFASTOPENPASSIVE: core::ffi::c_uint = 86;
pub const LINUX_MIB_TCPFASTOPENPASSIVEFAIL: core::ffi::c_uint = 87;
pub const LINUX_MIB_TCPFASTOPENLISTENOVERFLOW: core::ffi::c_uint = 88;
pub const LINUX_MIB_TCPFASTOPENCOOKIEREQD: core::ffi::c_uint = 89;
pub const LINUX_MIB_TCPFASTOPENBLACKHOLE: core::ffi::c_uint = 90;
pub const LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES: core::ffi::c_uint = 91;
pub const LINUX_MIB_BUSYPOLLRXPACKETS: core::ffi::c_uint = 92;
pub const LINUX_MIB_TCPAUTOCORKING: core::ffi::c_uint = 93;
pub const LINUX_MIB_TCPFROMZEROWINDOWADV: core::ffi::c_uint = 94;
pub const LINUX_MIB_TCPTOZEROWINDOWADV: core::ffi::c_uint = 95;
pub const LINUX_MIB_TCPWANTZEROWINDOWADV: core::ffi::c_uint = 96;
pub const LINUX_MIB_TCPSYNRETRANS: core::ffi::c_uint = 97;
pub const LINUX_MIB_TCPORIGDATASENT: core::ffi::c_uint = 98;
pub const LINUX_MIB_TCPHYSTARTTRAINDETECT: core::ffi::c_uint = 99;
pub const LINUX_MIB_TCPHYSTARTTRAINCWND: core::ffi::c_uint = 100;
pub const LINUX_MIB_TCPHYSTARTDELAYDETECT: core::ffi::c_uint = 101;
pub const LINUX_MIB_TCPHYSTARTDELAYCWND: core::ffi::c_uint = 102;
pub const LINUX_MIB_TCPACKSKIPPEDSYNRECV: core::ffi::c_uint = 103;
pub const LINUX_MIB_TCPACKSKIPPEDPAWS: core::ffi::c_uint = 104;
pub const LINUX_MIB_TCPACKSKIPPEDSEQ: core::ffi::c_uint = 105;
pub const LINUX_MIB_TCPACKSKIPPEDFINWAIT2: core::ffi::c_uint = 106;
pub const LINUX_MIB_TCPACKSKIPPEDTIMEWAIT: core::ffi::c_uint = 107;
pub const LINUX_MIB_TCPACKSKIPPEDCHALLENGE: core::ffi::c_uint = 108;
pub const LINUX_MIB_TCPWINPROBE: core::ffi::c_uint = 109;
pub const LINUX_MIB_TCPKEEPALIVE: core::ffi::c_uint = 110;
pub const LINUX_MIB_TCPMTUPFAIL: core::ffi::c_uint = 111;
pub const LINUX_MIB_TCPMTUPSUCCESS: core::ffi::c_uint = 112;
pub const LINUX_MIB_TCPDELIVERED: core::ffi::c_uint = 113;
pub const LINUX_MIB_TCPDELIVEREDCE: core::ffi::c_uint = 114;
pub const LINUX_MIB_TCPACKCOMPRESSED: core::ffi::c_uint = 115;
pub const LINUX_MIB_TCPZEROWINDOWDROP: core::ffi::c_uint = 116;
pub const LINUX_MIB_TCPRCVQDROP: core::ffi::c_uint = 117;
pub const LINUX_MIB_TCPWQUEUETOOBIG: core::ffi::c_uint = 118;
pub const LINUX_MIB_TCPFASTOPENPASSIVEALTKEY: core::ffi::c_uint = 119;
pub const LINUX_MIB_TCPTIMEOUTREHASH: core::ffi::c_uint = 120;
pub const LINUX_MIB_TCPDUPLICATEDATAREHASH: core::ffi::c_uint = 121;
pub const LINUX_MIB_TCPDSACKRECVSEGS: core::ffi::c_uint = 122;
pub const LINUX_MIB_TCPDSACKIGNOREDDUBIOUS: core::ffi::c_uint = 123;
pub const LINUX_MIB_TCPMIGRATEREQSUCCESS: core::ffi::c_uint = 124;
pub const LINUX_MIB_TCPMIGRATEREQFAILURE: core::ffi::c_uint = 125;
pub const __LINUX_MIB_MAX: core::ffi::c_uint = 126;
pub type _bindgen_ty_132 = core::ffi::c_uint;
pub const LINUX_MIB_XFRMNUM: core::ffi::c_uint = 0;
pub const LINUX_MIB_XFRMINERROR: core::ffi::c_uint = 1;
pub const LINUX_MIB_XFRMINBUFFERERROR: core::ffi::c_uint = 2;
pub const LINUX_MIB_XFRMINHDRERROR: core::ffi::c_uint = 3;
pub const LINUX_MIB_XFRMINNOSTATES: core::ffi::c_uint = 4;
pub const LINUX_MIB_XFRMINSTATEPROTOERROR: core::ffi::c_uint = 5;
pub const LINUX_MIB_XFRMINSTATEMODEERROR: core::ffi::c_uint = 6;
pub const LINUX_MIB_XFRMINSTATESEQERROR: core::ffi::c_uint = 7;
pub const LINUX_MIB_XFRMINSTATEEXPIRED: core::ffi::c_uint = 8;
pub const LINUX_MIB_XFRMINSTATEMISMATCH: core::ffi::c_uint = 9;
pub const LINUX_MIB_XFRMINSTATEINVALID: core::ffi::c_uint = 10;
pub const LINUX_MIB_XFRMINTMPLMISMATCH: core::ffi::c_uint = 11;
pub const LINUX_MIB_XFRMINNOPOLS: core::ffi::c_uint = 12;
pub const LINUX_MIB_XFRMINPOLBLOCK: core::ffi::c_uint = 13;
pub const LINUX_MIB_XFRMINPOLERROR: core::ffi::c_uint = 14;
pub const LINUX_MIB_XFRMOUTERROR: core::ffi::c_uint = 15;
pub const LINUX_MIB_XFRMOUTBUNDLEGENERROR: core::ffi::c_uint = 16;
pub const LINUX_MIB_XFRMOUTBUNDLECHECKERROR: core::ffi::c_uint = 17;
pub const LINUX_MIB_XFRMOUTNOSTATES: core::ffi::c_uint = 18;
pub const LINUX_MIB_XFRMOUTSTATEPROTOERROR: core::ffi::c_uint = 19;
pub const LINUX_MIB_XFRMOUTSTATEMODEERROR: core::ffi::c_uint = 20;
pub const LINUX_MIB_XFRMOUTSTATESEQERROR: core::ffi::c_uint = 21;
pub const LINUX_MIB_XFRMOUTSTATEEXPIRED: core::ffi::c_uint = 22;
pub const LINUX_MIB_XFRMOUTPOLBLOCK: core::ffi::c_uint = 23;
pub const LINUX_MIB_XFRMOUTPOLDEAD: core::ffi::c_uint = 24;
pub const LINUX_MIB_XFRMOUTPOLERROR: core::ffi::c_uint = 25;
pub const LINUX_MIB_XFRMFWDHDRERROR: core::ffi::c_uint = 26;
pub const LINUX_MIB_XFRMOUTSTATEINVALID: core::ffi::c_uint = 27;
pub const LINUX_MIB_XFRMACQUIREERROR: core::ffi::c_uint = 28;
pub const __LINUX_MIB_XFRMMAX: core::ffi::c_uint = 29;
pub type _bindgen_ty_133 = core::ffi::c_uint;
pub const LINUX_MIB_TLSNUM: core::ffi::c_uint = 0;
pub const LINUX_MIB_TLSCURRTXSW: core::ffi::c_uint = 1;
pub const LINUX_MIB_TLSCURRRXSW: core::ffi::c_uint = 2;
pub const LINUX_MIB_TLSCURRTXDEVICE: core::ffi::c_uint = 3;
pub const LINUX_MIB_TLSCURRRXDEVICE: core::ffi::c_uint = 4;
pub const LINUX_MIB_TLSTXSW: core::ffi::c_uint = 5;
pub const LINUX_MIB_TLSRXSW: core::ffi::c_uint = 6;
pub const LINUX_MIB_TLSTXDEVICE: core::ffi::c_uint = 7;
pub const LINUX_MIB_TLSRXDEVICE: core::ffi::c_uint = 8;
pub const LINUX_MIB_TLSDECRYPTERROR: core::ffi::c_uint = 9;
pub const LINUX_MIB_TLSRXDEVICERESYNC: core::ffi::c_uint = 10;
pub const LINUX_MIB_TLSDECRYPTRETRY: core::ffi::c_uint = 11;
pub const LINUX_MIB_TLSRXNOPADVIOL: core::ffi::c_uint = 12;
pub const __LINUX_MIB_TLSMAX: core::ffi::c_uint = 13;
pub type _bindgen_ty_134 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct snmp_mib {
    pub name: *const core::ffi::c_char,
    pub entry: core::ffi::c_int,
}
impl Default for snmp_mib {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipstats_mib {
    pub mibs: [u64_; 37usize],
    pub syncp: u64_stats_sync,
}
impl Default for ipstats_mib {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct icmp_mib {
    pub mibs: [core::ffi::c_ulong; 28usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmpmsg_mib {
    pub mibs: [atomic_long_t; 512usize],
}
impl Default for icmpmsg_mib {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct icmpv6_mib {
    pub mibs: [core::ffi::c_ulong; 6usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct icmpv6_mib_device {
    pub mibs: [atomic_long_t; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmpv6msg_mib {
    pub mibs: [atomic_long_t; 512usize],
}
impl Default for icmpv6msg_mib {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmpv6msg_mib_device {
    pub mibs: [atomic_long_t; 512usize],
}
impl Default for icmpv6msg_mib_device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_mib {
    pub mibs: [core::ffi::c_ulong; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct udp_mib {
    pub mibs: [core::ffi::c_ulong; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct linux_mib {
    pub mibs: [core::ffi::c_ulong; 126usize],
}
impl Default for linux_mib {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct linux_xfrm_mib {
    pub mibs: [core::ffi::c_ulong; 29usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct linux_tls_mib {
    pub mibs: [core::ffi::c_ulong; 13usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_mib {
    pub ip_statistics: *mut ipstats_mib,
    pub ipv6_statistics: *mut ipstats_mib,
    pub tcp_statistics: *mut tcp_mib,
    pub net_statistics: *mut linux_mib,
    pub udp_statistics: *mut udp_mib,
    pub udp_stats_in6: *mut udp_mib,
    pub udplite_statistics: *mut udp_mib,
    pub udplite_stats_in6: *mut udp_mib,
    pub icmp_statistics: *mut icmp_mib,
    pub icmpmsg_statistics: *mut icmpmsg_mib,
    pub icmpv6_statistics: *mut icmpv6_mib,
    pub icmpv6msg_statistics: *mut icmpv6msg_mib,
    pub proc_net_devsnmp6: *mut proc_dir_entry,
}
impl Default for netns_mib {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct unix_table {
    pub locks: *mut spinlock_t,
    pub buckets: *mut hlist_head,
}
impl Default for unix_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_unix {
    pub table: unix_table,
    pub sysctl_max_dgram_qlen: core::ffi::c_int,
    pub ctl: *mut ctl_table_header,
}
impl Default for netns_unix {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_packet {
    pub sklist_lock: mutex,
    pub sklist: hlist_head,
}
impl Default for netns_packet {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct fqdir {
    pub high_thresh: core::ffi::c_long,
    pub low_thresh: core::ffi::c_long,
    pub timeout: core::ffi::c_int,
    pub max_dist: core::ffi::c_int,
    pub f: *mut inet_frags,
    pub net: *mut net,
    pub dead: bool_,
    pub __bindgen_padding_0: [u64; 2usize],
    pub rhashtable: rhashtable,
    pub mem: atomic_long_t,
    pub destroy_work: work_struct,
    pub free_list: llist_node,
}
impl Default for fqdir {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const INET_FRAG_FIRST_IN: core::ffi::c_uint = 1;
pub const INET_FRAG_LAST_IN: core::ffi::c_uint = 2;
pub const INET_FRAG_COMPLETE: core::ffi::c_uint = 4;
pub const INET_FRAG_HASH_DEAD: core::ffi::c_uint = 8;
pub type _bindgen_ty_135 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct frag_v4_compare_key {
    pub saddr: __be32,
    pub daddr: __be32,
    pub user: u32_,
    pub vif: u32_,
    pub id: __be16,
    pub protocol: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct frag_v6_compare_key {
    pub saddr: in6_addr,
    pub daddr: in6_addr,
    pub user: u32_,
    pub id: __be32,
    pub iif: u32_,
}
impl Default for frag_v6_compare_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_frag_queue {
    pub node: rhash_head,
    pub key: inet_frag_queue__bindgen_ty_1,
    pub timer: timer_list,
    pub lock: spinlock_t,
    pub refcnt: refcount_t,
    pub rb_fragments: rb_root,
    pub fragments_tail: *mut sk_buff,
    pub last_run_head: *mut sk_buff,
    pub stamp: ktime_t,
    pub len: core::ffi::c_int,
    pub meat: core::ffi::c_int,
    pub mono_delivery_time: u8_,
    pub flags: __u8,
    pub max_size: u16_,
    pub fqdir: *mut fqdir,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inet_frag_queue__bindgen_ty_1 {
    pub v4: frag_v4_compare_key,
    pub v6: frag_v6_compare_key,
    _bindgen_union_align: [u32; 11usize],
}
impl Default for inet_frag_queue__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for inet_frag_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_frags {
    pub qsize: core::ffi::c_uint,
    pub constructor: ::core::option::Option<
        unsafe extern "C" fn(q: *mut inet_frag_queue, arg: *const core::ffi::c_void),
    >,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut inet_frag_queue)>,
    pub frag_expire: ::core::option::Option<unsafe extern "C" fn(t: *mut timer_list)>,
    pub frags_cachep: *mut kmem_cache,
    pub frags_cache_name: *const core::ffi::c_char,
    pub rhash_params: rhashtable_params,
    pub refcnt: refcount_t,
    pub completion: completion,
}
impl Default for inet_frags {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn inet_frags_init(arg1: *mut inet_frags) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_frags_fini(arg1: *mut inet_frags);
}
extern "C" {
    pub fn fqdir_init(
        fqdirp: *mut *mut fqdir,
        f: *mut inet_frags,
        net: *mut net,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fqdir_exit(fqdir: *mut fqdir);
}
extern "C" {
    pub fn inet_frag_kill(q: *mut inet_frag_queue);
}
extern "C" {
    pub fn inet_frag_destroy(q: *mut inet_frag_queue);
}
extern "C" {
    pub fn inet_frag_find(fqdir: *mut fqdir, key: *mut core::ffi::c_void) -> *mut inet_frag_queue;
}
extern "C" {
    pub fn inet_frag_rbtree_purge(root: *mut rb_root) -> core::ffi::c_uint;
}
extern "C" {
    pub static ip_frag_ecn_table: [u8_; 16usize];
}
extern "C" {
    pub fn inet_frag_queue_insert(
        q: *mut inet_frag_queue,
        skb: *mut sk_buff,
        offset: core::ffi::c_int,
        end: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_frag_reasm_prepare(
        q: *mut inet_frag_queue,
        skb: *mut sk_buff,
        parent: *mut sk_buff,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn inet_frag_reasm_finish(
        q: *mut inet_frag_queue,
        head: *mut sk_buff,
        reasm_data: *mut core::ffi::c_void,
        try_coalesce: bool_,
    );
}
extern "C" {
    pub fn inet_frag_pull_head(q: *mut inet_frag_queue) -> *mut sk_buff;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv4_devconf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct local_ports {
    pub lock: seqlock_t,
    pub range: [core::ffi::c_int; 2usize],
    pub warned: bool_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ping_group_range {
    pub lock: seqlock_t,
    pub range: [kgid_t; 2usize],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct inet_timewait_death_row {
    pub tw_refcount: refcount_t,
    pub __bindgen_padding_0: [u64; 7usize],
    pub hashinfo: *mut inet_hashinfo,
    pub sysctl_max_tw_buckets: core::ffi::c_int,
}
impl Default for inet_timewait_death_row {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct netns_ipv4 {
    pub tcp_death_row: inet_timewait_death_row,
    pub forw_hdr: *mut ctl_table_header,
    pub frags_hdr: *mut ctl_table_header,
    pub ipv4_hdr: *mut ctl_table_header,
    pub route_hdr: *mut ctl_table_header,
    pub xfrm4_hdr: *mut ctl_table_header,
    pub devconf_all: *mut ipv4_devconf,
    pub devconf_dflt: *mut ipv4_devconf,
    pub ra_chain: *mut ip_ra_chain,
    pub ra_mutex: mutex,
    pub fib_has_custom_local_routes: bool_,
    pub fib_offload_disabled: bool_,
    pub fib_table_hash: *mut hlist_head,
    pub fibnl: *mut sock,
    pub mc_autojoin_sk: *mut sock,
    pub peers: *mut inet_peer_base,
    pub fqdir: *mut fqdir,
    pub sysctl_icmp_echo_ignore_all: u8_,
    pub sysctl_icmp_echo_enable_probe: u8_,
    pub sysctl_icmp_echo_ignore_broadcasts: u8_,
    pub sysctl_icmp_ignore_bogus_error_responses: u8_,
    pub sysctl_icmp_errors_use_inbound_ifaddr: u8_,
    pub sysctl_icmp_ratelimit: core::ffi::c_int,
    pub sysctl_icmp_ratemask: core::ffi::c_int,
    pub ip_rt_min_pmtu: u32_,
    pub ip_rt_mtu_expires: core::ffi::c_int,
    pub ip_rt_min_advmss: core::ffi::c_int,
    pub ip_local_ports: local_ports,
    pub sysctl_tcp_ecn: u8_,
    pub sysctl_tcp_ecn_fallback: u8_,
    pub sysctl_ip_default_ttl: u8_,
    pub sysctl_ip_no_pmtu_disc: u8_,
    pub sysctl_ip_fwd_use_pmtu: u8_,
    pub sysctl_ip_fwd_update_priority: u8_,
    pub sysctl_ip_nonlocal_bind: u8_,
    pub sysctl_ip_autobind_reuse: u8_,
    pub sysctl_ip_dynaddr: u8_,
    pub sysctl_ip_early_demux: u8_,
    pub sysctl_raw_l3mdev_accept: u8_,
    pub sysctl_tcp_early_demux: u8_,
    pub sysctl_udp_early_demux: u8_,
    pub sysctl_nexthop_compat_mode: u8_,
    pub sysctl_fwmark_reflect: u8_,
    pub sysctl_tcp_fwmark_accept: u8_,
    pub sysctl_tcp_l3mdev_accept: u8_,
    pub sysctl_tcp_mtu_probing: u8_,
    pub sysctl_tcp_mtu_probe_floor: core::ffi::c_int,
    pub sysctl_tcp_base_mss: core::ffi::c_int,
    pub sysctl_tcp_min_snd_mss: core::ffi::c_int,
    pub sysctl_tcp_probe_threshold: core::ffi::c_int,
    pub sysctl_tcp_probe_interval: u32_,
    pub sysctl_tcp_keepalive_time: core::ffi::c_int,
    pub sysctl_tcp_keepalive_intvl: core::ffi::c_int,
    pub sysctl_tcp_keepalive_probes: u8_,
    pub sysctl_tcp_syn_retries: u8_,
    pub sysctl_tcp_synack_retries: u8_,
    pub sysctl_tcp_syncookies: u8_,
    pub sysctl_tcp_migrate_req: u8_,
    pub sysctl_tcp_comp_sack_nr: u8_,
    pub sysctl_tcp_reordering: core::ffi::c_int,
    pub sysctl_tcp_retries1: u8_,
    pub sysctl_tcp_retries2: u8_,
    pub sysctl_tcp_orphan_retries: u8_,
    pub sysctl_tcp_tw_reuse: u8_,
    pub sysctl_tcp_fin_timeout: core::ffi::c_int,
    pub sysctl_tcp_notsent_lowat: core::ffi::c_uint,
    pub sysctl_tcp_sack: u8_,
    pub sysctl_tcp_window_scaling: u8_,
    pub sysctl_tcp_timestamps: u8_,
    pub sysctl_tcp_early_retrans: u8_,
    pub sysctl_tcp_recovery: u8_,
    pub sysctl_tcp_thin_linear_timeouts: u8_,
    pub sysctl_tcp_slow_start_after_idle: u8_,
    pub sysctl_tcp_retrans_collapse: u8_,
    pub sysctl_tcp_stdurg: u8_,
    pub sysctl_tcp_rfc1337: u8_,
    pub sysctl_tcp_abort_on_overflow: u8_,
    pub sysctl_tcp_fack: u8_,
    pub sysctl_tcp_max_reordering: core::ffi::c_int,
    pub sysctl_tcp_adv_win_scale: core::ffi::c_int,
    pub sysctl_tcp_dsack: u8_,
    pub sysctl_tcp_app_win: u8_,
    pub sysctl_tcp_frto: u8_,
    pub sysctl_tcp_nometrics_save: u8_,
    pub sysctl_tcp_no_ssthresh_metrics_save: u8_,
    pub sysctl_tcp_moderate_rcvbuf: u8_,
    pub sysctl_tcp_tso_win_divisor: u8_,
    pub sysctl_tcp_workaround_signed_windows: u8_,
    pub sysctl_tcp_limit_output_bytes: core::ffi::c_int,
    pub sysctl_tcp_challenge_ack_limit: core::ffi::c_int,
    pub sysctl_tcp_min_rtt_wlen: core::ffi::c_int,
    pub sysctl_tcp_min_tso_segs: u8_,
    pub sysctl_tcp_tso_rtt_log: u8_,
    pub sysctl_tcp_autocorking: u8_,
    pub sysctl_tcp_reflect_tos: u8_,
    pub sysctl_tcp_invalid_ratelimit: core::ffi::c_int,
    pub sysctl_tcp_pacing_ss_ratio: core::ffi::c_int,
    pub sysctl_tcp_pacing_ca_ratio: core::ffi::c_int,
    pub sysctl_tcp_wmem: [core::ffi::c_int; 3usize],
    pub sysctl_tcp_rmem: [core::ffi::c_int; 3usize],
    pub sysctl_tcp_child_ehash_entries: core::ffi::c_uint,
    pub sysctl_tcp_comp_sack_delay_ns: core::ffi::c_ulong,
    pub sysctl_tcp_comp_sack_slack_ns: core::ffi::c_ulong,
    pub sysctl_max_syn_backlog: core::ffi::c_int,
    pub sysctl_tcp_fastopen: core::ffi::c_int,
    pub tcp_congestion_control: *const tcp_congestion_ops,
    pub tcp_fastopen_ctx: *mut tcp_fastopen_context,
    pub sysctl_tcp_fastopen_blackhole_timeout: core::ffi::c_uint,
    pub tfo_active_disable_times: atomic_t,
    pub tfo_active_disable_stamp: core::ffi::c_ulong,
    pub tcp_challenge_timestamp: u32_,
    pub tcp_challenge_count: u32_,
    pub sysctl_udp_wmem_min: core::ffi::c_int,
    pub sysctl_udp_rmem_min: core::ffi::c_int,
    pub sysctl_fib_notify_on_flag_change: u8_,
    pub sysctl_udp_l3mdev_accept: u8_,
    pub sysctl_igmp_llm_reports: u8_,
    pub sysctl_igmp_max_memberships: core::ffi::c_int,
    pub sysctl_igmp_max_msf: core::ffi::c_int,
    pub sysctl_igmp_qrv: core::ffi::c_int,
    pub ping_group_range: ping_group_range,
    pub dev_addr_genid: atomic_t,
    pub sysctl_local_reserved_ports: *mut core::ffi::c_ulong,
    pub sysctl_ip_prot_sock: core::ffi::c_int,
    pub notifier_ops: *mut fib_notifier_ops,
    pub fib_seq: core::ffi::c_uint,
    pub ipmr_notifier_ops: *mut fib_notifier_ops,
    pub ipmr_seq: core::ffi::c_uint,
    pub rt_genid: atomic_t,
    pub ip_id_key: siphash_key_t,
}
impl Default for netns_ipv4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct kmem_cachep {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct dst_ops {
    pub family: core::ffi::c_ushort,
    pub gc_thresh: core::ffi::c_uint,
    pub gc: ::core::option::Option<unsafe extern "C" fn(ops: *mut dst_ops) -> core::ffi::c_int>,
    pub check: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, cookie: __u32) -> *mut dst_entry,
    >,
    pub default_advmss:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dst_entry) -> core::ffi::c_uint>,
    pub mtu:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const dst_entry) -> core::ffi::c_uint>,
    pub cow_metrics: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, arg2: core::ffi::c_ulong) -> *mut u32_,
    >,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry)>,
    pub ifdown: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut dst_entry, dev: *mut net_device, how: core::ffi::c_int),
    >,
    pub negative_advice:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut dst_entry) -> *mut dst_entry>,
    pub link_failure: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff)>,
    pub update_pmtu: ::core::option::Option<
        unsafe extern "C" fn(
            dst: *mut dst_entry,
            sk: *mut sock,
            skb: *mut sk_buff,
            mtu: u32_,
            confirm_neigh: bool_,
        ),
    >,
    pub redirect: ::core::option::Option<
        unsafe extern "C" fn(dst: *mut dst_entry, sk: *mut sock, skb: *mut sk_buff),
    >,
    pub local_out: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub neigh_lookup: ::core::option::Option<
        unsafe extern "C" fn(
            dst: *const dst_entry,
            skb: *mut sk_buff,
            daddr: *const core::ffi::c_void,
        ) -> *mut neighbour,
    >,
    pub confirm_neigh: ::core::option::Option<
        unsafe extern "C" fn(dst: *const dst_entry, daddr: *const core::ffi::c_void),
    >,
    pub kmem_cachep: *mut kmem_cache,
    pub pcpuc_entries: percpu_counter,
}
impl Default for dst_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct icmp6hdr {
    pub icmp6_type: __u8,
    pub icmp6_code: __u8,
    pub icmp6_cksum: __sum16,
    pub icmp6_dataun: icmp6hdr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union icmp6hdr__bindgen_ty_1 {
    pub un_data32: [__be32; 1usize],
    pub un_data16: [__be16; 2usize],
    pub un_data8: [__u8; 4usize],
    pub u_echo: icmp6hdr__bindgen_ty_1_icmpv6_echo,
    pub u_nd_advt: icmp6hdr__bindgen_ty_1_icmpv6_nd_advt,
    pub u_nd_ra: icmp6hdr__bindgen_ty_1_icmpv6_nd_ra,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct icmp6hdr__bindgen_ty_1_icmpv6_echo {
    pub identifier: __be16,
    pub sequence: __be16,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Default, Copy, Clone)]
pub struct icmp6hdr__bindgen_ty_1_icmpv6_nd_advt {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
impl icmp6hdr__bindgen_ty_1_icmpv6_nd_advt {
    #[inline]
    pub fn reserved(&self) -> __u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn override_(&self) -> __u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_override(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn solicited(&self) -> __u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_solicited(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn router(&self) -> __u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_router(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved2(&self) -> __u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: __u32,
        override_: __u32,
        solicited: __u32,
        router: __u32,
        reserved2: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let override_: u32 = unsafe { ::core::mem::transmute(override_) };
            override_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let solicited: u32 = unsafe { ::core::mem::transmute(solicited) };
            solicited as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let router: u32 = unsafe { ::core::mem::transmute(router) };
            router as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let reserved2: u32 = unsafe { ::core::mem::transmute(reserved2) };
            reserved2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct icmp6hdr__bindgen_ty_1_icmpv6_nd_ra {
    pub hop_limit: __u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub rt_lifetime: __be16,
}
impl icmp6hdr__bindgen_ty_1_icmpv6_nd_ra {
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn router_pref(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_router_pref(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn home_agent(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_home_agent(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn other(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_other(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn managed(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_managed(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: __u8,
        router_pref: __u8,
        home_agent: __u8,
        other: __u8,
        managed: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let router_pref: u8 = unsafe { ::core::mem::transmute(router_pref) };
            router_pref as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let home_agent: u8 = unsafe { ::core::mem::transmute(home_agent) };
            home_agent as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let other: u8 = unsafe { ::core::mem::transmute(other) };
            other as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let managed: u8 = unsafe { ::core::mem::transmute(managed) };
            managed as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for icmp6hdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for icmp6hdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct icmp6_filter {
    pub data: [__u32; 8usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_sysctl_ipv6 {
    pub hdr: *mut ctl_table_header,
    pub route_hdr: *mut ctl_table_header,
    pub icmp_hdr: *mut ctl_table_header,
    pub frags_hdr: *mut ctl_table_header,
    pub xfrm6_hdr: *mut ctl_table_header,
    pub flush_delay: core::ffi::c_int,
    pub ip6_rt_max_size: core::ffi::c_int,
    pub ip6_rt_gc_min_interval: core::ffi::c_int,
    pub ip6_rt_gc_timeout: core::ffi::c_int,
    pub ip6_rt_gc_interval: core::ffi::c_int,
    pub ip6_rt_gc_elasticity: core::ffi::c_int,
    pub ip6_rt_mtu_expires: core::ffi::c_int,
    pub ip6_rt_min_advmss: core::ffi::c_int,
    pub multipath_hash_fields: u32_,
    pub multipath_hash_policy: u8_,
    pub bindv6only: u8_,
    pub flowlabel_consistency: u8_,
    pub auto_flowlabels: u8_,
    pub icmpv6_time: core::ffi::c_int,
    pub icmpv6_echo_ignore_all: u8_,
    pub icmpv6_echo_ignore_multicast: u8_,
    pub icmpv6_echo_ignore_anycast: u8_,
    pub icmpv6_ratemask: [core::ffi::c_ulong; 4usize],
    pub icmpv6_ratemask_ptr: *mut core::ffi::c_ulong,
    pub anycast_src_echo_reply: u8_,
    pub ip_nonlocal_bind: u8_,
    pub fwmark_reflect: u8_,
    pub flowlabel_state_ranges: u8_,
    pub idgen_retries: core::ffi::c_int,
    pub idgen_delay: core::ffi::c_int,
    pub flowlabel_reflect: core::ffi::c_int,
    pub max_dst_opts_cnt: core::ffi::c_int,
    pub max_hbh_opts_cnt: core::ffi::c_int,
    pub max_dst_opts_len: core::ffi::c_int,
    pub max_hbh_opts_len: core::ffi::c_int,
    pub seg6_flowlabel: core::ffi::c_int,
    pub ioam6_id: u32_,
    pub ioam6_id_wide: u64_,
    pub skip_notify_on_dev_down: bool_,
    pub fib_notify_on_flag_change: u8_,
}
impl Default for netns_sysctl_ipv6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct netns_ipv6 {
    pub ip6_dst_ops: dst_ops,
    pub sysctl: netns_sysctl_ipv6,
    pub devconf_all: *mut ipv6_devconf,
    pub devconf_dflt: *mut ipv6_devconf,
    pub peers: *mut inet_peer_base,
    pub fqdir: *mut fqdir,
    pub fib6_null_entry: *mut fib6_info,
    pub ip6_null_entry: *mut rt6_info,
    pub rt6_stats: *mut rt6_statistics,
    pub ip6_fib_timer: timer_list,
    pub fib_table_hash: *mut hlist_head,
    pub fib6_main_tbl: *mut fib6_table,
    pub fib6_walkers: list_head,
    pub fib6_walker_lock: rwlock_t,
    pub fib6_gc_lock: spinlock_t,
    pub ip6_rt_gc_expire: atomic_t,
    pub ip6_rt_last_gc: core::ffi::c_ulong,
    pub flowlabel_has_excl: core::ffi::c_uchar,
    pub ndisc_sk: *mut sock,
    pub tcp_sk: *mut sock,
    pub igmp_sk: *mut sock,
    pub mc_autojoin_sk: *mut sock,
    pub inet6_addr_lst: *mut hlist_head,
    pub addrconf_hash_lock: spinlock_t,
    pub addr_chk_work: delayed_work,
    pub dev_addr_genid: atomic_t,
    pub fib6_sernum: atomic_t,
    pub seg6_data: *mut seg6_pernet_data,
    pub notifier_ops: *mut fib_notifier_ops,
    pub ip6mr_notifier_ops: *mut fib_notifier_ops,
    pub ipmr_seq: core::ffi::c_uint,
    pub ip6addrlbl_table: netns_ipv6__bindgen_ty_1,
    pub ioam6_data: *mut ioam6_pernet_data,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_ipv6__bindgen_ty_1 {
    pub head: hlist_head,
    pub lock: spinlock_t,
    pub seq: u32_,
}
impl Default for netns_ipv6__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for netns_ipv6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_nf_frag {
    pub fqdir: *mut fqdir,
}
impl Default for netns_nf_frag {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_nexthop {
    pub rb_root: rb_root,
    pub devhash: *mut hlist_head,
    pub seq: core::ffi::c_uint,
    pub last_id_allocated: u32_,
    pub notifier_chain: blocking_notifier_head,
}
impl Default for netns_nexthop {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_sysctl_lowpan {
    pub frags_hdr: *mut ctl_table_header,
}
impl Default for netns_sysctl_lowpan {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_ieee802154_lowpan {
    pub sysctl: netns_sysctl_lowpan,
    pub fqdir: *mut fqdir,
}
impl Default for netns_ieee802154_lowpan {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sctp_mib {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_sctp {
    pub sctp_statistics: *mut sctp_mib,
    pub proc_net_sctp: *mut proc_dir_entry,
    pub sysctl_header: *mut ctl_table_header,
    pub ctl_sock: *mut sock,
    pub udp4_sock: *mut sock,
    pub udp6_sock: *mut sock,
    pub udp_port: core::ffi::c_int,
    pub encap_port: core::ffi::c_int,
    pub local_addr_list: list_head,
    pub addr_waitq: list_head,
    pub addr_wq_timer: timer_list,
    pub auto_asconf_splist: list_head,
    pub addr_wq_lock: spinlock_t,
    pub local_addr_lock: spinlock_t,
    pub rto_initial: core::ffi::c_uint,
    pub rto_min: core::ffi::c_uint,
    pub rto_max: core::ffi::c_uint,
    pub rto_alpha: core::ffi::c_int,
    pub rto_beta: core::ffi::c_int,
    pub max_burst: core::ffi::c_int,
    pub cookie_preserve_enable: core::ffi::c_int,
    pub sctp_hmac_alg: *mut core::ffi::c_char,
    pub valid_cookie_life: core::ffi::c_uint,
    pub sack_timeout: core::ffi::c_uint,
    pub hb_interval: core::ffi::c_uint,
    pub probe_interval: core::ffi::c_uint,
    pub max_retrans_association: core::ffi::c_int,
    pub max_retrans_path: core::ffi::c_int,
    pub max_retrans_init: core::ffi::c_int,
    pub pf_retrans: core::ffi::c_int,
    pub ps_retrans: core::ffi::c_int,
    pub pf_enable: core::ffi::c_int,
    pub pf_expose: core::ffi::c_int,
    pub sndbuf_policy: core::ffi::c_int,
    pub rcvbuf_policy: core::ffi::c_int,
    pub default_auto_asconf: core::ffi::c_int,
    pub addip_enable: core::ffi::c_int,
    pub addip_noauth: core::ffi::c_int,
    pub prsctp_enable: core::ffi::c_int,
    pub reconf_enable: core::ffi::c_int,
    pub auth_enable: core::ffi::c_int,
    pub intl_enable: core::ffi::c_int,
    pub ecn_enable: core::ffi::c_int,
    pub scope_policy: core::ffi::c_int,
    pub rwnd_upd_shift: core::ffi::c_int,
    pub max_autoclose: core::ffi::c_ulong,
}
impl Default for netns_sctp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_logger {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_queue_handler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_nf {
    pub proc_netfilter: *mut proc_dir_entry,
    pub nf_loggers: [*const nf_logger; 11usize],
    pub nf_log_dir_header: *mut ctl_table_header,
    pub hooks_ipv4: [*mut nf_hook_entries; 5usize],
    pub hooks_ipv6: [*mut nf_hook_entries; 5usize],
    pub hooks_bridge: [*mut nf_hook_entries; 5usize],
    pub defrag_ipv4_users: core::ffi::c_uint,
    pub defrag_ipv6_users: core::ffi::c_uint,
}
impl Default for netns_nf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_nulls_head {
    pub first: *mut hlist_nulls_node,
}
impl Default for hlist_nulls_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hlist_nulls_node {
    pub next: *mut hlist_nulls_node,
    pub pprev: *mut *mut hlist_nulls_node,
}
impl Default for hlist_nulls_node {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const tcp_conntrack_TCP_CONNTRACK_NONE: tcp_conntrack = 0;
pub const tcp_conntrack_TCP_CONNTRACK_SYN_SENT: tcp_conntrack = 1;
pub const tcp_conntrack_TCP_CONNTRACK_SYN_RECV: tcp_conntrack = 2;
pub const tcp_conntrack_TCP_CONNTRACK_ESTABLISHED: tcp_conntrack = 3;
pub const tcp_conntrack_TCP_CONNTRACK_FIN_WAIT: tcp_conntrack = 4;
pub const tcp_conntrack_TCP_CONNTRACK_CLOSE_WAIT: tcp_conntrack = 5;
pub const tcp_conntrack_TCP_CONNTRACK_LAST_ACK: tcp_conntrack = 6;
pub const tcp_conntrack_TCP_CONNTRACK_TIME_WAIT: tcp_conntrack = 7;
pub const tcp_conntrack_TCP_CONNTRACK_CLOSE: tcp_conntrack = 8;
pub const tcp_conntrack_TCP_CONNTRACK_LISTEN: tcp_conntrack = 9;
pub const tcp_conntrack_TCP_CONNTRACK_MAX: tcp_conntrack = 10;
pub const tcp_conntrack_TCP_CONNTRACK_IGNORE: tcp_conntrack = 11;
pub const tcp_conntrack_TCP_CONNTRACK_RETRANS: tcp_conntrack = 12;
pub const tcp_conntrack_TCP_CONNTRACK_UNACK: tcp_conntrack = 13;
pub const tcp_conntrack_TCP_CONNTRACK_TIMEOUT_MAX: tcp_conntrack = 14;
pub type tcp_conntrack = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_ct_tcp_flags {
    pub flags: __u8,
    pub mask: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_ct_tcp_state {
    pub td_end: u_int32_t,
    pub td_maxend: u_int32_t,
    pub td_maxwin: u_int32_t,
    pub td_maxack: u_int32_t,
    pub td_scale: u_int8_t,
    pub flags: u_int8_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_ct_tcp {
    pub seen: [ip_ct_tcp_state; 2usize],
    pub state: u_int8_t,
    pub last_dir: u_int8_t,
    pub retrans: u_int8_t,
    pub last_index: u_int8_t,
    pub last_seq: u_int32_t,
    pub last_ack: u_int32_t,
    pub last_end: u_int32_t,
    pub last_win: u_int16_t,
    pub last_wscale: u_int8_t,
    pub last_flags: u_int8_t,
}
pub const ct_dccp_states_CT_DCCP_NONE: ct_dccp_states = 0;
pub const ct_dccp_states_CT_DCCP_REQUEST: ct_dccp_states = 1;
pub const ct_dccp_states_CT_DCCP_RESPOND: ct_dccp_states = 2;
pub const ct_dccp_states_CT_DCCP_PARTOPEN: ct_dccp_states = 3;
pub const ct_dccp_states_CT_DCCP_OPEN: ct_dccp_states = 4;
pub const ct_dccp_states_CT_DCCP_CLOSEREQ: ct_dccp_states = 5;
pub const ct_dccp_states_CT_DCCP_CLOSING: ct_dccp_states = 6;
pub const ct_dccp_states_CT_DCCP_TIMEWAIT: ct_dccp_states = 7;
pub const ct_dccp_states_CT_DCCP_IGNORE: ct_dccp_states = 8;
pub const ct_dccp_states_CT_DCCP_INVALID: ct_dccp_states = 9;
pub const ct_dccp_states___CT_DCCP_MAX: ct_dccp_states = 10;
pub type ct_dccp_states = core::ffi::c_uint;
pub const ct_dccp_roles_CT_DCCP_ROLE_CLIENT: ct_dccp_roles = 0;
pub const ct_dccp_roles_CT_DCCP_ROLE_SERVER: ct_dccp_roles = 1;
pub const ct_dccp_roles___CT_DCCP_ROLE_MAX: ct_dccp_roles = 2;
pub type ct_dccp_roles = core::ffi::c_uint;
pub const ip_conntrack_dir_IP_CT_DIR_ORIGINAL: ip_conntrack_dir = 0;
pub const ip_conntrack_dir_IP_CT_DIR_REPLY: ip_conntrack_dir = 1;
pub const ip_conntrack_dir_IP_CT_DIR_MAX: ip_conntrack_dir = 2;
pub type ip_conntrack_dir = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union nf_conntrack_man_proto {
    pub all: __be16,
    pub tcp: nf_conntrack_man_proto__bindgen_ty_1,
    pub udp: nf_conntrack_man_proto__bindgen_ty_2,
    pub icmp: nf_conntrack_man_proto__bindgen_ty_3,
    pub dccp: nf_conntrack_man_proto__bindgen_ty_4,
    pub sctp: nf_conntrack_man_proto__bindgen_ty_5,
    pub gre: nf_conntrack_man_proto__bindgen_ty_6,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_1 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_2 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_3 {
    pub id: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_4 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_5 {
    pub port: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_conntrack_man_proto__bindgen_ty_6 {
    pub key: __be16,
}
impl Default for nf_conntrack_man_proto {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_ct_dccp {
    pub role: [u_int8_t; 2usize],
    pub state: u_int8_t,
    pub last_pkt: u_int8_t,
    pub last_dir: u_int8_t,
    pub handshake_seq: u_int64_t,
}
pub const sctp_conntrack_SCTP_CONNTRACK_NONE: sctp_conntrack = 0;
pub const sctp_conntrack_SCTP_CONNTRACK_CLOSED: sctp_conntrack = 1;
pub const sctp_conntrack_SCTP_CONNTRACK_COOKIE_WAIT: sctp_conntrack = 2;
pub const sctp_conntrack_SCTP_CONNTRACK_COOKIE_ECHOED: sctp_conntrack = 3;
pub const sctp_conntrack_SCTP_CONNTRACK_ESTABLISHED: sctp_conntrack = 4;
pub const sctp_conntrack_SCTP_CONNTRACK_SHUTDOWN_SENT: sctp_conntrack = 5;
pub const sctp_conntrack_SCTP_CONNTRACK_SHUTDOWN_RECD: sctp_conntrack = 6;
pub const sctp_conntrack_SCTP_CONNTRACK_SHUTDOWN_ACK_SENT: sctp_conntrack = 7;
pub const sctp_conntrack_SCTP_CONNTRACK_HEARTBEAT_SENT: sctp_conntrack = 8;
pub const sctp_conntrack_SCTP_CONNTRACK_HEARTBEAT_ACKED: sctp_conntrack = 9;
pub const sctp_conntrack_SCTP_CONNTRACK_MAX: sctp_conntrack = 10;
pub type sctp_conntrack = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_ct_sctp {
    pub state: sctp_conntrack,
    pub vtag: [__be32; 2usize],
    pub last_dir: u8_,
    pub flags: u8_,
}
impl Default for ip_ct_sctp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_ecache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_generic_net {
    pub timeout: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_tcp_net {
    pub timeouts: [core::ffi::c_uint; 14usize],
    pub tcp_loose: u8_,
    pub tcp_be_liberal: u8_,
    pub tcp_max_retrans: u8_,
    pub tcp_ignore_invalid_rst: u8_,
}
pub const udp_conntrack_UDP_CT_UNREPLIED: udp_conntrack = 0;
pub const udp_conntrack_UDP_CT_REPLIED: udp_conntrack = 1;
pub const udp_conntrack_UDP_CT_MAX: udp_conntrack = 2;
pub type udp_conntrack = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_udp_net {
    pub timeouts: [core::ffi::c_uint; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_icmp_net {
    pub timeout: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_dccp_net {
    pub dccp_loose: u8_,
    pub dccp_timeout: [core::ffi::c_uint; 10usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_sctp_net {
    pub timeouts: [core::ffi::c_uint; 10usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_ip_net {
    pub generic: nf_generic_net,
    pub tcp: nf_tcp_net,
    pub udp: nf_udp_net,
    pub icmp: nf_icmp_net,
    pub icmpv6: nf_icmp_net,
    pub dccp: nf_dccp_net,
    pub sctp: nf_sctp_net,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_ct {
    pub sysctl_log_invalid: u8_,
    pub sysctl_events: u8_,
    pub sysctl_acct: u8_,
    pub sysctl_tstamp: u8_,
    pub sysctl_checksum: u8_,
    pub stat: *mut ip_conntrack_stat,
    pub nf_conntrack_event_cb: *mut nf_ct_event_notifier,
    pub nf_ct_proto: nf_ip_net,
}
impl Default for netns_ct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netns_nftables {
    pub gencursor: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union xfrm_address_t {
    pub a4: __be32,
    pub a6: [__be32; 4usize],
    pub in6: in6_addr,
    _bindgen_union_align: [u32; 4usize],
}
impl Default for xfrm_address_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_id {
    pub daddr: xfrm_address_t,
    pub spi: __be32,
    pub proto: __u8,
}
impl Default for xfrm_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct xfrm_sec_ctx {
    pub ctx_doi: __u8,
    pub ctx_alg: __u8,
    pub ctx_len: __u16,
    pub ctx_sid: __u32,
    pub ctx_str: __IncompleteArrayField<core::ffi::c_char>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_selector {
    pub daddr: xfrm_address_t,
    pub saddr: xfrm_address_t,
    pub dport: __be16,
    pub dport_mask: __be16,
    pub sport: __be16,
    pub sport_mask: __be16,
    pub family: __u16,
    pub prefixlen_d: __u8,
    pub prefixlen_s: __u8,
    pub proto: __u8,
    pub ifindex: core::ffi::c_int,
    pub user: __kernel_uid32_t,
}
impl Default for xfrm_selector {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrm_lifetime_cfg {
    pub soft_byte_limit: __u64,
    pub hard_byte_limit: __u64,
    pub soft_packet_limit: __u64,
    pub hard_packet_limit: __u64,
    pub soft_add_expires_seconds: __u64,
    pub hard_add_expires_seconds: __u64,
    pub soft_use_expires_seconds: __u64,
    pub hard_use_expires_seconds: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrm_lifetime_cur {
    pub bytes: __u64,
    pub packets: __u64,
    pub add_time: __u64,
    pub use_time: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrm_replay_state {
    pub oseq: __u32,
    pub seq: __u32,
    pub bitmap: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct xfrm_replay_state_esn {
    pub bmp_len: core::ffi::c_uint,
    pub oseq: __u32,
    pub seq: __u32,
    pub oseq_hi: __u32,
    pub seq_hi: __u32,
    pub replay_window: __u32,
    pub bmp: __IncompleteArrayField<__u32>,
}
#[repr(C)]
pub struct xfrm_algo {
    pub alg_name: [core::ffi::c_char; 64usize],
    pub alg_key_len: core::ffi::c_uint,
    pub alg_key: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for xfrm_algo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct xfrm_algo_auth {
    pub alg_name: [core::ffi::c_char; 64usize],
    pub alg_key_len: core::ffi::c_uint,
    pub alg_trunc_len: core::ffi::c_uint,
    pub alg_key: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for xfrm_algo_auth {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct xfrm_algo_aead {
    pub alg_name: [core::ffi::c_char; 64usize],
    pub alg_key_len: core::ffi::c_uint,
    pub alg_icv_len: core::ffi::c_uint,
    pub alg_key: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for xfrm_algo_aead {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrm_stats {
    pub replay_window: __u32,
    pub replay: __u32,
    pub integrity_failed: __u32,
}
pub const XFRM_POLICY_TYPE_MAIN: core::ffi::c_uint = 0;
pub const XFRM_POLICY_TYPE_SUB: core::ffi::c_uint = 1;
pub const XFRM_POLICY_TYPE_MAX: core::ffi::c_uint = 2;
pub const XFRM_POLICY_TYPE_ANY: core::ffi::c_uint = 255;
pub type _bindgen_ty_136 = core::ffi::c_uint;
pub const XFRM_POLICY_IN: core::ffi::c_uint = 0;
pub const XFRM_POLICY_OUT: core::ffi::c_uint = 1;
pub const XFRM_POLICY_FWD: core::ffi::c_uint = 2;
pub const XFRM_POLICY_MASK: core::ffi::c_uint = 3;
pub const XFRM_POLICY_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_137 = core::ffi::c_uint;
pub const XFRM_SHARE_ANY: core::ffi::c_uint = 0;
pub const XFRM_SHARE_SESSION: core::ffi::c_uint = 1;
pub const XFRM_SHARE_USER: core::ffi::c_uint = 2;
pub const XFRM_SHARE_UNIQUE: core::ffi::c_uint = 3;
pub type _bindgen_ty_138 = core::ffi::c_uint;
pub const XFRM_MSG_BASE: core::ffi::c_uint = 16;
pub const XFRM_MSG_NEWSA: core::ffi::c_uint = 16;
pub const XFRM_MSG_DELSA: core::ffi::c_uint = 17;
pub const XFRM_MSG_GETSA: core::ffi::c_uint = 18;
pub const XFRM_MSG_NEWPOLICY: core::ffi::c_uint = 19;
pub const XFRM_MSG_DELPOLICY: core::ffi::c_uint = 20;
pub const XFRM_MSG_GETPOLICY: core::ffi::c_uint = 21;
pub const XFRM_MSG_ALLOCSPI: core::ffi::c_uint = 22;
pub const XFRM_MSG_ACQUIRE: core::ffi::c_uint = 23;
pub const XFRM_MSG_EXPIRE: core::ffi::c_uint = 24;
pub const XFRM_MSG_UPDPOLICY: core::ffi::c_uint = 25;
pub const XFRM_MSG_UPDSA: core::ffi::c_uint = 26;
pub const XFRM_MSG_POLEXPIRE: core::ffi::c_uint = 27;
pub const XFRM_MSG_FLUSHSA: core::ffi::c_uint = 28;
pub const XFRM_MSG_FLUSHPOLICY: core::ffi::c_uint = 29;
pub const XFRM_MSG_NEWAE: core::ffi::c_uint = 30;
pub const XFRM_MSG_GETAE: core::ffi::c_uint = 31;
pub const XFRM_MSG_REPORT: core::ffi::c_uint = 32;
pub const XFRM_MSG_MIGRATE: core::ffi::c_uint = 33;
pub const XFRM_MSG_NEWSADINFO: core::ffi::c_uint = 34;
pub const XFRM_MSG_GETSADINFO: core::ffi::c_uint = 35;
pub const XFRM_MSG_NEWSPDINFO: core::ffi::c_uint = 36;
pub const XFRM_MSG_GETSPDINFO: core::ffi::c_uint = 37;
pub const XFRM_MSG_MAPPING: core::ffi::c_uint = 38;
pub const XFRM_MSG_SETDEFAULT: core::ffi::c_uint = 39;
pub const XFRM_MSG_GETDEFAULT: core::ffi::c_uint = 40;
pub const __XFRM_MSG_MAX: core::ffi::c_uint = 41;
pub type _bindgen_ty_139 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrm_user_sec_ctx {
    pub len: __u16,
    pub exttype: __u16,
    pub ctx_alg: __u8,
    pub ctx_doi: __u8,
    pub ctx_len: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_user_tmpl {
    pub id: xfrm_id,
    pub family: __u16,
    pub saddr: xfrm_address_t,
    pub reqid: __u32,
    pub mode: __u8,
    pub share: __u8,
    pub optional: __u8,
    pub aalgos: __u32,
    pub ealgos: __u32,
    pub calgos: __u32,
}
impl Default for xfrm_user_tmpl {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_encap_tmpl {
    pub encap_type: __u16,
    pub encap_sport: __be16,
    pub encap_dport: __be16,
    pub encap_oa: xfrm_address_t,
}
impl Default for xfrm_encap_tmpl {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const xfrm_ae_ftype_t_XFRM_AE_UNSPEC: xfrm_ae_ftype_t = 0;
pub const xfrm_ae_ftype_t_XFRM_AE_RTHR: xfrm_ae_ftype_t = 1;
pub const xfrm_ae_ftype_t_XFRM_AE_RVAL: xfrm_ae_ftype_t = 2;
pub const xfrm_ae_ftype_t_XFRM_AE_LVAL: xfrm_ae_ftype_t = 4;
pub const xfrm_ae_ftype_t_XFRM_AE_ETHR: xfrm_ae_ftype_t = 8;
pub const xfrm_ae_ftype_t_XFRM_AE_CR: xfrm_ae_ftype_t = 16;
pub const xfrm_ae_ftype_t_XFRM_AE_CE: xfrm_ae_ftype_t = 32;
pub const xfrm_ae_ftype_t_XFRM_AE_CU: xfrm_ae_ftype_t = 64;
pub const xfrm_ae_ftype_t___XFRM_AE_MAX: xfrm_ae_ftype_t = 65;
pub type xfrm_ae_ftype_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrm_userpolicy_type {
    pub type_: __u8,
    pub reserved1: __u16,
    pub reserved2: __u8,
}
pub const xfrm_attr_type_t_XFRMA_UNSPEC: xfrm_attr_type_t = 0;
pub const xfrm_attr_type_t_XFRMA_ALG_AUTH: xfrm_attr_type_t = 1;
pub const xfrm_attr_type_t_XFRMA_ALG_CRYPT: xfrm_attr_type_t = 2;
pub const xfrm_attr_type_t_XFRMA_ALG_COMP: xfrm_attr_type_t = 3;
pub const xfrm_attr_type_t_XFRMA_ENCAP: xfrm_attr_type_t = 4;
pub const xfrm_attr_type_t_XFRMA_TMPL: xfrm_attr_type_t = 5;
pub const xfrm_attr_type_t_XFRMA_SA: xfrm_attr_type_t = 6;
pub const xfrm_attr_type_t_XFRMA_POLICY: xfrm_attr_type_t = 7;
pub const xfrm_attr_type_t_XFRMA_SEC_CTX: xfrm_attr_type_t = 8;
pub const xfrm_attr_type_t_XFRMA_LTIME_VAL: xfrm_attr_type_t = 9;
pub const xfrm_attr_type_t_XFRMA_REPLAY_VAL: xfrm_attr_type_t = 10;
pub const xfrm_attr_type_t_XFRMA_REPLAY_THRESH: xfrm_attr_type_t = 11;
pub const xfrm_attr_type_t_XFRMA_ETIMER_THRESH: xfrm_attr_type_t = 12;
pub const xfrm_attr_type_t_XFRMA_SRCADDR: xfrm_attr_type_t = 13;
pub const xfrm_attr_type_t_XFRMA_COADDR: xfrm_attr_type_t = 14;
pub const xfrm_attr_type_t_XFRMA_LASTUSED: xfrm_attr_type_t = 15;
pub const xfrm_attr_type_t_XFRMA_POLICY_TYPE: xfrm_attr_type_t = 16;
pub const xfrm_attr_type_t_XFRMA_MIGRATE: xfrm_attr_type_t = 17;
pub const xfrm_attr_type_t_XFRMA_ALG_AEAD: xfrm_attr_type_t = 18;
pub const xfrm_attr_type_t_XFRMA_KMADDRESS: xfrm_attr_type_t = 19;
pub const xfrm_attr_type_t_XFRMA_ALG_AUTH_TRUNC: xfrm_attr_type_t = 20;
pub const xfrm_attr_type_t_XFRMA_MARK: xfrm_attr_type_t = 21;
pub const xfrm_attr_type_t_XFRMA_TFCPAD: xfrm_attr_type_t = 22;
pub const xfrm_attr_type_t_XFRMA_REPLAY_ESN_VAL: xfrm_attr_type_t = 23;
pub const xfrm_attr_type_t_XFRMA_SA_EXTRA_FLAGS: xfrm_attr_type_t = 24;
pub const xfrm_attr_type_t_XFRMA_PROTO: xfrm_attr_type_t = 25;
pub const xfrm_attr_type_t_XFRMA_ADDRESS_FILTER: xfrm_attr_type_t = 26;
pub const xfrm_attr_type_t_XFRMA_PAD: xfrm_attr_type_t = 27;
pub const xfrm_attr_type_t_XFRMA_OFFLOAD_DEV: xfrm_attr_type_t = 28;
pub const xfrm_attr_type_t_XFRMA_SET_MARK: xfrm_attr_type_t = 29;
pub const xfrm_attr_type_t_XFRMA_SET_MARK_MASK: xfrm_attr_type_t = 30;
pub const xfrm_attr_type_t_XFRMA_IF_ID: xfrm_attr_type_t = 31;
pub const xfrm_attr_type_t_XFRMA_MTIMER_THRESH: xfrm_attr_type_t = 32;
pub const xfrm_attr_type_t___XFRMA_MAX: xfrm_attr_type_t = 33;
pub type xfrm_attr_type_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrm_mark {
    pub v: __u32,
    pub m: __u32,
}
pub const xfrm_sadattr_type_t_XFRMA_SAD_UNSPEC: xfrm_sadattr_type_t = 0;
pub const xfrm_sadattr_type_t_XFRMA_SAD_CNT: xfrm_sadattr_type_t = 1;
pub const xfrm_sadattr_type_t_XFRMA_SAD_HINFO: xfrm_sadattr_type_t = 2;
pub const xfrm_sadattr_type_t___XFRMA_SAD_MAX: xfrm_sadattr_type_t = 3;
pub type xfrm_sadattr_type_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrmu_sadhinfo {
    pub sadhcnt: __u32,
    pub sadhmcnt: __u32,
}
pub const xfrm_spdattr_type_t_XFRMA_SPD_UNSPEC: xfrm_spdattr_type_t = 0;
pub const xfrm_spdattr_type_t_XFRMA_SPD_INFO: xfrm_spdattr_type_t = 1;
pub const xfrm_spdattr_type_t_XFRMA_SPD_HINFO: xfrm_spdattr_type_t = 2;
pub const xfrm_spdattr_type_t_XFRMA_SPD_IPV4_HTHRESH: xfrm_spdattr_type_t = 3;
pub const xfrm_spdattr_type_t_XFRMA_SPD_IPV6_HTHRESH: xfrm_spdattr_type_t = 4;
pub const xfrm_spdattr_type_t___XFRMA_SPD_MAX: xfrm_spdattr_type_t = 5;
pub type xfrm_spdattr_type_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrmu_spdinfo {
    pub incnt: __u32,
    pub outcnt: __u32,
    pub fwdcnt: __u32,
    pub inscnt: __u32,
    pub outscnt: __u32,
    pub fwdscnt: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrmu_spdhinfo {
    pub spdhcnt: __u32,
    pub spdhmcnt: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrmu_spdhthresh {
    pub lbits: __u8,
    pub rbits: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_usersa_info {
    pub sel: xfrm_selector,
    pub id: xfrm_id,
    pub saddr: xfrm_address_t,
    pub lft: xfrm_lifetime_cfg,
    pub curlft: xfrm_lifetime_cur,
    pub stats: xfrm_stats,
    pub seq: __u32,
    pub reqid: __u32,
    pub family: __u16,
    pub mode: __u8,
    pub replay_window: __u8,
    pub flags: __u8,
}
impl Default for xfrm_usersa_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_usersa_id {
    pub daddr: xfrm_address_t,
    pub spi: __be32,
    pub family: __u16,
    pub proto: __u8,
}
impl Default for xfrm_usersa_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_aevent_id {
    pub sa_id: xfrm_usersa_id,
    pub saddr: xfrm_address_t,
    pub flags: __u32,
    pub reqid: __u32,
}
impl Default for xfrm_aevent_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_userspi_info {
    pub info: xfrm_usersa_info,
    pub min: __u32,
    pub max: __u32,
}
impl Default for xfrm_userspi_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_userpolicy_info {
    pub sel: xfrm_selector,
    pub lft: xfrm_lifetime_cfg,
    pub curlft: xfrm_lifetime_cur,
    pub priority: __u32,
    pub index: __u32,
    pub dir: __u8,
    pub action: __u8,
    pub flags: __u8,
    pub share: __u8,
}
impl Default for xfrm_userpolicy_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_userpolicy_id {
    pub sel: xfrm_selector,
    pub index: __u32,
    pub dir: __u8,
}
impl Default for xfrm_userpolicy_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_user_acquire {
    pub id: xfrm_id,
    pub saddr: xfrm_address_t,
    pub sel: xfrm_selector,
    pub policy: xfrm_userpolicy_info,
    pub aalgos: __u32,
    pub ealgos: __u32,
    pub calgos: __u32,
    pub seq: __u32,
}
impl Default for xfrm_user_acquire {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_user_expire {
    pub state: xfrm_usersa_info,
    pub hard: __u8,
}
impl Default for xfrm_user_expire {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_user_polexpire {
    pub pol: xfrm_userpolicy_info,
    pub hard: __u8,
}
impl Default for xfrm_user_polexpire {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrm_usersa_flush {
    pub proto: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_user_report {
    pub proto: __u8,
    pub sel: xfrm_selector,
}
impl Default for xfrm_user_report {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_user_kmaddress {
    pub local: xfrm_address_t,
    pub remote: xfrm_address_t,
    pub reserved: __u32,
    pub family: __u16,
}
impl Default for xfrm_user_kmaddress {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_user_migrate {
    pub old_daddr: xfrm_address_t,
    pub old_saddr: xfrm_address_t,
    pub new_daddr: xfrm_address_t,
    pub new_saddr: xfrm_address_t,
    pub proto: __u8,
    pub mode: __u8,
    pub reserved: __u16,
    pub reqid: __u32,
    pub old_family: __u16,
    pub new_family: __u16,
}
impl Default for xfrm_user_migrate {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_user_mapping {
    pub id: xfrm_usersa_id,
    pub reqid: __u32,
    pub old_saddr: xfrm_address_t,
    pub new_saddr: xfrm_address_t,
    pub old_sport: __be16,
    pub new_sport: __be16,
}
impl Default for xfrm_user_mapping {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_address_filter {
    pub saddr: xfrm_address_t,
    pub daddr: xfrm_address_t,
    pub family: __u16,
    pub splen: __u8,
    pub dplen: __u8,
}
impl Default for xfrm_address_filter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrm_user_offload {
    pub ifindex: core::ffi::c_int,
    pub flags: __u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xfrm_userpolicy_default {
    pub in_: __u8,
    pub fwd: __u8,
    pub out: __u8,
}
pub const xfrm_nlgroups_XFRMNLGRP_NONE: xfrm_nlgroups = 0;
pub const xfrm_nlgroups_XFRMNLGRP_ACQUIRE: xfrm_nlgroups = 1;
pub const xfrm_nlgroups_XFRMNLGRP_EXPIRE: xfrm_nlgroups = 2;
pub const xfrm_nlgroups_XFRMNLGRP_SA: xfrm_nlgroups = 3;
pub const xfrm_nlgroups_XFRMNLGRP_POLICY: xfrm_nlgroups = 4;
pub const xfrm_nlgroups_XFRMNLGRP_AEVENTS: xfrm_nlgroups = 5;
pub const xfrm_nlgroups_XFRMNLGRP_REPORT: xfrm_nlgroups = 6;
pub const xfrm_nlgroups_XFRMNLGRP_MIGRATE: xfrm_nlgroups = 7;
pub const xfrm_nlgroups_XFRMNLGRP_MAPPING: xfrm_nlgroups = 8;
pub const xfrm_nlgroups___XFRMNLGRP_MAX: xfrm_nlgroups = 9;
pub type xfrm_nlgroups = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy_hash {
    pub table: *mut hlist_head,
    pub hmask: core::ffi::c_uint,
    pub dbits4: u8_,
    pub sbits4: u8_,
    pub dbits6: u8_,
    pub sbits6: u8_,
}
impl Default for xfrm_policy_hash {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xfrm_policy_hthresh {
    pub work: work_struct,
    pub lock: seqlock_t,
    pub lbits4: u8_,
    pub rbits4: u8_,
    pub lbits6: u8_,
    pub rbits6: u8_,
}
impl Default for xfrm_policy_hthresh {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct netns_xfrm {
    pub state_all: list_head,
    pub state_bydst: *mut hlist_head,
    pub state_bysrc: *mut hlist_head,
    pub state_byspi: *mut hlist_head,
    pub state_byseq: *mut hlist_head,
    pub state_hmask: core::ffi::c_uint,
    pub state_num: core::ffi::c_uint,
    pub state_hash_work: work_struct,
    pub policy_all: list_head,
    pub policy_byidx: *mut hlist_head,
    pub policy_idx_hmask: core::ffi::c_uint,
    pub policy_inexact: [hlist_head; 3usize],
    pub policy_bydst: [xfrm_policy_hash; 3usize],
    pub policy_count: [core::ffi::c_uint; 6usize],
    pub policy_hash_work: work_struct,
    pub policy_hthresh: xfrm_policy_hthresh,
    pub inexact_bins: list_head,
    pub nlsk: *mut sock,
    pub nlsk_stash: *mut sock,
    pub sysctl_aevent_etime: u32_,
    pub sysctl_aevent_rseqth: u32_,
    pub sysctl_larval_drop: core::ffi::c_int,
    pub sysctl_acq_expires: u32_,
    pub policy_default: [u8_; 3usize],
    pub sysctl_hdr: *mut ctl_table_header,
    pub xfrm4_dst_ops: dst_ops,
    pub xfrm6_dst_ops: dst_ops,
    pub xfrm_state_lock: spinlock_t,
    pub xfrm_state_hash_generation: seqcount_spinlock_t,
    pub xfrm_policy_hash_generation: seqcount_spinlock_t,
    pub xfrm_policy_lock: spinlock_t,
    pub xfrm_cfg_mutex: mutex,
}
impl Default for netns_xfrm {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpls_route {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_mpls {
    pub ip_ttl_propagate: core::ffi::c_int,
    pub default_ttl: core::ffi::c_int,
    pub platform_labels: usize,
    pub platform_label: *mut *mut mpls_route,
    pub ctl: *mut ctl_table_header,
}
impl Default for netns_mpls {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct can_dev_rcv_lists {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct can_pkg_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct can_rcv_lists_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_can {
    pub proc_dir: *mut proc_dir_entry,
    pub pde_stats: *mut proc_dir_entry,
    pub pde_reset_stats: *mut proc_dir_entry,
    pub pde_rcvlist_all: *mut proc_dir_entry,
    pub pde_rcvlist_fil: *mut proc_dir_entry,
    pub pde_rcvlist_inv: *mut proc_dir_entry,
    pub pde_rcvlist_sff: *mut proc_dir_entry,
    pub pde_rcvlist_eff: *mut proc_dir_entry,
    pub pde_rcvlist_err: *mut proc_dir_entry,
    pub bcmproc_dir: *mut proc_dir_entry,
    pub rx_alldev_list: *mut can_dev_rcv_lists,
    pub rcvlists_lock: spinlock_t,
    pub stattimer: timer_list,
    pub pkg_stats: *mut can_pkg_stats,
    pub rcv_lists_stats: *mut can_rcv_lists_stats,
    pub cgw_list: hlist_head,
}
impl Default for netns_can {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_xdp {
    pub lock: mutex,
    pub list: hlist_head,
}
impl Default for netns_xdp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smc_stats_rsn {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smc_stats {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_smc {
    pub smc_stats: *mut smc_stats,
    pub mutex_fback_rsn: mutex,
    pub fback_rsn: *mut smc_stats_rsn,
    pub limit_smc_hs: bool_,
    pub smc_hdr: *mut ctl_table_header,
    pub sysctl_autocorking_size: core::ffi::c_uint,
    pub sysctl_smcr_buf_type: core::ffi::c_uint,
    pub sysctl_smcr_testlink_time: core::ffi::c_int,
    pub sysctl_wmem: core::ffi::c_int,
    pub sysctl_rmem: core::ffi::c_int,
}
impl Default for netns_smc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const netns_bpf_attach_type_NETNS_BPF_INVALID: netns_bpf_attach_type = -1;
pub const netns_bpf_attach_type_NETNS_BPF_FLOW_DISSECTOR: netns_bpf_attach_type = 0;
pub const netns_bpf_attach_type_NETNS_BPF_SK_LOOKUP: netns_bpf_attach_type = 1;
pub const netns_bpf_attach_type_MAX_NETNS_BPF_ATTACH_TYPE: netns_bpf_attach_type = 2;
pub type netns_bpf_attach_type = core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_bpf {
    pub run_array: [*mut bpf_prog_array; 2usize],
    pub progs: [*mut bpf_prog; 2usize],
    pub links: [list_head; 2usize],
}
impl Default for netns_bpf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_mctp {
    pub routes: list_head,
    pub bind_lock: mutex,
    pub binds: hlist_head,
    pub keys_lock: spinlock_t,
    pub keys: hlist_head,
    pub default_net: core::ffi::c_uint,
    pub neigh_lock: mutex,
    pub neighbours: list_head,
}
impl Default for netns_mctp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ref_tracker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ref_tracker_dir {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netdevice_tracker {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netns_tracker {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_generic {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uevent_sock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netns_ipvs {
    _unused: [u8; 0],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct net {
    pub passive: refcount_t,
    pub rules_mod_lock: spinlock_t,
    pub dev_unreg_count: atomic_t,
    pub dev_base_seq: core::ffi::c_uint,
    pub ifindex: core::ffi::c_int,
    pub nsid_lock: spinlock_t,
    pub fnhe_genid: atomic_t,
    pub list: list_head,
    pub exit_list: list_head,
    pub cleanup_list: llist_node,
    pub key_domain: *mut key_tag,
    pub user_ns: *mut user_namespace,
    pub ucounts: *mut ucounts,
    pub netns_ids: idr,
    pub ns: ns_common,
    pub refcnt_tracker: ref_tracker_dir,
    pub dev_base_head: list_head,
    pub proc_net: *mut proc_dir_entry,
    pub proc_net_stat: *mut proc_dir_entry,
    pub sysctls: ctl_table_set,
    pub rtnl: *mut sock,
    pub genl_sock: *mut sock,
    pub uevent_sock: *mut uevent_sock,
    pub dev_name_head: *mut hlist_head,
    pub dev_index_head: *mut hlist_head,
    pub netdev_chain: raw_notifier_head,
    pub hash_mix: u32_,
    pub loopback_dev: *mut net_device,
    pub rules_ops: list_head,
    pub core: netns_core,
    pub mib: netns_mib,
    pub packet: netns_packet,
    pub unx: netns_unix,
    pub nexthop: netns_nexthop,
    pub __bindgen_padding_0: u64,
    pub ipv4: netns_ipv4,
    pub ipv6: netns_ipv6,
    pub nf: netns_nf,
    pub ct: netns_ct,
    pub gen: *mut net_generic,
    pub bpf: netns_bpf,
    pub __bindgen_padding_1: [u64; 2usize],
    pub xfrm: netns_xfrm,
    pub net_cookie: u64_,
    pub ipvs: *mut netns_ipvs,
    pub diag_nlsk: *mut sock,
}
impl Default for net {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut init_net: net;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct seq_net_private {
    pub net: *mut net,
    pub ns_tracker: netns_tracker,
}
impl Default for seq_net_private {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn copy_net_ns(
        flags: core::ffi::c_ulong,
        user_ns: *mut user_namespace,
        old_net: *mut net,
    ) -> *mut net;
}
extern "C" {
    pub fn net_ns_get_ownership(net: *const net, uid: *mut kuid_t, gid: *mut kgid_t);
}
extern "C" {
    pub fn net_ns_barrier();
}
extern "C" {
    pub fn get_net_ns(ns: *mut ns_common) -> *mut ns_common;
}
extern "C" {
    pub fn get_net_ns_by_fd(fd: core::ffi::c_int) -> *mut net;
}
extern "C" {
    pub static mut net_namespace_list: list_head;
}
extern "C" {
    pub fn get_net_ns_by_pid(pid: pid_t) -> *mut net;
}
extern "C" {
    pub fn ipx_register_sysctl();
}
extern "C" {
    pub fn ipx_unregister_sysctl();
}
extern "C" {
    pub fn __put_net(net: *mut net);
}
extern "C" {
    pub fn net_drop_ns(arg1: *mut core::ffi::c_void);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct possible_net_t {
    pub net: *mut net,
}
impl Default for possible_net_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn peernet2id_alloc(net: *mut net, peer: *mut net, gfp: gfp_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn peernet2id(net: *const net, peer: *mut net) -> core::ffi::c_int;
}
extern "C" {
    pub fn peernet_has_id(net: *const net, peer: *mut net) -> bool_;
}
extern "C" {
    pub fn get_net_ns_by_id(net: *const net, id: core::ffi::c_int) -> *mut net;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pernet_operations {
    pub list: list_head,
    pub init: ::core::option::Option<unsafe extern "C" fn(net: *mut net) -> core::ffi::c_int>,
    pub pre_exit: ::core::option::Option<unsafe extern "C" fn(net: *mut net)>,
    pub exit: ::core::option::Option<unsafe extern "C" fn(net: *mut net)>,
    pub exit_batch: ::core::option::Option<unsafe extern "C" fn(net_exit_list: *mut list_head)>,
    pub id: *mut core::ffi::c_uint,
    pub size: usize,
}
impl Default for pernet_operations {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn register_pernet_subsys(arg1: *mut pernet_operations) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_pernet_subsys(arg1: *mut pernet_operations);
}
extern "C" {
    pub fn register_pernet_device(arg1: *mut pernet_operations) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_pernet_device(arg1: *mut pernet_operations);
}
extern "C" {
    pub fn net_sysctl_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn register_net_sysctl(
        net: *mut net,
        path: *const core::ffi::c_char,
        table: *mut ctl_table,
    ) -> *mut ctl_table_header;
}
extern "C" {
    pub fn unregister_net_sysctl_table(header: *mut ctl_table_header);
}
extern "C" {
    pub static mut __fib6_flush_trees: ::core::option::Option<unsafe extern "C" fn(net: *mut net)>;
}
extern "C" {
    pub fn net_ns_init();
}
#[repr(C)]
pub struct netprio_map {
    pub rcu: callback_head,
    pub priomap_len: u32_,
    pub priomap: __IncompleteArrayField<u32_>,
}
impl Default for netprio_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const xdp_mem_type_MEM_TYPE_PAGE_SHARED: xdp_mem_type = 0;
pub const xdp_mem_type_MEM_TYPE_PAGE_ORDER0: xdp_mem_type = 1;
pub const xdp_mem_type_MEM_TYPE_PAGE_POOL: xdp_mem_type = 2;
pub const xdp_mem_type_MEM_TYPE_XSK_BUFF_POOL: xdp_mem_type = 3;
pub const xdp_mem_type_MEM_TYPE_MAX: xdp_mem_type = 4;
pub type xdp_mem_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xdp_mem_info {
    pub type_: u32_,
    pub id: u32_,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct xdp_rxq_info {
    pub dev: *mut net_device,
    pub queue_index: u32_,
    pub reg_state: u32_,
    pub mem: xdp_mem_info,
    pub napi_id: core::ffi::c_uint,
    pub frag_size: u32_,
}
impl Default for xdp_rxq_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdp_txq_info {
    pub dev: *mut net_device,
}
impl Default for xdp_txq_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const xdp_buff_flags_XDP_FLAGS_HAS_FRAGS: xdp_buff_flags = 1;
pub const xdp_buff_flags_XDP_FLAGS_FRAGS_PF_MEMALLOC: xdp_buff_flags = 2;
pub type xdp_buff_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdp_buff {
    pub data: *mut core::ffi::c_void,
    pub data_end: *mut core::ffi::c_void,
    pub data_meta: *mut core::ffi::c_void,
    pub data_hard_start: *mut core::ffi::c_void,
    pub rxq: *mut xdp_rxq_info,
    pub txq: *mut xdp_txq_info,
    pub frame_sz: u32_,
    pub flags: u32_,
}
impl Default for xdp_buff {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdp_frame {
    pub data: *mut core::ffi::c_void,
    pub len: u16_,
    pub headroom: u16_,
    pub metasize: u32_,
    pub mem: xdp_mem_info,
    pub dev_rx: *mut net_device,
    pub frame_sz: u32_,
    pub flags: u32_,
}
impl Default for xdp_frame {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdp_frame_bulk {
    pub count: core::ffi::c_int,
    pub xa: *mut core::ffi::c_void,
    pub q: [*mut core::ffi::c_void; 16usize],
}
impl Default for xdp_frame_bulk {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xdp_cpumap_stats {
    pub redirect: core::ffi::c_uint,
    pub pass: core::ffi::c_uint,
    pub drop: core::ffi::c_uint,
}
extern "C" {
    pub fn xdp_warn(
        msg: *const core::ffi::c_char,
        func: *const core::ffi::c_char,
        line: core::ffi::c_int,
    );
}
extern "C" {
    pub fn xdp_convert_zc_to_xdp_frame(xdp: *mut xdp_buff) -> *mut xdp_frame;
}
extern "C" {
    pub fn __xdp_build_skb_from_frame(
        xdpf: *mut xdp_frame,
        skb: *mut sk_buff,
        dev: *mut net_device,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn xdp_build_skb_from_frame(xdpf: *mut xdp_frame, dev: *mut net_device) -> *mut sk_buff;
}
extern "C" {
    pub fn xdp_alloc_skb_bulk(
        skbs: *mut *mut core::ffi::c_void,
        n_skb: core::ffi::c_int,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn xdpf_clone(xdpf: *mut xdp_frame) -> *mut xdp_frame;
}
extern "C" {
    pub fn __xdp_return(
        data: *mut core::ffi::c_void,
        mem: *mut xdp_mem_info,
        napi_direct: bool_,
        xdp: *mut xdp_buff,
    );
}
extern "C" {
    pub fn xdp_return_frame(xdpf: *mut xdp_frame);
}
extern "C" {
    pub fn xdp_return_frame_rx_napi(xdpf: *mut xdp_frame);
}
extern "C" {
    pub fn xdp_return_buff(xdp: *mut xdp_buff);
}
extern "C" {
    pub fn xdp_flush_frame_bulk(bq: *mut xdp_frame_bulk);
}
extern "C" {
    pub fn xdp_return_frame_bulk(xdpf: *mut xdp_frame, bq: *mut xdp_frame_bulk);
}
extern "C" {
    pub fn __xdp_release_frame(data: *mut core::ffi::c_void, mem: *mut xdp_mem_info);
}
extern "C" {
    pub fn __xdp_rxq_info_reg(
        xdp_rxq: *mut xdp_rxq_info,
        dev: *mut net_device,
        queue_index: u32_,
        napi_id: core::ffi::c_uint,
        frag_size: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn xdp_rxq_info_unreg(xdp_rxq: *mut xdp_rxq_info);
}
extern "C" {
    pub fn xdp_rxq_info_unused(xdp_rxq: *mut xdp_rxq_info);
}
extern "C" {
    pub fn xdp_rxq_info_is_reg(xdp_rxq: *mut xdp_rxq_info) -> bool_;
}
extern "C" {
    pub fn xdp_rxq_info_reg_mem_model(
        xdp_rxq: *mut xdp_rxq_info,
        type_: xdp_mem_type,
        allocator: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn xdp_rxq_info_unreg_mem_model(xdp_rxq: *mut xdp_rxq_info);
}
extern "C" {
    pub fn xdp_reg_mem_model(
        mem: *mut xdp_mem_info,
        type_: xdp_mem_type,
        allocator: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn xdp_unreg_mem_model(mem: *mut xdp_mem_info);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdp_attachment_info {
    pub prog: *mut bpf_prog,
    pub flags: u32_,
}
impl Default for xdp_attachment_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn xdp_attachment_setup(info: *mut xdp_attachment_info, bpf: *mut netdev_bpf);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scm_creds {
    pub pid: u32_,
    pub uid: kuid_t,
    pub gid: kgid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct scm_fp_list {
    pub count: core::ffi::c_short,
    pub max: core::ffi::c_short,
    pub user: *mut user_struct,
    pub fp: [*mut file; 253usize],
}
impl Default for scm_fp_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct scm_cookie {
    pub pid: *mut pid,
    pub fp: *mut scm_fp_list,
    pub creds: scm_creds,
    pub secid: u32_,
}
impl Default for scm_cookie {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn scm_detach_fds(msg: *mut msghdr, scm: *mut scm_cookie);
}
extern "C" {
    pub fn scm_detach_fds_compat(msg: *mut msghdr, scm: *mut scm_cookie);
}
extern "C" {
    pub fn __scm_send(
        sock: *mut socket,
        msg: *mut msghdr,
        scm: *mut scm_cookie,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __scm_destroy(scm: *mut scm_cookie);
}
extern "C" {
    pub fn scm_fp_dup(fpl: *mut scm_fp_list) -> *mut scm_fp_list;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockaddr_nl {
    pub nl_family: __kernel_sa_family_t,
    pub nl_pad: core::ffi::c_ushort,
    pub nl_pid: __u32,
    pub nl_groups: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nlmsghdr {
    pub nlmsg_len: __u32,
    pub nlmsg_type: __u16,
    pub nlmsg_flags: __u16,
    pub nlmsg_seq: __u32,
    pub nlmsg_pid: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nlmsgerr {
    pub error: core::ffi::c_int,
    pub msg: nlmsghdr,
}
pub const nlmsgerr_attrs_NLMSGERR_ATTR_UNUSED: nlmsgerr_attrs = 0;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MSG: nlmsgerr_attrs = 1;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_OFFS: nlmsgerr_attrs = 2;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_COOKIE: nlmsgerr_attrs = 3;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_POLICY: nlmsgerr_attrs = 4;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MISS_TYPE: nlmsgerr_attrs = 5;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MISS_NEST: nlmsgerr_attrs = 6;
pub const nlmsgerr_attrs___NLMSGERR_ATTR_MAX: nlmsgerr_attrs = 7;
pub const nlmsgerr_attrs_NLMSGERR_ATTR_MAX: nlmsgerr_attrs = 6;
pub type nlmsgerr_attrs = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nl_pktinfo {
    pub group: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nl_mmap_req {
    pub nm_block_size: core::ffi::c_uint,
    pub nm_block_nr: core::ffi::c_uint,
    pub nm_frame_size: core::ffi::c_uint,
    pub nm_frame_nr: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nl_mmap_hdr {
    pub nm_status: core::ffi::c_uint,
    pub nm_len: core::ffi::c_uint,
    pub nm_group: __u32,
    pub nm_pid: __u32,
    pub nm_uid: __u32,
    pub nm_gid: __u32,
}
pub const NETLINK_UNCONNECTED: core::ffi::c_uint = 0;
pub const NETLINK_CONNECTED: core::ffi::c_uint = 1;
pub type _bindgen_ty_140 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nlattr {
    pub nla_len: __u16,
    pub nla_type: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nla_bitfield32 {
    pub value: __u32,
    pub selector: __u32,
}
pub const netlink_attribute_type_NL_ATTR_TYPE_INVALID: netlink_attribute_type = 0;
pub const netlink_attribute_type_NL_ATTR_TYPE_FLAG: netlink_attribute_type = 1;
pub const netlink_attribute_type_NL_ATTR_TYPE_U8: netlink_attribute_type = 2;
pub const netlink_attribute_type_NL_ATTR_TYPE_U16: netlink_attribute_type = 3;
pub const netlink_attribute_type_NL_ATTR_TYPE_U32: netlink_attribute_type = 4;
pub const netlink_attribute_type_NL_ATTR_TYPE_U64: netlink_attribute_type = 5;
pub const netlink_attribute_type_NL_ATTR_TYPE_S8: netlink_attribute_type = 6;
pub const netlink_attribute_type_NL_ATTR_TYPE_S16: netlink_attribute_type = 7;
pub const netlink_attribute_type_NL_ATTR_TYPE_S32: netlink_attribute_type = 8;
pub const netlink_attribute_type_NL_ATTR_TYPE_S64: netlink_attribute_type = 9;
pub const netlink_attribute_type_NL_ATTR_TYPE_BINARY: netlink_attribute_type = 10;
pub const netlink_attribute_type_NL_ATTR_TYPE_STRING: netlink_attribute_type = 11;
pub const netlink_attribute_type_NL_ATTR_TYPE_NUL_STRING: netlink_attribute_type = 12;
pub const netlink_attribute_type_NL_ATTR_TYPE_NESTED: netlink_attribute_type = 13;
pub const netlink_attribute_type_NL_ATTR_TYPE_NESTED_ARRAY: netlink_attribute_type = 14;
pub const netlink_attribute_type_NL_ATTR_TYPE_BITFIELD32: netlink_attribute_type = 15;
pub type netlink_attribute_type = core::ffi::c_uint;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_UNSPEC: netlink_policy_type_attr = 0;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_TYPE: netlink_policy_type_attr = 1;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_VALUE_S: netlink_policy_type_attr = 2;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_VALUE_S: netlink_policy_type_attr = 3;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_VALUE_U: netlink_policy_type_attr = 4;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_VALUE_U: netlink_policy_type_attr = 5;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MIN_LENGTH: netlink_policy_type_attr = 6;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX_LENGTH: netlink_policy_type_attr = 7;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_POLICY_IDX: netlink_policy_type_attr = 8;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE: netlink_policy_type_attr = 9;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_BITFIELD32_MASK: netlink_policy_type_attr =
    10;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_PAD: netlink_policy_type_attr = 11;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MASK: netlink_policy_type_attr = 12;
pub const netlink_policy_type_attr___NL_POLICY_TYPE_ATTR_MAX: netlink_policy_type_attr = 13;
pub const netlink_policy_type_attr_NL_POLICY_TYPE_ATTR_MAX: netlink_policy_type_attr = 12;
pub type netlink_policy_type_attr = core::ffi::c_uint;
extern "C" {
    pub fn do_trace_netlink_extack(msg: *const core::ffi::c_char);
}
pub const netlink_skb_flags_NETLINK_SKB_DST: netlink_skb_flags = 8;
pub type netlink_skb_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_skb_parms {
    pub creds: scm_creds,
    pub portid: __u32,
    pub dst_group: __u32,
    pub flags: __u32,
    pub sk: *mut sock,
    pub nsid_is_set: bool_,
    pub nsid: core::ffi::c_int,
}
impl Default for netlink_skb_parms {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn netlink_table_grab();
}
extern "C" {
    pub fn netlink_table_ungrab();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_kernel_cfg {
    pub groups: core::ffi::c_uint,
    pub flags: core::ffi::c_uint,
    pub input: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
    pub cb_mutex: *mut mutex,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, group: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub unbind:
        ::core::option::Option<unsafe extern "C" fn(net: *mut net, group: core::ffi::c_int)>,
    pub compare:
        ::core::option::Option<unsafe extern "C" fn(net: *mut net, sk: *mut sock) -> bool_>,
}
impl Default for netlink_kernel_cfg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __netlink_kernel_create(
        net: *mut net,
        unit: core::ffi::c_int,
        module: *mut module,
        cfg: *mut netlink_kernel_cfg,
    ) -> *mut sock;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_ext_ack {
    pub _msg: *const core::ffi::c_char,
    pub bad_attr: *const nlattr,
    pub policy: *const nla_policy,
    pub miss_nest: *const nlattr,
    pub miss_type: u16_,
    pub cookie: [u8_; 20usize],
    pub cookie_len: u8_,
}
impl Default for netlink_ext_ack {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn netlink_kernel_release(sk: *mut sock);
}
extern "C" {
    pub fn __netlink_change_ngroups(sk: *mut sock, groups: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_change_ngroups(sk: *mut sock, groups: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn __netlink_clear_multicast_users(sk: *mut sock, group: core::ffi::c_uint);
}
extern "C" {
    pub fn netlink_ack(
        in_skb: *mut sk_buff,
        nlh: *mut nlmsghdr,
        err: core::ffi::c_int,
        extack: *const netlink_ext_ack,
    );
}
extern "C" {
    pub fn netlink_has_listeners(sk: *mut sock, group: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_strict_get_check(skb: *mut sk_buff) -> bool_;
}
extern "C" {
    pub fn netlink_unicast(
        ssk: *mut sock,
        skb: *mut sk_buff,
        portid: __u32,
        nonblock: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_broadcast(
        ssk: *mut sock,
        skb: *mut sk_buff,
        portid: __u32,
        group: __u32,
        allocation: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_set_err(
        ssk: *mut sock,
        portid: __u32,
        group: __u32,
        code: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_register_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_unregister_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_getsockbyfilp(filp: *mut file) -> *mut sock;
}
extern "C" {
    pub fn netlink_attachskb(
        sk: *mut sock,
        skb: *mut sk_buff,
        timeo: *mut core::ffi::c_long,
        ssk: *mut sock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_detachskb(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn netlink_sendskb(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_callback {
    pub skb: *mut sk_buff,
    pub nlh: *const nlmsghdr,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, cb: *mut netlink_callback) -> core::ffi::c_int,
    >,
    pub done:
        ::core::option::Option<unsafe extern "C" fn(cb: *mut netlink_callback) -> core::ffi::c_int>,
    pub data: *mut core::ffi::c_void,
    pub module: *mut module,
    pub extack: *mut netlink_ext_ack,
    pub family: u16_,
    pub answer_flags: u16_,
    pub min_dump_alloc: u32_,
    pub prev_seq: core::ffi::c_uint,
    pub seq: core::ffi::c_uint,
    pub strict_check: bool_,
    pub __bindgen_anon_1: netlink_callback__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netlink_callback__bindgen_ty_1 {
    pub ctx: [u8_; 48usize],
    pub args: [core::ffi::c_long; 6usize],
    _bindgen_union_align: [u64; 6usize],
}
impl Default for netlink_callback__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for netlink_callback {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_notify {
    pub net: *mut net,
    pub portid: u32_,
    pub protocol: core::ffi::c_int,
}
impl Default for netlink_notify {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __nlmsg_put(
        skb: *mut sk_buff,
        portid: u32_,
        seq: u32_,
        type_: core::ffi::c_int,
        len: core::ffi::c_int,
        flags: core::ffi::c_int,
    ) -> *mut nlmsghdr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_dump_control {
    pub start: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut netlink_callback) -> core::ffi::c_int,
    >,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, arg1: *mut netlink_callback) -> core::ffi::c_int,
    >,
    pub done: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut netlink_callback) -> core::ffi::c_int,
    >,
    pub data: *mut core::ffi::c_void,
    pub module: *mut module,
    pub min_dump_alloc: u32_,
}
impl Default for netlink_dump_control {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __netlink_dump_start(
        ssk: *mut sock,
        skb: *mut sk_buff,
        nlh: *const nlmsghdr,
        control: *mut netlink_dump_control,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_tap {
    pub dev: *mut net_device,
    pub module: *mut module,
    pub list: list_head,
}
impl Default for netlink_tap {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn netlink_add_tap(nt: *mut netlink_tap) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_remove_tap(nt: *mut netlink_tap) -> core::ffi::c_int;
}
extern "C" {
    pub fn __netlink_ns_capable(
        nsp: *const netlink_skb_parms,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn netlink_ns_capable(
        skb: *const sk_buff,
        ns: *mut user_namespace,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn netlink_capable(skb: *const sk_buff, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn netlink_net_capable(skb: *const sk_buff, cap: core::ffi::c_int) -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ndmsg {
    pub ndm_family: __u8,
    pub ndm_pad1: __u8,
    pub ndm_pad2: __u16,
    pub ndm_ifindex: __s32,
    pub ndm_state: __u16,
    pub ndm_flags: __u8,
    pub ndm_type: __u8,
}
pub const NDA_UNSPEC: core::ffi::c_uint = 0;
pub const NDA_DST: core::ffi::c_uint = 1;
pub const NDA_LLADDR: core::ffi::c_uint = 2;
pub const NDA_CACHEINFO: core::ffi::c_uint = 3;
pub const NDA_PROBES: core::ffi::c_uint = 4;
pub const NDA_VLAN: core::ffi::c_uint = 5;
pub const NDA_PORT: core::ffi::c_uint = 6;
pub const NDA_VNI: core::ffi::c_uint = 7;
pub const NDA_IFINDEX: core::ffi::c_uint = 8;
pub const NDA_MASTER: core::ffi::c_uint = 9;
pub const NDA_LINK_NETNSID: core::ffi::c_uint = 10;
pub const NDA_SRC_VNI: core::ffi::c_uint = 11;
pub const NDA_PROTOCOL: core::ffi::c_uint = 12;
pub const NDA_NH_ID: core::ffi::c_uint = 13;
pub const NDA_FDB_EXT_ATTRS: core::ffi::c_uint = 14;
pub const NDA_FLAGS_EXT: core::ffi::c_uint = 15;
pub const NDA_NDM_STATE_MASK: core::ffi::c_uint = 16;
pub const NDA_NDM_FLAGS_MASK: core::ffi::c_uint = 17;
pub const __NDA_MAX: core::ffi::c_uint = 18;
pub type _bindgen_ty_141 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nda_cacheinfo {
    pub ndm_confirmed: __u32,
    pub ndm_used: __u32,
    pub ndm_updated: __u32,
    pub ndm_refcnt: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ndt_stats {
    pub ndts_allocs: __u64,
    pub ndts_destroys: __u64,
    pub ndts_hash_grows: __u64,
    pub ndts_res_failed: __u64,
    pub ndts_lookups: __u64,
    pub ndts_hits: __u64,
    pub ndts_rcv_probes_mcast: __u64,
    pub ndts_rcv_probes_ucast: __u64,
    pub ndts_periodic_gc_runs: __u64,
    pub ndts_forced_gc_runs: __u64,
    pub ndts_table_fulls: __u64,
}
pub const NDTPA_UNSPEC: core::ffi::c_uint = 0;
pub const NDTPA_IFINDEX: core::ffi::c_uint = 1;
pub const NDTPA_REFCNT: core::ffi::c_uint = 2;
pub const NDTPA_REACHABLE_TIME: core::ffi::c_uint = 3;
pub const NDTPA_BASE_REACHABLE_TIME: core::ffi::c_uint = 4;
pub const NDTPA_RETRANS_TIME: core::ffi::c_uint = 5;
pub const NDTPA_GC_STALETIME: core::ffi::c_uint = 6;
pub const NDTPA_DELAY_PROBE_TIME: core::ffi::c_uint = 7;
pub const NDTPA_QUEUE_LEN: core::ffi::c_uint = 8;
pub const NDTPA_APP_PROBES: core::ffi::c_uint = 9;
pub const NDTPA_UCAST_PROBES: core::ffi::c_uint = 10;
pub const NDTPA_MCAST_PROBES: core::ffi::c_uint = 11;
pub const NDTPA_ANYCAST_DELAY: core::ffi::c_uint = 12;
pub const NDTPA_PROXY_DELAY: core::ffi::c_uint = 13;
pub const NDTPA_PROXY_QLEN: core::ffi::c_uint = 14;
pub const NDTPA_LOCKTIME: core::ffi::c_uint = 15;
pub const NDTPA_QUEUE_LENBYTES: core::ffi::c_uint = 16;
pub const NDTPA_MCAST_REPROBES: core::ffi::c_uint = 17;
pub const NDTPA_PAD: core::ffi::c_uint = 18;
pub const NDTPA_INTERVAL_PROBE_TIME_MS: core::ffi::c_uint = 19;
pub const __NDTPA_MAX: core::ffi::c_uint = 20;
pub type _bindgen_ty_142 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ndtmsg {
    pub ndtm_family: __u8,
    pub ndtm_pad1: __u8,
    pub ndtm_pad2: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ndt_config {
    pub ndtc_key_len: __u16,
    pub ndtc_entry_size: __u16,
    pub ndtc_entries: __u32,
    pub ndtc_last_flush: __u32,
    pub ndtc_last_rand: __u32,
    pub ndtc_hash_rnd: __u32,
    pub ndtc_hash_mask: __u32,
    pub ndtc_hash_chain_gc: __u32,
    pub ndtc_proxy_qlen: __u32,
}
pub const NDTA_UNSPEC: core::ffi::c_uint = 0;
pub const NDTA_NAME: core::ffi::c_uint = 1;
pub const NDTA_THRESH1: core::ffi::c_uint = 2;
pub const NDTA_THRESH2: core::ffi::c_uint = 3;
pub const NDTA_THRESH3: core::ffi::c_uint = 4;
pub const NDTA_CONFIG: core::ffi::c_uint = 5;
pub const NDTA_PARMS: core::ffi::c_uint = 6;
pub const NDTA_STATS: core::ffi::c_uint = 7;
pub const NDTA_GC_INTERVAL: core::ffi::c_uint = 8;
pub const NDTA_PAD: core::ffi::c_uint = 9;
pub const __NDTA_MAX: core::ffi::c_uint = 10;
pub type _bindgen_ty_143 = core::ffi::c_uint;
pub const FDB_NOTIFY_BIT: core::ffi::c_uint = 1;
pub const FDB_NOTIFY_INACTIVE_BIT: core::ffi::c_uint = 2;
pub type _bindgen_ty_144 = core::ffi::c_uint;
pub const NFEA_UNSPEC: core::ffi::c_uint = 0;
pub const NFEA_ACTIVITY_NOTIFY: core::ffi::c_uint = 1;
pub const NFEA_DONT_REFRESH: core::ffi::c_uint = 2;
pub const __NFEA_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_145 = core::ffi::c_uint;
extern "C" {
    pub fn eth_header_parse(
        skb: *const sk_buff,
        haddr: *mut core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sysfs_format_mac(
        buf: *mut core::ffi::c_char,
        addr: *const core::ffi::c_uchar,
        len: core::ffi::c_int,
    ) -> isize;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rtnl_link_stats {
    pub rx_packets: __u32,
    pub tx_packets: __u32,
    pub rx_bytes: __u32,
    pub tx_bytes: __u32,
    pub rx_errors: __u32,
    pub tx_errors: __u32,
    pub rx_dropped: __u32,
    pub tx_dropped: __u32,
    pub multicast: __u32,
    pub collisions: __u32,
    pub rx_length_errors: __u32,
    pub rx_over_errors: __u32,
    pub rx_crc_errors: __u32,
    pub rx_frame_errors: __u32,
    pub rx_fifo_errors: __u32,
    pub rx_missed_errors: __u32,
    pub tx_aborted_errors: __u32,
    pub tx_carrier_errors: __u32,
    pub tx_fifo_errors: __u32,
    pub tx_heartbeat_errors: __u32,
    pub tx_window_errors: __u32,
    pub rx_compressed: __u32,
    pub tx_compressed: __u32,
    pub rx_nohandler: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rtnl_link_stats64 {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub rx_errors: __u64,
    pub tx_errors: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
    pub multicast: __u64,
    pub collisions: __u64,
    pub rx_length_errors: __u64,
    pub rx_over_errors: __u64,
    pub rx_crc_errors: __u64,
    pub rx_frame_errors: __u64,
    pub rx_fifo_errors: __u64,
    pub rx_missed_errors: __u64,
    pub tx_aborted_errors: __u64,
    pub tx_carrier_errors: __u64,
    pub tx_fifo_errors: __u64,
    pub tx_heartbeat_errors: __u64,
    pub tx_window_errors: __u64,
    pub rx_compressed: __u64,
    pub tx_compressed: __u64,
    pub rx_nohandler: __u64,
    pub rx_otherhost_dropped: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rtnl_hw_stats64 {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub rx_errors: __u64,
    pub tx_errors: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
    pub multicast: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rtnl_link_ifmap {
    pub mem_start: __u64,
    pub mem_end: __u64,
    pub base_addr: __u64,
    pub irq: __u16,
    pub dma: __u8,
    pub port: __u8,
}
pub const IFLA_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_ADDRESS: core::ffi::c_uint = 1;
pub const IFLA_BROADCAST: core::ffi::c_uint = 2;
pub const IFLA_IFNAME: core::ffi::c_uint = 3;
pub const IFLA_MTU: core::ffi::c_uint = 4;
pub const IFLA_LINK: core::ffi::c_uint = 5;
pub const IFLA_QDISC: core::ffi::c_uint = 6;
pub const IFLA_STATS: core::ffi::c_uint = 7;
pub const IFLA_COST: core::ffi::c_uint = 8;
pub const IFLA_PRIORITY: core::ffi::c_uint = 9;
pub const IFLA_MASTER: core::ffi::c_uint = 10;
pub const IFLA_WIRELESS: core::ffi::c_uint = 11;
pub const IFLA_PROTINFO: core::ffi::c_uint = 12;
pub const IFLA_TXQLEN: core::ffi::c_uint = 13;
pub const IFLA_MAP: core::ffi::c_uint = 14;
pub const IFLA_WEIGHT: core::ffi::c_uint = 15;
pub const IFLA_OPERSTATE: core::ffi::c_uint = 16;
pub const IFLA_LINKMODE: core::ffi::c_uint = 17;
pub const IFLA_LINKINFO: core::ffi::c_uint = 18;
pub const IFLA_NET_NS_PID: core::ffi::c_uint = 19;
pub const IFLA_IFALIAS: core::ffi::c_uint = 20;
pub const IFLA_NUM_VF: core::ffi::c_uint = 21;
pub const IFLA_VFINFO_LIST: core::ffi::c_uint = 22;
pub const IFLA_STATS64: core::ffi::c_uint = 23;
pub const IFLA_VF_PORTS: core::ffi::c_uint = 24;
pub const IFLA_PORT_SELF: core::ffi::c_uint = 25;
pub const IFLA_AF_SPEC: core::ffi::c_uint = 26;
pub const IFLA_GROUP: core::ffi::c_uint = 27;
pub const IFLA_NET_NS_FD: core::ffi::c_uint = 28;
pub const IFLA_EXT_MASK: core::ffi::c_uint = 29;
pub const IFLA_PROMISCUITY: core::ffi::c_uint = 30;
pub const IFLA_NUM_TX_QUEUES: core::ffi::c_uint = 31;
pub const IFLA_NUM_RX_QUEUES: core::ffi::c_uint = 32;
pub const IFLA_CARRIER: core::ffi::c_uint = 33;
pub const IFLA_PHYS_PORT_ID: core::ffi::c_uint = 34;
pub const IFLA_CARRIER_CHANGES: core::ffi::c_uint = 35;
pub const IFLA_PHYS_SWITCH_ID: core::ffi::c_uint = 36;
pub const IFLA_LINK_NETNSID: core::ffi::c_uint = 37;
pub const IFLA_PHYS_PORT_NAME: core::ffi::c_uint = 38;
pub const IFLA_PROTO_DOWN: core::ffi::c_uint = 39;
pub const IFLA_GSO_MAX_SEGS: core::ffi::c_uint = 40;
pub const IFLA_GSO_MAX_SIZE: core::ffi::c_uint = 41;
pub const IFLA_PAD: core::ffi::c_uint = 42;
pub const IFLA_XDP: core::ffi::c_uint = 43;
pub const IFLA_EVENT: core::ffi::c_uint = 44;
pub const IFLA_NEW_NETNSID: core::ffi::c_uint = 45;
pub const IFLA_IF_NETNSID: core::ffi::c_uint = 46;
pub const IFLA_TARGET_NETNSID: core::ffi::c_uint = 46;
pub const IFLA_CARRIER_UP_COUNT: core::ffi::c_uint = 47;
pub const IFLA_CARRIER_DOWN_COUNT: core::ffi::c_uint = 48;
pub const IFLA_NEW_IFINDEX: core::ffi::c_uint = 49;
pub const IFLA_MIN_MTU: core::ffi::c_uint = 50;
pub const IFLA_MAX_MTU: core::ffi::c_uint = 51;
pub const IFLA_PROP_LIST: core::ffi::c_uint = 52;
pub const IFLA_ALT_IFNAME: core::ffi::c_uint = 53;
pub const IFLA_PERM_ADDRESS: core::ffi::c_uint = 54;
pub const IFLA_PROTO_DOWN_REASON: core::ffi::c_uint = 55;
pub const IFLA_PARENT_DEV_NAME: core::ffi::c_uint = 56;
pub const IFLA_PARENT_DEV_BUS_NAME: core::ffi::c_uint = 57;
pub const IFLA_GRO_MAX_SIZE: core::ffi::c_uint = 58;
pub const IFLA_TSO_MAX_SIZE: core::ffi::c_uint = 59;
pub const IFLA_TSO_MAX_SEGS: core::ffi::c_uint = 60;
pub const IFLA_ALLMULTI: core::ffi::c_uint = 61;
pub const __IFLA_MAX: core::ffi::c_uint = 62;
pub type _bindgen_ty_146 = core::ffi::c_uint;
pub const IFLA_PROTO_DOWN_REASON_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_PROTO_DOWN_REASON_MASK: core::ffi::c_uint = 1;
pub const IFLA_PROTO_DOWN_REASON_VALUE: core::ffi::c_uint = 2;
pub const __IFLA_PROTO_DOWN_REASON_CNT: core::ffi::c_uint = 3;
pub const IFLA_PROTO_DOWN_REASON_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_147 = core::ffi::c_uint;
pub const IFLA_INET_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_INET_CONF: core::ffi::c_uint = 1;
pub const __IFLA_INET_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_148 = core::ffi::c_uint;
pub const IFLA_INET6_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_INET6_FLAGS: core::ffi::c_uint = 1;
pub const IFLA_INET6_CONF: core::ffi::c_uint = 2;
pub const IFLA_INET6_STATS: core::ffi::c_uint = 3;
pub const IFLA_INET6_MCAST: core::ffi::c_uint = 4;
pub const IFLA_INET6_CACHEINFO: core::ffi::c_uint = 5;
pub const IFLA_INET6_ICMP6STATS: core::ffi::c_uint = 6;
pub const IFLA_INET6_TOKEN: core::ffi::c_uint = 7;
pub const IFLA_INET6_ADDR_GEN_MODE: core::ffi::c_uint = 8;
pub const IFLA_INET6_RA_MTU: core::ffi::c_uint = 9;
pub const __IFLA_INET6_MAX: core::ffi::c_uint = 10;
pub type _bindgen_ty_149 = core::ffi::c_uint;
pub const in6_addr_gen_mode_IN6_ADDR_GEN_MODE_EUI64: in6_addr_gen_mode = 0;
pub const in6_addr_gen_mode_IN6_ADDR_GEN_MODE_NONE: in6_addr_gen_mode = 1;
pub const in6_addr_gen_mode_IN6_ADDR_GEN_MODE_STABLE_PRIVACY: in6_addr_gen_mode = 2;
pub const in6_addr_gen_mode_IN6_ADDR_GEN_MODE_RANDOM: in6_addr_gen_mode = 3;
pub type in6_addr_gen_mode = core::ffi::c_uint;
pub const IFLA_BR_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_BR_FORWARD_DELAY: core::ffi::c_uint = 1;
pub const IFLA_BR_HELLO_TIME: core::ffi::c_uint = 2;
pub const IFLA_BR_MAX_AGE: core::ffi::c_uint = 3;
pub const IFLA_BR_AGEING_TIME: core::ffi::c_uint = 4;
pub const IFLA_BR_STP_STATE: core::ffi::c_uint = 5;
pub const IFLA_BR_PRIORITY: core::ffi::c_uint = 6;
pub const IFLA_BR_VLAN_FILTERING: core::ffi::c_uint = 7;
pub const IFLA_BR_VLAN_PROTOCOL: core::ffi::c_uint = 8;
pub const IFLA_BR_GROUP_FWD_MASK: core::ffi::c_uint = 9;
pub const IFLA_BR_ROOT_ID: core::ffi::c_uint = 10;
pub const IFLA_BR_BRIDGE_ID: core::ffi::c_uint = 11;
pub const IFLA_BR_ROOT_PORT: core::ffi::c_uint = 12;
pub const IFLA_BR_ROOT_PATH_COST: core::ffi::c_uint = 13;
pub const IFLA_BR_TOPOLOGY_CHANGE: core::ffi::c_uint = 14;
pub const IFLA_BR_TOPOLOGY_CHANGE_DETECTED: core::ffi::c_uint = 15;
pub const IFLA_BR_HELLO_TIMER: core::ffi::c_uint = 16;
pub const IFLA_BR_TCN_TIMER: core::ffi::c_uint = 17;
pub const IFLA_BR_TOPOLOGY_CHANGE_TIMER: core::ffi::c_uint = 18;
pub const IFLA_BR_GC_TIMER: core::ffi::c_uint = 19;
pub const IFLA_BR_GROUP_ADDR: core::ffi::c_uint = 20;
pub const IFLA_BR_FDB_FLUSH: core::ffi::c_uint = 21;
pub const IFLA_BR_MCAST_ROUTER: core::ffi::c_uint = 22;
pub const IFLA_BR_MCAST_SNOOPING: core::ffi::c_uint = 23;
pub const IFLA_BR_MCAST_QUERY_USE_IFADDR: core::ffi::c_uint = 24;
pub const IFLA_BR_MCAST_QUERIER: core::ffi::c_uint = 25;
pub const IFLA_BR_MCAST_HASH_ELASTICITY: core::ffi::c_uint = 26;
pub const IFLA_BR_MCAST_HASH_MAX: core::ffi::c_uint = 27;
pub const IFLA_BR_MCAST_LAST_MEMBER_CNT: core::ffi::c_uint = 28;
pub const IFLA_BR_MCAST_STARTUP_QUERY_CNT: core::ffi::c_uint = 29;
pub const IFLA_BR_MCAST_LAST_MEMBER_INTVL: core::ffi::c_uint = 30;
pub const IFLA_BR_MCAST_MEMBERSHIP_INTVL: core::ffi::c_uint = 31;
pub const IFLA_BR_MCAST_QUERIER_INTVL: core::ffi::c_uint = 32;
pub const IFLA_BR_MCAST_QUERY_INTVL: core::ffi::c_uint = 33;
pub const IFLA_BR_MCAST_QUERY_RESPONSE_INTVL: core::ffi::c_uint = 34;
pub const IFLA_BR_MCAST_STARTUP_QUERY_INTVL: core::ffi::c_uint = 35;
pub const IFLA_BR_NF_CALL_IPTABLES: core::ffi::c_uint = 36;
pub const IFLA_BR_NF_CALL_IP6TABLES: core::ffi::c_uint = 37;
pub const IFLA_BR_NF_CALL_ARPTABLES: core::ffi::c_uint = 38;
pub const IFLA_BR_VLAN_DEFAULT_PVID: core::ffi::c_uint = 39;
pub const IFLA_BR_PAD: core::ffi::c_uint = 40;
pub const IFLA_BR_VLAN_STATS_ENABLED: core::ffi::c_uint = 41;
pub const IFLA_BR_MCAST_STATS_ENABLED: core::ffi::c_uint = 42;
pub const IFLA_BR_MCAST_IGMP_VERSION: core::ffi::c_uint = 43;
pub const IFLA_BR_MCAST_MLD_VERSION: core::ffi::c_uint = 44;
pub const IFLA_BR_VLAN_STATS_PER_PORT: core::ffi::c_uint = 45;
pub const IFLA_BR_MULTI_BOOLOPT: core::ffi::c_uint = 46;
pub const IFLA_BR_MCAST_QUERIER_STATE: core::ffi::c_uint = 47;
pub const __IFLA_BR_MAX: core::ffi::c_uint = 48;
pub type _bindgen_ty_150 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_bridge_id {
    pub prio: [__u8; 2usize],
    pub addr: [__u8; 6usize],
}
pub const BRIDGE_MODE_UNSPEC: core::ffi::c_uint = 0;
pub const BRIDGE_MODE_HAIRPIN: core::ffi::c_uint = 1;
pub type _bindgen_ty_151 = core::ffi::c_uint;
pub const IFLA_BRPORT_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_BRPORT_STATE: core::ffi::c_uint = 1;
pub const IFLA_BRPORT_PRIORITY: core::ffi::c_uint = 2;
pub const IFLA_BRPORT_COST: core::ffi::c_uint = 3;
pub const IFLA_BRPORT_MODE: core::ffi::c_uint = 4;
pub const IFLA_BRPORT_GUARD: core::ffi::c_uint = 5;
pub const IFLA_BRPORT_PROTECT: core::ffi::c_uint = 6;
pub const IFLA_BRPORT_FAST_LEAVE: core::ffi::c_uint = 7;
pub const IFLA_BRPORT_LEARNING: core::ffi::c_uint = 8;
pub const IFLA_BRPORT_UNICAST_FLOOD: core::ffi::c_uint = 9;
pub const IFLA_BRPORT_PROXYARP: core::ffi::c_uint = 10;
pub const IFLA_BRPORT_LEARNING_SYNC: core::ffi::c_uint = 11;
pub const IFLA_BRPORT_PROXYARP_WIFI: core::ffi::c_uint = 12;
pub const IFLA_BRPORT_ROOT_ID: core::ffi::c_uint = 13;
pub const IFLA_BRPORT_BRIDGE_ID: core::ffi::c_uint = 14;
pub const IFLA_BRPORT_DESIGNATED_PORT: core::ffi::c_uint = 15;
pub const IFLA_BRPORT_DESIGNATED_COST: core::ffi::c_uint = 16;
pub const IFLA_BRPORT_ID: core::ffi::c_uint = 17;
pub const IFLA_BRPORT_NO: core::ffi::c_uint = 18;
pub const IFLA_BRPORT_TOPOLOGY_CHANGE_ACK: core::ffi::c_uint = 19;
pub const IFLA_BRPORT_CONFIG_PENDING: core::ffi::c_uint = 20;
pub const IFLA_BRPORT_MESSAGE_AGE_TIMER: core::ffi::c_uint = 21;
pub const IFLA_BRPORT_FORWARD_DELAY_TIMER: core::ffi::c_uint = 22;
pub const IFLA_BRPORT_HOLD_TIMER: core::ffi::c_uint = 23;
pub const IFLA_BRPORT_FLUSH: core::ffi::c_uint = 24;
pub const IFLA_BRPORT_MULTICAST_ROUTER: core::ffi::c_uint = 25;
pub const IFLA_BRPORT_PAD: core::ffi::c_uint = 26;
pub const IFLA_BRPORT_MCAST_FLOOD: core::ffi::c_uint = 27;
pub const IFLA_BRPORT_MCAST_TO_UCAST: core::ffi::c_uint = 28;
pub const IFLA_BRPORT_VLAN_TUNNEL: core::ffi::c_uint = 29;
pub const IFLA_BRPORT_BCAST_FLOOD: core::ffi::c_uint = 30;
pub const IFLA_BRPORT_GROUP_FWD_MASK: core::ffi::c_uint = 31;
pub const IFLA_BRPORT_NEIGH_SUPPRESS: core::ffi::c_uint = 32;
pub const IFLA_BRPORT_ISOLATED: core::ffi::c_uint = 33;
pub const IFLA_BRPORT_BACKUP_PORT: core::ffi::c_uint = 34;
pub const IFLA_BRPORT_MRP_RING_OPEN: core::ffi::c_uint = 35;
pub const IFLA_BRPORT_MRP_IN_OPEN: core::ffi::c_uint = 36;
pub const IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT: core::ffi::c_uint = 37;
pub const IFLA_BRPORT_MCAST_EHT_HOSTS_CNT: core::ffi::c_uint = 38;
pub const IFLA_BRPORT_LOCKED: core::ffi::c_uint = 39;
pub const __IFLA_BRPORT_MAX: core::ffi::c_uint = 40;
pub type _bindgen_ty_152 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_cacheinfo {
    pub max_reasm_len: __u32,
    pub tstamp: __u32,
    pub reachable_time: __u32,
    pub retrans_time: __u32,
}
pub const IFLA_INFO_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_INFO_KIND: core::ffi::c_uint = 1;
pub const IFLA_INFO_DATA: core::ffi::c_uint = 2;
pub const IFLA_INFO_XSTATS: core::ffi::c_uint = 3;
pub const IFLA_INFO_SLAVE_KIND: core::ffi::c_uint = 4;
pub const IFLA_INFO_SLAVE_DATA: core::ffi::c_uint = 5;
pub const __IFLA_INFO_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_153 = core::ffi::c_uint;
pub const IFLA_VLAN_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_VLAN_ID: core::ffi::c_uint = 1;
pub const IFLA_VLAN_FLAGS: core::ffi::c_uint = 2;
pub const IFLA_VLAN_EGRESS_QOS: core::ffi::c_uint = 3;
pub const IFLA_VLAN_INGRESS_QOS: core::ffi::c_uint = 4;
pub const IFLA_VLAN_PROTOCOL: core::ffi::c_uint = 5;
pub const __IFLA_VLAN_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_154 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vlan_flags {
    pub flags: __u32,
    pub mask: __u32,
}
pub const IFLA_VLAN_QOS_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_VLAN_QOS_MAPPING: core::ffi::c_uint = 1;
pub const __IFLA_VLAN_QOS_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_155 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vlan_qos_mapping {
    pub from: __u32,
    pub to: __u32,
}
pub const IFLA_MACVLAN_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_MACVLAN_MODE: core::ffi::c_uint = 1;
pub const IFLA_MACVLAN_FLAGS: core::ffi::c_uint = 2;
pub const IFLA_MACVLAN_MACADDR_MODE: core::ffi::c_uint = 3;
pub const IFLA_MACVLAN_MACADDR: core::ffi::c_uint = 4;
pub const IFLA_MACVLAN_MACADDR_DATA: core::ffi::c_uint = 5;
pub const IFLA_MACVLAN_MACADDR_COUNT: core::ffi::c_uint = 6;
pub const IFLA_MACVLAN_BC_QUEUE_LEN: core::ffi::c_uint = 7;
pub const IFLA_MACVLAN_BC_QUEUE_LEN_USED: core::ffi::c_uint = 8;
pub const __IFLA_MACVLAN_MAX: core::ffi::c_uint = 9;
pub type _bindgen_ty_156 = core::ffi::c_uint;
pub const macvlan_mode_MACVLAN_MODE_PRIVATE: macvlan_mode = 1;
pub const macvlan_mode_MACVLAN_MODE_VEPA: macvlan_mode = 2;
pub const macvlan_mode_MACVLAN_MODE_BRIDGE: macvlan_mode = 4;
pub const macvlan_mode_MACVLAN_MODE_PASSTHRU: macvlan_mode = 8;
pub const macvlan_mode_MACVLAN_MODE_SOURCE: macvlan_mode = 16;
pub type macvlan_mode = core::ffi::c_uint;
pub const macvlan_macaddr_mode_MACVLAN_MACADDR_ADD: macvlan_macaddr_mode = 0;
pub const macvlan_macaddr_mode_MACVLAN_MACADDR_DEL: macvlan_macaddr_mode = 1;
pub const macvlan_macaddr_mode_MACVLAN_MACADDR_FLUSH: macvlan_macaddr_mode = 2;
pub const macvlan_macaddr_mode_MACVLAN_MACADDR_SET: macvlan_macaddr_mode = 3;
pub type macvlan_macaddr_mode = core::ffi::c_uint;
pub const IFLA_VRF_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_VRF_TABLE: core::ffi::c_uint = 1;
pub const __IFLA_VRF_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_157 = core::ffi::c_uint;
pub const IFLA_VRF_PORT_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_VRF_PORT_TABLE: core::ffi::c_uint = 1;
pub const __IFLA_VRF_PORT_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_158 = core::ffi::c_uint;
pub const IFLA_MACSEC_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_MACSEC_SCI: core::ffi::c_uint = 1;
pub const IFLA_MACSEC_PORT: core::ffi::c_uint = 2;
pub const IFLA_MACSEC_ICV_LEN: core::ffi::c_uint = 3;
pub const IFLA_MACSEC_CIPHER_SUITE: core::ffi::c_uint = 4;
pub const IFLA_MACSEC_WINDOW: core::ffi::c_uint = 5;
pub const IFLA_MACSEC_ENCODING_SA: core::ffi::c_uint = 6;
pub const IFLA_MACSEC_ENCRYPT: core::ffi::c_uint = 7;
pub const IFLA_MACSEC_PROTECT: core::ffi::c_uint = 8;
pub const IFLA_MACSEC_INC_SCI: core::ffi::c_uint = 9;
pub const IFLA_MACSEC_ES: core::ffi::c_uint = 10;
pub const IFLA_MACSEC_SCB: core::ffi::c_uint = 11;
pub const IFLA_MACSEC_REPLAY_PROTECT: core::ffi::c_uint = 12;
pub const IFLA_MACSEC_VALIDATION: core::ffi::c_uint = 13;
pub const IFLA_MACSEC_PAD: core::ffi::c_uint = 14;
pub const IFLA_MACSEC_OFFLOAD: core::ffi::c_uint = 15;
pub const __IFLA_MACSEC_MAX: core::ffi::c_uint = 16;
pub type _bindgen_ty_159 = core::ffi::c_uint;
pub const IFLA_XFRM_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_XFRM_LINK: core::ffi::c_uint = 1;
pub const IFLA_XFRM_IF_ID: core::ffi::c_uint = 2;
pub const IFLA_XFRM_COLLECT_METADATA: core::ffi::c_uint = 3;
pub const __IFLA_XFRM_MAX: core::ffi::c_uint = 4;
pub type _bindgen_ty_160 = core::ffi::c_uint;
pub const macsec_validation_type_MACSEC_VALIDATE_DISABLED: macsec_validation_type = 0;
pub const macsec_validation_type_MACSEC_VALIDATE_CHECK: macsec_validation_type = 1;
pub const macsec_validation_type_MACSEC_VALIDATE_STRICT: macsec_validation_type = 2;
pub const macsec_validation_type___MACSEC_VALIDATE_END: macsec_validation_type = 3;
pub const macsec_validation_type_MACSEC_VALIDATE_MAX: macsec_validation_type = 2;
pub type macsec_validation_type = core::ffi::c_uint;
pub const macsec_offload_MACSEC_OFFLOAD_OFF: macsec_offload = 0;
pub const macsec_offload_MACSEC_OFFLOAD_PHY: macsec_offload = 1;
pub const macsec_offload_MACSEC_OFFLOAD_MAC: macsec_offload = 2;
pub const macsec_offload___MACSEC_OFFLOAD_END: macsec_offload = 3;
pub const macsec_offload_MACSEC_OFFLOAD_MAX: macsec_offload = 2;
pub type macsec_offload = core::ffi::c_uint;
pub const IFLA_IPVLAN_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_IPVLAN_MODE: core::ffi::c_uint = 1;
pub const IFLA_IPVLAN_FLAGS: core::ffi::c_uint = 2;
pub const __IFLA_IPVLAN_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_161 = core::ffi::c_uint;
pub const ipvlan_mode_IPVLAN_MODE_L2: ipvlan_mode = 0;
pub const ipvlan_mode_IPVLAN_MODE_L3: ipvlan_mode = 1;
pub const ipvlan_mode_IPVLAN_MODE_L3S: ipvlan_mode = 2;
pub const ipvlan_mode_IPVLAN_MODE_MAX: ipvlan_mode = 3;
pub type ipvlan_mode = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tunnel_msg {
    pub family: __u8,
    pub flags: __u8,
    pub reserved2: __u16,
    pub ifindex: __u32,
}
pub const VNIFILTER_ENTRY_STATS_UNSPEC: core::ffi::c_uint = 0;
pub const VNIFILTER_ENTRY_STATS_RX_BYTES: core::ffi::c_uint = 1;
pub const VNIFILTER_ENTRY_STATS_RX_PKTS: core::ffi::c_uint = 2;
pub const VNIFILTER_ENTRY_STATS_RX_DROPS: core::ffi::c_uint = 3;
pub const VNIFILTER_ENTRY_STATS_RX_ERRORS: core::ffi::c_uint = 4;
pub const VNIFILTER_ENTRY_STATS_TX_BYTES: core::ffi::c_uint = 5;
pub const VNIFILTER_ENTRY_STATS_TX_PKTS: core::ffi::c_uint = 6;
pub const VNIFILTER_ENTRY_STATS_TX_DROPS: core::ffi::c_uint = 7;
pub const VNIFILTER_ENTRY_STATS_TX_ERRORS: core::ffi::c_uint = 8;
pub const VNIFILTER_ENTRY_STATS_PAD: core::ffi::c_uint = 9;
pub const __VNIFILTER_ENTRY_STATS_MAX: core::ffi::c_uint = 10;
pub type _bindgen_ty_162 = core::ffi::c_uint;
pub const VXLAN_VNIFILTER_ENTRY_UNSPEC: core::ffi::c_uint = 0;
pub const VXLAN_VNIFILTER_ENTRY_START: core::ffi::c_uint = 1;
pub const VXLAN_VNIFILTER_ENTRY_END: core::ffi::c_uint = 2;
pub const VXLAN_VNIFILTER_ENTRY_GROUP: core::ffi::c_uint = 3;
pub const VXLAN_VNIFILTER_ENTRY_GROUP6: core::ffi::c_uint = 4;
pub const VXLAN_VNIFILTER_ENTRY_STATS: core::ffi::c_uint = 5;
pub const __VXLAN_VNIFILTER_ENTRY_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_163 = core::ffi::c_uint;
pub const VXLAN_VNIFILTER_UNSPEC: core::ffi::c_uint = 0;
pub const VXLAN_VNIFILTER_ENTRY: core::ffi::c_uint = 1;
pub const __VXLAN_VNIFILTER_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_164 = core::ffi::c_uint;
pub const IFLA_VXLAN_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_VXLAN_ID: core::ffi::c_uint = 1;
pub const IFLA_VXLAN_GROUP: core::ffi::c_uint = 2;
pub const IFLA_VXLAN_LINK: core::ffi::c_uint = 3;
pub const IFLA_VXLAN_LOCAL: core::ffi::c_uint = 4;
pub const IFLA_VXLAN_TTL: core::ffi::c_uint = 5;
pub const IFLA_VXLAN_TOS: core::ffi::c_uint = 6;
pub const IFLA_VXLAN_LEARNING: core::ffi::c_uint = 7;
pub const IFLA_VXLAN_AGEING: core::ffi::c_uint = 8;
pub const IFLA_VXLAN_LIMIT: core::ffi::c_uint = 9;
pub const IFLA_VXLAN_PORT_RANGE: core::ffi::c_uint = 10;
pub const IFLA_VXLAN_PROXY: core::ffi::c_uint = 11;
pub const IFLA_VXLAN_RSC: core::ffi::c_uint = 12;
pub const IFLA_VXLAN_L2MISS: core::ffi::c_uint = 13;
pub const IFLA_VXLAN_L3MISS: core::ffi::c_uint = 14;
pub const IFLA_VXLAN_PORT: core::ffi::c_uint = 15;
pub const IFLA_VXLAN_GROUP6: core::ffi::c_uint = 16;
pub const IFLA_VXLAN_LOCAL6: core::ffi::c_uint = 17;
pub const IFLA_VXLAN_UDP_CSUM: core::ffi::c_uint = 18;
pub const IFLA_VXLAN_UDP_ZERO_CSUM6_TX: core::ffi::c_uint = 19;
pub const IFLA_VXLAN_UDP_ZERO_CSUM6_RX: core::ffi::c_uint = 20;
pub const IFLA_VXLAN_REMCSUM_TX: core::ffi::c_uint = 21;
pub const IFLA_VXLAN_REMCSUM_RX: core::ffi::c_uint = 22;
pub const IFLA_VXLAN_GBP: core::ffi::c_uint = 23;
pub const IFLA_VXLAN_REMCSUM_NOPARTIAL: core::ffi::c_uint = 24;
pub const IFLA_VXLAN_COLLECT_METADATA: core::ffi::c_uint = 25;
pub const IFLA_VXLAN_LABEL: core::ffi::c_uint = 26;
pub const IFLA_VXLAN_GPE: core::ffi::c_uint = 27;
pub const IFLA_VXLAN_TTL_INHERIT: core::ffi::c_uint = 28;
pub const IFLA_VXLAN_DF: core::ffi::c_uint = 29;
pub const IFLA_VXLAN_VNIFILTER: core::ffi::c_uint = 30;
pub const __IFLA_VXLAN_MAX: core::ffi::c_uint = 31;
pub type _bindgen_ty_165 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vxlan_port_range {
    pub low: __be16,
    pub high: __be16,
}
pub const ifla_vxlan_df_VXLAN_DF_UNSET: ifla_vxlan_df = 0;
pub const ifla_vxlan_df_VXLAN_DF_SET: ifla_vxlan_df = 1;
pub const ifla_vxlan_df_VXLAN_DF_INHERIT: ifla_vxlan_df = 2;
pub const ifla_vxlan_df___VXLAN_DF_END: ifla_vxlan_df = 3;
pub const ifla_vxlan_df_VXLAN_DF_MAX: ifla_vxlan_df = 2;
pub type ifla_vxlan_df = core::ffi::c_uint;
pub const IFLA_GENEVE_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_GENEVE_ID: core::ffi::c_uint = 1;
pub const IFLA_GENEVE_REMOTE: core::ffi::c_uint = 2;
pub const IFLA_GENEVE_TTL: core::ffi::c_uint = 3;
pub const IFLA_GENEVE_TOS: core::ffi::c_uint = 4;
pub const IFLA_GENEVE_PORT: core::ffi::c_uint = 5;
pub const IFLA_GENEVE_COLLECT_METADATA: core::ffi::c_uint = 6;
pub const IFLA_GENEVE_REMOTE6: core::ffi::c_uint = 7;
pub const IFLA_GENEVE_UDP_CSUM: core::ffi::c_uint = 8;
pub const IFLA_GENEVE_UDP_ZERO_CSUM6_TX: core::ffi::c_uint = 9;
pub const IFLA_GENEVE_UDP_ZERO_CSUM6_RX: core::ffi::c_uint = 10;
pub const IFLA_GENEVE_LABEL: core::ffi::c_uint = 11;
pub const IFLA_GENEVE_TTL_INHERIT: core::ffi::c_uint = 12;
pub const IFLA_GENEVE_DF: core::ffi::c_uint = 13;
pub const IFLA_GENEVE_INNER_PROTO_INHERIT: core::ffi::c_uint = 14;
pub const __IFLA_GENEVE_MAX: core::ffi::c_uint = 15;
pub type _bindgen_ty_166 = core::ffi::c_uint;
pub const ifla_geneve_df_GENEVE_DF_UNSET: ifla_geneve_df = 0;
pub const ifla_geneve_df_GENEVE_DF_SET: ifla_geneve_df = 1;
pub const ifla_geneve_df_GENEVE_DF_INHERIT: ifla_geneve_df = 2;
pub const ifla_geneve_df___GENEVE_DF_END: ifla_geneve_df = 3;
pub const ifla_geneve_df_GENEVE_DF_MAX: ifla_geneve_df = 2;
pub type ifla_geneve_df = core::ffi::c_uint;
pub const IFLA_BAREUDP_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_BAREUDP_PORT: core::ffi::c_uint = 1;
pub const IFLA_BAREUDP_ETHERTYPE: core::ffi::c_uint = 2;
pub const IFLA_BAREUDP_SRCPORT_MIN: core::ffi::c_uint = 3;
pub const IFLA_BAREUDP_MULTIPROTO_MODE: core::ffi::c_uint = 4;
pub const __IFLA_BAREUDP_MAX: core::ffi::c_uint = 5;
pub type _bindgen_ty_167 = core::ffi::c_uint;
pub const IFLA_PPP_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_PPP_DEV_FD: core::ffi::c_uint = 1;
pub const __IFLA_PPP_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_168 = core::ffi::c_uint;
pub const ifla_gtp_role_GTP_ROLE_GGSN: ifla_gtp_role = 0;
pub const ifla_gtp_role_GTP_ROLE_SGSN: ifla_gtp_role = 1;
pub type ifla_gtp_role = core::ffi::c_uint;
pub const IFLA_GTP_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_GTP_FD0: core::ffi::c_uint = 1;
pub const IFLA_GTP_FD1: core::ffi::c_uint = 2;
pub const IFLA_GTP_PDP_HASHSIZE: core::ffi::c_uint = 3;
pub const IFLA_GTP_ROLE: core::ffi::c_uint = 4;
pub const IFLA_GTP_CREATE_SOCKETS: core::ffi::c_uint = 5;
pub const IFLA_GTP_RESTART_COUNT: core::ffi::c_uint = 6;
pub const __IFLA_GTP_MAX: core::ffi::c_uint = 7;
pub type _bindgen_ty_169 = core::ffi::c_uint;
pub const IFLA_BOND_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_BOND_MODE: core::ffi::c_uint = 1;
pub const IFLA_BOND_ACTIVE_SLAVE: core::ffi::c_uint = 2;
pub const IFLA_BOND_MIIMON: core::ffi::c_uint = 3;
pub const IFLA_BOND_UPDELAY: core::ffi::c_uint = 4;
pub const IFLA_BOND_DOWNDELAY: core::ffi::c_uint = 5;
pub const IFLA_BOND_USE_CARRIER: core::ffi::c_uint = 6;
pub const IFLA_BOND_ARP_INTERVAL: core::ffi::c_uint = 7;
pub const IFLA_BOND_ARP_IP_TARGET: core::ffi::c_uint = 8;
pub const IFLA_BOND_ARP_VALIDATE: core::ffi::c_uint = 9;
pub const IFLA_BOND_ARP_ALL_TARGETS: core::ffi::c_uint = 10;
pub const IFLA_BOND_PRIMARY: core::ffi::c_uint = 11;
pub const IFLA_BOND_PRIMARY_RESELECT: core::ffi::c_uint = 12;
pub const IFLA_BOND_FAIL_OVER_MAC: core::ffi::c_uint = 13;
pub const IFLA_BOND_XMIT_HASH_POLICY: core::ffi::c_uint = 14;
pub const IFLA_BOND_RESEND_IGMP: core::ffi::c_uint = 15;
pub const IFLA_BOND_NUM_PEER_NOTIF: core::ffi::c_uint = 16;
pub const IFLA_BOND_ALL_SLAVES_ACTIVE: core::ffi::c_uint = 17;
pub const IFLA_BOND_MIN_LINKS: core::ffi::c_uint = 18;
pub const IFLA_BOND_LP_INTERVAL: core::ffi::c_uint = 19;
pub const IFLA_BOND_PACKETS_PER_SLAVE: core::ffi::c_uint = 20;
pub const IFLA_BOND_AD_LACP_RATE: core::ffi::c_uint = 21;
pub const IFLA_BOND_AD_SELECT: core::ffi::c_uint = 22;
pub const IFLA_BOND_AD_INFO: core::ffi::c_uint = 23;
pub const IFLA_BOND_AD_ACTOR_SYS_PRIO: core::ffi::c_uint = 24;
pub const IFLA_BOND_AD_USER_PORT_KEY: core::ffi::c_uint = 25;
pub const IFLA_BOND_AD_ACTOR_SYSTEM: core::ffi::c_uint = 26;
pub const IFLA_BOND_TLB_DYNAMIC_LB: core::ffi::c_uint = 27;
pub const IFLA_BOND_PEER_NOTIF_DELAY: core::ffi::c_uint = 28;
pub const IFLA_BOND_AD_LACP_ACTIVE: core::ffi::c_uint = 29;
pub const IFLA_BOND_MISSED_MAX: core::ffi::c_uint = 30;
pub const IFLA_BOND_NS_IP6_TARGET: core::ffi::c_uint = 31;
pub const __IFLA_BOND_MAX: core::ffi::c_uint = 32;
pub type _bindgen_ty_170 = core::ffi::c_uint;
pub const IFLA_BOND_AD_INFO_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_BOND_AD_INFO_AGGREGATOR: core::ffi::c_uint = 1;
pub const IFLA_BOND_AD_INFO_NUM_PORTS: core::ffi::c_uint = 2;
pub const IFLA_BOND_AD_INFO_ACTOR_KEY: core::ffi::c_uint = 3;
pub const IFLA_BOND_AD_INFO_PARTNER_KEY: core::ffi::c_uint = 4;
pub const IFLA_BOND_AD_INFO_PARTNER_MAC: core::ffi::c_uint = 5;
pub const __IFLA_BOND_AD_INFO_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_171 = core::ffi::c_uint;
pub const IFLA_BOND_SLAVE_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_BOND_SLAVE_STATE: core::ffi::c_uint = 1;
pub const IFLA_BOND_SLAVE_MII_STATUS: core::ffi::c_uint = 2;
pub const IFLA_BOND_SLAVE_LINK_FAILURE_COUNT: core::ffi::c_uint = 3;
pub const IFLA_BOND_SLAVE_PERM_HWADDR: core::ffi::c_uint = 4;
pub const IFLA_BOND_SLAVE_QUEUE_ID: core::ffi::c_uint = 5;
pub const IFLA_BOND_SLAVE_AD_AGGREGATOR_ID: core::ffi::c_uint = 6;
pub const IFLA_BOND_SLAVE_AD_ACTOR_OPER_PORT_STATE: core::ffi::c_uint = 7;
pub const IFLA_BOND_SLAVE_AD_PARTNER_OPER_PORT_STATE: core::ffi::c_uint = 8;
pub const IFLA_BOND_SLAVE_PRIO: core::ffi::c_uint = 9;
pub const __IFLA_BOND_SLAVE_MAX: core::ffi::c_uint = 10;
pub type _bindgen_ty_172 = core::ffi::c_uint;
pub const IFLA_VF_INFO_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_VF_INFO: core::ffi::c_uint = 1;
pub const __IFLA_VF_INFO_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_173 = core::ffi::c_uint;
pub const IFLA_VF_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_VF_MAC: core::ffi::c_uint = 1;
pub const IFLA_VF_VLAN: core::ffi::c_uint = 2;
pub const IFLA_VF_TX_RATE: core::ffi::c_uint = 3;
pub const IFLA_VF_SPOOFCHK: core::ffi::c_uint = 4;
pub const IFLA_VF_LINK_STATE: core::ffi::c_uint = 5;
pub const IFLA_VF_RATE: core::ffi::c_uint = 6;
pub const IFLA_VF_RSS_QUERY_EN: core::ffi::c_uint = 7;
pub const IFLA_VF_STATS: core::ffi::c_uint = 8;
pub const IFLA_VF_TRUST: core::ffi::c_uint = 9;
pub const IFLA_VF_IB_NODE_GUID: core::ffi::c_uint = 10;
pub const IFLA_VF_IB_PORT_GUID: core::ffi::c_uint = 11;
pub const IFLA_VF_VLAN_LIST: core::ffi::c_uint = 12;
pub const IFLA_VF_BROADCAST: core::ffi::c_uint = 13;
pub const __IFLA_VF_MAX: core::ffi::c_uint = 14;
pub type _bindgen_ty_174 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_mac {
    pub vf: __u32,
    pub mac: [__u8; 32usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_broadcast {
    pub broadcast: [__u8; 32usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_vlan {
    pub vf: __u32,
    pub vlan: __u32,
    pub qos: __u32,
}
pub const IFLA_VF_VLAN_INFO_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_VF_VLAN_INFO: core::ffi::c_uint = 1;
pub const __IFLA_VF_VLAN_INFO_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_175 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_vlan_info {
    pub vf: __u32,
    pub vlan: __u32,
    pub qos: __u32,
    pub vlan_proto: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_tx_rate {
    pub vf: __u32,
    pub rate: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_rate {
    pub vf: __u32,
    pub min_tx_rate: __u32,
    pub max_tx_rate: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_spoofchk {
    pub vf: __u32,
    pub setting: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_guid {
    pub vf: __u32,
    pub guid: __u64,
}
pub const IFLA_VF_LINK_STATE_AUTO: core::ffi::c_uint = 0;
pub const IFLA_VF_LINK_STATE_ENABLE: core::ffi::c_uint = 1;
pub const IFLA_VF_LINK_STATE_DISABLE: core::ffi::c_uint = 2;
pub const __IFLA_VF_LINK_STATE_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_176 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_link_state {
    pub vf: __u32,
    pub link_state: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_rss_query_en {
    pub vf: __u32,
    pub setting: __u32,
}
pub const IFLA_VF_STATS_RX_PACKETS: core::ffi::c_uint = 0;
pub const IFLA_VF_STATS_TX_PACKETS: core::ffi::c_uint = 1;
pub const IFLA_VF_STATS_RX_BYTES: core::ffi::c_uint = 2;
pub const IFLA_VF_STATS_TX_BYTES: core::ffi::c_uint = 3;
pub const IFLA_VF_STATS_BROADCAST: core::ffi::c_uint = 4;
pub const IFLA_VF_STATS_MULTICAST: core::ffi::c_uint = 5;
pub const IFLA_VF_STATS_PAD: core::ffi::c_uint = 6;
pub const IFLA_VF_STATS_RX_DROPPED: core::ffi::c_uint = 7;
pub const IFLA_VF_STATS_TX_DROPPED: core::ffi::c_uint = 8;
pub const __IFLA_VF_STATS_MAX: core::ffi::c_uint = 9;
pub type _bindgen_ty_177 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_trust {
    pub vf: __u32,
    pub setting: __u32,
}
pub const IFLA_VF_PORT_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_VF_PORT: core::ffi::c_uint = 1;
pub const __IFLA_VF_PORT_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_178 = core::ffi::c_uint;
pub const IFLA_PORT_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_PORT_VF: core::ffi::c_uint = 1;
pub const IFLA_PORT_PROFILE: core::ffi::c_uint = 2;
pub const IFLA_PORT_VSI_TYPE: core::ffi::c_uint = 3;
pub const IFLA_PORT_INSTANCE_UUID: core::ffi::c_uint = 4;
pub const IFLA_PORT_HOST_UUID: core::ffi::c_uint = 5;
pub const IFLA_PORT_REQUEST: core::ffi::c_uint = 6;
pub const IFLA_PORT_RESPONSE: core::ffi::c_uint = 7;
pub const __IFLA_PORT_MAX: core::ffi::c_uint = 8;
pub type _bindgen_ty_179 = core::ffi::c_uint;
pub const PORT_REQUEST_PREASSOCIATE: core::ffi::c_uint = 0;
pub const PORT_REQUEST_PREASSOCIATE_RR: core::ffi::c_uint = 1;
pub const PORT_REQUEST_ASSOCIATE: core::ffi::c_uint = 2;
pub const PORT_REQUEST_DISASSOCIATE: core::ffi::c_uint = 3;
pub type _bindgen_ty_180 = core::ffi::c_uint;
pub const PORT_VDP_RESPONSE_SUCCESS: core::ffi::c_uint = 0;
pub const PORT_VDP_RESPONSE_INVALID_FORMAT: core::ffi::c_uint = 1;
pub const PORT_VDP_RESPONSE_INSUFFICIENT_RESOURCES: core::ffi::c_uint = 2;
pub const PORT_VDP_RESPONSE_UNUSED_VTID: core::ffi::c_uint = 3;
pub const PORT_VDP_RESPONSE_VTID_VIOLATION: core::ffi::c_uint = 4;
pub const PORT_VDP_RESPONSE_VTID_VERSION_VIOALTION: core::ffi::c_uint = 5;
pub const PORT_VDP_RESPONSE_OUT_OF_SYNC: core::ffi::c_uint = 6;
pub const PORT_PROFILE_RESPONSE_SUCCESS: core::ffi::c_uint = 256;
pub const PORT_PROFILE_RESPONSE_INPROGRESS: core::ffi::c_uint = 257;
pub const PORT_PROFILE_RESPONSE_INVALID: core::ffi::c_uint = 258;
pub const PORT_PROFILE_RESPONSE_BADSTATE: core::ffi::c_uint = 259;
pub const PORT_PROFILE_RESPONSE_INSUFFICIENT_RESOURCES: core::ffi::c_uint = 260;
pub const PORT_PROFILE_RESPONSE_ERROR: core::ffi::c_uint = 261;
pub type _bindgen_ty_181 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_port_vsi {
    pub vsi_mgr_id: __u8,
    pub vsi_type_id: [__u8; 3usize],
    pub vsi_type_version: __u8,
    pub pad: [__u8; 3usize],
}
pub const IFLA_IPOIB_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_IPOIB_PKEY: core::ffi::c_uint = 1;
pub const IFLA_IPOIB_MODE: core::ffi::c_uint = 2;
pub const IFLA_IPOIB_UMCAST: core::ffi::c_uint = 3;
pub const __IFLA_IPOIB_MAX: core::ffi::c_uint = 4;
pub type _bindgen_ty_182 = core::ffi::c_uint;
pub const IPOIB_MODE_DATAGRAM: core::ffi::c_uint = 0;
pub const IPOIB_MODE_CONNECTED: core::ffi::c_uint = 1;
pub type _bindgen_ty_183 = core::ffi::c_uint;
pub const HSR_PROTOCOL_HSR: core::ffi::c_uint = 0;
pub const HSR_PROTOCOL_PRP: core::ffi::c_uint = 1;
pub const HSR_PROTOCOL_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_184 = core::ffi::c_uint;
pub const IFLA_HSR_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_HSR_SLAVE1: core::ffi::c_uint = 1;
pub const IFLA_HSR_SLAVE2: core::ffi::c_uint = 2;
pub const IFLA_HSR_MULTICAST_SPEC: core::ffi::c_uint = 3;
pub const IFLA_HSR_SUPERVISION_ADDR: core::ffi::c_uint = 4;
pub const IFLA_HSR_SEQ_NR: core::ffi::c_uint = 5;
pub const IFLA_HSR_VERSION: core::ffi::c_uint = 6;
pub const IFLA_HSR_PROTOCOL: core::ffi::c_uint = 7;
pub const __IFLA_HSR_MAX: core::ffi::c_uint = 8;
pub type _bindgen_ty_185 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct if_stats_msg {
    pub family: __u8,
    pub pad1: __u8,
    pub pad2: __u16,
    pub ifindex: __u32,
    pub filter_mask: __u32,
}
pub const IFLA_STATS_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_STATS_LINK_64: core::ffi::c_uint = 1;
pub const IFLA_STATS_LINK_XSTATS: core::ffi::c_uint = 2;
pub const IFLA_STATS_LINK_XSTATS_SLAVE: core::ffi::c_uint = 3;
pub const IFLA_STATS_LINK_OFFLOAD_XSTATS: core::ffi::c_uint = 4;
pub const IFLA_STATS_AF_SPEC: core::ffi::c_uint = 5;
pub const __IFLA_STATS_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_186 = core::ffi::c_uint;
pub const IFLA_STATS_GETSET_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_STATS_GET_FILTERS: core::ffi::c_uint = 1;
pub const IFLA_STATS_SET_OFFLOAD_XSTATS_L3_STATS: core::ffi::c_uint = 2;
pub const __IFLA_STATS_GETSET_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_187 = core::ffi::c_uint;
pub const LINK_XSTATS_TYPE_UNSPEC: core::ffi::c_uint = 0;
pub const LINK_XSTATS_TYPE_BRIDGE: core::ffi::c_uint = 1;
pub const LINK_XSTATS_TYPE_BOND: core::ffi::c_uint = 2;
pub const __LINK_XSTATS_TYPE_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_188 = core::ffi::c_uint;
pub const IFLA_OFFLOAD_XSTATS_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_OFFLOAD_XSTATS_CPU_HIT: core::ffi::c_uint = 1;
pub const IFLA_OFFLOAD_XSTATS_HW_S_INFO: core::ffi::c_uint = 2;
pub const IFLA_OFFLOAD_XSTATS_L3_STATS: core::ffi::c_uint = 3;
pub const __IFLA_OFFLOAD_XSTATS_MAX: core::ffi::c_uint = 4;
pub type _bindgen_ty_189 = core::ffi::c_uint;
pub const IFLA_OFFLOAD_XSTATS_HW_S_INFO_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_OFFLOAD_XSTATS_HW_S_INFO_REQUEST: core::ffi::c_uint = 1;
pub const IFLA_OFFLOAD_XSTATS_HW_S_INFO_USED: core::ffi::c_uint = 2;
pub const __IFLA_OFFLOAD_XSTATS_HW_S_INFO_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_190 = core::ffi::c_uint;
pub const XDP_ATTACHED_NONE: core::ffi::c_uint = 0;
pub const XDP_ATTACHED_DRV: core::ffi::c_uint = 1;
pub const XDP_ATTACHED_SKB: core::ffi::c_uint = 2;
pub const XDP_ATTACHED_HW: core::ffi::c_uint = 3;
pub const XDP_ATTACHED_MULTI: core::ffi::c_uint = 4;
pub type _bindgen_ty_191 = core::ffi::c_uint;
pub const IFLA_XDP_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_XDP_FD: core::ffi::c_uint = 1;
pub const IFLA_XDP_ATTACHED: core::ffi::c_uint = 2;
pub const IFLA_XDP_FLAGS: core::ffi::c_uint = 3;
pub const IFLA_XDP_PROG_ID: core::ffi::c_uint = 4;
pub const IFLA_XDP_DRV_PROG_ID: core::ffi::c_uint = 5;
pub const IFLA_XDP_SKB_PROG_ID: core::ffi::c_uint = 6;
pub const IFLA_XDP_HW_PROG_ID: core::ffi::c_uint = 7;
pub const IFLA_XDP_EXPECTED_FD: core::ffi::c_uint = 8;
pub const __IFLA_XDP_MAX: core::ffi::c_uint = 9;
pub type _bindgen_ty_192 = core::ffi::c_uint;
pub const IFLA_EVENT_NONE: core::ffi::c_uint = 0;
pub const IFLA_EVENT_REBOOT: core::ffi::c_uint = 1;
pub const IFLA_EVENT_FEATURES: core::ffi::c_uint = 2;
pub const IFLA_EVENT_BONDING_FAILOVER: core::ffi::c_uint = 3;
pub const IFLA_EVENT_NOTIFY_PEERS: core::ffi::c_uint = 4;
pub const IFLA_EVENT_IGMP_RESEND: core::ffi::c_uint = 5;
pub const IFLA_EVENT_BONDING_OPTIONS: core::ffi::c_uint = 6;
pub type _bindgen_ty_193 = core::ffi::c_uint;
pub const IFLA_TUN_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_TUN_OWNER: core::ffi::c_uint = 1;
pub const IFLA_TUN_GROUP: core::ffi::c_uint = 2;
pub const IFLA_TUN_TYPE: core::ffi::c_uint = 3;
pub const IFLA_TUN_PI: core::ffi::c_uint = 4;
pub const IFLA_TUN_VNET_HDR: core::ffi::c_uint = 5;
pub const IFLA_TUN_PERSIST: core::ffi::c_uint = 6;
pub const IFLA_TUN_MULTI_QUEUE: core::ffi::c_uint = 7;
pub const IFLA_TUN_NUM_QUEUES: core::ffi::c_uint = 8;
pub const IFLA_TUN_NUM_DISABLED_QUEUES: core::ffi::c_uint = 9;
pub const __IFLA_TUN_MAX: core::ffi::c_uint = 10;
pub type _bindgen_ty_194 = core::ffi::c_uint;
pub const IFLA_RMNET_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_RMNET_MUX_ID: core::ffi::c_uint = 1;
pub const IFLA_RMNET_FLAGS: core::ffi::c_uint = 2;
pub const __IFLA_RMNET_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_195 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_rmnet_flags {
    pub flags: __u32,
    pub mask: __u32,
}
pub const IFLA_MCTP_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_MCTP_NET: core::ffi::c_uint = 1;
pub const __IFLA_MCTP_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_196 = core::ffi::c_uint;
pub const IFLA_DSA_UNSPEC: core::ffi::c_uint = 0;
pub const IFLA_DSA_MASTER: core::ffi::c_uint = 1;
pub const __IFLA_DSA_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_197 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_stats {
    pub rx_packets: __u64,
    pub tx_packets: __u64,
    pub rx_bytes: __u64,
    pub tx_bytes: __u64,
    pub broadcast: __u64,
    pub multicast: __u64,
    pub rx_dropped: __u64,
    pub tx_dropped: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifla_vf_info {
    pub vf: __u32,
    pub mac: [__u8; 32usize],
    pub vlan: __u32,
    pub qos: __u32,
    pub spoofchk: __u32,
    pub linkstate: __u32,
    pub min_tx_rate: __u32,
    pub max_tx_rate: __u32,
    pub rss_query_en: __u32,
    pub trusted: __u32,
    pub vlan_proto: __be16,
}
pub const IF_PORT_UNKNOWN: core::ffi::c_uint = 0;
pub const IF_PORT_10BASE2: core::ffi::c_uint = 1;
pub const IF_PORT_10BASET: core::ffi::c_uint = 2;
pub const IF_PORT_AUI: core::ffi::c_uint = 3;
pub const IF_PORT_100BASET: core::ffi::c_uint = 4;
pub const IF_PORT_100BASETX: core::ffi::c_uint = 5;
pub const IF_PORT_100BASEFX: core::ffi::c_uint = 6;
pub type _bindgen_ty_198 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifbond {
    pub bond_mode: __s32,
    pub num_slaves: __s32,
    pub miimon: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifslave {
    pub slave_id: __s32,
    pub slave_name: [core::ffi::c_char; 16usize],
    pub link: __s8,
    pub state: __s8,
    pub link_failure_count: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ad_info {
    pub aggregator_id: __u16,
    pub ports: __u16,
    pub actor_key: __u16,
    pub partner_key: __u16,
    pub partner_system: [__u8; 6usize],
}
pub const BOND_XSTATS_UNSPEC: core::ffi::c_uint = 0;
pub const BOND_XSTATS_3AD: core::ffi::c_uint = 1;
pub const __BOND_XSTATS_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_199 = core::ffi::c_uint;
pub const BOND_3AD_STAT_LACPDU_RX: core::ffi::c_uint = 0;
pub const BOND_3AD_STAT_LACPDU_TX: core::ffi::c_uint = 1;
pub const BOND_3AD_STAT_LACPDU_UNKNOWN_RX: core::ffi::c_uint = 2;
pub const BOND_3AD_STAT_LACPDU_ILLEGAL_RX: core::ffi::c_uint = 3;
pub const BOND_3AD_STAT_MARKER_RX: core::ffi::c_uint = 4;
pub const BOND_3AD_STAT_MARKER_TX: core::ffi::c_uint = 5;
pub const BOND_3AD_STAT_MARKER_RESP_RX: core::ffi::c_uint = 6;
pub const BOND_3AD_STAT_MARKER_RESP_TX: core::ffi::c_uint = 7;
pub const BOND_3AD_STAT_MARKER_UNKNOWN_RX: core::ffi::c_uint = 8;
pub const BOND_3AD_STAT_PAD: core::ffi::c_uint = 9;
pub const __BOND_3AD_STAT_MAX: core::ffi::c_uint = 10;
pub type _bindgen_ty_200 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_stats {
    pub bytes: __u64,
    pub packets: __u32,
    pub drops: __u32,
    pub overlimits: __u32,
    pub bps: __u32,
    pub pps: __u32,
    pub qlen: __u32,
    pub backlog: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_estimator {
    pub interval: core::ffi::c_schar,
    pub ewma_log: core::ffi::c_uchar,
}
pub const tc_link_layer_TC_LINKLAYER_UNAWARE: tc_link_layer = 0;
pub const tc_link_layer_TC_LINKLAYER_ETHERNET: tc_link_layer = 1;
pub const tc_link_layer_TC_LINKLAYER_ATM: tc_link_layer = 2;
pub type tc_link_layer = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_ratespec {
    pub cell_log: core::ffi::c_uchar,
    pub linklayer: __u8,
    pub overhead: core::ffi::c_ushort,
    pub cell_align: core::ffi::c_short,
    pub mpu: core::ffi::c_ushort,
    pub rate: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sizespec {
    pub cell_log: core::ffi::c_uchar,
    pub size_log: core::ffi::c_uchar,
    pub cell_align: core::ffi::c_short,
    pub overhead: core::ffi::c_int,
    pub linklayer: core::ffi::c_uint,
    pub mpu: core::ffi::c_uint,
    pub mtu: core::ffi::c_uint,
    pub tsize: core::ffi::c_uint,
}
pub const TCA_STAB_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_STAB_BASE: core::ffi::c_uint = 1;
pub const TCA_STAB_DATA: core::ffi::c_uint = 2;
pub const __TCA_STAB_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_201 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_fifo_qopt {
    pub limit: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_skbprio_qopt {
    pub limit: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_prio_qopt {
    pub bands: core::ffi::c_int,
    pub priomap: [__u8; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_multiq_qopt {
    pub bands: __u16,
    pub max_bands: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_plug_qopt {
    pub action: core::ffi::c_int,
    pub limit: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_tbf_qopt {
    pub rate: tc_ratespec,
    pub peakrate: tc_ratespec,
    pub limit: __u32,
    pub buffer: __u32,
    pub mtu: __u32,
}
pub const TCA_TBF_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_TBF_PARMS: core::ffi::c_uint = 1;
pub const TCA_TBF_RTAB: core::ffi::c_uint = 2;
pub const TCA_TBF_PTAB: core::ffi::c_uint = 3;
pub const TCA_TBF_RATE64: core::ffi::c_uint = 4;
pub const TCA_TBF_PRATE64: core::ffi::c_uint = 5;
pub const TCA_TBF_BURST: core::ffi::c_uint = 6;
pub const TCA_TBF_PBURST: core::ffi::c_uint = 7;
pub const TCA_TBF_PAD: core::ffi::c_uint = 8;
pub const __TCA_TBF_MAX: core::ffi::c_uint = 9;
pub type _bindgen_ty_202 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfq_qopt {
    pub quantum: core::ffi::c_uint,
    pub perturb_period: core::ffi::c_int,
    pub limit: __u32,
    pub divisor: core::ffi::c_uint,
    pub flows: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfqred_stats {
    pub prob_drop: __u32,
    pub forced_drop: __u32,
    pub prob_mark: __u32,
    pub forced_mark: __u32,
    pub prob_mark_head: __u32,
    pub forced_mark_head: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfq_qopt_v1 {
    pub v0: tc_sfq_qopt,
    pub depth: core::ffi::c_uint,
    pub headdrop: core::ffi::c_uint,
    pub limit: __u32,
    pub qth_min: __u32,
    pub qth_max: __u32,
    pub Wlog: core::ffi::c_uchar,
    pub Plog: core::ffi::c_uchar,
    pub Scell_log: core::ffi::c_uchar,
    pub flags: core::ffi::c_uchar,
    pub max_P: __u32,
    pub stats: tc_sfqred_stats,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfq_xstats {
    pub allot: __s32,
}
pub const TCA_RED_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_RED_PARMS: core::ffi::c_uint = 1;
pub const TCA_RED_STAB: core::ffi::c_uint = 2;
pub const TCA_RED_MAX_P: core::ffi::c_uint = 3;
pub const TCA_RED_FLAGS: core::ffi::c_uint = 4;
pub const TCA_RED_EARLY_DROP_BLOCK: core::ffi::c_uint = 5;
pub const TCA_RED_MARK_BLOCK: core::ffi::c_uint = 6;
pub const __TCA_RED_MAX: core::ffi::c_uint = 7;
pub type _bindgen_ty_203 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_red_qopt {
    pub limit: __u32,
    pub qth_min: __u32,
    pub qth_max: __u32,
    pub Wlog: core::ffi::c_uchar,
    pub Plog: core::ffi::c_uchar,
    pub Scell_log: core::ffi::c_uchar,
    pub flags: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_red_xstats {
    pub early: __u32,
    pub pdrop: __u32,
    pub other: __u32,
    pub marked: __u32,
}
pub const TCA_GRED_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_GRED_PARMS: core::ffi::c_uint = 1;
pub const TCA_GRED_STAB: core::ffi::c_uint = 2;
pub const TCA_GRED_DPS: core::ffi::c_uint = 3;
pub const TCA_GRED_MAX_P: core::ffi::c_uint = 4;
pub const TCA_GRED_LIMIT: core::ffi::c_uint = 5;
pub const TCA_GRED_VQ_LIST: core::ffi::c_uint = 6;
pub const __TCA_GRED_MAX: core::ffi::c_uint = 7;
pub type _bindgen_ty_204 = core::ffi::c_uint;
pub const TCA_GRED_VQ_ENTRY_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_GRED_VQ_ENTRY: core::ffi::c_uint = 1;
pub const __TCA_GRED_VQ_ENTRY_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_205 = core::ffi::c_uint;
pub const TCA_GRED_VQ_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_GRED_VQ_PAD: core::ffi::c_uint = 1;
pub const TCA_GRED_VQ_DP: core::ffi::c_uint = 2;
pub const TCA_GRED_VQ_STAT_BYTES: core::ffi::c_uint = 3;
pub const TCA_GRED_VQ_STAT_PACKETS: core::ffi::c_uint = 4;
pub const TCA_GRED_VQ_STAT_BACKLOG: core::ffi::c_uint = 5;
pub const TCA_GRED_VQ_STAT_PROB_DROP: core::ffi::c_uint = 6;
pub const TCA_GRED_VQ_STAT_PROB_MARK: core::ffi::c_uint = 7;
pub const TCA_GRED_VQ_STAT_FORCED_DROP: core::ffi::c_uint = 8;
pub const TCA_GRED_VQ_STAT_FORCED_MARK: core::ffi::c_uint = 9;
pub const TCA_GRED_VQ_STAT_PDROP: core::ffi::c_uint = 10;
pub const TCA_GRED_VQ_STAT_OTHER: core::ffi::c_uint = 11;
pub const TCA_GRED_VQ_FLAGS: core::ffi::c_uint = 12;
pub const __TCA_GRED_VQ_MAX: core::ffi::c_uint = 13;
pub type _bindgen_ty_206 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_gred_qopt {
    pub limit: __u32,
    pub qth_min: __u32,
    pub qth_max: __u32,
    pub DP: __u32,
    pub backlog: __u32,
    pub qave: __u32,
    pub forced: __u32,
    pub early: __u32,
    pub other: __u32,
    pub pdrop: __u32,
    pub Wlog: __u8,
    pub Plog: __u8,
    pub Scell_log: __u8,
    pub prio: __u8,
    pub packets: __u32,
    pub bytesin: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_gred_sopt {
    pub DPs: __u32,
    pub def_DP: __u32,
    pub grio: __u8,
    pub flags: __u8,
    pub pad1: __u16,
}
pub const TCA_CHOKE_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_CHOKE_PARMS: core::ffi::c_uint = 1;
pub const TCA_CHOKE_STAB: core::ffi::c_uint = 2;
pub const TCA_CHOKE_MAX_P: core::ffi::c_uint = 3;
pub const __TCA_CHOKE_MAX: core::ffi::c_uint = 4;
pub type _bindgen_ty_207 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_choke_qopt {
    pub limit: __u32,
    pub qth_min: __u32,
    pub qth_max: __u32,
    pub Wlog: core::ffi::c_uchar,
    pub Plog: core::ffi::c_uchar,
    pub Scell_log: core::ffi::c_uchar,
    pub flags: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_choke_xstats {
    pub early: __u32,
    pub pdrop: __u32,
    pub other: __u32,
    pub marked: __u32,
    pub matched: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_htb_opt {
    pub rate: tc_ratespec,
    pub ceil: tc_ratespec,
    pub buffer: __u32,
    pub cbuffer: __u32,
    pub quantum: __u32,
    pub level: __u32,
    pub prio: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_htb_glob {
    pub version: __u32,
    pub rate2quantum: __u32,
    pub defcls: __u32,
    pub debug: __u32,
    pub direct_pkts: __u32,
}
pub const TCA_HTB_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_HTB_PARMS: core::ffi::c_uint = 1;
pub const TCA_HTB_INIT: core::ffi::c_uint = 2;
pub const TCA_HTB_CTAB: core::ffi::c_uint = 3;
pub const TCA_HTB_RTAB: core::ffi::c_uint = 4;
pub const TCA_HTB_DIRECT_QLEN: core::ffi::c_uint = 5;
pub const TCA_HTB_RATE64: core::ffi::c_uint = 6;
pub const TCA_HTB_CEIL64: core::ffi::c_uint = 7;
pub const TCA_HTB_PAD: core::ffi::c_uint = 8;
pub const TCA_HTB_OFFLOAD: core::ffi::c_uint = 9;
pub const __TCA_HTB_MAX: core::ffi::c_uint = 10;
pub type _bindgen_ty_208 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_htb_xstats {
    pub lends: __u32,
    pub borrows: __u32,
    pub giants: __u32,
    pub tokens: __s32,
    pub ctokens: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_hfsc_qopt {
    pub defcls: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_service_curve {
    pub m1: __u32,
    pub d: __u32,
    pub m2: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_hfsc_stats {
    pub work: __u64,
    pub rtwork: __u64,
    pub period: __u32,
    pub level: __u32,
}
pub const TCA_HFSC_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_HFSC_RSC: core::ffi::c_uint = 1;
pub const TCA_HFSC_FSC: core::ffi::c_uint = 2;
pub const TCA_HFSC_USC: core::ffi::c_uint = 3;
pub const __TCA_HFSC_MAX: core::ffi::c_uint = 4;
pub type _bindgen_ty_209 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_cbq_lssopt {
    pub change: core::ffi::c_uchar,
    pub flags: core::ffi::c_uchar,
    pub ewma_log: core::ffi::c_uchar,
    pub level: core::ffi::c_uchar,
    pub maxidle: __u32,
    pub minidle: __u32,
    pub offtime: __u32,
    pub avpkt: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_cbq_wrropt {
    pub flags: core::ffi::c_uchar,
    pub priority: core::ffi::c_uchar,
    pub cpriority: core::ffi::c_uchar,
    pub __reserved: core::ffi::c_uchar,
    pub allot: __u32,
    pub weight: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_cbq_ovl {
    pub strategy: core::ffi::c_uchar,
    pub priority2: core::ffi::c_uchar,
    pub pad: __u16,
    pub penalty: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_cbq_police {
    pub police: core::ffi::c_uchar,
    pub __res1: core::ffi::c_uchar,
    pub __res2: core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_cbq_fopt {
    pub split: __u32,
    pub defmap: __u32,
    pub defchange: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_cbq_xstats {
    pub borrows: __u32,
    pub overactions: __u32,
    pub avgidle: __s32,
    pub undertime: __s32,
}
pub const TCA_CBQ_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_CBQ_LSSOPT: core::ffi::c_uint = 1;
pub const TCA_CBQ_WRROPT: core::ffi::c_uint = 2;
pub const TCA_CBQ_FOPT: core::ffi::c_uint = 3;
pub const TCA_CBQ_OVL_STRATEGY: core::ffi::c_uint = 4;
pub const TCA_CBQ_RATE: core::ffi::c_uint = 5;
pub const TCA_CBQ_RTAB: core::ffi::c_uint = 6;
pub const TCA_CBQ_POLICE: core::ffi::c_uint = 7;
pub const __TCA_CBQ_MAX: core::ffi::c_uint = 8;
pub type _bindgen_ty_210 = core::ffi::c_uint;
pub const TCA_DSMARK_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_DSMARK_INDICES: core::ffi::c_uint = 1;
pub const TCA_DSMARK_DEFAULT_INDEX: core::ffi::c_uint = 2;
pub const TCA_DSMARK_SET_TC_INDEX: core::ffi::c_uint = 3;
pub const TCA_DSMARK_MASK: core::ffi::c_uint = 4;
pub const TCA_DSMARK_VALUE: core::ffi::c_uint = 5;
pub const __TCA_DSMARK_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_211 = core::ffi::c_uint;
pub const TCA_ATM_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_ATM_FD: core::ffi::c_uint = 1;
pub const TCA_ATM_PTR: core::ffi::c_uint = 2;
pub const TCA_ATM_HDR: core::ffi::c_uint = 3;
pub const TCA_ATM_EXCESS: core::ffi::c_uint = 4;
pub const TCA_ATM_ADDR: core::ffi::c_uint = 5;
pub const TCA_ATM_STATE: core::ffi::c_uint = 6;
pub const __TCA_ATM_MAX: core::ffi::c_uint = 7;
pub type _bindgen_ty_212 = core::ffi::c_uint;
pub const TCA_NETEM_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_NETEM_CORR: core::ffi::c_uint = 1;
pub const TCA_NETEM_DELAY_DIST: core::ffi::c_uint = 2;
pub const TCA_NETEM_REORDER: core::ffi::c_uint = 3;
pub const TCA_NETEM_CORRUPT: core::ffi::c_uint = 4;
pub const TCA_NETEM_LOSS: core::ffi::c_uint = 5;
pub const TCA_NETEM_RATE: core::ffi::c_uint = 6;
pub const TCA_NETEM_ECN: core::ffi::c_uint = 7;
pub const TCA_NETEM_RATE64: core::ffi::c_uint = 8;
pub const TCA_NETEM_PAD: core::ffi::c_uint = 9;
pub const TCA_NETEM_LATENCY64: core::ffi::c_uint = 10;
pub const TCA_NETEM_JITTER64: core::ffi::c_uint = 11;
pub const TCA_NETEM_SLOT: core::ffi::c_uint = 12;
pub const TCA_NETEM_SLOT_DIST: core::ffi::c_uint = 13;
pub const __TCA_NETEM_MAX: core::ffi::c_uint = 14;
pub type _bindgen_ty_213 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_qopt {
    pub latency: __u32,
    pub limit: __u32,
    pub loss: __u32,
    pub gap: __u32,
    pub duplicate: __u32,
    pub jitter: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_corr {
    pub delay_corr: __u32,
    pub loss_corr: __u32,
    pub dup_corr: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_reorder {
    pub probability: __u32,
    pub correlation: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_corrupt {
    pub probability: __u32,
    pub correlation: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_rate {
    pub rate: __u32,
    pub packet_overhead: __s32,
    pub cell_size: __u32,
    pub cell_overhead: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_slot {
    pub min_delay: __s64,
    pub max_delay: __s64,
    pub max_packets: __s32,
    pub max_bytes: __s32,
    pub dist_delay: __s64,
    pub dist_jitter: __s64,
}
pub const NETEM_LOSS_UNSPEC: core::ffi::c_uint = 0;
pub const NETEM_LOSS_GI: core::ffi::c_uint = 1;
pub const NETEM_LOSS_GE: core::ffi::c_uint = 2;
pub const __NETEM_LOSS_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_214 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_gimodel {
    pub p13: __u32,
    pub p31: __u32,
    pub p32: __u32,
    pub p14: __u32,
    pub p23: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_netem_gemodel {
    pub p: __u32,
    pub r: __u32,
    pub h: __u32,
    pub k1: __u32,
}
pub const TCA_DRR_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_DRR_QUANTUM: core::ffi::c_uint = 1;
pub const __TCA_DRR_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_215 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_drr_stats {
    pub deficit: __u32,
}
pub const TC_MQPRIO_HW_OFFLOAD_NONE: core::ffi::c_uint = 0;
pub const TC_MQPRIO_HW_OFFLOAD_TCS: core::ffi::c_uint = 1;
pub const __TC_MQPRIO_HW_OFFLOAD_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_216 = core::ffi::c_uint;
pub const TC_MQPRIO_MODE_DCB: core::ffi::c_uint = 0;
pub const TC_MQPRIO_MODE_CHANNEL: core::ffi::c_uint = 1;
pub const __TC_MQPRIO_MODE_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_217 = core::ffi::c_uint;
pub const TC_MQPRIO_SHAPER_DCB: core::ffi::c_uint = 0;
pub const TC_MQPRIO_SHAPER_BW_RATE: core::ffi::c_uint = 1;
pub const __TC_MQPRIO_SHAPER_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_218 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_mqprio_qopt {
    pub num_tc: __u8,
    pub prio_tc_map: [__u8; 16usize],
    pub hw: __u8,
    pub count: [__u16; 16usize],
    pub offset: [__u16; 16usize],
}
pub const TCA_MQPRIO_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_MQPRIO_MODE: core::ffi::c_uint = 1;
pub const TCA_MQPRIO_SHAPER: core::ffi::c_uint = 2;
pub const TCA_MQPRIO_MIN_RATE64: core::ffi::c_uint = 3;
pub const TCA_MQPRIO_MAX_RATE64: core::ffi::c_uint = 4;
pub const __TCA_MQPRIO_MAX: core::ffi::c_uint = 5;
pub type _bindgen_ty_219 = core::ffi::c_uint;
pub const TCA_SFB_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_SFB_PARMS: core::ffi::c_uint = 1;
pub const __TCA_SFB_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_220 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfb_qopt {
    pub rehash_interval: __u32,
    pub warmup_time: __u32,
    pub max: __u32,
    pub bin_size: __u32,
    pub increment: __u32,
    pub decrement: __u32,
    pub limit: __u32,
    pub penalty_rate: __u32,
    pub penalty_burst: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_sfb_xstats {
    pub earlydrop: __u32,
    pub penaltydrop: __u32,
    pub bucketdrop: __u32,
    pub queuedrop: __u32,
    pub childdrop: __u32,
    pub marked: __u32,
    pub maxqlen: __u32,
    pub maxprob: __u32,
    pub avgprob: __u32,
}
pub const TCA_QFQ_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_QFQ_WEIGHT: core::ffi::c_uint = 1;
pub const TCA_QFQ_LMAX: core::ffi::c_uint = 2;
pub const __TCA_QFQ_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_221 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_qfq_stats {
    pub weight: __u32,
    pub lmax: __u32,
}
pub const TCA_CODEL_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_CODEL_TARGET: core::ffi::c_uint = 1;
pub const TCA_CODEL_LIMIT: core::ffi::c_uint = 2;
pub const TCA_CODEL_INTERVAL: core::ffi::c_uint = 3;
pub const TCA_CODEL_ECN: core::ffi::c_uint = 4;
pub const TCA_CODEL_CE_THRESHOLD: core::ffi::c_uint = 5;
pub const __TCA_CODEL_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_222 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_codel_xstats {
    pub maxpacket: __u32,
    pub count: __u32,
    pub lastcount: __u32,
    pub ldelay: __u32,
    pub drop_next: __s32,
    pub drop_overlimit: __u32,
    pub ecn_mark: __u32,
    pub dropping: __u32,
    pub ce_mark: __u32,
}
pub const TCA_FQ_CODEL_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FQ_CODEL_TARGET: core::ffi::c_uint = 1;
pub const TCA_FQ_CODEL_LIMIT: core::ffi::c_uint = 2;
pub const TCA_FQ_CODEL_INTERVAL: core::ffi::c_uint = 3;
pub const TCA_FQ_CODEL_ECN: core::ffi::c_uint = 4;
pub const TCA_FQ_CODEL_FLOWS: core::ffi::c_uint = 5;
pub const TCA_FQ_CODEL_QUANTUM: core::ffi::c_uint = 6;
pub const TCA_FQ_CODEL_CE_THRESHOLD: core::ffi::c_uint = 7;
pub const TCA_FQ_CODEL_DROP_BATCH_SIZE: core::ffi::c_uint = 8;
pub const TCA_FQ_CODEL_MEMORY_LIMIT: core::ffi::c_uint = 9;
pub const TCA_FQ_CODEL_CE_THRESHOLD_SELECTOR: core::ffi::c_uint = 10;
pub const TCA_FQ_CODEL_CE_THRESHOLD_MASK: core::ffi::c_uint = 11;
pub const __TCA_FQ_CODEL_MAX: core::ffi::c_uint = 12;
pub type _bindgen_ty_223 = core::ffi::c_uint;
pub const TCA_FQ_CODEL_XSTATS_QDISC: core::ffi::c_uint = 0;
pub const TCA_FQ_CODEL_XSTATS_CLASS: core::ffi::c_uint = 1;
pub type _bindgen_ty_224 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_fq_codel_qd_stats {
    pub maxpacket: __u32,
    pub drop_overlimit: __u32,
    pub ecn_mark: __u32,
    pub new_flow_count: __u32,
    pub new_flows_len: __u32,
    pub old_flows_len: __u32,
    pub ce_mark: __u32,
    pub memory_usage: __u32,
    pub drop_overmemory: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_fq_codel_cl_stats {
    pub deficit: __s32,
    pub ldelay: __u32,
    pub count: __u32,
    pub lastcount: __u32,
    pub dropping: __u32,
    pub drop_next: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tc_fq_codel_xstats {
    pub type_: __u32,
    pub __bindgen_anon_1: tc_fq_codel_xstats__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tc_fq_codel_xstats__bindgen_ty_1 {
    pub qdisc_stats: tc_fq_codel_qd_stats,
    pub class_stats: tc_fq_codel_cl_stats,
    _bindgen_union_align: [u32; 9usize],
}
impl Default for tc_fq_codel_xstats__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for tc_fq_codel_xstats {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const TCA_FQ_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FQ_PLIMIT: core::ffi::c_uint = 1;
pub const TCA_FQ_FLOW_PLIMIT: core::ffi::c_uint = 2;
pub const TCA_FQ_QUANTUM: core::ffi::c_uint = 3;
pub const TCA_FQ_INITIAL_QUANTUM: core::ffi::c_uint = 4;
pub const TCA_FQ_RATE_ENABLE: core::ffi::c_uint = 5;
pub const TCA_FQ_FLOW_DEFAULT_RATE: core::ffi::c_uint = 6;
pub const TCA_FQ_FLOW_MAX_RATE: core::ffi::c_uint = 7;
pub const TCA_FQ_BUCKETS_LOG: core::ffi::c_uint = 8;
pub const TCA_FQ_FLOW_REFILL_DELAY: core::ffi::c_uint = 9;
pub const TCA_FQ_ORPHAN_MASK: core::ffi::c_uint = 10;
pub const TCA_FQ_LOW_RATE_THRESHOLD: core::ffi::c_uint = 11;
pub const TCA_FQ_CE_THRESHOLD: core::ffi::c_uint = 12;
pub const TCA_FQ_TIMER_SLACK: core::ffi::c_uint = 13;
pub const TCA_FQ_HORIZON: core::ffi::c_uint = 14;
pub const TCA_FQ_HORIZON_DROP: core::ffi::c_uint = 15;
pub const __TCA_FQ_MAX: core::ffi::c_uint = 16;
pub type _bindgen_ty_225 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_fq_qd_stats {
    pub gc_flows: __u64,
    pub highprio_packets: __u64,
    pub tcp_retrans: __u64,
    pub throttled: __u64,
    pub flows_plimit: __u64,
    pub pkts_too_long: __u64,
    pub allocation_errors: __u64,
    pub time_next_delayed_flow: __s64,
    pub flows: __u32,
    pub inactive_flows: __u32,
    pub throttled_flows: __u32,
    pub unthrottle_latency_ns: __u32,
    pub ce_mark: __u64,
    pub horizon_drops: __u64,
    pub horizon_caps: __u64,
}
pub const TCA_HHF_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_HHF_BACKLOG_LIMIT: core::ffi::c_uint = 1;
pub const TCA_HHF_QUANTUM: core::ffi::c_uint = 2;
pub const TCA_HHF_HH_FLOWS_LIMIT: core::ffi::c_uint = 3;
pub const TCA_HHF_RESET_TIMEOUT: core::ffi::c_uint = 4;
pub const TCA_HHF_ADMIT_BYTES: core::ffi::c_uint = 5;
pub const TCA_HHF_EVICT_TIMEOUT: core::ffi::c_uint = 6;
pub const TCA_HHF_NON_HH_WEIGHT: core::ffi::c_uint = 7;
pub const __TCA_HHF_MAX: core::ffi::c_uint = 8;
pub type _bindgen_ty_226 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_hhf_xstats {
    pub drop_overlimit: __u32,
    pub hh_overlimit: __u32,
    pub hh_tot_count: __u32,
    pub hh_cur_count: __u32,
}
pub const TCA_PIE_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_PIE_TARGET: core::ffi::c_uint = 1;
pub const TCA_PIE_LIMIT: core::ffi::c_uint = 2;
pub const TCA_PIE_TUPDATE: core::ffi::c_uint = 3;
pub const TCA_PIE_ALPHA: core::ffi::c_uint = 4;
pub const TCA_PIE_BETA: core::ffi::c_uint = 5;
pub const TCA_PIE_ECN: core::ffi::c_uint = 6;
pub const TCA_PIE_BYTEMODE: core::ffi::c_uint = 7;
pub const TCA_PIE_DQ_RATE_ESTIMATOR: core::ffi::c_uint = 8;
pub const __TCA_PIE_MAX: core::ffi::c_uint = 9;
pub type _bindgen_ty_227 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_pie_xstats {
    pub prob: __u64,
    pub delay: __u32,
    pub avg_dq_rate: __u32,
    pub dq_rate_estimating: __u32,
    pub packets_in: __u32,
    pub dropped: __u32,
    pub overlimit: __u32,
    pub maxq: __u32,
    pub ecn_mark: __u32,
}
pub const TCA_FQ_PIE_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FQ_PIE_LIMIT: core::ffi::c_uint = 1;
pub const TCA_FQ_PIE_FLOWS: core::ffi::c_uint = 2;
pub const TCA_FQ_PIE_TARGET: core::ffi::c_uint = 3;
pub const TCA_FQ_PIE_TUPDATE: core::ffi::c_uint = 4;
pub const TCA_FQ_PIE_ALPHA: core::ffi::c_uint = 5;
pub const TCA_FQ_PIE_BETA: core::ffi::c_uint = 6;
pub const TCA_FQ_PIE_QUANTUM: core::ffi::c_uint = 7;
pub const TCA_FQ_PIE_MEMORY_LIMIT: core::ffi::c_uint = 8;
pub const TCA_FQ_PIE_ECN_PROB: core::ffi::c_uint = 9;
pub const TCA_FQ_PIE_ECN: core::ffi::c_uint = 10;
pub const TCA_FQ_PIE_BYTEMODE: core::ffi::c_uint = 11;
pub const TCA_FQ_PIE_DQ_RATE_ESTIMATOR: core::ffi::c_uint = 12;
pub const __TCA_FQ_PIE_MAX: core::ffi::c_uint = 13;
pub type _bindgen_ty_228 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_fq_pie_xstats {
    pub packets_in: __u32,
    pub dropped: __u32,
    pub overlimit: __u32,
    pub overmemory: __u32,
    pub ecn_mark: __u32,
    pub new_flow_count: __u32,
    pub new_flows_len: __u32,
    pub old_flows_len: __u32,
    pub memory_usage: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_cbs_qopt {
    pub offload: __u8,
    pub _pad: [__u8; 3usize],
    pub hicredit: __s32,
    pub locredit: __s32,
    pub idleslope: __s32,
    pub sendslope: __s32,
}
pub const TCA_CBS_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_CBS_PARMS: core::ffi::c_uint = 1;
pub const __TCA_CBS_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_229 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_etf_qopt {
    pub delta: __s32,
    pub clockid: __s32,
    pub flags: __u32,
}
pub const TCA_ETF_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_ETF_PARMS: core::ffi::c_uint = 1;
pub const __TCA_ETF_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_230 = core::ffi::c_uint;
pub const TCA_CAKE_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_CAKE_PAD: core::ffi::c_uint = 1;
pub const TCA_CAKE_BASE_RATE64: core::ffi::c_uint = 2;
pub const TCA_CAKE_DIFFSERV_MODE: core::ffi::c_uint = 3;
pub const TCA_CAKE_ATM: core::ffi::c_uint = 4;
pub const TCA_CAKE_FLOW_MODE: core::ffi::c_uint = 5;
pub const TCA_CAKE_OVERHEAD: core::ffi::c_uint = 6;
pub const TCA_CAKE_RTT: core::ffi::c_uint = 7;
pub const TCA_CAKE_TARGET: core::ffi::c_uint = 8;
pub const TCA_CAKE_AUTORATE: core::ffi::c_uint = 9;
pub const TCA_CAKE_MEMORY: core::ffi::c_uint = 10;
pub const TCA_CAKE_NAT: core::ffi::c_uint = 11;
pub const TCA_CAKE_RAW: core::ffi::c_uint = 12;
pub const TCA_CAKE_WASH: core::ffi::c_uint = 13;
pub const TCA_CAKE_MPU: core::ffi::c_uint = 14;
pub const TCA_CAKE_INGRESS: core::ffi::c_uint = 15;
pub const TCA_CAKE_ACK_FILTER: core::ffi::c_uint = 16;
pub const TCA_CAKE_SPLIT_GSO: core::ffi::c_uint = 17;
pub const TCA_CAKE_FWMARK: core::ffi::c_uint = 18;
pub const __TCA_CAKE_MAX: core::ffi::c_uint = 19;
pub type _bindgen_ty_231 = core::ffi::c_uint;
pub const __TCA_CAKE_STATS_INVALID: core::ffi::c_uint = 0;
pub const TCA_CAKE_STATS_PAD: core::ffi::c_uint = 1;
pub const TCA_CAKE_STATS_CAPACITY_ESTIMATE64: core::ffi::c_uint = 2;
pub const TCA_CAKE_STATS_MEMORY_LIMIT: core::ffi::c_uint = 3;
pub const TCA_CAKE_STATS_MEMORY_USED: core::ffi::c_uint = 4;
pub const TCA_CAKE_STATS_AVG_NETOFF: core::ffi::c_uint = 5;
pub const TCA_CAKE_STATS_MIN_NETLEN: core::ffi::c_uint = 6;
pub const TCA_CAKE_STATS_MAX_NETLEN: core::ffi::c_uint = 7;
pub const TCA_CAKE_STATS_MIN_ADJLEN: core::ffi::c_uint = 8;
pub const TCA_CAKE_STATS_MAX_ADJLEN: core::ffi::c_uint = 9;
pub const TCA_CAKE_STATS_TIN_STATS: core::ffi::c_uint = 10;
pub const TCA_CAKE_STATS_DEFICIT: core::ffi::c_uint = 11;
pub const TCA_CAKE_STATS_COBALT_COUNT: core::ffi::c_uint = 12;
pub const TCA_CAKE_STATS_DROPPING: core::ffi::c_uint = 13;
pub const TCA_CAKE_STATS_DROP_NEXT_US: core::ffi::c_uint = 14;
pub const TCA_CAKE_STATS_P_DROP: core::ffi::c_uint = 15;
pub const TCA_CAKE_STATS_BLUE_TIMER_US: core::ffi::c_uint = 16;
pub const __TCA_CAKE_STATS_MAX: core::ffi::c_uint = 17;
pub type _bindgen_ty_232 = core::ffi::c_uint;
pub const __TCA_CAKE_TIN_STATS_INVALID: core::ffi::c_uint = 0;
pub const TCA_CAKE_TIN_STATS_PAD: core::ffi::c_uint = 1;
pub const TCA_CAKE_TIN_STATS_SENT_PACKETS: core::ffi::c_uint = 2;
pub const TCA_CAKE_TIN_STATS_SENT_BYTES64: core::ffi::c_uint = 3;
pub const TCA_CAKE_TIN_STATS_DROPPED_PACKETS: core::ffi::c_uint = 4;
pub const TCA_CAKE_TIN_STATS_DROPPED_BYTES64: core::ffi::c_uint = 5;
pub const TCA_CAKE_TIN_STATS_ACKS_DROPPED_PACKETS: core::ffi::c_uint = 6;
pub const TCA_CAKE_TIN_STATS_ACKS_DROPPED_BYTES64: core::ffi::c_uint = 7;
pub const TCA_CAKE_TIN_STATS_ECN_MARKED_PACKETS: core::ffi::c_uint = 8;
pub const TCA_CAKE_TIN_STATS_ECN_MARKED_BYTES64: core::ffi::c_uint = 9;
pub const TCA_CAKE_TIN_STATS_BACKLOG_PACKETS: core::ffi::c_uint = 10;
pub const TCA_CAKE_TIN_STATS_BACKLOG_BYTES: core::ffi::c_uint = 11;
pub const TCA_CAKE_TIN_STATS_THRESHOLD_RATE64: core::ffi::c_uint = 12;
pub const TCA_CAKE_TIN_STATS_TARGET_US: core::ffi::c_uint = 13;
pub const TCA_CAKE_TIN_STATS_INTERVAL_US: core::ffi::c_uint = 14;
pub const TCA_CAKE_TIN_STATS_WAY_INDIRECT_HITS: core::ffi::c_uint = 15;
pub const TCA_CAKE_TIN_STATS_WAY_MISSES: core::ffi::c_uint = 16;
pub const TCA_CAKE_TIN_STATS_WAY_COLLISIONS: core::ffi::c_uint = 17;
pub const TCA_CAKE_TIN_STATS_PEAK_DELAY_US: core::ffi::c_uint = 18;
pub const TCA_CAKE_TIN_STATS_AVG_DELAY_US: core::ffi::c_uint = 19;
pub const TCA_CAKE_TIN_STATS_BASE_DELAY_US: core::ffi::c_uint = 20;
pub const TCA_CAKE_TIN_STATS_SPARSE_FLOWS: core::ffi::c_uint = 21;
pub const TCA_CAKE_TIN_STATS_BULK_FLOWS: core::ffi::c_uint = 22;
pub const TCA_CAKE_TIN_STATS_UNRESPONSIVE_FLOWS: core::ffi::c_uint = 23;
pub const TCA_CAKE_TIN_STATS_MAX_SKBLEN: core::ffi::c_uint = 24;
pub const TCA_CAKE_TIN_STATS_FLOW_QUANTUM: core::ffi::c_uint = 25;
pub const __TCA_CAKE_TIN_STATS_MAX: core::ffi::c_uint = 26;
pub type _bindgen_ty_233 = core::ffi::c_uint;
pub const CAKE_FLOW_NONE: core::ffi::c_uint = 0;
pub const CAKE_FLOW_SRC_IP: core::ffi::c_uint = 1;
pub const CAKE_FLOW_DST_IP: core::ffi::c_uint = 2;
pub const CAKE_FLOW_HOSTS: core::ffi::c_uint = 3;
pub const CAKE_FLOW_FLOWS: core::ffi::c_uint = 4;
pub const CAKE_FLOW_DUAL_SRC: core::ffi::c_uint = 5;
pub const CAKE_FLOW_DUAL_DST: core::ffi::c_uint = 6;
pub const CAKE_FLOW_TRIPLE: core::ffi::c_uint = 7;
pub const CAKE_FLOW_MAX: core::ffi::c_uint = 8;
pub type _bindgen_ty_234 = core::ffi::c_uint;
pub const CAKE_DIFFSERV_DIFFSERV3: core::ffi::c_uint = 0;
pub const CAKE_DIFFSERV_DIFFSERV4: core::ffi::c_uint = 1;
pub const CAKE_DIFFSERV_DIFFSERV8: core::ffi::c_uint = 2;
pub const CAKE_DIFFSERV_BESTEFFORT: core::ffi::c_uint = 3;
pub const CAKE_DIFFSERV_PRECEDENCE: core::ffi::c_uint = 4;
pub const CAKE_DIFFSERV_MAX: core::ffi::c_uint = 5;
pub type _bindgen_ty_235 = core::ffi::c_uint;
pub const CAKE_ACK_NONE: core::ffi::c_uint = 0;
pub const CAKE_ACK_FILTER: core::ffi::c_uint = 1;
pub const CAKE_ACK_AGGRESSIVE: core::ffi::c_uint = 2;
pub const CAKE_ACK_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_236 = core::ffi::c_uint;
pub const CAKE_ATM_NONE: core::ffi::c_uint = 0;
pub const CAKE_ATM_ATM: core::ffi::c_uint = 1;
pub const CAKE_ATM_PTM: core::ffi::c_uint = 2;
pub const CAKE_ATM_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_237 = core::ffi::c_uint;
pub const TC_TAPRIO_CMD_SET_GATES: core::ffi::c_uint = 0;
pub const TC_TAPRIO_CMD_SET_AND_HOLD: core::ffi::c_uint = 1;
pub const TC_TAPRIO_CMD_SET_AND_RELEASE: core::ffi::c_uint = 2;
pub type _bindgen_ty_238 = core::ffi::c_uint;
pub const TCA_TAPRIO_SCHED_ENTRY_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_TAPRIO_SCHED_ENTRY_INDEX: core::ffi::c_uint = 1;
pub const TCA_TAPRIO_SCHED_ENTRY_CMD: core::ffi::c_uint = 2;
pub const TCA_TAPRIO_SCHED_ENTRY_GATE_MASK: core::ffi::c_uint = 3;
pub const TCA_TAPRIO_SCHED_ENTRY_INTERVAL: core::ffi::c_uint = 4;
pub const __TCA_TAPRIO_SCHED_ENTRY_MAX: core::ffi::c_uint = 5;
pub type _bindgen_ty_239 = core::ffi::c_uint;
pub const TCA_TAPRIO_SCHED_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_TAPRIO_SCHED_ENTRY: core::ffi::c_uint = 1;
pub const __TCA_TAPRIO_SCHED_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_240 = core::ffi::c_uint;
pub const TCA_TAPRIO_TC_ENTRY_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_TAPRIO_TC_ENTRY_INDEX: core::ffi::c_uint = 1;
pub const TCA_TAPRIO_TC_ENTRY_MAX_SDU: core::ffi::c_uint = 2;
pub const __TCA_TAPRIO_TC_ENTRY_CNT: core::ffi::c_uint = 3;
pub const TCA_TAPRIO_TC_ENTRY_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_241 = core::ffi::c_uint;
pub const TCA_TAPRIO_ATTR_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_TAPRIO_ATTR_PRIOMAP: core::ffi::c_uint = 1;
pub const TCA_TAPRIO_ATTR_SCHED_ENTRY_LIST: core::ffi::c_uint = 2;
pub const TCA_TAPRIO_ATTR_SCHED_BASE_TIME: core::ffi::c_uint = 3;
pub const TCA_TAPRIO_ATTR_SCHED_SINGLE_ENTRY: core::ffi::c_uint = 4;
pub const TCA_TAPRIO_ATTR_SCHED_CLOCKID: core::ffi::c_uint = 5;
pub const TCA_TAPRIO_PAD: core::ffi::c_uint = 6;
pub const TCA_TAPRIO_ATTR_ADMIN_SCHED: core::ffi::c_uint = 7;
pub const TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME: core::ffi::c_uint = 8;
pub const TCA_TAPRIO_ATTR_SCHED_CYCLE_TIME_EXTENSION: core::ffi::c_uint = 9;
pub const TCA_TAPRIO_ATTR_FLAGS: core::ffi::c_uint = 10;
pub const TCA_TAPRIO_ATTR_TXTIME_DELAY: core::ffi::c_uint = 11;
pub const TCA_TAPRIO_ATTR_TC_ENTRY: core::ffi::c_uint = 12;
pub const __TCA_TAPRIO_ATTR_MAX: core::ffi::c_uint = 13;
pub type _bindgen_ty_242 = core::ffi::c_uint;
pub const TCA_ETS_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_ETS_NBANDS: core::ffi::c_uint = 1;
pub const TCA_ETS_NSTRICT: core::ffi::c_uint = 2;
pub const TCA_ETS_QUANTA: core::ffi::c_uint = 3;
pub const TCA_ETS_QUANTA_BAND: core::ffi::c_uint = 4;
pub const TCA_ETS_PRIOMAP: core::ffi::c_uint = 5;
pub const TCA_ETS_PRIOMAP_BAND: core::ffi::c_uint = 6;
pub const __TCA_ETS_MAX: core::ffi::c_uint = 7;
pub type _bindgen_ty_243 = core::ffi::c_uint;
pub const TCA_ACT_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_ACT_KIND: core::ffi::c_uint = 1;
pub const TCA_ACT_OPTIONS: core::ffi::c_uint = 2;
pub const TCA_ACT_INDEX: core::ffi::c_uint = 3;
pub const TCA_ACT_STATS: core::ffi::c_uint = 4;
pub const TCA_ACT_PAD: core::ffi::c_uint = 5;
pub const TCA_ACT_COOKIE: core::ffi::c_uint = 6;
pub const TCA_ACT_FLAGS: core::ffi::c_uint = 7;
pub const TCA_ACT_HW_STATS: core::ffi::c_uint = 8;
pub const TCA_ACT_USED_HW_STATS: core::ffi::c_uint = 9;
pub const TCA_ACT_IN_HW_COUNT: core::ffi::c_uint = 10;
pub const __TCA_ACT_MAX: core::ffi::c_uint = 11;
pub type _bindgen_ty_244 = core::ffi::c_uint;
pub const tca_id_TCA_ID_UNSPEC: tca_id = 0;
pub const tca_id_TCA_ID_POLICE: tca_id = 1;
pub const tca_id_TCA_ID_GACT: tca_id = 5;
pub const tca_id_TCA_ID_IPT: tca_id = 6;
pub const tca_id_TCA_ID_PEDIT: tca_id = 7;
pub const tca_id_TCA_ID_MIRRED: tca_id = 8;
pub const tca_id_TCA_ID_NAT: tca_id = 9;
pub const tca_id_TCA_ID_XT: tca_id = 10;
pub const tca_id_TCA_ID_SKBEDIT: tca_id = 11;
pub const tca_id_TCA_ID_VLAN: tca_id = 12;
pub const tca_id_TCA_ID_BPF: tca_id = 13;
pub const tca_id_TCA_ID_CONNMARK: tca_id = 14;
pub const tca_id_TCA_ID_SKBMOD: tca_id = 15;
pub const tca_id_TCA_ID_CSUM: tca_id = 16;
pub const tca_id_TCA_ID_TUNNEL_KEY: tca_id = 17;
pub const tca_id_TCA_ID_SIMP: tca_id = 22;
pub const tca_id_TCA_ID_IFE: tca_id = 25;
pub const tca_id_TCA_ID_SAMPLE: tca_id = 26;
pub const tca_id_TCA_ID_CTINFO: tca_id = 27;
pub const tca_id_TCA_ID_MPLS: tca_id = 28;
pub const tca_id_TCA_ID_CT: tca_id = 29;
pub const tca_id_TCA_ID_GATE: tca_id = 30;
pub const tca_id___TCA_ID_MAX: tca_id = 255;
pub type tca_id = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_police {
    pub index: __u32,
    pub action: core::ffi::c_int,
    pub limit: __u32,
    pub burst: __u32,
    pub mtu: __u32,
    pub rate: tc_ratespec,
    pub peakrate: tc_ratespec,
    pub refcnt: core::ffi::c_int,
    pub bindcnt: core::ffi::c_int,
    pub capab: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcf_t {
    pub install: __u64,
    pub lastuse: __u64,
    pub expires: __u64,
    pub firstuse: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_cnt {
    pub refcnt: core::ffi::c_int,
    pub bindcnt: core::ffi::c_int,
}
pub const TCA_POLICE_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_POLICE_TBF: core::ffi::c_uint = 1;
pub const TCA_POLICE_RATE: core::ffi::c_uint = 2;
pub const TCA_POLICE_PEAKRATE: core::ffi::c_uint = 3;
pub const TCA_POLICE_AVRATE: core::ffi::c_uint = 4;
pub const TCA_POLICE_RESULT: core::ffi::c_uint = 5;
pub const TCA_POLICE_TM: core::ffi::c_uint = 6;
pub const TCA_POLICE_PAD: core::ffi::c_uint = 7;
pub const TCA_POLICE_RATE64: core::ffi::c_uint = 8;
pub const TCA_POLICE_PEAKRATE64: core::ffi::c_uint = 9;
pub const TCA_POLICE_PKTRATE64: core::ffi::c_uint = 10;
pub const TCA_POLICE_PKTBURST64: core::ffi::c_uint = 11;
pub const __TCA_POLICE_MAX: core::ffi::c_uint = 12;
pub type _bindgen_ty_245 = core::ffi::c_uint;
pub const TCA_U32_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_U32_CLASSID: core::ffi::c_uint = 1;
pub const TCA_U32_HASH: core::ffi::c_uint = 2;
pub const TCA_U32_LINK: core::ffi::c_uint = 3;
pub const TCA_U32_DIVISOR: core::ffi::c_uint = 4;
pub const TCA_U32_SEL: core::ffi::c_uint = 5;
pub const TCA_U32_POLICE: core::ffi::c_uint = 6;
pub const TCA_U32_ACT: core::ffi::c_uint = 7;
pub const TCA_U32_INDEV: core::ffi::c_uint = 8;
pub const TCA_U32_PCNT: core::ffi::c_uint = 9;
pub const TCA_U32_MARK: core::ffi::c_uint = 10;
pub const TCA_U32_FLAGS: core::ffi::c_uint = 11;
pub const TCA_U32_PAD: core::ffi::c_uint = 12;
pub const __TCA_U32_MAX: core::ffi::c_uint = 13;
pub type _bindgen_ty_246 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_u32_key {
    pub mask: __be32,
    pub val: __be32,
    pub off: core::ffi::c_int,
    pub offmask: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default)]
pub struct tc_u32_sel {
    pub flags: core::ffi::c_uchar,
    pub offshift: core::ffi::c_uchar,
    pub nkeys: core::ffi::c_uchar,
    pub offmask: __be16,
    pub off: __u16,
    pub offoff: core::ffi::c_short,
    pub hoff: core::ffi::c_short,
    pub hmask: __be32,
    pub keys: __IncompleteArrayField<tc_u32_key>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_u32_mark {
    pub val: __u32,
    pub mask: __u32,
    pub success: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct tc_u32_pcnt {
    pub rcnt: __u64,
    pub rhit: __u64,
    pub kcnts: __IncompleteArrayField<__u64>,
}
pub const TCA_RSVP_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_RSVP_CLASSID: core::ffi::c_uint = 1;
pub const TCA_RSVP_DST: core::ffi::c_uint = 2;
pub const TCA_RSVP_SRC: core::ffi::c_uint = 3;
pub const TCA_RSVP_PINFO: core::ffi::c_uint = 4;
pub const TCA_RSVP_POLICE: core::ffi::c_uint = 5;
pub const TCA_RSVP_ACT: core::ffi::c_uint = 6;
pub const __TCA_RSVP_MAX: core::ffi::c_uint = 7;
pub type _bindgen_ty_247 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_rsvp_gpi {
    pub key: __u32,
    pub mask: __u32,
    pub offset: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_rsvp_pinfo {
    pub dpi: tc_rsvp_gpi,
    pub spi: tc_rsvp_gpi,
    pub protocol: __u8,
    pub tunnelid: __u8,
    pub tunnelhdr: __u8,
    pub pad: __u8,
}
pub const TCA_ROUTE4_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_ROUTE4_CLASSID: core::ffi::c_uint = 1;
pub const TCA_ROUTE4_TO: core::ffi::c_uint = 2;
pub const TCA_ROUTE4_FROM: core::ffi::c_uint = 3;
pub const TCA_ROUTE4_IIF: core::ffi::c_uint = 4;
pub const TCA_ROUTE4_POLICE: core::ffi::c_uint = 5;
pub const TCA_ROUTE4_ACT: core::ffi::c_uint = 6;
pub const __TCA_ROUTE4_MAX: core::ffi::c_uint = 7;
pub type _bindgen_ty_248 = core::ffi::c_uint;
pub const TCA_FW_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FW_CLASSID: core::ffi::c_uint = 1;
pub const TCA_FW_POLICE: core::ffi::c_uint = 2;
pub const TCA_FW_INDEV: core::ffi::c_uint = 3;
pub const TCA_FW_ACT: core::ffi::c_uint = 4;
pub const TCA_FW_MASK: core::ffi::c_uint = 5;
pub const __TCA_FW_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_249 = core::ffi::c_uint;
pub const TCA_TCINDEX_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_TCINDEX_HASH: core::ffi::c_uint = 1;
pub const TCA_TCINDEX_MASK: core::ffi::c_uint = 2;
pub const TCA_TCINDEX_SHIFT: core::ffi::c_uint = 3;
pub const TCA_TCINDEX_FALL_THROUGH: core::ffi::c_uint = 4;
pub const TCA_TCINDEX_CLASSID: core::ffi::c_uint = 5;
pub const TCA_TCINDEX_POLICE: core::ffi::c_uint = 6;
pub const TCA_TCINDEX_ACT: core::ffi::c_uint = 7;
pub const __TCA_TCINDEX_MAX: core::ffi::c_uint = 8;
pub type _bindgen_ty_250 = core::ffi::c_uint;
pub const FLOW_KEY_SRC: core::ffi::c_uint = 0;
pub const FLOW_KEY_DST: core::ffi::c_uint = 1;
pub const FLOW_KEY_PROTO: core::ffi::c_uint = 2;
pub const FLOW_KEY_PROTO_SRC: core::ffi::c_uint = 3;
pub const FLOW_KEY_PROTO_DST: core::ffi::c_uint = 4;
pub const FLOW_KEY_IIF: core::ffi::c_uint = 5;
pub const FLOW_KEY_PRIORITY: core::ffi::c_uint = 6;
pub const FLOW_KEY_MARK: core::ffi::c_uint = 7;
pub const FLOW_KEY_NFCT: core::ffi::c_uint = 8;
pub const FLOW_KEY_NFCT_SRC: core::ffi::c_uint = 9;
pub const FLOW_KEY_NFCT_DST: core::ffi::c_uint = 10;
pub const FLOW_KEY_NFCT_PROTO_SRC: core::ffi::c_uint = 11;
pub const FLOW_KEY_NFCT_PROTO_DST: core::ffi::c_uint = 12;
pub const FLOW_KEY_RTCLASSID: core::ffi::c_uint = 13;
pub const FLOW_KEY_SKUID: core::ffi::c_uint = 14;
pub const FLOW_KEY_SKGID: core::ffi::c_uint = 15;
pub const FLOW_KEY_VLAN_TAG: core::ffi::c_uint = 16;
pub const FLOW_KEY_RXHASH: core::ffi::c_uint = 17;
pub const __FLOW_KEY_MAX: core::ffi::c_uint = 18;
pub type _bindgen_ty_251 = core::ffi::c_uint;
pub const FLOW_MODE_MAP: core::ffi::c_uint = 0;
pub const FLOW_MODE_HASH: core::ffi::c_uint = 1;
pub type _bindgen_ty_252 = core::ffi::c_uint;
pub const TCA_FLOW_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FLOW_KEYS: core::ffi::c_uint = 1;
pub const TCA_FLOW_MODE: core::ffi::c_uint = 2;
pub const TCA_FLOW_BASECLASS: core::ffi::c_uint = 3;
pub const TCA_FLOW_RSHIFT: core::ffi::c_uint = 4;
pub const TCA_FLOW_ADDEND: core::ffi::c_uint = 5;
pub const TCA_FLOW_MASK: core::ffi::c_uint = 6;
pub const TCA_FLOW_XOR: core::ffi::c_uint = 7;
pub const TCA_FLOW_DIVISOR: core::ffi::c_uint = 8;
pub const TCA_FLOW_ACT: core::ffi::c_uint = 9;
pub const TCA_FLOW_POLICE: core::ffi::c_uint = 10;
pub const TCA_FLOW_EMATCHES: core::ffi::c_uint = 11;
pub const TCA_FLOW_PERTURB: core::ffi::c_uint = 12;
pub const __TCA_FLOW_MAX: core::ffi::c_uint = 13;
pub type _bindgen_ty_253 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_basic_pcnt {
    pub rcnt: __u64,
    pub rhit: __u64,
}
pub const TCA_BASIC_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_BASIC_CLASSID: core::ffi::c_uint = 1;
pub const TCA_BASIC_EMATCHES: core::ffi::c_uint = 2;
pub const TCA_BASIC_ACT: core::ffi::c_uint = 3;
pub const TCA_BASIC_POLICE: core::ffi::c_uint = 4;
pub const TCA_BASIC_PCNT: core::ffi::c_uint = 5;
pub const TCA_BASIC_PAD: core::ffi::c_uint = 6;
pub const __TCA_BASIC_MAX: core::ffi::c_uint = 7;
pub type _bindgen_ty_254 = core::ffi::c_uint;
pub const TCA_CGROUP_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_CGROUP_ACT: core::ffi::c_uint = 1;
pub const TCA_CGROUP_POLICE: core::ffi::c_uint = 2;
pub const TCA_CGROUP_EMATCHES: core::ffi::c_uint = 3;
pub const __TCA_CGROUP_MAX: core::ffi::c_uint = 4;
pub type _bindgen_ty_255 = core::ffi::c_uint;
pub const TCA_BPF_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_BPF_ACT: core::ffi::c_uint = 1;
pub const TCA_BPF_POLICE: core::ffi::c_uint = 2;
pub const TCA_BPF_CLASSID: core::ffi::c_uint = 3;
pub const TCA_BPF_OPS_LEN: core::ffi::c_uint = 4;
pub const TCA_BPF_OPS: core::ffi::c_uint = 5;
pub const TCA_BPF_FD: core::ffi::c_uint = 6;
pub const TCA_BPF_NAME: core::ffi::c_uint = 7;
pub const TCA_BPF_FLAGS: core::ffi::c_uint = 8;
pub const TCA_BPF_FLAGS_GEN: core::ffi::c_uint = 9;
pub const TCA_BPF_TAG: core::ffi::c_uint = 10;
pub const TCA_BPF_ID: core::ffi::c_uint = 11;
pub const __TCA_BPF_MAX: core::ffi::c_uint = 12;
pub type _bindgen_ty_256 = core::ffi::c_uint;
pub const TCA_FLOWER_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FLOWER_CLASSID: core::ffi::c_uint = 1;
pub const TCA_FLOWER_INDEV: core::ffi::c_uint = 2;
pub const TCA_FLOWER_ACT: core::ffi::c_uint = 3;
pub const TCA_FLOWER_KEY_ETH_DST: core::ffi::c_uint = 4;
pub const TCA_FLOWER_KEY_ETH_DST_MASK: core::ffi::c_uint = 5;
pub const TCA_FLOWER_KEY_ETH_SRC: core::ffi::c_uint = 6;
pub const TCA_FLOWER_KEY_ETH_SRC_MASK: core::ffi::c_uint = 7;
pub const TCA_FLOWER_KEY_ETH_TYPE: core::ffi::c_uint = 8;
pub const TCA_FLOWER_KEY_IP_PROTO: core::ffi::c_uint = 9;
pub const TCA_FLOWER_KEY_IPV4_SRC: core::ffi::c_uint = 10;
pub const TCA_FLOWER_KEY_IPV4_SRC_MASK: core::ffi::c_uint = 11;
pub const TCA_FLOWER_KEY_IPV4_DST: core::ffi::c_uint = 12;
pub const TCA_FLOWER_KEY_IPV4_DST_MASK: core::ffi::c_uint = 13;
pub const TCA_FLOWER_KEY_IPV6_SRC: core::ffi::c_uint = 14;
pub const TCA_FLOWER_KEY_IPV6_SRC_MASK: core::ffi::c_uint = 15;
pub const TCA_FLOWER_KEY_IPV6_DST: core::ffi::c_uint = 16;
pub const TCA_FLOWER_KEY_IPV6_DST_MASK: core::ffi::c_uint = 17;
pub const TCA_FLOWER_KEY_TCP_SRC: core::ffi::c_uint = 18;
pub const TCA_FLOWER_KEY_TCP_DST: core::ffi::c_uint = 19;
pub const TCA_FLOWER_KEY_UDP_SRC: core::ffi::c_uint = 20;
pub const TCA_FLOWER_KEY_UDP_DST: core::ffi::c_uint = 21;
pub const TCA_FLOWER_FLAGS: core::ffi::c_uint = 22;
pub const TCA_FLOWER_KEY_VLAN_ID: core::ffi::c_uint = 23;
pub const TCA_FLOWER_KEY_VLAN_PRIO: core::ffi::c_uint = 24;
pub const TCA_FLOWER_KEY_VLAN_ETH_TYPE: core::ffi::c_uint = 25;
pub const TCA_FLOWER_KEY_ENC_KEY_ID: core::ffi::c_uint = 26;
pub const TCA_FLOWER_KEY_ENC_IPV4_SRC: core::ffi::c_uint = 27;
pub const TCA_FLOWER_KEY_ENC_IPV4_SRC_MASK: core::ffi::c_uint = 28;
pub const TCA_FLOWER_KEY_ENC_IPV4_DST: core::ffi::c_uint = 29;
pub const TCA_FLOWER_KEY_ENC_IPV4_DST_MASK: core::ffi::c_uint = 30;
pub const TCA_FLOWER_KEY_ENC_IPV6_SRC: core::ffi::c_uint = 31;
pub const TCA_FLOWER_KEY_ENC_IPV6_SRC_MASK: core::ffi::c_uint = 32;
pub const TCA_FLOWER_KEY_ENC_IPV6_DST: core::ffi::c_uint = 33;
pub const TCA_FLOWER_KEY_ENC_IPV6_DST_MASK: core::ffi::c_uint = 34;
pub const TCA_FLOWER_KEY_TCP_SRC_MASK: core::ffi::c_uint = 35;
pub const TCA_FLOWER_KEY_TCP_DST_MASK: core::ffi::c_uint = 36;
pub const TCA_FLOWER_KEY_UDP_SRC_MASK: core::ffi::c_uint = 37;
pub const TCA_FLOWER_KEY_UDP_DST_MASK: core::ffi::c_uint = 38;
pub const TCA_FLOWER_KEY_SCTP_SRC_MASK: core::ffi::c_uint = 39;
pub const TCA_FLOWER_KEY_SCTP_DST_MASK: core::ffi::c_uint = 40;
pub const TCA_FLOWER_KEY_SCTP_SRC: core::ffi::c_uint = 41;
pub const TCA_FLOWER_KEY_SCTP_DST: core::ffi::c_uint = 42;
pub const TCA_FLOWER_KEY_ENC_UDP_SRC_PORT: core::ffi::c_uint = 43;
pub const TCA_FLOWER_KEY_ENC_UDP_SRC_PORT_MASK: core::ffi::c_uint = 44;
pub const TCA_FLOWER_KEY_ENC_UDP_DST_PORT: core::ffi::c_uint = 45;
pub const TCA_FLOWER_KEY_ENC_UDP_DST_PORT_MASK: core::ffi::c_uint = 46;
pub const TCA_FLOWER_KEY_FLAGS: core::ffi::c_uint = 47;
pub const TCA_FLOWER_KEY_FLAGS_MASK: core::ffi::c_uint = 48;
pub const TCA_FLOWER_KEY_ICMPV4_CODE: core::ffi::c_uint = 49;
pub const TCA_FLOWER_KEY_ICMPV4_CODE_MASK: core::ffi::c_uint = 50;
pub const TCA_FLOWER_KEY_ICMPV4_TYPE: core::ffi::c_uint = 51;
pub const TCA_FLOWER_KEY_ICMPV4_TYPE_MASK: core::ffi::c_uint = 52;
pub const TCA_FLOWER_KEY_ICMPV6_CODE: core::ffi::c_uint = 53;
pub const TCA_FLOWER_KEY_ICMPV6_CODE_MASK: core::ffi::c_uint = 54;
pub const TCA_FLOWER_KEY_ICMPV6_TYPE: core::ffi::c_uint = 55;
pub const TCA_FLOWER_KEY_ICMPV6_TYPE_MASK: core::ffi::c_uint = 56;
pub const TCA_FLOWER_KEY_ARP_SIP: core::ffi::c_uint = 57;
pub const TCA_FLOWER_KEY_ARP_SIP_MASK: core::ffi::c_uint = 58;
pub const TCA_FLOWER_KEY_ARP_TIP: core::ffi::c_uint = 59;
pub const TCA_FLOWER_KEY_ARP_TIP_MASK: core::ffi::c_uint = 60;
pub const TCA_FLOWER_KEY_ARP_OP: core::ffi::c_uint = 61;
pub const TCA_FLOWER_KEY_ARP_OP_MASK: core::ffi::c_uint = 62;
pub const TCA_FLOWER_KEY_ARP_SHA: core::ffi::c_uint = 63;
pub const TCA_FLOWER_KEY_ARP_SHA_MASK: core::ffi::c_uint = 64;
pub const TCA_FLOWER_KEY_ARP_THA: core::ffi::c_uint = 65;
pub const TCA_FLOWER_KEY_ARP_THA_MASK: core::ffi::c_uint = 66;
pub const TCA_FLOWER_KEY_MPLS_TTL: core::ffi::c_uint = 67;
pub const TCA_FLOWER_KEY_MPLS_BOS: core::ffi::c_uint = 68;
pub const TCA_FLOWER_KEY_MPLS_TC: core::ffi::c_uint = 69;
pub const TCA_FLOWER_KEY_MPLS_LABEL: core::ffi::c_uint = 70;
pub const TCA_FLOWER_KEY_TCP_FLAGS: core::ffi::c_uint = 71;
pub const TCA_FLOWER_KEY_TCP_FLAGS_MASK: core::ffi::c_uint = 72;
pub const TCA_FLOWER_KEY_IP_TOS: core::ffi::c_uint = 73;
pub const TCA_FLOWER_KEY_IP_TOS_MASK: core::ffi::c_uint = 74;
pub const TCA_FLOWER_KEY_IP_TTL: core::ffi::c_uint = 75;
pub const TCA_FLOWER_KEY_IP_TTL_MASK: core::ffi::c_uint = 76;
pub const TCA_FLOWER_KEY_CVLAN_ID: core::ffi::c_uint = 77;
pub const TCA_FLOWER_KEY_CVLAN_PRIO: core::ffi::c_uint = 78;
pub const TCA_FLOWER_KEY_CVLAN_ETH_TYPE: core::ffi::c_uint = 79;
pub const TCA_FLOWER_KEY_ENC_IP_TOS: core::ffi::c_uint = 80;
pub const TCA_FLOWER_KEY_ENC_IP_TOS_MASK: core::ffi::c_uint = 81;
pub const TCA_FLOWER_KEY_ENC_IP_TTL: core::ffi::c_uint = 82;
pub const TCA_FLOWER_KEY_ENC_IP_TTL_MASK: core::ffi::c_uint = 83;
pub const TCA_FLOWER_KEY_ENC_OPTS: core::ffi::c_uint = 84;
pub const TCA_FLOWER_KEY_ENC_OPTS_MASK: core::ffi::c_uint = 85;
pub const TCA_FLOWER_IN_HW_COUNT: core::ffi::c_uint = 86;
pub const TCA_FLOWER_KEY_PORT_SRC_MIN: core::ffi::c_uint = 87;
pub const TCA_FLOWER_KEY_PORT_SRC_MAX: core::ffi::c_uint = 88;
pub const TCA_FLOWER_KEY_PORT_DST_MIN: core::ffi::c_uint = 89;
pub const TCA_FLOWER_KEY_PORT_DST_MAX: core::ffi::c_uint = 90;
pub const TCA_FLOWER_KEY_CT_STATE: core::ffi::c_uint = 91;
pub const TCA_FLOWER_KEY_CT_STATE_MASK: core::ffi::c_uint = 92;
pub const TCA_FLOWER_KEY_CT_ZONE: core::ffi::c_uint = 93;
pub const TCA_FLOWER_KEY_CT_ZONE_MASK: core::ffi::c_uint = 94;
pub const TCA_FLOWER_KEY_CT_MARK: core::ffi::c_uint = 95;
pub const TCA_FLOWER_KEY_CT_MARK_MASK: core::ffi::c_uint = 96;
pub const TCA_FLOWER_KEY_CT_LABELS: core::ffi::c_uint = 97;
pub const TCA_FLOWER_KEY_CT_LABELS_MASK: core::ffi::c_uint = 98;
pub const TCA_FLOWER_KEY_MPLS_OPTS: core::ffi::c_uint = 99;
pub const TCA_FLOWER_KEY_HASH: core::ffi::c_uint = 100;
pub const TCA_FLOWER_KEY_HASH_MASK: core::ffi::c_uint = 101;
pub const TCA_FLOWER_KEY_NUM_OF_VLANS: core::ffi::c_uint = 102;
pub const TCA_FLOWER_KEY_PPPOE_SID: core::ffi::c_uint = 103;
pub const TCA_FLOWER_KEY_PPP_PROTO: core::ffi::c_uint = 104;
pub const TCA_FLOWER_KEY_L2TPV3_SID: core::ffi::c_uint = 105;
pub const __TCA_FLOWER_MAX: core::ffi::c_uint = 106;
pub type _bindgen_ty_257 = core::ffi::c_uint;
pub const TCA_FLOWER_KEY_CT_FLAGS_NEW: core::ffi::c_uint = 1;
pub const TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED: core::ffi::c_uint = 2;
pub const TCA_FLOWER_KEY_CT_FLAGS_RELATED: core::ffi::c_uint = 4;
pub const TCA_FLOWER_KEY_CT_FLAGS_TRACKED: core::ffi::c_uint = 8;
pub const TCA_FLOWER_KEY_CT_FLAGS_INVALID: core::ffi::c_uint = 16;
pub const TCA_FLOWER_KEY_CT_FLAGS_REPLY: core::ffi::c_uint = 32;
pub const __TCA_FLOWER_KEY_CT_FLAGS_MAX: core::ffi::c_uint = 33;
pub type _bindgen_ty_258 = core::ffi::c_uint;
pub const TCA_FLOWER_KEY_ENC_OPTS_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FLOWER_KEY_ENC_OPTS_GENEVE: core::ffi::c_uint = 1;
pub const TCA_FLOWER_KEY_ENC_OPTS_VXLAN: core::ffi::c_uint = 2;
pub const TCA_FLOWER_KEY_ENC_OPTS_ERSPAN: core::ffi::c_uint = 3;
pub const TCA_FLOWER_KEY_ENC_OPTS_GTP: core::ffi::c_uint = 4;
pub const __TCA_FLOWER_KEY_ENC_OPTS_MAX: core::ffi::c_uint = 5;
pub type _bindgen_ty_259 = core::ffi::c_uint;
pub const TCA_FLOWER_KEY_ENC_OPT_GENEVE_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FLOWER_KEY_ENC_OPT_GENEVE_CLASS: core::ffi::c_uint = 1;
pub const TCA_FLOWER_KEY_ENC_OPT_GENEVE_TYPE: core::ffi::c_uint = 2;
pub const TCA_FLOWER_KEY_ENC_OPT_GENEVE_DATA: core::ffi::c_uint = 3;
pub const __TCA_FLOWER_KEY_ENC_OPT_GENEVE_MAX: core::ffi::c_uint = 4;
pub type _bindgen_ty_260 = core::ffi::c_uint;
pub const TCA_FLOWER_KEY_ENC_OPT_VXLAN_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FLOWER_KEY_ENC_OPT_VXLAN_GBP: core::ffi::c_uint = 1;
pub const __TCA_FLOWER_KEY_ENC_OPT_VXLAN_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_261 = core::ffi::c_uint;
pub const TCA_FLOWER_KEY_ENC_OPT_ERSPAN_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FLOWER_KEY_ENC_OPT_ERSPAN_VER: core::ffi::c_uint = 1;
pub const TCA_FLOWER_KEY_ENC_OPT_ERSPAN_INDEX: core::ffi::c_uint = 2;
pub const TCA_FLOWER_KEY_ENC_OPT_ERSPAN_DIR: core::ffi::c_uint = 3;
pub const TCA_FLOWER_KEY_ENC_OPT_ERSPAN_HWID: core::ffi::c_uint = 4;
pub const __TCA_FLOWER_KEY_ENC_OPT_ERSPAN_MAX: core::ffi::c_uint = 5;
pub type _bindgen_ty_262 = core::ffi::c_uint;
pub const TCA_FLOWER_KEY_ENC_OPT_GTP_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FLOWER_KEY_ENC_OPT_GTP_PDU_TYPE: core::ffi::c_uint = 1;
pub const TCA_FLOWER_KEY_ENC_OPT_GTP_QFI: core::ffi::c_uint = 2;
pub const __TCA_FLOWER_KEY_ENC_OPT_GTP_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_263 = core::ffi::c_uint;
pub const TCA_FLOWER_KEY_MPLS_OPTS_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FLOWER_KEY_MPLS_OPTS_LSE: core::ffi::c_uint = 1;
pub const __TCA_FLOWER_KEY_MPLS_OPTS_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_264 = core::ffi::c_uint;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_DEPTH: core::ffi::c_uint = 1;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_TTL: core::ffi::c_uint = 2;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_BOS: core::ffi::c_uint = 3;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_TC: core::ffi::c_uint = 4;
pub const TCA_FLOWER_KEY_MPLS_OPT_LSE_LABEL: core::ffi::c_uint = 5;
pub const __TCA_FLOWER_KEY_MPLS_OPT_LSE_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_265 = core::ffi::c_uint;
pub const TCA_FLOWER_KEY_FLAGS_IS_FRAGMENT: core::ffi::c_uint = 1;
pub const TCA_FLOWER_KEY_FLAGS_FRAG_IS_FIRST: core::ffi::c_uint = 2;
pub type _bindgen_ty_266 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tc_matchall_pcnt {
    pub rhit: __u64,
}
pub const TCA_MATCHALL_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_MATCHALL_CLASSID: core::ffi::c_uint = 1;
pub const TCA_MATCHALL_ACT: core::ffi::c_uint = 2;
pub const TCA_MATCHALL_FLAGS: core::ffi::c_uint = 3;
pub const TCA_MATCHALL_PCNT: core::ffi::c_uint = 4;
pub const TCA_MATCHALL_PAD: core::ffi::c_uint = 5;
pub const __TCA_MATCHALL_MAX: core::ffi::c_uint = 6;
pub type _bindgen_ty_267 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcf_ematch_tree_hdr {
    pub nmatches: __u16,
    pub progid: __u16,
}
pub const TCA_EMATCH_TREE_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_EMATCH_TREE_HDR: core::ffi::c_uint = 1;
pub const TCA_EMATCH_TREE_LIST: core::ffi::c_uint = 2;
pub const __TCA_EMATCH_TREE_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_268 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcf_ematch_hdr {
    pub matchid: __u16,
    pub kind: __u16,
    pub flags: __u16,
    pub pad: __u16,
}
pub const TCF_LAYER_LINK: core::ffi::c_uint = 0;
pub const TCF_LAYER_NETWORK: core::ffi::c_uint = 1;
pub const TCF_LAYER_TRANSPORT: core::ffi::c_uint = 2;
pub const __TCF_LAYER_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_269 = core::ffi::c_uint;
pub const TCF_EM_PROG_TC: core::ffi::c_uint = 0;
pub type _bindgen_ty_270 = core::ffi::c_uint;
pub const TCF_EM_OPND_EQ: core::ffi::c_uint = 0;
pub const TCF_EM_OPND_GT: core::ffi::c_uint = 1;
pub const TCF_EM_OPND_LT: core::ffi::c_uint = 2;
pub type _bindgen_ty_271 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netpoll_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ethtool_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct phy_device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dsa_port {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_tunnel_parm {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct macsec_context {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct macsec_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_name_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sd_flow_limit {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sfp_bus {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wireless_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct wpan_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpls_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udp_tunnel_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udp_tunnel_nic_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct udp_tunnel_nic {
    _unused: [u8; 0],
}
extern "C" {
    pub fn synchronize_net();
}
extern "C" {
    pub fn netdev_set_default_ethtool_ops(dev: *mut net_device, ops: *const ethtool_ops);
}
pub const netdev_tx___NETDEV_TX_MIN: netdev_tx = -2147483648;
pub const netdev_tx_NETDEV_TX_OK: netdev_tx = 0;
pub const netdev_tx_NETDEV_TX_BUSY: netdev_tx = 16;
pub type netdev_tx = core::ffi::c_int;
pub use self::netdev_tx as netdev_tx_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct net_device_stats {
    pub rx_packets: core::ffi::c_ulong,
    pub tx_packets: core::ffi::c_ulong,
    pub rx_bytes: core::ffi::c_ulong,
    pub tx_bytes: core::ffi::c_ulong,
    pub rx_errors: core::ffi::c_ulong,
    pub tx_errors: core::ffi::c_ulong,
    pub rx_dropped: core::ffi::c_ulong,
    pub tx_dropped: core::ffi::c_ulong,
    pub multicast: core::ffi::c_ulong,
    pub collisions: core::ffi::c_ulong,
    pub rx_length_errors: core::ffi::c_ulong,
    pub rx_over_errors: core::ffi::c_ulong,
    pub rx_crc_errors: core::ffi::c_ulong,
    pub rx_frame_errors: core::ffi::c_ulong,
    pub rx_fifo_errors: core::ffi::c_ulong,
    pub rx_missed_errors: core::ffi::c_ulong,
    pub tx_aborted_errors: core::ffi::c_ulong,
    pub tx_carrier_errors: core::ffi::c_ulong,
    pub tx_fifo_errors: core::ffi::c_ulong,
    pub tx_heartbeat_errors: core::ffi::c_ulong,
    pub tx_window_errors: core::ffi::c_ulong,
    pub rx_compressed: core::ffi::c_ulong,
    pub tx_compressed: core::ffi::c_ulong,
}
#[repr(C)]
#[repr(align(32))]
#[derive(Default, Copy, Clone)]
pub struct net_device_core_stats {
    pub rx_dropped: core::ffi::c_ulong,
    pub tx_dropped: core::ffi::c_ulong,
    pub rx_nohandler: core::ffi::c_ulong,
    pub rx_otherhost_dropped: core::ffi::c_ulong,
}
extern "C" {
    pub static mut rps_needed: static_key_false;
}
extern "C" {
    pub static mut rfs_needed: static_key_false;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_hw_addr {
    pub list: list_head,
    pub node: rb_node,
    pub addr: [core::ffi::c_uchar; 32usize],
    pub type_: core::ffi::c_uchar,
    pub global_use: bool_,
    pub sync_cnt: core::ffi::c_int,
    pub refcount: core::ffi::c_int,
    pub synced: core::ffi::c_int,
    pub callback_head: callback_head,
}
impl Default for netdev_hw_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_hw_addr_list {
    pub list: list_head,
    pub count: core::ffi::c_int,
    pub tree: rb_root,
}
impl Default for netdev_hw_addr_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hh_cache {
    pub hh_len: core::ffi::c_uint,
    pub hh_lock: seqlock_t,
    pub hh_data: [core::ffi::c_ulong; 12usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct header_ops {
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            dev: *mut net_device,
            type_: core::ffi::c_ushort,
            daddr: *const core::ffi::c_void,
            saddr: *const core::ffi::c_void,
            len: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub parse: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *const sk_buff,
            haddr: *mut core::ffi::c_uchar,
        ) -> core::ffi::c_int,
    >,
    pub cache: ::core::option::Option<
        unsafe extern "C" fn(
            neigh: *const neighbour,
            hh: *mut hh_cache,
            type_: __be16,
        ) -> core::ffi::c_int,
    >,
    pub cache_update: ::core::option::Option<
        unsafe extern "C" fn(
            hh: *mut hh_cache,
            dev: *const net_device,
            haddr: *const core::ffi::c_uchar,
        ),
    >,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(ll_header: *const core::ffi::c_char, len: core::ffi::c_uint) -> bool_,
    >,
    pub parse_protocol: ::core::option::Option<unsafe extern "C" fn(skb: *const sk_buff) -> __be16>,
}
pub const netdev_state_t___LINK_STATE_START: netdev_state_t = 0;
pub const netdev_state_t___LINK_STATE_PRESENT: netdev_state_t = 1;
pub const netdev_state_t___LINK_STATE_NOCARRIER: netdev_state_t = 2;
pub const netdev_state_t___LINK_STATE_LINKWATCH_PENDING: netdev_state_t = 3;
pub const netdev_state_t___LINK_STATE_DORMANT: netdev_state_t = 4;
pub const netdev_state_t___LINK_STATE_TESTING: netdev_state_t = 5;
pub type netdev_state_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gro_list {
    pub list: list_head,
    pub count: core::ffi::c_int,
}
impl Default for gro_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct napi_struct {
    pub poll_list: list_head,
    pub state: core::ffi::c_ulong,
    pub weight: core::ffi::c_int,
    pub defer_hard_irqs_count: core::ffi::c_int,
    pub gro_bitmask: core::ffi::c_ulong,
    pub poll: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut napi_struct, arg2: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub dev: *mut net_device,
    pub gro_hash: [gro_list; 8usize],
    pub skb: *mut sk_buff,
    pub rx_list: list_head,
    pub rx_count: core::ffi::c_int,
    pub timer: hrtimer,
    pub dev_list: list_head,
    pub napi_hash_node: hlist_node,
    pub napi_id: core::ffi::c_uint,
    pub thread: *mut task_struct,
}
impl Default for napi_struct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const NAPI_STATE_SCHED: core::ffi::c_uint = 0;
pub const NAPI_STATE_MISSED: core::ffi::c_uint = 1;
pub const NAPI_STATE_DISABLE: core::ffi::c_uint = 2;
pub const NAPI_STATE_NPSVC: core::ffi::c_uint = 3;
pub const NAPI_STATE_LISTED: core::ffi::c_uint = 4;
pub const NAPI_STATE_NO_BUSY_POLL: core::ffi::c_uint = 5;
pub const NAPI_STATE_IN_BUSY_POLL: core::ffi::c_uint = 6;
pub const NAPI_STATE_PREFER_BUSY_POLL: core::ffi::c_uint = 7;
pub const NAPI_STATE_THREADED: core::ffi::c_uint = 8;
pub const NAPI_STATE_SCHED_THREADED: core::ffi::c_uint = 9;
pub type _bindgen_ty_272 = core::ffi::c_uint;
pub const NAPIF_STATE_SCHED: core::ffi::c_uint = 1;
pub const NAPIF_STATE_MISSED: core::ffi::c_uint = 2;
pub const NAPIF_STATE_DISABLE: core::ffi::c_uint = 4;
pub const NAPIF_STATE_NPSVC: core::ffi::c_uint = 8;
pub const NAPIF_STATE_LISTED: core::ffi::c_uint = 16;
pub const NAPIF_STATE_NO_BUSY_POLL: core::ffi::c_uint = 32;
pub const NAPIF_STATE_IN_BUSY_POLL: core::ffi::c_uint = 64;
pub const NAPIF_STATE_PREFER_BUSY_POLL: core::ffi::c_uint = 128;
pub const NAPIF_STATE_THREADED: core::ffi::c_uint = 256;
pub const NAPIF_STATE_SCHED_THREADED: core::ffi::c_uint = 512;
pub type _bindgen_ty_273 = core::ffi::c_uint;
pub const gro_result_GRO_MERGED: gro_result = 0;
pub const gro_result_GRO_MERGED_FREE: gro_result = 1;
pub const gro_result_GRO_HELD: gro_result = 2;
pub const gro_result_GRO_NORMAL: gro_result = 3;
pub const gro_result_GRO_CONSUMED: gro_result = 4;
pub type gro_result = core::ffi::c_uint;
pub use self::gro_result as gro_result_t;
pub const rx_handler_result_RX_HANDLER_CONSUMED: rx_handler_result = 0;
pub const rx_handler_result_RX_HANDLER_ANOTHER: rx_handler_result = 1;
pub const rx_handler_result_RX_HANDLER_EXACT: rx_handler_result = 2;
pub const rx_handler_result_RX_HANDLER_PASS: rx_handler_result = 3;
pub type rx_handler_result = core::ffi::c_uint;
pub use self::rx_handler_result as rx_handler_result_t;
pub type rx_handler_func_t =
    ::core::option::Option<unsafe extern "C" fn(pskb: *mut *mut sk_buff) -> rx_handler_result_t>;
extern "C" {
    pub fn __napi_schedule(n: *mut napi_struct);
}
extern "C" {
    pub fn __napi_schedule_irqoff(n: *mut napi_struct);
}
extern "C" {
    pub fn napi_schedule_prep(n: *mut napi_struct) -> bool_;
}
extern "C" {
    pub fn napi_complete_done(n: *mut napi_struct, work_done: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn dev_set_threaded(dev: *mut net_device, threaded: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn napi_disable(n: *mut napi_struct);
}
extern "C" {
    pub fn napi_enable(n: *mut napi_struct);
}
pub const netdev_queue_state_t___QUEUE_STATE_DRV_XOFF: netdev_queue_state_t = 0;
pub const netdev_queue_state_t___QUEUE_STATE_STACK_XOFF: netdev_queue_state_t = 1;
pub const netdev_queue_state_t___QUEUE_STATE_FROZEN: netdev_queue_state_t = 2;
pub type netdev_queue_state_t = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct netdev_queue {
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub qdisc: *mut Qdisc,
    pub qdisc_sleeping: *mut Qdisc,
    pub kobj: kobject,
    pub tx_maxrate: core::ffi::c_ulong,
    pub trans_timeout: atomic_long_t,
    pub sb_dev: *mut net_device,
    pub __bindgen_padding_0: [u64; 2usize],
    pub _xmit_lock: spinlock_t,
    pub xmit_lock_owner: core::ffi::c_int,
    pub trans_start: core::ffi::c_ulong,
    pub state: core::ffi::c_ulong,
    pub __bindgen_padding_1: [u64; 2usize],
    pub dql: dql,
}
impl Default for netdev_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut sysctl_fb_tunnels_only_for_init_net: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_devconf_inherit_init_net: core::ffi::c_int;
}
#[repr(C)]
pub struct rps_map {
    pub len: core::ffi::c_uint,
    pub rcu: callback_head,
    pub cpus: __IncompleteArrayField<u16_>,
}
impl Default for rps_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rps_dev_flow {
    pub cpu: u16_,
    pub filter: u16_,
    pub last_qtail: core::ffi::c_uint,
}
#[repr(C)]
pub struct rps_dev_flow_table {
    pub mask: core::ffi::c_uint,
    pub rcu: callback_head,
    pub flows: __IncompleteArrayField<rps_dev_flow>,
}
impl Default for rps_dev_flow_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct rps_sock_flow_table {
    pub mask: u32_,
    pub __bindgen_padding_0: [u32; 15usize],
    pub ents: __IncompleteArrayField<u32_>,
}
impl Default for rps_sock_flow_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut rps_cpu_mask: u32_;
}
extern "C" {
    pub static mut rps_sock_flow_table: *mut rps_sock_flow_table;
}
extern "C" {
    pub fn rps_may_expire_flow(
        dev: *mut net_device,
        rxq_index: u16_,
        flow_id: u32_,
        filter_id: u16_,
    ) -> bool_;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct netdev_rx_queue {
    pub xdp_rxq: xdp_rxq_info,
    pub rps_map: *mut rps_map,
    pub rps_flow_table: *mut rps_dev_flow_table,
    pub kobj: kobject,
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
}
impl Default for netdev_rx_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rx_queue_attribute {
    pub attr: attribute,
    pub show: ::core::option::Option<
        unsafe extern "C" fn(queue: *mut netdev_rx_queue, buf: *mut core::ffi::c_char) -> isize,
    >,
    pub store: ::core::option::Option<
        unsafe extern "C" fn(
            queue: *mut netdev_rx_queue,
            buf: *const core::ffi::c_char,
            len: usize,
        ) -> isize,
    >,
}
impl Default for rx_queue_attribute {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const xps_map_type_XPS_CPUS: xps_map_type = 0;
pub const xps_map_type_XPS_RXQS: xps_map_type = 1;
pub const xps_map_type_XPS_MAPS_MAX: xps_map_type = 2;
pub type xps_map_type = core::ffi::c_uint;
#[repr(C)]
pub struct xps_map {
    pub len: core::ffi::c_uint,
    pub alloc_len: core::ffi::c_uint,
    pub rcu: callback_head,
    pub queues: __IncompleteArrayField<u16_>,
}
impl Default for xps_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct xps_dev_maps {
    pub rcu: callback_head,
    pub nr_ids: core::ffi::c_uint,
    pub num_tc: s16,
    pub attr_map: __IncompleteArrayField<*mut xps_map>,
}
impl Default for xps_dev_maps {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netdev_tc_txq {
    pub count: u16_,
    pub offset: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netdev_phys_item_id {
    pub id: [core::ffi::c_uchar; 32usize],
    pub id_len: core::ffi::c_uchar,
}
pub type select_queue_fallback_t = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut net_device, skb: *mut sk_buff, sb_dev: *mut net_device) -> u16_,
>;
pub const net_device_path_type_DEV_PATH_ETHERNET: net_device_path_type = 0;
pub const net_device_path_type_DEV_PATH_VLAN: net_device_path_type = 1;
pub const net_device_path_type_DEV_PATH_BRIDGE: net_device_path_type = 2;
pub const net_device_path_type_DEV_PATH_PPPOE: net_device_path_type = 3;
pub const net_device_path_type_DEV_PATH_DSA: net_device_path_type = 4;
pub const net_device_path_type_DEV_PATH_MTK_WDMA: net_device_path_type = 5;
pub type net_device_path_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device_path {
    pub type_: net_device_path_type,
    pub dev: *const net_device,
    pub __bindgen_anon_1: net_device_path__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device_path__bindgen_ty_1 {
    pub encap: net_device_path__bindgen_ty_1__bindgen_ty_1,
    pub bridge: net_device_path__bindgen_ty_1__bindgen_ty_2,
    pub dsa: net_device_path__bindgen_ty_1__bindgen_ty_3,
    pub mtk_wdma: net_device_path__bindgen_ty_1__bindgen_ty_4,
    _bindgen_union_align: [u32; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct net_device_path__bindgen_ty_1__bindgen_ty_1 {
    pub id: u16_,
    pub proto: __be16,
    pub h_dest: [u8_; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device_path__bindgen_ty_1__bindgen_ty_2 {
    pub vlan_mode: net_device_path__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub vlan_id: u16_,
    pub vlan_proto: __be16,
}
pub const net_device_path__bindgen_ty_1__bindgen_ty_2_DEV_PATH_BR_VLAN_KEEP: core::ffi::c_uint = 0;
pub const net_device_path__bindgen_ty_1__bindgen_ty_2_DEV_PATH_BR_VLAN_TAG: core::ffi::c_uint = 1;
pub const net_device_path__bindgen_ty_1__bindgen_ty_2_DEV_PATH_BR_VLAN_UNTAG: core::ffi::c_uint = 2;
pub const net_device_path__bindgen_ty_1__bindgen_ty_2_DEV_PATH_BR_VLAN_UNTAG_HW: core::ffi::c_uint =
    3;
pub type net_device_path__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 = core::ffi::c_uint;
impl Default for net_device_path__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct net_device_path__bindgen_ty_1__bindgen_ty_3 {
    pub port: core::ffi::c_int,
    pub proto: u16_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct net_device_path__bindgen_ty_1__bindgen_ty_4 {
    pub wdma_idx: u8_,
    pub queue: u8_,
    pub wcid: u16_,
    pub bss: u8_,
}
impl Default for net_device_path__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for net_device_path {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device_path_stack {
    pub num_paths: core::ffi::c_int,
    pub path: [net_device_path; 5usize],
}
impl Default for net_device_path_stack {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device_path_ctx {
    pub dev: *const net_device,
    pub daddr: [u8_; 6usize],
    pub num_vlans: core::ffi::c_int,
    pub vlan: [net_device_path_ctx__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct net_device_path_ctx__bindgen_ty_1 {
    pub id: u16_,
    pub proto: __be16,
}
impl Default for net_device_path_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const tc_setup_type_TC_QUERY_CAPS: tc_setup_type = 0;
pub const tc_setup_type_TC_SETUP_QDISC_MQPRIO: tc_setup_type = 1;
pub const tc_setup_type_TC_SETUP_CLSU32: tc_setup_type = 2;
pub const tc_setup_type_TC_SETUP_CLSFLOWER: tc_setup_type = 3;
pub const tc_setup_type_TC_SETUP_CLSMATCHALL: tc_setup_type = 4;
pub const tc_setup_type_TC_SETUP_CLSBPF: tc_setup_type = 5;
pub const tc_setup_type_TC_SETUP_BLOCK: tc_setup_type = 6;
pub const tc_setup_type_TC_SETUP_QDISC_CBS: tc_setup_type = 7;
pub const tc_setup_type_TC_SETUP_QDISC_RED: tc_setup_type = 8;
pub const tc_setup_type_TC_SETUP_QDISC_PRIO: tc_setup_type = 9;
pub const tc_setup_type_TC_SETUP_QDISC_MQ: tc_setup_type = 10;
pub const tc_setup_type_TC_SETUP_QDISC_ETF: tc_setup_type = 11;
pub const tc_setup_type_TC_SETUP_ROOT_QDISC: tc_setup_type = 12;
pub const tc_setup_type_TC_SETUP_QDISC_GRED: tc_setup_type = 13;
pub const tc_setup_type_TC_SETUP_QDISC_TAPRIO: tc_setup_type = 14;
pub const tc_setup_type_TC_SETUP_FT: tc_setup_type = 15;
pub const tc_setup_type_TC_SETUP_QDISC_ETS: tc_setup_type = 16;
pub const tc_setup_type_TC_SETUP_QDISC_TBF: tc_setup_type = 17;
pub const tc_setup_type_TC_SETUP_QDISC_FIFO: tc_setup_type = 18;
pub const tc_setup_type_TC_SETUP_QDISC_HTB: tc_setup_type = 19;
pub const tc_setup_type_TC_SETUP_ACT: tc_setup_type = 20;
pub type tc_setup_type = core::ffi::c_uint;
pub const bpf_netdev_command_XDP_SETUP_PROG: bpf_netdev_command = 0;
pub const bpf_netdev_command_XDP_SETUP_PROG_HW: bpf_netdev_command = 1;
pub const bpf_netdev_command_BPF_OFFLOAD_MAP_ALLOC: bpf_netdev_command = 2;
pub const bpf_netdev_command_BPF_OFFLOAD_MAP_FREE: bpf_netdev_command = 3;
pub const bpf_netdev_command_XDP_SETUP_XSK_POOL: bpf_netdev_command = 4;
pub type bpf_netdev_command = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdp_umem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xdp_dev_bulk_queue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_xdp_link {
    _unused: [u8; 0],
}
pub const bpf_xdp_mode_XDP_MODE_SKB: bpf_xdp_mode = 0;
pub const bpf_xdp_mode_XDP_MODE_DRV: bpf_xdp_mode = 1;
pub const bpf_xdp_mode_XDP_MODE_HW: bpf_xdp_mode = 2;
pub const bpf_xdp_mode___MAX_XDP_MODE: bpf_xdp_mode = 3;
pub type bpf_xdp_mode = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_xdp_entity {
    pub prog: *mut bpf_prog,
    pub link: *mut bpf_xdp_link,
}
impl Default for bpf_xdp_entity {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_bpf {
    pub command: bpf_netdev_command,
    pub __bindgen_anon_1: netdev_bpf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netdev_bpf__bindgen_ty_1 {
    pub __bindgen_anon_1: netdev_bpf__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: netdev_bpf__bindgen_ty_1__bindgen_ty_2,
    pub xsk: netdev_bpf__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_1 {
    pub flags: u32_,
    pub prog: *mut bpf_prog,
    pub extack: *mut netlink_ext_ack,
}
impl Default for netdev_bpf__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_2 {
    pub offmap: *mut bpf_offloaded_map,
}
impl Default for netdev_bpf__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_bpf__bindgen_ty_1__bindgen_ty_3 {
    pub pool: *mut xsk_buff_pool,
    pub queue_id: u16_,
}
impl Default for netdev_bpf__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for netdev_bpf__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for netdev_bpf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct dev_ifalias {
    pub rcuhead: callback_head,
    pub ifalias: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for dev_ifalias {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct devlink {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tlsdev_ops {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_net_notifier {
    pub list: list_head,
    pub nb: *mut notifier_block,
}
impl Default for netdev_net_notifier {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct net_device_ops {
    pub ndo_init:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> core::ffi::c_int>,
    pub ndo_uninit: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub ndo_open:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> core::ffi::c_int>,
    pub ndo_stop:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> core::ffi::c_int>,
    pub ndo_start_xmit: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, dev: *mut net_device) -> netdev_tx_t,
    >,
    pub ndo_features_check: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            dev: *mut net_device,
            features: netdev_features_t,
        ) -> netdev_features_t,
    >,
    pub ndo_select_queue: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            skb: *mut sk_buff,
            sb_dev: *mut net_device,
        ) -> u16_,
    >,
    pub ndo_change_rx_flags:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device, flags: core::ffi::c_int)>,
    pub ndo_set_rx_mode: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub ndo_set_mac_address: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            addr: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub ndo_validate_addr:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> core::ffi::c_int>,
    pub ndo_do_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            ifr: *mut ifreq,
            cmd: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub ndo_eth_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            ifr: *mut ifreq,
            cmd: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub ndo_siocbond: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            ifr: *mut ifreq,
            cmd: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub ndo_siocwandev: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, ifs: *mut if_settings) -> core::ffi::c_int,
    >,
    pub ndo_siocdevprivate: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            ifr: *mut ifreq,
            data: *mut core::ffi::c_void,
            cmd: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub ndo_set_config: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, map: *mut ifmap) -> core::ffi::c_int,
    >,
    pub ndo_change_mtu: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, new_mtu: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub ndo_neigh_setup: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, arg1: *mut neigh_parms) -> core::ffi::c_int,
    >,
    pub ndo_tx_timeout: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, txqueue: core::ffi::c_uint),
    >,
    pub ndo_get_stats64: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, storage: *mut rtnl_link_stats64),
    >,
    pub ndo_has_offload_stats: ::core::option::Option<
        unsafe extern "C" fn(dev: *const net_device, attr_id: core::ffi::c_int) -> bool_,
    >,
    pub ndo_get_offload_stats: ::core::option::Option<
        unsafe extern "C" fn(
            attr_id: core::ffi::c_int,
            dev: *const net_device,
            attr_data: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub ndo_get_stats:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> *mut net_device_stats>,
    pub ndo_vlan_rx_add_vid: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, proto: __be16, vid: u16_) -> core::ffi::c_int,
    >,
    pub ndo_vlan_rx_kill_vid: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, proto: __be16, vid: u16_) -> core::ffi::c_int,
    >,
    pub ndo_set_vf_mac: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            queue: core::ffi::c_int,
            mac: *mut u8_,
        ) -> core::ffi::c_int,
    >,
    pub ndo_set_vf_vlan: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            queue: core::ffi::c_int,
            vlan: u16_,
            qos: u8_,
            proto: __be16,
        ) -> core::ffi::c_int,
    >,
    pub ndo_set_vf_rate: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: core::ffi::c_int,
            min_tx_rate: core::ffi::c_int,
            max_tx_rate: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub ndo_set_vf_spoofchk: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: core::ffi::c_int,
            setting: bool_,
        ) -> core::ffi::c_int,
    >,
    pub ndo_set_vf_trust: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: core::ffi::c_int,
            setting: bool_,
        ) -> core::ffi::c_int,
    >,
    pub ndo_get_vf_config: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: core::ffi::c_int,
            ivf: *mut ifla_vf_info,
        ) -> core::ffi::c_int,
    >,
    pub ndo_set_vf_link_state: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: core::ffi::c_int,
            link_state: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub ndo_get_vf_stats: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: core::ffi::c_int,
            vf_stats: *mut ifla_vf_stats,
        ) -> core::ffi::c_int,
    >,
    pub ndo_set_vf_port: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: core::ffi::c_int,
            port: *mut *mut nlattr,
        ) -> core::ffi::c_int,
    >,
    pub ndo_get_vf_port: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: core::ffi::c_int,
            skb: *mut sk_buff,
        ) -> core::ffi::c_int,
    >,
    pub ndo_get_vf_guid: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: core::ffi::c_int,
            node_guid: *mut ifla_vf_guid,
            port_guid: *mut ifla_vf_guid,
        ) -> core::ffi::c_int,
    >,
    pub ndo_set_vf_guid: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: core::ffi::c_int,
            guid: u64_,
            guid_type: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub ndo_set_vf_rss_query_en: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            vf: core::ffi::c_int,
            setting: bool_,
        ) -> core::ffi::c_int,
    >,
    pub ndo_setup_tc: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            type_: tc_setup_type,
            type_data: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub ndo_rx_flow_steer: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            skb: *const sk_buff,
            rxq_index: u16_,
            flow_id: u32_,
        ) -> core::ffi::c_int,
    >,
    pub ndo_add_slave: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            slave_dev: *mut net_device,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub ndo_del_slave: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, slave_dev: *mut net_device) -> core::ffi::c_int,
    >,
    pub ndo_get_xmit_slave: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            skb: *mut sk_buff,
            all_slaves: bool_,
        ) -> *mut net_device,
    >,
    pub ndo_sk_get_lower_dev: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, sk: *mut sock) -> *mut net_device,
    >,
    pub ndo_fix_features: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            features: netdev_features_t,
        ) -> netdev_features_t,
    >,
    pub ndo_set_features: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, features: netdev_features_t) -> core::ffi::c_int,
    >,
    pub ndo_neigh_construct: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, n: *mut neighbour) -> core::ffi::c_int,
    >,
    pub ndo_neigh_destroy:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device, n: *mut neighbour)>,
    pub ndo_fdb_add: ::core::option::Option<
        unsafe extern "C" fn(
            ndm: *mut ndmsg,
            tb: *mut *mut nlattr,
            dev: *mut net_device,
            addr: *const core::ffi::c_uchar,
            vid: u16_,
            flags: u16_,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub ndo_fdb_del: ::core::option::Option<
        unsafe extern "C" fn(
            ndm: *mut ndmsg,
            tb: *mut *mut nlattr,
            dev: *mut net_device,
            addr: *const core::ffi::c_uchar,
            vid: u16_,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub ndo_fdb_del_bulk: ::core::option::Option<
        unsafe extern "C" fn(
            ndm: *mut ndmsg,
            tb: *mut *mut nlattr,
            dev: *mut net_device,
            vid: u16_,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub ndo_fdb_dump: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            cb: *mut netlink_callback,
            dev: *mut net_device,
            filter_dev: *mut net_device,
            idx: *mut core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub ndo_fdb_get: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            tb: *mut *mut nlattr,
            dev: *mut net_device,
            addr: *const core::ffi::c_uchar,
            vid: u16_,
            portid: u32_,
            seq: u32_,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub ndo_bridge_setlink: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            nlh: *mut nlmsghdr,
            flags: u16_,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub ndo_bridge_getlink: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            pid: u32_,
            seq: u32_,
            dev: *mut net_device,
            filter_mask: u32_,
            nlflags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub ndo_bridge_dellink: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            nlh: *mut nlmsghdr,
            flags: u16_,
        ) -> core::ffi::c_int,
    >,
    pub ndo_change_carrier: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, new_carrier: bool_) -> core::ffi::c_int,
    >,
    pub ndo_get_phys_port_id: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            ppid: *mut netdev_phys_item_id,
        ) -> core::ffi::c_int,
    >,
    pub ndo_get_port_parent_id: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            ppid: *mut netdev_phys_item_id,
        ) -> core::ffi::c_int,
    >,
    pub ndo_get_phys_port_name: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            name: *mut core::ffi::c_char,
            len: usize,
        ) -> core::ffi::c_int,
    >,
    pub ndo_dfwd_add_station: ::core::option::Option<
        unsafe extern "C" fn(pdev: *mut net_device, dev: *mut net_device) -> *mut core::ffi::c_void,
    >,
    pub ndo_dfwd_del_station: ::core::option::Option<
        unsafe extern "C" fn(pdev: *mut net_device, priv_: *mut core::ffi::c_void),
    >,
    pub ndo_set_tx_maxrate: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            queue_index: core::ffi::c_int,
            maxrate: u32_,
        ) -> core::ffi::c_int,
    >,
    pub ndo_get_iflink:
        ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> core::ffi::c_int>,
    pub ndo_fill_metadata_dst: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub ndo_set_rx_headroom: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, needed_headroom: core::ffi::c_int),
    >,
    pub ndo_bpf: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, bpf: *mut netdev_bpf) -> core::ffi::c_int,
    >,
    pub ndo_xdp_xmit: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            n: core::ffi::c_int,
            xdp: *mut *mut xdp_frame,
            flags: u32_,
        ) -> core::ffi::c_int,
    >,
    pub ndo_xdp_get_xmit_slave: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, xdp: *mut xdp_buff) -> *mut net_device,
    >,
    pub ndo_xsk_wakeup: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, queue_id: u32_, flags: u32_) -> core::ffi::c_int,
    >,
    pub ndo_get_devlink_port:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> *mut devlink_port>,
    pub ndo_tunnel_ctl: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            p: *mut ip_tunnel_parm,
            cmd: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub ndo_get_peer_dev:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device) -> *mut net_device>,
    pub ndo_fill_forward_path: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut net_device_path_ctx,
            path: *mut net_device_path,
        ) -> core::ffi::c_int,
    >,
    pub ndo_get_tstamp: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            hwtstamps: *const skb_shared_hwtstamps,
            cycles: bool_,
        ) -> ktime_t,
    >,
}
pub const netdev_priv_flags_IFF_802_1Q_VLAN: netdev_priv_flags = 1;
pub const netdev_priv_flags_IFF_EBRIDGE: netdev_priv_flags = 2;
pub const netdev_priv_flags_IFF_BONDING: netdev_priv_flags = 4;
pub const netdev_priv_flags_IFF_ISATAP: netdev_priv_flags = 8;
pub const netdev_priv_flags_IFF_WAN_HDLC: netdev_priv_flags = 16;
pub const netdev_priv_flags_IFF_XMIT_DST_RELEASE: netdev_priv_flags = 32;
pub const netdev_priv_flags_IFF_DONT_BRIDGE: netdev_priv_flags = 64;
pub const netdev_priv_flags_IFF_DISABLE_NETPOLL: netdev_priv_flags = 128;
pub const netdev_priv_flags_IFF_MACVLAN_PORT: netdev_priv_flags = 256;
pub const netdev_priv_flags_IFF_BRIDGE_PORT: netdev_priv_flags = 512;
pub const netdev_priv_flags_IFF_OVS_DATAPATH: netdev_priv_flags = 1024;
pub const netdev_priv_flags_IFF_TX_SKB_SHARING: netdev_priv_flags = 2048;
pub const netdev_priv_flags_IFF_UNICAST_FLT: netdev_priv_flags = 4096;
pub const netdev_priv_flags_IFF_TEAM_PORT: netdev_priv_flags = 8192;
pub const netdev_priv_flags_IFF_SUPP_NOFCS: netdev_priv_flags = 16384;
pub const netdev_priv_flags_IFF_LIVE_ADDR_CHANGE: netdev_priv_flags = 32768;
pub const netdev_priv_flags_IFF_MACVLAN: netdev_priv_flags = 65536;
pub const netdev_priv_flags_IFF_XMIT_DST_RELEASE_PERM: netdev_priv_flags = 131072;
pub const netdev_priv_flags_IFF_L3MDEV_MASTER: netdev_priv_flags = 262144;
pub const netdev_priv_flags_IFF_NO_QUEUE: netdev_priv_flags = 524288;
pub const netdev_priv_flags_IFF_OPENVSWITCH: netdev_priv_flags = 1048576;
pub const netdev_priv_flags_IFF_L3MDEV_SLAVE: netdev_priv_flags = 2097152;
pub const netdev_priv_flags_IFF_TEAM: netdev_priv_flags = 4194304;
pub const netdev_priv_flags_IFF_RXFH_CONFIGURED: netdev_priv_flags = 8388608;
pub const netdev_priv_flags_IFF_PHONY_HEADROOM: netdev_priv_flags = 16777216;
pub const netdev_priv_flags_IFF_MACSEC: netdev_priv_flags = 33554432;
pub const netdev_priv_flags_IFF_NO_RX_HANDLER: netdev_priv_flags = 67108864;
pub const netdev_priv_flags_IFF_FAILOVER: netdev_priv_flags = 134217728;
pub const netdev_priv_flags_IFF_FAILOVER_SLAVE: netdev_priv_flags = 268435456;
pub const netdev_priv_flags_IFF_L3MDEV_RX_HANDLER: netdev_priv_flags = 536870912;
pub const netdev_priv_flags_IFF_LIVE_RENAME_OK: netdev_priv_flags = 1073741824;
pub const netdev_priv_flags_IFF_TX_SKB_NO_LINEAR: netdev_priv_flags = 2147483648;
pub const netdev_priv_flags_IFF_CHANGE_PROTO_DOWN: netdev_priv_flags = 4294967296;
pub type netdev_priv_flags = core::ffi::c_ulong;
pub const netdev_ml_priv_type_ML_PRIV_NONE: netdev_ml_priv_type = 0;
pub const netdev_ml_priv_type_ML_PRIV_CAN: netdev_ml_priv_type = 1;
pub type netdev_ml_priv_type = core::ffi::c_uint;
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct net_device {
    pub name: [core::ffi::c_char; 16usize],
    pub name_node: *mut netdev_name_node,
    pub ifalias: *mut dev_ifalias,
    pub mem_end: core::ffi::c_ulong,
    pub mem_start: core::ffi::c_ulong,
    pub base_addr: core::ffi::c_ulong,
    pub state: core::ffi::c_ulong,
    pub dev_list: list_head,
    pub napi_list: list_head,
    pub unreg_list: list_head,
    pub close_list: list_head,
    pub ptype_all: list_head,
    pub ptype_specific: list_head,
    pub adj_list: net_device__bindgen_ty_1,
    pub flags: core::ffi::c_uint,
    pub priv_flags: core::ffi::c_ulonglong,
    pub netdev_ops: *const net_device_ops,
    pub ifindex: core::ffi::c_int,
    pub gflags: core::ffi::c_ushort,
    pub hard_header_len: core::ffi::c_ushort,
    pub mtu: core::ffi::c_uint,
    pub needed_headroom: core::ffi::c_ushort,
    pub needed_tailroom: core::ffi::c_ushort,
    pub features: netdev_features_t,
    pub hw_features: netdev_features_t,
    pub wanted_features: netdev_features_t,
    pub vlan_features: netdev_features_t,
    pub hw_enc_features: netdev_features_t,
    pub mpls_features: netdev_features_t,
    pub gso_partial_features: netdev_features_t,
    pub min_mtu: core::ffi::c_uint,
    pub max_mtu: core::ffi::c_uint,
    pub type_: core::ffi::c_ushort,
    pub min_header_len: core::ffi::c_uchar,
    pub name_assign_type: core::ffi::c_uchar,
    pub group: core::ffi::c_int,
    pub stats: net_device_stats,
    pub core_stats: *mut net_device_core_stats,
    pub carrier_up_count: atomic_t,
    pub carrier_down_count: atomic_t,
    pub ethtool_ops: *const ethtool_ops,
    pub l3mdev_ops: *const l3mdev_ops,
    pub ndisc_ops: *const ndisc_ops,
    pub header_ops: *const header_ops,
    pub operstate: core::ffi::c_uchar,
    pub link_mode: core::ffi::c_uchar,
    pub if_port: core::ffi::c_uchar,
    pub dma: core::ffi::c_uchar,
    pub perm_addr: [core::ffi::c_uchar; 32usize],
    pub addr_assign_type: core::ffi::c_uchar,
    pub addr_len: core::ffi::c_uchar,
    pub upper_level: core::ffi::c_uchar,
    pub lower_level: core::ffi::c_uchar,
    pub neigh_priv_len: core::ffi::c_ushort,
    pub dev_id: core::ffi::c_ushort,
    pub dev_port: core::ffi::c_ushort,
    pub padded: core::ffi::c_ushort,
    pub addr_list_lock: spinlock_t,
    pub irq: core::ffi::c_int,
    pub uc: netdev_hw_addr_list,
    pub mc: netdev_hw_addr_list,
    pub dev_addrs: netdev_hw_addr_list,
    pub queues_kset: *mut kset,
    pub promiscuity: core::ffi::c_uint,
    pub allmulti: core::ffi::c_uint,
    pub uc_promisc: bool_,
    pub ip_ptr: *mut in_device,
    pub ip6_ptr: *mut inet6_dev,
    pub vlan_info: *mut vlan_info,
    pub dev_addr: *const core::ffi::c_uchar,
    pub _rx: *mut netdev_rx_queue,
    pub num_rx_queues: core::ffi::c_uint,
    pub real_num_rx_queues: core::ffi::c_uint,
    pub xdp_prog: *mut bpf_prog,
    pub gro_flush_timeout: core::ffi::c_ulong,
    pub napi_defer_hard_irqs: core::ffi::c_int,
    pub gro_max_size: core::ffi::c_uint,
    pub rx_handler: rx_handler_func_t,
    pub rx_handler_data: *mut core::ffi::c_void,
    pub ingress_queue: *mut netdev_queue,
    pub nf_hooks_ingress: *mut nf_hook_entries,
    pub broadcast: [core::ffi::c_uchar; 32usize],
    pub rx_cpu_rmap: *mut cpu_rmap,
    pub index_hlist: hlist_node,
    pub _tx: *mut netdev_queue,
    pub num_tx_queues: core::ffi::c_uint,
    pub real_num_tx_queues: core::ffi::c_uint,
    pub qdisc: *mut Qdisc,
    pub tx_queue_len: core::ffi::c_uint,
    pub tx_global_lock: spinlock_t,
    pub xdp_bulkq: *mut xdp_dev_bulk_queue,
    pub xps_maps: [*mut xps_dev_maps; 2usize],
    pub nf_hooks_egress: *mut nf_hook_entries,
    pub qdisc_hash: [hlist_head; 16usize],
    pub watchdog_timer: timer_list,
    pub watchdog_timeo: core::ffi::c_int,
    pub proto_down_reason: u32_,
    pub todo_list: list_head,
    pub pcpu_refcnt: *mut core::ffi::c_int,
    pub refcnt_tracker: ref_tracker_dir,
    pub link_watch_list: list_head,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub dismantle: bool_,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub needs_free_netdev: bool_,
    pub priv_destructor: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub nd_net: possible_net_t,
    pub ml_priv: *mut core::ffi::c_void,
    pub ml_priv_type: netdev_ml_priv_type,
    pub __bindgen_anon_1: net_device__bindgen_ty_4,
    pub dev: device,
    pub sysfs_groups: [*const attribute_group; 4usize],
    pub sysfs_rx_queue_group: *const attribute_group,
    pub rtnl_link_ops: *const rtnl_link_ops,
    pub gso_max_size: core::ffi::c_uint,
    pub tso_max_size: core::ffi::c_uint,
    pub gso_max_segs: u16_,
    pub tso_max_segs: u16_,
    pub num_tc: s16,
    pub tc_to_txq: [netdev_tc_txq; 16usize],
    pub prio_tc_map: [u8_; 16usize],
    pub priomap: *mut netprio_map,
    pub phydev: *mut phy_device,
    pub sfp_bus: *mut sfp_bus,
    pub qdisc_tx_busylock: *mut lock_class_key,
    pub proto_down: bool_,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub net_notifier_list: list_head,
    pub udp_tunnel_nic_info: *const udp_tunnel_nic_info,
    pub udp_tunnel_nic: *mut udp_tunnel_nic,
    pub xdp_state: [bpf_xdp_entity; 3usize],
    pub dev_addr_shadow: [u8_; 32usize],
    pub linkwatch_dev_tracker: netdevice_tracker,
    pub watchdog_dev_tracker: netdevice_tracker,
    pub dev_registered_tracker: netdevice_tracker,
    pub offload_xstats_l3: *mut rtnl_hw_stats64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_device__bindgen_ty_1 {
    pub upper: list_head,
    pub lower: list_head,
}
impl Default for net_device__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const net_device_NETREG_UNINITIALIZED: core::ffi::c_uint = 0;
pub const net_device_NETREG_REGISTERED: core::ffi::c_uint = 1;
pub const net_device_NETREG_UNREGISTERING: core::ffi::c_uint = 2;
pub const net_device_NETREG_UNREGISTERED: core::ffi::c_uint = 3;
pub const net_device_NETREG_RELEASED: core::ffi::c_uint = 4;
pub const net_device_NETREG_DUMMY: core::ffi::c_uint = 5;
pub type net_device__bindgen_ty_2 = core::ffi::c_uint;
pub const net_device_RTNL_LINK_INITIALIZED: core::ffi::c_uint = 0;
pub const net_device_RTNL_LINK_INITIALIZING: core::ffi::c_uint = 1;
pub type net_device__bindgen_ty_3 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union net_device__bindgen_ty_4 {
    pub lstats: *mut pcpu_lstats,
    pub tstats: *mut pcpu_sw_netstats,
    pub dstats: *mut pcpu_dstats,
    _bindgen_union_align: u64,
}
impl Default for net_device__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for net_device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl net_device {
    #[inline]
    pub fn reg_state(&self) -> net_device__bindgen_ty_2 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_reg_state(&mut self, val: net_device__bindgen_ty_2) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reg_state: net_device__bindgen_ty_2,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let reg_state: u32 = unsafe { ::core::mem::transmute(reg_state) };
            reg_state as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn rtnl_link_state(&self) -> net_device__bindgen_ty_3 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_rtnl_link_state(&mut self, val: net_device__bindgen_ty_3) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        rtnl_link_state: net_device__bindgen_ty_3,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let rtnl_link_state: u32 = unsafe { ::core::mem::transmute(rtnl_link_state) };
            rtnl_link_state as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn wol_enabled(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_wol_enabled(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn threaded(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_threaded(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_3.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        wol_enabled: core::ffi::c_uint,
        threaded: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let wol_enabled: u32 = unsafe { ::core::mem::transmute(wol_enabled) };
            wol_enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let threaded: u32 = unsafe { ::core::mem::transmute(threaded) };
            threaded as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn netdev_txq_to_tc(dev: *mut net_device, txq: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_reset_tc(dev: *mut net_device);
}
extern "C" {
    pub fn netdev_set_tc_queue(
        dev: *mut net_device,
        tc: u8_,
        count: u16_,
        offset: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_set_num_tc(dev: *mut net_device, num_tc: u8_) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_unbind_sb_channel(dev: *mut net_device, sb_dev: *mut net_device);
}
extern "C" {
    pub fn netdev_bind_sb_channel_queue(
        dev: *mut net_device,
        sb_dev: *mut net_device,
        tc: u8_,
        count: u16_,
        offset: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_set_sb_channel(dev: *mut net_device, channel: u16_) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_pick_tx(dev: *mut net_device, skb: *mut sk_buff, sb_dev: *mut net_device)
        -> u16_;
}
extern "C" {
    pub fn netdev_core_pick_tx(
        dev: *mut net_device,
        skb: *mut sk_buff,
        sb_dev: *mut net_device,
    ) -> *mut netdev_queue;
}
extern "C" {
    pub fn netif_napi_add_weight(
        dev: *mut net_device,
        napi: *mut napi_struct,
        poll: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut napi_struct,
                arg2: core::ffi::c_int,
            ) -> core::ffi::c_int,
        >,
        weight: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __netif_napi_del(napi: *mut napi_struct);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct packet_type {
    pub type_: __be16,
    pub ignore_outgoing: bool_,
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub func: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *mut net_device,
            arg3: *mut packet_type,
            arg4: *mut net_device,
        ) -> core::ffi::c_int,
    >,
    pub list_func: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut list_head, arg2: *mut packet_type, arg3: *mut net_device),
    >,
    pub id_match: ::core::option::Option<
        unsafe extern "C" fn(ptype: *mut packet_type, sk: *mut sock) -> bool_,
    >,
    pub af_packet_net: *mut net,
    pub af_packet_priv: *mut core::ffi::c_void,
    pub list: list_head,
}
impl Default for packet_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct offload_callbacks {
    pub gso_segment: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, features: netdev_features_t) -> *mut sk_buff,
    >,
    pub gro_receive: ::core::option::Option<
        unsafe extern "C" fn(head: *mut list_head, skb: *mut sk_buff) -> *mut sk_buff,
    >,
    pub gro_complete: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, nhoff: core::ffi::c_int) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct packet_offload {
    pub type_: __be16,
    pub priority: u16_,
    pub callbacks: offload_callbacks,
    pub list: list_head,
}
impl Default for packet_offload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Default, Copy, Clone)]
pub struct pcpu_sw_netstats {
    pub rx_packets: u64_stats_t,
    pub rx_bytes: u64_stats_t,
    pub tx_packets: u64_stats_t,
    pub tx_bytes: u64_stats_t,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Default, Copy, Clone)]
pub struct pcpu_lstats {
    pub packets: u64_stats_t,
    pub bytes: u64_stats_t,
    pub syncp: u64_stats_sync,
}
extern "C" {
    pub fn dev_lstats_read(dev: *mut net_device, packets: *mut u64_, bytes: *mut u64_);
}
pub const netdev_lag_tx_type_NETDEV_LAG_TX_TYPE_UNKNOWN: netdev_lag_tx_type = 0;
pub const netdev_lag_tx_type_NETDEV_LAG_TX_TYPE_RANDOM: netdev_lag_tx_type = 1;
pub const netdev_lag_tx_type_NETDEV_LAG_TX_TYPE_BROADCAST: netdev_lag_tx_type = 2;
pub const netdev_lag_tx_type_NETDEV_LAG_TX_TYPE_ROUNDROBIN: netdev_lag_tx_type = 3;
pub const netdev_lag_tx_type_NETDEV_LAG_TX_TYPE_ACTIVEBACKUP: netdev_lag_tx_type = 4;
pub const netdev_lag_tx_type_NETDEV_LAG_TX_TYPE_HASH: netdev_lag_tx_type = 5;
pub type netdev_lag_tx_type = core::ffi::c_uint;
pub const netdev_lag_hash_NETDEV_LAG_HASH_NONE: netdev_lag_hash = 0;
pub const netdev_lag_hash_NETDEV_LAG_HASH_L2: netdev_lag_hash = 1;
pub const netdev_lag_hash_NETDEV_LAG_HASH_L34: netdev_lag_hash = 2;
pub const netdev_lag_hash_NETDEV_LAG_HASH_L23: netdev_lag_hash = 3;
pub const netdev_lag_hash_NETDEV_LAG_HASH_E23: netdev_lag_hash = 4;
pub const netdev_lag_hash_NETDEV_LAG_HASH_E34: netdev_lag_hash = 5;
pub const netdev_lag_hash_NETDEV_LAG_HASH_VLAN_SRCMAC: netdev_lag_hash = 6;
pub const netdev_lag_hash_NETDEV_LAG_HASH_UNKNOWN: netdev_lag_hash = 7;
pub type netdev_lag_hash = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_lag_upper_info {
    pub tx_type: netdev_lag_tx_type,
    pub hash_type: netdev_lag_hash,
}
impl Default for netdev_lag_upper_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct netdev_lag_lower_state_info {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
impl netdev_lag_lower_state_info {
    #[inline]
    pub fn link_up(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_link_up(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tx_enabled(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tx_enabled(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        link_up: u8_,
        tx_enabled: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let link_up: u8 = unsafe { ::core::mem::transmute(link_up) };
            link_up as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tx_enabled: u8 = unsafe { ::core::mem::transmute(tx_enabled) };
            tx_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const netdev_cmd_NETDEV_UP: netdev_cmd = 1;
pub const netdev_cmd_NETDEV_DOWN: netdev_cmd = 2;
pub const netdev_cmd_NETDEV_REBOOT: netdev_cmd = 3;
pub const netdev_cmd_NETDEV_CHANGE: netdev_cmd = 4;
pub const netdev_cmd_NETDEV_REGISTER: netdev_cmd = 5;
pub const netdev_cmd_NETDEV_UNREGISTER: netdev_cmd = 6;
pub const netdev_cmd_NETDEV_CHANGEMTU: netdev_cmd = 7;
pub const netdev_cmd_NETDEV_CHANGEADDR: netdev_cmd = 8;
pub const netdev_cmd_NETDEV_PRE_CHANGEADDR: netdev_cmd = 9;
pub const netdev_cmd_NETDEV_GOING_DOWN: netdev_cmd = 10;
pub const netdev_cmd_NETDEV_CHANGENAME: netdev_cmd = 11;
pub const netdev_cmd_NETDEV_FEAT_CHANGE: netdev_cmd = 12;
pub const netdev_cmd_NETDEV_BONDING_FAILOVER: netdev_cmd = 13;
pub const netdev_cmd_NETDEV_PRE_UP: netdev_cmd = 14;
pub const netdev_cmd_NETDEV_PRE_TYPE_CHANGE: netdev_cmd = 15;
pub const netdev_cmd_NETDEV_POST_TYPE_CHANGE: netdev_cmd = 16;
pub const netdev_cmd_NETDEV_POST_INIT: netdev_cmd = 17;
pub const netdev_cmd_NETDEV_RELEASE: netdev_cmd = 18;
pub const netdev_cmd_NETDEV_NOTIFY_PEERS: netdev_cmd = 19;
pub const netdev_cmd_NETDEV_JOIN: netdev_cmd = 20;
pub const netdev_cmd_NETDEV_CHANGEUPPER: netdev_cmd = 21;
pub const netdev_cmd_NETDEV_RESEND_IGMP: netdev_cmd = 22;
pub const netdev_cmd_NETDEV_PRECHANGEMTU: netdev_cmd = 23;
pub const netdev_cmd_NETDEV_CHANGEINFODATA: netdev_cmd = 24;
pub const netdev_cmd_NETDEV_BONDING_INFO: netdev_cmd = 25;
pub const netdev_cmd_NETDEV_PRECHANGEUPPER: netdev_cmd = 26;
pub const netdev_cmd_NETDEV_CHANGELOWERSTATE: netdev_cmd = 27;
pub const netdev_cmd_NETDEV_UDP_TUNNEL_PUSH_INFO: netdev_cmd = 28;
pub const netdev_cmd_NETDEV_UDP_TUNNEL_DROP_INFO: netdev_cmd = 29;
pub const netdev_cmd_NETDEV_CHANGE_TX_QUEUE_LEN: netdev_cmd = 30;
pub const netdev_cmd_NETDEV_CVLAN_FILTER_PUSH_INFO: netdev_cmd = 31;
pub const netdev_cmd_NETDEV_CVLAN_FILTER_DROP_INFO: netdev_cmd = 32;
pub const netdev_cmd_NETDEV_SVLAN_FILTER_PUSH_INFO: netdev_cmd = 33;
pub const netdev_cmd_NETDEV_SVLAN_FILTER_DROP_INFO: netdev_cmd = 34;
pub const netdev_cmd_NETDEV_OFFLOAD_XSTATS_ENABLE: netdev_cmd = 35;
pub const netdev_cmd_NETDEV_OFFLOAD_XSTATS_DISABLE: netdev_cmd = 36;
pub const netdev_cmd_NETDEV_OFFLOAD_XSTATS_REPORT_USED: netdev_cmd = 37;
pub const netdev_cmd_NETDEV_OFFLOAD_XSTATS_REPORT_DELTA: netdev_cmd = 38;
pub type netdev_cmd = core::ffi::c_uint;
extern "C" {
    pub fn netdev_cmd_to_name(cmd: netdev_cmd) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn register_netdevice_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_netdevice_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn register_netdevice_notifier_net(
        net: *mut net,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_netdevice_notifier_net(
        net: *mut net,
        nb: *mut notifier_block,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn register_netdevice_notifier_dev_net(
        dev: *mut net_device,
        nb: *mut notifier_block,
        nn: *mut netdev_net_notifier,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_netdevice_notifier_dev_net(
        dev: *mut net_device,
        nb: *mut notifier_block,
        nn: *mut netdev_net_notifier,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_notifier_info {
    pub dev: *mut net_device,
    pub extack: *mut netlink_ext_ack,
}
impl Default for netdev_notifier_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_notifier_info_ext {
    pub info: netdev_notifier_info,
    pub ext: netdev_notifier_info_ext__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netdev_notifier_info_ext__bindgen_ty_1 {
    pub mtu: u32_,
    _bindgen_union_align: u32,
}
impl Default for netdev_notifier_info_ext__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for netdev_notifier_info_ext {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_notifier_change_info {
    pub info: netdev_notifier_info,
    pub flags_changed: core::ffi::c_uint,
}
impl Default for netdev_notifier_change_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_notifier_changeupper_info {
    pub info: netdev_notifier_info,
    pub upper_dev: *mut net_device,
    pub master: bool_,
    pub linking: bool_,
    pub upper_info: *mut core::ffi::c_void,
}
impl Default for netdev_notifier_changeupper_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_notifier_changelowerstate_info {
    pub info: netdev_notifier_info,
    pub lower_state_info: *mut core::ffi::c_void,
}
impl Default for netdev_notifier_changelowerstate_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_notifier_pre_changeaddr_info {
    pub info: netdev_notifier_info,
    pub dev_addr: *const core::ffi::c_uchar,
}
impl Default for netdev_notifier_pre_changeaddr_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const netdev_offload_xstats_type_NETDEV_OFFLOAD_XSTATS_TYPE_L3: netdev_offload_xstats_type = 1;
pub type netdev_offload_xstats_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_notifier_offload_xstats_info {
    pub info: netdev_notifier_info,
    pub type_: netdev_offload_xstats_type,
    pub __bindgen_anon_1: netdev_notifier_offload_xstats_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union netdev_notifier_offload_xstats_info__bindgen_ty_1 {
    pub report_delta: *mut netdev_notifier_offload_xstats_rd,
    pub report_used: *mut netdev_notifier_offload_xstats_ru,
    _bindgen_union_align: u64,
}
impl Default for netdev_notifier_offload_xstats_info__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for netdev_notifier_offload_xstats_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn netdev_offload_xstats_enable(
        dev: *mut net_device,
        type_: netdev_offload_xstats_type,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_offload_xstats_disable(
        dev: *mut net_device,
        type_: netdev_offload_xstats_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_offload_xstats_enabled(
        dev: *const net_device,
        type_: netdev_offload_xstats_type,
    ) -> bool_;
}
extern "C" {
    pub fn netdev_offload_xstats_get(
        dev: *mut net_device,
        type_: netdev_offload_xstats_type,
        stats: *mut rtnl_hw_stats64,
        used: *mut bool_,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_offload_xstats_report_delta(
        rd: *mut netdev_notifier_offload_xstats_rd,
        stats: *const rtnl_hw_stats64,
    );
}
extern "C" {
    pub fn netdev_offload_xstats_report_used(ru: *mut netdev_notifier_offload_xstats_ru);
}
extern "C" {
    pub fn netdev_offload_xstats_push_delta(
        dev: *mut net_device,
        type_: netdev_offload_xstats_type,
        stats: *const rtnl_hw_stats64,
    );
}
extern "C" {
    pub fn call_netdevice_notifiers(
        val: core::ffi::c_ulong,
        dev: *mut net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut dev_base_lock: rwlock_t;
}
extern "C" {
    pub fn netdev_boot_setup_check(dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_getbyhwaddr_rcu(
        net: *mut net,
        type_: core::ffi::c_ushort,
        hwaddr: *const core::ffi::c_char,
    ) -> *mut net_device;
}
extern "C" {
    pub fn dev_getfirstbyhwtype(net: *mut net, type_: core::ffi::c_ushort) -> *mut net_device;
}
extern "C" {
    pub fn dev_add_pack(pt: *mut packet_type);
}
extern "C" {
    pub fn dev_remove_pack(pt: *mut packet_type);
}
extern "C" {
    pub fn __dev_remove_pack(pt: *mut packet_type);
}
extern "C" {
    pub fn dev_add_offload(po: *mut packet_offload);
}
extern "C" {
    pub fn dev_remove_offload(po: *mut packet_offload);
}
extern "C" {
    pub fn dev_get_iflink(dev: *const net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_fill_metadata_dst(dev: *mut net_device, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_fill_forward_path(
        dev: *const net_device,
        daddr: *const u8_,
        stack: *mut net_device_path_stack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __dev_get_by_flags(
        net: *mut net,
        flags: core::ffi::c_ushort,
        mask: core::ffi::c_ushort,
    ) -> *mut net_device;
}
extern "C" {
    pub fn dev_get_by_name(net: *mut net, name: *const core::ffi::c_char) -> *mut net_device;
}
extern "C" {
    pub fn dev_get_by_name_rcu(net: *mut net, name: *const core::ffi::c_char) -> *mut net_device;
}
extern "C" {
    pub fn __dev_get_by_name(net: *mut net, name: *const core::ffi::c_char) -> *mut net_device;
}
extern "C" {
    pub fn netdev_name_in_use(net: *mut net, name: *const core::ffi::c_char) -> bool_;
}
extern "C" {
    pub fn dev_alloc_name(dev: *mut net_device, name: *const core::ffi::c_char)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_open(dev: *mut net_device, extack: *mut netlink_ext_ack) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_close(dev: *mut net_device);
}
extern "C" {
    pub fn dev_close_many(head: *mut list_head, unlink: bool_);
}
extern "C" {
    pub fn dev_disable_lro(dev: *mut net_device);
}
extern "C" {
    pub fn dev_loopback_xmit(
        net: *mut net,
        sk: *mut sock,
        newskb: *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_pick_tx_zero(
        dev: *mut net_device,
        skb: *mut sk_buff,
        sb_dev: *mut net_device,
    ) -> u16_;
}
extern "C" {
    pub fn dev_pick_tx_cpu_id(
        dev: *mut net_device,
        skb: *mut sk_buff,
        sb_dev: *mut net_device,
    ) -> u16_;
}
extern "C" {
    pub fn __dev_queue_xmit(skb: *mut sk_buff, sb_dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn __dev_direct_xmit(skb: *mut sk_buff, queue_id: u16_) -> core::ffi::c_int;
}
extern "C" {
    pub fn register_netdevice(dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_netdevice_queue(dev: *mut net_device, head: *mut list_head);
}
extern "C" {
    pub fn unregister_netdevice_many(head: *mut list_head);
}
extern "C" {
    pub fn netdev_refcnt_read(dev: *const net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn free_netdev(dev: *mut net_device);
}
extern "C" {
    pub fn netdev_freemem(dev: *mut net_device);
}
extern "C" {
    pub fn init_dummy_netdev(dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_get_xmit_slave(
        dev: *mut net_device,
        skb: *mut sk_buff,
        all_slaves: bool_,
    ) -> *mut net_device;
}
extern "C" {
    pub fn netdev_sk_get_lowest_dev(dev: *mut net_device, sk: *mut sock) -> *mut net_device;
}
extern "C" {
    pub fn dev_get_by_index(net: *mut net, ifindex: core::ffi::c_int) -> *mut net_device;
}
extern "C" {
    pub fn __dev_get_by_index(net: *mut net, ifindex: core::ffi::c_int) -> *mut net_device;
}
extern "C" {
    pub fn dev_get_by_index_rcu(net: *mut net, ifindex: core::ffi::c_int) -> *mut net_device;
}
extern "C" {
    pub fn dev_get_by_napi_id(napi_id: core::ffi::c_uint) -> *mut net_device;
}
extern "C" {
    pub fn dev_restart(dev: *mut net_device) -> core::ffi::c_int;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct softnet_data {
    pub poll_list: list_head,
    pub process_queue: sk_buff_head,
    pub processed: core::ffi::c_uint,
    pub time_squeeze: core::ffi::c_uint,
    pub received_rps: core::ffi::c_uint,
    pub rps_ipi_list: *mut softnet_data,
    pub flow_limit: *mut sd_flow_limit,
    pub output_queue: *mut Qdisc,
    pub output_queue_tailp: *mut *mut Qdisc,
    pub completion_queue: *mut sk_buff,
    pub xmit: softnet_data__bindgen_ty_1,
    pub __bindgen_padding_0: u32,
    pub input_queue_head: core::ffi::c_uint,
    pub __bindgen_padding_1: [u64; 7usize],
    pub csd: call_single_data_t,
    pub rps_ipi_next: *mut softnet_data,
    pub cpu: core::ffi::c_uint,
    pub input_queue_tail: core::ffi::c_uint,
    pub dropped: core::ffi::c_uint,
    pub input_pkt_queue: sk_buff_head,
    pub backlog: napi_struct,
    pub __bindgen_padding_2: [u64; 2usize],
    pub defer_lock: spinlock_t,
    pub defer_count: core::ffi::c_int,
    pub defer_ipi_scheduled: core::ffi::c_int,
    pub defer_list: *mut sk_buff,
    pub __bindgen_padding_3: [u64; 3usize],
    pub defer_csd: call_single_data_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct softnet_data__bindgen_ty_1 {
    pub recursion: u16_,
    pub more: u8_,
    pub skip_txqueue: u8_,
}
impl Default for softnet_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut softnet_data: softnet_data;
}
extern "C" {
    pub fn __netif_schedule(q: *mut Qdisc);
}
extern "C" {
    pub fn netif_schedule_queue(txq: *mut netdev_queue);
}
extern "C" {
    pub fn netif_tx_wake_queue(dev_queue: *mut netdev_queue);
}
extern "C" {
    pub fn netif_tx_stop_all_queues(dev: *mut net_device);
}
extern "C" {
    pub fn netif_set_xps_queue(
        dev: *mut net_device,
        mask: *const cpumask,
        index: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __netif_set_xps_queue(
        dev: *mut net_device,
        mask: *const core::ffi::c_ulong,
        index: u16_,
        type_: xps_map_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netif_set_real_num_tx_queues(
        dev: *mut net_device,
        txq: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netif_set_real_num_rx_queues(
        dev: *mut net_device,
        rxq: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netif_set_real_num_queues(
        dev: *mut net_device,
        txq: core::ffi::c_uint,
        rxq: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netif_get_num_default_rss_queues() -> core::ffi::c_int;
}
pub const skb_free_reason_SKB_REASON_CONSUMED: skb_free_reason = 0;
pub const skb_free_reason_SKB_REASON_DROPPED: skb_free_reason = 1;
pub type skb_free_reason = core::ffi::c_uint;
extern "C" {
    pub fn __dev_kfree_skb_irq(skb: *mut sk_buff, reason: skb_free_reason);
}
extern "C" {
    pub fn __dev_kfree_skb_any(skb: *mut sk_buff, reason: skb_free_reason);
}
extern "C" {
    pub fn bpf_prog_run_generic_xdp(
        skb: *mut sk_buff,
        xdp: *mut xdp_buff,
        xdp_prog: *mut bpf_prog,
    ) -> u32_;
}
extern "C" {
    pub fn generic_xdp_tx(skb: *mut sk_buff, xdp_prog: *mut bpf_prog);
}
extern "C" {
    pub fn do_xdp_generic(xdp_prog: *mut bpf_prog, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn netif_rx(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn __netif_rx(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn netif_receive_skb(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn netif_receive_skb_core(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn netif_receive_skb_list_internal(head: *mut list_head);
}
extern "C" {
    pub fn netif_receive_skb_list(head: *mut list_head);
}
extern "C" {
    pub fn napi_gro_receive(napi: *mut napi_struct, skb: *mut sk_buff) -> gro_result_t;
}
extern "C" {
    pub fn napi_gro_flush(napi: *mut napi_struct, flush_old: bool_);
}
extern "C" {
    pub fn napi_get_frags(napi: *mut napi_struct) -> *mut sk_buff;
}
extern "C" {
    pub fn napi_get_frags_check(napi: *mut napi_struct);
}
extern "C" {
    pub fn napi_gro_frags(napi: *mut napi_struct) -> gro_result_t;
}
extern "C" {
    pub fn gro_find_receive_by_type(type_: __be16) -> *mut packet_offload;
}
extern "C" {
    pub fn gro_find_complete_by_type(type_: __be16) -> *mut packet_offload;
}
extern "C" {
    pub fn netdev_is_rx_handler_busy(dev: *mut net_device) -> bool_;
}
extern "C" {
    pub fn netdev_rx_handler_register(
        dev: *mut net_device,
        rx_handler: rx_handler_func_t,
        rx_handler_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_rx_handler_unregister(dev: *mut net_device);
}
extern "C" {
    pub fn dev_valid_name(name: *const core::ffi::c_char) -> bool_;
}
extern "C" {
    pub fn get_user_ifreq(
        ifr: *mut ifreq,
        ifrdata: *mut *mut core::ffi::c_void,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn put_user_ifreq(ifr: *mut ifreq, arg: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_ioctl(
        net: *mut net,
        cmd: core::ffi::c_uint,
        ifr: *mut ifreq,
        data: *mut core::ffi::c_void,
        need_copyout: *mut bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_ifconf(net: *mut net, ifc: *mut ifconf) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_ethtool(
        net: *mut net,
        ifr: *mut ifreq,
        userdata: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_get_flags(arg1: *const net_device) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __dev_change_flags(
        dev: *mut net_device,
        flags: core::ffi::c_uint,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_change_flags(
        dev: *mut net_device,
        flags: core::ffi::c_uint,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __dev_notify_flags(
        arg1: *mut net_device,
        old_flags: core::ffi::c_uint,
        gchanges: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn dev_set_alias(
        arg1: *mut net_device,
        arg2: *const core::ffi::c_char,
        arg3: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_get_alias(
        arg1: *const net_device,
        arg2: *mut core::ffi::c_char,
        arg3: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __dev_change_net_namespace(
        dev: *mut net_device,
        net: *mut net,
        pat: *const core::ffi::c_char,
        new_ifindex: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __dev_set_mtu(arg1: *mut net_device, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_set_mtu(arg1: *mut net_device, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_pre_changeaddr_notify(
        dev: *mut net_device,
        addr: *const core::ffi::c_char,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_set_mac_address(
        dev: *mut net_device,
        sa: *mut sockaddr,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_set_mac_address_user(
        dev: *mut net_device,
        sa: *mut sockaddr,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_get_mac_address(
        sa: *mut sockaddr,
        net: *mut net,
        dev_name: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_get_port_parent_id(
        dev: *mut net_device,
        ppid: *mut netdev_phys_item_id,
        recurse: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_port_same_parent_id(a: *mut net_device, b: *mut net_device) -> bool_;
}
extern "C" {
    pub fn validate_xmit_skb_list(
        skb: *mut sk_buff,
        dev: *mut net_device,
        again: *mut bool_,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn dev_hard_start_xmit(
        skb: *mut sk_buff,
        dev: *mut net_device,
        txq: *mut netdev_queue,
        ret: *mut core::ffi::c_int,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn bpf_xdp_link_attach(attr: *const bpf_attr, prog: *mut bpf_prog) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_xdp_prog_count(dev: *mut net_device) -> u8_;
}
extern "C" {
    pub fn dev_xdp_prog_id(dev: *mut net_device, mode: bpf_xdp_mode) -> u32_;
}
extern "C" {
    pub fn __dev_forward_skb(dev: *mut net_device, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_forward_skb(dev: *mut net_device, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_forward_skb_nomtu(dev: *mut net_device, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn is_skb_forwardable(dev: *const net_device, skb: *const sk_buff) -> bool_;
}
extern "C" {
    pub fn netdev_core_stats_alloc(dev: *mut net_device) -> *mut net_device_core_stats;
}
extern "C" {
    pub fn dev_nit_active(dev: *mut net_device) -> bool_;
}
extern "C" {
    pub fn dev_queue_xmit_nit(skb: *mut sk_buff, dev: *mut net_device);
}
extern "C" {
    pub fn linkwatch_fire_event(dev: *mut net_device);
}
extern "C" {
    pub fn dev_trans_start(dev: *mut net_device) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __netdev_watchdog_up(dev: *mut net_device);
}
extern "C" {
    pub fn netif_carrier_on(dev: *mut net_device);
}
extern "C" {
    pub fn netif_carrier_off(dev: *mut net_device);
}
extern "C" {
    pub fn netif_carrier_event(dev: *mut net_device);
}
extern "C" {
    pub fn netif_device_detach(dev: *mut net_device);
}
extern "C" {
    pub fn netif_device_attach(dev: *mut net_device);
}
pub const NETIF_MSG_DRV_BIT: core::ffi::c_uint = 0;
pub const NETIF_MSG_PROBE_BIT: core::ffi::c_uint = 1;
pub const NETIF_MSG_LINK_BIT: core::ffi::c_uint = 2;
pub const NETIF_MSG_TIMER_BIT: core::ffi::c_uint = 3;
pub const NETIF_MSG_IFDOWN_BIT: core::ffi::c_uint = 4;
pub const NETIF_MSG_IFUP_BIT: core::ffi::c_uint = 5;
pub const NETIF_MSG_RX_ERR_BIT: core::ffi::c_uint = 6;
pub const NETIF_MSG_TX_ERR_BIT: core::ffi::c_uint = 7;
pub const NETIF_MSG_TX_QUEUED_BIT: core::ffi::c_uint = 8;
pub const NETIF_MSG_INTR_BIT: core::ffi::c_uint = 9;
pub const NETIF_MSG_TX_DONE_BIT: core::ffi::c_uint = 10;
pub const NETIF_MSG_RX_STATUS_BIT: core::ffi::c_uint = 11;
pub const NETIF_MSG_PKTDATA_BIT: core::ffi::c_uint = 12;
pub const NETIF_MSG_HW_BIT: core::ffi::c_uint = 13;
pub const NETIF_MSG_WOL_BIT: core::ffi::c_uint = 14;
pub const NETIF_MSG_CLASS_COUNT: core::ffi::c_uint = 15;
pub type _bindgen_ty_274 = core::ffi::c_uint;
extern "C" {
    pub fn netif_tx_lock(dev: *mut net_device);
}
extern "C" {
    pub fn netif_tx_unlock(dev: *mut net_device);
}
extern "C" {
    pub fn ether_setup(dev: *mut net_device);
}
extern "C" {
    pub fn alloc_netdev_mqs(
        sizeof_priv: core::ffi::c_int,
        name: *const core::ffi::c_char,
        name_assign_type: core::ffi::c_uchar,
        setup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut net_device)>,
        txqs: core::ffi::c_uint,
        rxqs: core::ffi::c_uint,
    ) -> *mut net_device;
}
extern "C" {
    pub fn register_netdev(dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_netdev(dev: *mut net_device);
}
extern "C" {
    pub fn devm_register_netdev(dev: *mut device, ndev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn __hw_addr_sync(
        to_list: *mut netdev_hw_addr_list,
        from_list: *mut netdev_hw_addr_list,
        addr_len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __hw_addr_unsync(
        to_list: *mut netdev_hw_addr_list,
        from_list: *mut netdev_hw_addr_list,
        addr_len: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __hw_addr_sync_dev(
        list: *mut netdev_hw_addr_list,
        dev: *mut net_device,
        sync: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const core::ffi::c_uchar,
            ) -> core::ffi::c_int,
        >,
        unsync: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const core::ffi::c_uchar,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __hw_addr_ref_sync_dev(
        list: *mut netdev_hw_addr_list,
        dev: *mut net_device,
        sync: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const core::ffi::c_uchar,
                arg3: core::ffi::c_int,
            ) -> core::ffi::c_int,
        >,
        unsync: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const core::ffi::c_uchar,
                arg3: core::ffi::c_int,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __hw_addr_ref_unsync_dev(
        list: *mut netdev_hw_addr_list,
        dev: *mut net_device,
        unsync: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const core::ffi::c_uchar,
                arg3: core::ffi::c_int,
            ) -> core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub fn __hw_addr_unsync_dev(
        list: *mut netdev_hw_addr_list,
        dev: *mut net_device,
        unsync: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net_device,
                arg2: *const core::ffi::c_uchar,
            ) -> core::ffi::c_int,
        >,
    );
}
extern "C" {
    pub fn __hw_addr_init(list: *mut netdev_hw_addr_list);
}
extern "C" {
    pub fn dev_addr_mod(
        dev: *mut net_device,
        offset: core::ffi::c_uint,
        addr: *const core::ffi::c_void,
        len: usize,
    );
}
extern "C" {
    pub fn dev_addr_add(
        dev: *mut net_device,
        addr: *const core::ffi::c_uchar,
        addr_type: core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_addr_del(
        dev: *mut net_device,
        addr: *const core::ffi::c_uchar,
        addr_type: core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_uc_add(dev: *mut net_device, addr: *const core::ffi::c_uchar) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_uc_add_excl(
        dev: *mut net_device,
        addr: *const core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_uc_del(dev: *mut net_device, addr: *const core::ffi::c_uchar) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_uc_sync(to: *mut net_device, from: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_uc_sync_multiple(to: *mut net_device, from: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_uc_unsync(to: *mut net_device, from: *mut net_device);
}
extern "C" {
    pub fn dev_uc_flush(dev: *mut net_device);
}
extern "C" {
    pub fn dev_uc_init(dev: *mut net_device);
}
extern "C" {
    pub fn dev_mc_add(dev: *mut net_device, addr: *const core::ffi::c_uchar) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_mc_add_global(
        dev: *mut net_device,
        addr: *const core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_mc_add_excl(
        dev: *mut net_device,
        addr: *const core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_mc_del(dev: *mut net_device, addr: *const core::ffi::c_uchar) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_mc_del_global(
        dev: *mut net_device,
        addr: *const core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_mc_sync(to: *mut net_device, from: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_mc_sync_multiple(to: *mut net_device, from: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_mc_unsync(to: *mut net_device, from: *mut net_device);
}
extern "C" {
    pub fn dev_mc_flush(dev: *mut net_device);
}
extern "C" {
    pub fn dev_mc_init(dev: *mut net_device);
}
extern "C" {
    pub fn dev_set_rx_mode(dev: *mut net_device);
}
extern "C" {
    pub fn dev_set_promiscuity(dev: *mut net_device, inc: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_set_allmulti(dev: *mut net_device, inc: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_state_change(dev: *mut net_device);
}
extern "C" {
    pub fn __netdev_notify_peers(dev: *mut net_device);
}
extern "C" {
    pub fn netdev_notify_peers(dev: *mut net_device);
}
extern "C" {
    pub fn netdev_features_change(dev: *mut net_device);
}
extern "C" {
    pub fn dev_load(net: *mut net, name: *const core::ffi::c_char);
}
extern "C" {
    pub fn dev_get_stats(
        dev: *mut net_device,
        storage: *mut rtnl_link_stats64,
    ) -> *mut rtnl_link_stats64;
}
extern "C" {
    pub fn netdev_stats_to_stats64(
        stats64: *mut rtnl_link_stats64,
        netdev_stats: *const net_device_stats,
    );
}
extern "C" {
    pub fn dev_fetch_sw_netstats(s: *mut rtnl_link_stats64, netstats: *const pcpu_sw_netstats);
}
extern "C" {
    pub fn dev_get_tstats64(dev: *mut net_device, s: *mut rtnl_link_stats64);
}
extern "C" {
    pub static mut netdev_max_backlog: core::ffi::c_int;
}
extern "C" {
    pub static mut dev_rx_weight: core::ffi::c_int;
}
extern "C" {
    pub static mut dev_tx_weight: core::ffi::c_int;
}
extern "C" {
    pub static mut gro_normal_batch: core::ffi::c_int;
}
pub const NESTED_SYNC_IMM_BIT: core::ffi::c_uint = 0;
pub const NESTED_SYNC_TODO_BIT: core::ffi::c_uint = 1;
pub type _bindgen_ty_275 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_nested_priv {
    pub flags: core::ffi::c_uchar,
    pub data: *mut core::ffi::c_void,
}
impl Default for netdev_nested_priv {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn netdev_has_upper_dev(dev: *mut net_device, upper_dev: *mut net_device) -> bool_;
}
extern "C" {
    pub fn netdev_upper_get_next_dev_rcu(
        dev: *mut net_device,
        iter: *mut *mut list_head,
    ) -> *mut net_device;
}
extern "C" {
    pub fn netdev_walk_all_upper_dev_rcu(
        dev: *mut net_device,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                upper_dev: *mut net_device,
                priv_: *mut netdev_nested_priv,
            ) -> core::ffi::c_int,
        >,
        priv_: *mut netdev_nested_priv,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_has_upper_dev_all_rcu(dev: *mut net_device, upper_dev: *mut net_device) -> bool_;
}
extern "C" {
    pub fn netdev_has_any_upper_dev(dev: *mut net_device) -> bool_;
}
extern "C" {
    pub fn netdev_lower_get_next_private(
        dev: *mut net_device,
        iter: *mut *mut list_head,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn netdev_lower_get_next_private_rcu(
        dev: *mut net_device,
        iter: *mut *mut list_head,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn netdev_lower_get_next(
        dev: *mut net_device,
        iter: *mut *mut list_head,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn netdev_next_lower_dev_rcu(
        dev: *mut net_device,
        iter: *mut *mut list_head,
    ) -> *mut net_device;
}
extern "C" {
    pub fn netdev_walk_all_lower_dev(
        dev: *mut net_device,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                lower_dev: *mut net_device,
                priv_: *mut netdev_nested_priv,
            ) -> core::ffi::c_int,
        >,
        priv_: *mut netdev_nested_priv,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_walk_all_lower_dev_rcu(
        dev: *mut net_device,
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                lower_dev: *mut net_device,
                priv_: *mut netdev_nested_priv,
            ) -> core::ffi::c_int,
        >,
        priv_: *mut netdev_nested_priv,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_adjacent_get_private(adj_list: *mut list_head) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn netdev_lower_get_first_private_rcu(dev: *mut net_device) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn netdev_master_upper_dev_get(dev: *mut net_device) -> *mut net_device;
}
extern "C" {
    pub fn netdev_master_upper_dev_get_rcu(dev: *mut net_device) -> *mut net_device;
}
extern "C" {
    pub fn netdev_upper_dev_link(
        dev: *mut net_device,
        upper_dev: *mut net_device,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_master_upper_dev_link(
        dev: *mut net_device,
        upper_dev: *mut net_device,
        upper_priv: *mut core::ffi::c_void,
        upper_info: *mut core::ffi::c_void,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_upper_dev_unlink(dev: *mut net_device, upper_dev: *mut net_device);
}
extern "C" {
    pub fn netdev_adjacent_change_prepare(
        old_dev: *mut net_device,
        new_dev: *mut net_device,
        dev: *mut net_device,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_adjacent_change_commit(
        old_dev: *mut net_device,
        new_dev: *mut net_device,
        dev: *mut net_device,
    );
}
extern "C" {
    pub fn netdev_adjacent_change_abort(
        old_dev: *mut net_device,
        new_dev: *mut net_device,
        dev: *mut net_device,
    );
}
extern "C" {
    pub fn netdev_adjacent_rename_links(dev: *mut net_device, oldname: *mut core::ffi::c_char);
}
extern "C" {
    pub fn netdev_lower_dev_get_private(
        dev: *mut net_device,
        lower_dev: *mut net_device,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn netdev_lower_state_changed(
        lower_dev: *mut net_device,
        lower_state_info: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub static mut netdev_rss_key: [u8_; 52usize];
}
extern "C" {
    pub fn netdev_rss_key_fill(buffer: *mut core::ffi::c_void, len: usize);
}
extern "C" {
    pub fn skb_checksum_help(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_crc32c_csum_help(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn skb_csum_hwoffload_help(
        skb: *mut sk_buff,
        features: netdev_features_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __skb_gso_segment(
        skb: *mut sk_buff,
        features: netdev_features_t,
        tx_path: bool_,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_eth_gso_segment(
        skb: *mut sk_buff,
        features: netdev_features_t,
        type_: __be16,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_mac_gso_segment(skb: *mut sk_buff, features: netdev_features_t) -> *mut sk_buff;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netdev_bonding_info {
    pub slave: ifslave,
    pub master: ifbond,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netdev_notifier_bonding_info {
    pub info: netdev_notifier_info,
    pub bonding_info: netdev_bonding_info,
}
impl Default for netdev_notifier_bonding_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn netdev_bonding_info_change(dev: *mut net_device, bonding_info: *mut netdev_bonding_info);
}
extern "C" {
    pub fn ethtool_notify(
        dev: *mut net_device,
        cmd: core::ffi::c_uint,
        data: *const core::ffi::c_void,
    );
}
extern "C" {
    pub fn skb_network_protocol(skb: *mut sk_buff, depth: *mut core::ffi::c_int) -> __be16;
}
extern "C" {
    pub fn netdev_rx_csum_fault(dev: *mut net_device, skb: *mut sk_buff);
}
extern "C" {
    pub fn net_enable_timestamp();
}
extern "C" {
    pub fn net_disable_timestamp();
}
extern "C" {
    pub fn netdev_class_create_file_ns(
        class_attr: *const class_attribute,
        ns: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_class_remove_file_ns(
        class_attr: *const class_attribute,
        ns: *const core::ffi::c_void,
    );
}
extern "C" {
    pub static net_ns_type_operations: kobj_ns_type_operations;
}
extern "C" {
    pub fn netdev_drivername(dev: *const net_device) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn netdev_increment_features(
        all: netdev_features_t,
        one: netdev_features_t,
        mask: netdev_features_t,
    ) -> netdev_features_t;
}
extern "C" {
    pub fn __netdev_update_features(dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn netdev_update_features(dev: *mut net_device);
}
extern "C" {
    pub fn netdev_change_features(dev: *mut net_device);
}
extern "C" {
    pub fn netif_stacked_transfer_operstate(rootdev: *const net_device, dev: *mut net_device);
}
extern "C" {
    pub fn passthru_features_check(
        skb: *mut sk_buff,
        dev: *mut net_device,
        features: netdev_features_t,
    ) -> netdev_features_t;
}
extern "C" {
    pub fn netif_skb_features(skb: *mut sk_buff) -> netdev_features_t;
}
extern "C" {
    pub fn netif_set_tso_max_size(dev: *mut net_device, size: core::ffi::c_uint);
}
extern "C" {
    pub fn netif_set_tso_max_segs(dev: *mut net_device, segs: core::ffi::c_uint);
}
extern "C" {
    pub fn netif_inherit_tso_max(to: *mut net_device, from: *const net_device);
}
extern "C" {
    pub static mut loopback_net_ops: pernet_operations;
}
extern "C" {
    pub static mut ptype_all: list_head;
}
extern "C" {
    pub static mut ptype_base: [list_head; 16usize];
}
extern "C" {
    pub static mut blackhole_netdev: *mut net_device;
}
extern "C" {
    pub fn netfilter_init() -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_hook_state {
    pub hook: u8_,
    pub pf: u8_,
    pub in_: *mut net_device,
    pub out: *mut net_device,
    pub sk: *mut sock,
    pub net: *mut net,
    pub okfn: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut sock,
            arg3: *mut sk_buff,
        ) -> core::ffi::c_int,
    >,
}
impl Default for nf_hook_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type nf_hookfn = ::core::option::Option<
    unsafe extern "C" fn(
        priv_: *mut core::ffi::c_void,
        skb: *mut sk_buff,
        state: *const nf_hook_state,
    ) -> core::ffi::c_uint,
>;
pub const nf_hook_ops_type_NF_HOOK_OP_UNDEFINED: nf_hook_ops_type = 0;
pub const nf_hook_ops_type_NF_HOOK_OP_NF_TABLES: nf_hook_ops_type = 1;
pub type nf_hook_ops_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_hook_ops {
    pub hook: nf_hookfn,
    pub dev: *mut net_device,
    pub priv_: *mut core::ffi::c_void,
    pub pf: u8_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub hooknum: core::ffi::c_uint,
    pub priority: core::ffi::c_int,
}
impl Default for nf_hook_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl nf_hook_ops {
    #[inline]
    pub fn hook_ops_type(&self) -> nf_hook_ops_type {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_hook_ops_type(&mut self, val: nf_hook_ops_type) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_ops_type: nf_hook_ops_type,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let hook_ops_type: u32 = unsafe { ::core::mem::transmute(hook_ops_type) };
            hook_ops_type as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_hook_entry {
    pub hook: nf_hookfn,
    pub priv_: *mut core::ffi::c_void,
}
impl Default for nf_hook_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_hook_entries_rcu_head {
    pub head: callback_head,
    pub allocation: *mut core::ffi::c_void,
}
impl Default for nf_hook_entries_rcu_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct nf_hook_entries {
    pub num_hook_entries: u16_,
    pub hooks: __IncompleteArrayField<nf_hook_entry>,
}
impl Default for nf_hook_entries {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_sockopt_ops {
    pub list: list_head,
    pub pf: u_int8_t,
    pub set_optmin: core::ffi::c_int,
    pub set_optmax: core::ffi::c_int,
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            optval: core::ffi::c_int,
            arg: sockptr_t,
            len: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub get_optmin: core::ffi::c_int,
    pub get_optmax: core::ffi::c_int,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            optval: core::ffi::c_int,
            user: *mut core::ffi::c_void,
            len: *mut core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub owner: *mut module,
}
impl Default for nf_sockopt_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn nf_register_net_hook(net: *mut net, ops: *const nf_hook_ops) -> core::ffi::c_int;
}
extern "C" {
    pub fn nf_unregister_net_hook(net: *mut net, ops: *const nf_hook_ops);
}
extern "C" {
    pub fn nf_register_net_hooks(
        net: *mut net,
        reg: *const nf_hook_ops,
        n: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nf_unregister_net_hooks(net: *mut net, reg: *const nf_hook_ops, n: core::ffi::c_uint);
}
extern "C" {
    pub fn nf_register_sockopt(reg: *mut nf_sockopt_ops) -> core::ffi::c_int;
}
extern "C" {
    pub fn nf_unregister_sockopt(reg: *mut nf_sockopt_ops);
}
extern "C" {
    pub static mut nf_hooks_needed: [[static_key; 5usize]; 11usize];
}
extern "C" {
    pub fn nf_hook_slow(
        skb: *mut sk_buff,
        state: *mut nf_hook_state,
        e: *const nf_hook_entries,
        i: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nf_hook_slow_list(
        head: *mut list_head,
        state: *mut nf_hook_state,
        e: *const nf_hook_entries,
    );
}
extern "C" {
    pub fn nf_setsockopt(
        sk: *mut sock,
        pf: u_int8_t,
        optval: core::ffi::c_int,
        opt: sockptr_t,
        len: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nf_getsockopt(
        sk: *mut sock,
        pf: u_int8_t,
        optval: core::ffi::c_int,
        opt: *mut core::ffi::c_char,
        len: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_queue_entry {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nf_checksum(
        skb: *mut sk_buff,
        hook: core::ffi::c_uint,
        dataoff: core::ffi::c_uint,
        protocol: u_int8_t,
        family: core::ffi::c_ushort,
    ) -> __sum16;
}
extern "C" {
    pub fn nf_checksum_partial(
        skb: *mut sk_buff,
        hook: core::ffi::c_uint,
        dataoff: core::ffi::c_uint,
        len: core::ffi::c_uint,
        protocol: u_int8_t,
        family: core::ffi::c_ushort,
    ) -> __sum16;
}
extern "C" {
    pub fn nf_route(
        net: *mut net,
        dst: *mut *mut dst_entry,
        fl: *mut flowi,
        strict: bool_,
        family: core::ffi::c_ushort,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nf_reroute(skb: *mut sk_buff, entry: *mut nf_queue_entry) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conn {
    _unused: [u8; 0],
}
pub type nf_nat_manip_type = i32;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_nat_hook {
    pub parse_nat_setup: ::core::option::Option<
        unsafe extern "C" fn(
            ct: *mut nf_conn,
            manip: nf_nat_manip_type,
            attr: *const nlattr,
        ) -> core::ffi::c_int,
    >,
    pub decode_session:
        ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff, fl: *mut flowi)>,
    pub manip_pkt: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            ct: *mut nf_conn,
            mtype: nf_nat_manip_type,
            dir: ip_conntrack_dir,
        ) -> core::ffi::c_uint,
    >,
    pub remove_nat_bysrc: ::core::option::Option<unsafe extern "C" fn(ct: *mut nf_conn)>,
}
extern "C" {
    pub static mut nf_nat_hook: *const nf_nat_hook;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_conntrack_zone {
    pub id: u16_,
    pub flags: u8_,
    pub dir: u8_,
}
extern "C" {
    pub static nf_ct_zone_dflt: nf_conntrack_zone;
}
extern "C" {
    pub fn nf_ct_attach(arg1: *mut sk_buff, arg2: *const sk_buff);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_conntrack_tuple {
    _unused: [u8; 0],
}
extern "C" {
    pub fn nf_ct_get_tuple_skb(dst_tuple: *mut nf_conntrack_tuple, skb: *const sk_buff) -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_ct_hook {
    pub update: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut nf_conntrack)>,
    pub get_tuple_skb: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut nf_conntrack_tuple, arg2: *const sk_buff) -> bool_,
    >,
    pub attach:
        ::core::option::Option<unsafe extern "C" fn(nskb: *mut sk_buff, skb: *const sk_buff)>,
}
extern "C" {
    pub static mut nf_ct_hook: *const nf_ct_hook;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nfnl_ct_hook {
    pub build_size: ::core::option::Option<unsafe extern "C" fn(ct: *const nf_conn) -> usize>,
    pub build: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            ct: *mut nf_conn,
            ctinfo: ip_conntrack_info,
            ct_attr: u_int16_t,
            ct_info_attr: u_int16_t,
        ) -> core::ffi::c_int,
    >,
    pub parse: ::core::option::Option<
        unsafe extern "C" fn(attr: *const nlattr, ct: *mut nf_conn) -> core::ffi::c_int,
    >,
    pub attach_expect: ::core::option::Option<
        unsafe extern "C" fn(
            attr: *const nlattr,
            ct: *mut nf_conn,
            portid: u32_,
            report: u32_,
        ) -> core::ffi::c_int,
    >,
    pub seq_adjust: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            ct: *mut nf_conn,
            ctinfo: ip_conntrack_info,
            off: s32,
        ),
    >,
}
extern "C" {
    pub static mut nfnl_ct_hook: *const nfnl_ct_hook;
}
extern "C" {
    pub static mut nf_skb_duplicated: bool;
}
pub const nf_ip_hook_priorities_NF_IP_PRI_FIRST: nf_ip_hook_priorities = -2147483648;
pub const nf_ip_hook_priorities_NF_IP_PRI_RAW_BEFORE_DEFRAG: nf_ip_hook_priorities = -450;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK_DEFRAG: nf_ip_hook_priorities = -400;
pub const nf_ip_hook_priorities_NF_IP_PRI_RAW: nf_ip_hook_priorities = -300;
pub const nf_ip_hook_priorities_NF_IP_PRI_SELINUX_FIRST: nf_ip_hook_priorities = -225;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK: nf_ip_hook_priorities = -200;
pub const nf_ip_hook_priorities_NF_IP_PRI_MANGLE: nf_ip_hook_priorities = -150;
pub const nf_ip_hook_priorities_NF_IP_PRI_NAT_DST: nf_ip_hook_priorities = -100;
pub const nf_ip_hook_priorities_NF_IP_PRI_FILTER: nf_ip_hook_priorities = 0;
pub const nf_ip_hook_priorities_NF_IP_PRI_SECURITY: nf_ip_hook_priorities = 50;
pub const nf_ip_hook_priorities_NF_IP_PRI_NAT_SRC: nf_ip_hook_priorities = 100;
pub const nf_ip_hook_priorities_NF_IP_PRI_SELINUX_LAST: nf_ip_hook_priorities = 225;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK_HELPER: nf_ip_hook_priorities = 300;
pub const nf_ip_hook_priorities_NF_IP_PRI_CONNTRACK_CONFIRM: nf_ip_hook_priorities = 2147483647;
pub const nf_ip_hook_priorities_NF_IP_PRI_LAST: nf_ip_hook_priorities = 2147483647;
pub type nf_ip_hook_priorities = core::ffi::c_int;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_rt_info {
    pub daddr: __be32,
    pub saddr: __be32,
    pub tos: u_int8_t,
    pub mark: u_int32_t,
}
extern "C" {
    pub fn ip_route_me_harder(
        net: *mut net,
        sk: *mut sock,
        skb: *mut sk_buff,
        addr_type: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nf_ip_checksum(
        skb: *mut sk_buff,
        hook: core::ffi::c_uint,
        dataoff: core::ffi::c_uint,
        protocol: u_int8_t,
    ) -> __sum16;
}
extern "C" {
    pub fn nf_ip_route(
        net: *mut net,
        dst: *mut *mut dst_entry,
        fl: *mut flowi,
        strict: bool_,
    ) -> core::ffi::c_int;
}
pub const nf_ip6_hook_priorities_NF_IP6_PRI_FIRST: nf_ip6_hook_priorities = -2147483648;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_RAW_BEFORE_DEFRAG: nf_ip6_hook_priorities = -450;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_CONNTRACK_DEFRAG: nf_ip6_hook_priorities = -400;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_RAW: nf_ip6_hook_priorities = -300;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_SELINUX_FIRST: nf_ip6_hook_priorities = -225;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_CONNTRACK: nf_ip6_hook_priorities = -200;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_MANGLE: nf_ip6_hook_priorities = -150;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_NAT_DST: nf_ip6_hook_priorities = -100;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_FILTER: nf_ip6_hook_priorities = 0;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_SECURITY: nf_ip6_hook_priorities = 50;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_NAT_SRC: nf_ip6_hook_priorities = 100;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_SELINUX_LAST: nf_ip6_hook_priorities = 225;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_CONNTRACK_HELPER: nf_ip6_hook_priorities = 300;
pub const nf_ip6_hook_priorities_NF_IP6_PRI_LAST: nf_ip6_hook_priorities = 2147483647;
pub type nf_ip6_hook_priorities = core::ffi::c_int;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct minmax_sample {
    pub t: u32_,
    pub v: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct minmax {
    pub s: [minmax_sample; 3usize],
}
extern "C" {
    pub fn minmax_running_max(m: *mut minmax, win: u32_, t: u32_, meas: u32_) -> u32_;
}
extern "C" {
    pub fn minmax_running_min(m: *mut minmax, win: u32_, t: u32_, meas: u32_) -> u32_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pollfd {
    pub fd: core::ffi::c_int,
    pub events: core::ffi::c_short,
    pub revents: core::ffi::c_short,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct epoll_event {
    pub events: __poll_t,
    pub data: __u64,
}
pub type poll_queue_proc = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut file,
        arg2: *mut wait_queue_head_t,
        arg3: *mut poll_table_struct,
    ),
>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct poll_table_struct {
    pub _qproc: poll_queue_proc,
    pub _key: __poll_t,
}
pub type poll_table = poll_table_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct poll_table_entry {
    pub filp: *mut file,
    pub key: __poll_t,
    pub wait: wait_queue_entry_t,
    pub wait_address: *mut wait_queue_head_t,
}
impl Default for poll_table_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct poll_wqueues {
    pub pt: poll_table,
    pub table: *mut poll_table_page,
    pub polling_task: *mut task_struct,
    pub triggered: core::ffi::c_int,
    pub error: core::ffi::c_int,
    pub inline_index: core::ffi::c_int,
    pub inline_entries: [poll_table_entry; 8usize],
}
impl Default for poll_wqueues {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn poll_initwait(pwq: *mut poll_wqueues);
}
extern "C" {
    pub fn poll_freewait(pwq: *mut poll_wqueues);
}
extern "C" {
    pub fn select_estimate_accuracy(tv: *mut timespec64) -> u64_;
}
extern "C" {
    pub fn core_sys_select(
        n: core::ffi::c_int,
        inp: *mut fd_set,
        outp: *mut fd_set,
        exp: *mut fd_set,
        end_time: *mut timespec64,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn poll_select_set_timeout(
        to: *mut timespec64,
        sec: time64_t,
        nsec: core::ffi::c_long,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifaddrmsg {
    pub ifa_family: __u8,
    pub ifa_prefixlen: __u8,
    pub ifa_flags: __u8,
    pub ifa_scope: __u8,
    pub ifa_index: __u32,
}
pub const IFA_UNSPEC: core::ffi::c_uint = 0;
pub const IFA_ADDRESS: core::ffi::c_uint = 1;
pub const IFA_LOCAL: core::ffi::c_uint = 2;
pub const IFA_LABEL: core::ffi::c_uint = 3;
pub const IFA_BROADCAST: core::ffi::c_uint = 4;
pub const IFA_ANYCAST: core::ffi::c_uint = 5;
pub const IFA_CACHEINFO: core::ffi::c_uint = 6;
pub const IFA_MULTICAST: core::ffi::c_uint = 7;
pub const IFA_FLAGS: core::ffi::c_uint = 8;
pub const IFA_RT_PRIORITY: core::ffi::c_uint = 9;
pub const IFA_TARGET_NETNSID: core::ffi::c_uint = 10;
pub const IFA_PROTO: core::ffi::c_uint = 11;
pub const __IFA_MAX: core::ffi::c_uint = 12;
pub type _bindgen_ty_276 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifa_cacheinfo {
    pub ifa_prefered: __u32,
    pub ifa_valid: __u32,
    pub cstamp: __u32,
    pub tstamp: __u32,
}
pub const RTM_BASE: core::ffi::c_uint = 16;
pub const RTM_NEWLINK: core::ffi::c_uint = 16;
pub const RTM_DELLINK: core::ffi::c_uint = 17;
pub const RTM_GETLINK: core::ffi::c_uint = 18;
pub const RTM_SETLINK: core::ffi::c_uint = 19;
pub const RTM_NEWADDR: core::ffi::c_uint = 20;
pub const RTM_DELADDR: core::ffi::c_uint = 21;
pub const RTM_GETADDR: core::ffi::c_uint = 22;
pub const RTM_NEWROUTE: core::ffi::c_uint = 24;
pub const RTM_DELROUTE: core::ffi::c_uint = 25;
pub const RTM_GETROUTE: core::ffi::c_uint = 26;
pub const RTM_NEWNEIGH: core::ffi::c_uint = 28;
pub const RTM_DELNEIGH: core::ffi::c_uint = 29;
pub const RTM_GETNEIGH: core::ffi::c_uint = 30;
pub const RTM_NEWRULE: core::ffi::c_uint = 32;
pub const RTM_DELRULE: core::ffi::c_uint = 33;
pub const RTM_GETRULE: core::ffi::c_uint = 34;
pub const RTM_NEWQDISC: core::ffi::c_uint = 36;
pub const RTM_DELQDISC: core::ffi::c_uint = 37;
pub const RTM_GETQDISC: core::ffi::c_uint = 38;
pub const RTM_NEWTCLASS: core::ffi::c_uint = 40;
pub const RTM_DELTCLASS: core::ffi::c_uint = 41;
pub const RTM_GETTCLASS: core::ffi::c_uint = 42;
pub const RTM_NEWTFILTER: core::ffi::c_uint = 44;
pub const RTM_DELTFILTER: core::ffi::c_uint = 45;
pub const RTM_GETTFILTER: core::ffi::c_uint = 46;
pub const RTM_NEWACTION: core::ffi::c_uint = 48;
pub const RTM_DELACTION: core::ffi::c_uint = 49;
pub const RTM_GETACTION: core::ffi::c_uint = 50;
pub const RTM_NEWPREFIX: core::ffi::c_uint = 52;
pub const RTM_GETMULTICAST: core::ffi::c_uint = 58;
pub const RTM_GETANYCAST: core::ffi::c_uint = 62;
pub const RTM_NEWNEIGHTBL: core::ffi::c_uint = 64;
pub const RTM_GETNEIGHTBL: core::ffi::c_uint = 66;
pub const RTM_SETNEIGHTBL: core::ffi::c_uint = 67;
pub const RTM_NEWNDUSEROPT: core::ffi::c_uint = 68;
pub const RTM_NEWADDRLABEL: core::ffi::c_uint = 72;
pub const RTM_DELADDRLABEL: core::ffi::c_uint = 73;
pub const RTM_GETADDRLABEL: core::ffi::c_uint = 74;
pub const RTM_GETDCB: core::ffi::c_uint = 78;
pub const RTM_SETDCB: core::ffi::c_uint = 79;
pub const RTM_NEWNETCONF: core::ffi::c_uint = 80;
pub const RTM_DELNETCONF: core::ffi::c_uint = 81;
pub const RTM_GETNETCONF: core::ffi::c_uint = 82;
pub const RTM_NEWMDB: core::ffi::c_uint = 84;
pub const RTM_DELMDB: core::ffi::c_uint = 85;
pub const RTM_GETMDB: core::ffi::c_uint = 86;
pub const RTM_NEWNSID: core::ffi::c_uint = 88;
pub const RTM_DELNSID: core::ffi::c_uint = 89;
pub const RTM_GETNSID: core::ffi::c_uint = 90;
pub const RTM_NEWSTATS: core::ffi::c_uint = 92;
pub const RTM_GETSTATS: core::ffi::c_uint = 94;
pub const RTM_SETSTATS: core::ffi::c_uint = 95;
pub const RTM_NEWCACHEREPORT: core::ffi::c_uint = 96;
pub const RTM_NEWCHAIN: core::ffi::c_uint = 100;
pub const RTM_DELCHAIN: core::ffi::c_uint = 101;
pub const RTM_GETCHAIN: core::ffi::c_uint = 102;
pub const RTM_NEWNEXTHOP: core::ffi::c_uint = 104;
pub const RTM_DELNEXTHOP: core::ffi::c_uint = 105;
pub const RTM_GETNEXTHOP: core::ffi::c_uint = 106;
pub const RTM_NEWLINKPROP: core::ffi::c_uint = 108;
pub const RTM_DELLINKPROP: core::ffi::c_uint = 109;
pub const RTM_GETLINKPROP: core::ffi::c_uint = 110;
pub const RTM_NEWVLAN: core::ffi::c_uint = 112;
pub const RTM_DELVLAN: core::ffi::c_uint = 113;
pub const RTM_GETVLAN: core::ffi::c_uint = 114;
pub const RTM_NEWNEXTHOPBUCKET: core::ffi::c_uint = 116;
pub const RTM_DELNEXTHOPBUCKET: core::ffi::c_uint = 117;
pub const RTM_GETNEXTHOPBUCKET: core::ffi::c_uint = 118;
pub const RTM_NEWTUNNEL: core::ffi::c_uint = 120;
pub const RTM_DELTUNNEL: core::ffi::c_uint = 121;
pub const RTM_GETTUNNEL: core::ffi::c_uint = 122;
pub const __RTM_MAX: core::ffi::c_uint = 123;
pub type _bindgen_ty_277 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rtattr {
    pub rta_len: core::ffi::c_ushort,
    pub rta_type: core::ffi::c_ushort,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rtmsg {
    pub rtm_family: core::ffi::c_uchar,
    pub rtm_dst_len: core::ffi::c_uchar,
    pub rtm_src_len: core::ffi::c_uchar,
    pub rtm_tos: core::ffi::c_uchar,
    pub rtm_table: core::ffi::c_uchar,
    pub rtm_protocol: core::ffi::c_uchar,
    pub rtm_scope: core::ffi::c_uchar,
    pub rtm_type: core::ffi::c_uchar,
    pub rtm_flags: core::ffi::c_uint,
}
pub const RTN_UNSPEC: core::ffi::c_uint = 0;
pub const RTN_UNICAST: core::ffi::c_uint = 1;
pub const RTN_LOCAL: core::ffi::c_uint = 2;
pub const RTN_BROADCAST: core::ffi::c_uint = 3;
pub const RTN_ANYCAST: core::ffi::c_uint = 4;
pub const RTN_MULTICAST: core::ffi::c_uint = 5;
pub const RTN_BLACKHOLE: core::ffi::c_uint = 6;
pub const RTN_UNREACHABLE: core::ffi::c_uint = 7;
pub const RTN_PROHIBIT: core::ffi::c_uint = 8;
pub const RTN_THROW: core::ffi::c_uint = 9;
pub const RTN_NAT: core::ffi::c_uint = 10;
pub const RTN_XRESOLVE: core::ffi::c_uint = 11;
pub const __RTN_MAX: core::ffi::c_uint = 12;
pub type _bindgen_ty_278 = core::ffi::c_uint;
pub const rt_scope_t_RT_SCOPE_UNIVERSE: rt_scope_t = 0;
pub const rt_scope_t_RT_SCOPE_SITE: rt_scope_t = 200;
pub const rt_scope_t_RT_SCOPE_LINK: rt_scope_t = 253;
pub const rt_scope_t_RT_SCOPE_HOST: rt_scope_t = 254;
pub const rt_scope_t_RT_SCOPE_NOWHERE: rt_scope_t = 255;
pub type rt_scope_t = core::ffi::c_uint;
pub const rt_class_t_RT_TABLE_UNSPEC: rt_class_t = 0;
pub const rt_class_t_RT_TABLE_COMPAT: rt_class_t = 252;
pub const rt_class_t_RT_TABLE_DEFAULT: rt_class_t = 253;
pub const rt_class_t_RT_TABLE_MAIN: rt_class_t = 254;
pub const rt_class_t_RT_TABLE_LOCAL: rt_class_t = 255;
pub const rt_class_t_RT_TABLE_MAX: rt_class_t = 4294967295;
pub type rt_class_t = core::ffi::c_uint;
pub const rtattr_type_t_RTA_UNSPEC: rtattr_type_t = 0;
pub const rtattr_type_t_RTA_DST: rtattr_type_t = 1;
pub const rtattr_type_t_RTA_SRC: rtattr_type_t = 2;
pub const rtattr_type_t_RTA_IIF: rtattr_type_t = 3;
pub const rtattr_type_t_RTA_OIF: rtattr_type_t = 4;
pub const rtattr_type_t_RTA_GATEWAY: rtattr_type_t = 5;
pub const rtattr_type_t_RTA_PRIORITY: rtattr_type_t = 6;
pub const rtattr_type_t_RTA_PREFSRC: rtattr_type_t = 7;
pub const rtattr_type_t_RTA_METRICS: rtattr_type_t = 8;
pub const rtattr_type_t_RTA_MULTIPATH: rtattr_type_t = 9;
pub const rtattr_type_t_RTA_PROTOINFO: rtattr_type_t = 10;
pub const rtattr_type_t_RTA_FLOW: rtattr_type_t = 11;
pub const rtattr_type_t_RTA_CACHEINFO: rtattr_type_t = 12;
pub const rtattr_type_t_RTA_SESSION: rtattr_type_t = 13;
pub const rtattr_type_t_RTA_MP_ALGO: rtattr_type_t = 14;
pub const rtattr_type_t_RTA_TABLE: rtattr_type_t = 15;
pub const rtattr_type_t_RTA_MARK: rtattr_type_t = 16;
pub const rtattr_type_t_RTA_MFC_STATS: rtattr_type_t = 17;
pub const rtattr_type_t_RTA_VIA: rtattr_type_t = 18;
pub const rtattr_type_t_RTA_NEWDST: rtattr_type_t = 19;
pub const rtattr_type_t_RTA_PREF: rtattr_type_t = 20;
pub const rtattr_type_t_RTA_ENCAP_TYPE: rtattr_type_t = 21;
pub const rtattr_type_t_RTA_ENCAP: rtattr_type_t = 22;
pub const rtattr_type_t_RTA_EXPIRES: rtattr_type_t = 23;
pub const rtattr_type_t_RTA_PAD: rtattr_type_t = 24;
pub const rtattr_type_t_RTA_UID: rtattr_type_t = 25;
pub const rtattr_type_t_RTA_TTL_PROPAGATE: rtattr_type_t = 26;
pub const rtattr_type_t_RTA_IP_PROTO: rtattr_type_t = 27;
pub const rtattr_type_t_RTA_SPORT: rtattr_type_t = 28;
pub const rtattr_type_t_RTA_DPORT: rtattr_type_t = 29;
pub const rtattr_type_t_RTA_NH_ID: rtattr_type_t = 30;
pub const rtattr_type_t___RTA_MAX: rtattr_type_t = 31;
pub type rtattr_type_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rtnexthop {
    pub rtnh_len: core::ffi::c_ushort,
    pub rtnh_flags: core::ffi::c_uchar,
    pub rtnh_hops: core::ffi::c_uchar,
    pub rtnh_ifindex: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default)]
pub struct rtvia {
    pub rtvia_family: __kernel_sa_family_t,
    pub rtvia_addr: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rta_cacheinfo {
    pub rta_clntref: __u32,
    pub rta_lastuse: __u32,
    pub rta_expires: __s32,
    pub rta_error: __u32,
    pub rta_used: __u32,
    pub rta_id: __u32,
    pub rta_ts: __u32,
    pub rta_tsage: __u32,
}
pub const RTAX_UNSPEC: core::ffi::c_uint = 0;
pub const RTAX_LOCK: core::ffi::c_uint = 1;
pub const RTAX_MTU: core::ffi::c_uint = 2;
pub const RTAX_WINDOW: core::ffi::c_uint = 3;
pub const RTAX_RTT: core::ffi::c_uint = 4;
pub const RTAX_RTTVAR: core::ffi::c_uint = 5;
pub const RTAX_SSTHRESH: core::ffi::c_uint = 6;
pub const RTAX_CWND: core::ffi::c_uint = 7;
pub const RTAX_ADVMSS: core::ffi::c_uint = 8;
pub const RTAX_REORDERING: core::ffi::c_uint = 9;
pub const RTAX_HOPLIMIT: core::ffi::c_uint = 10;
pub const RTAX_INITCWND: core::ffi::c_uint = 11;
pub const RTAX_FEATURES: core::ffi::c_uint = 12;
pub const RTAX_RTO_MIN: core::ffi::c_uint = 13;
pub const RTAX_INITRWND: core::ffi::c_uint = 14;
pub const RTAX_QUICKACK: core::ffi::c_uint = 15;
pub const RTAX_CC_ALGO: core::ffi::c_uint = 16;
pub const RTAX_FASTOPEN_NO_COOKIE: core::ffi::c_uint = 17;
pub const __RTAX_MAX: core::ffi::c_uint = 18;
pub type _bindgen_ty_279 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rta_session {
    pub proto: __u8,
    pub pad1: __u8,
    pub pad2: __u16,
    pub u: rta_session__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rta_session__bindgen_ty_1 {
    pub ports: rta_session__bindgen_ty_1__bindgen_ty_1,
    pub icmpt: rta_session__bindgen_ty_1__bindgen_ty_2,
    pub spi: __u32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rta_session__bindgen_ty_1__bindgen_ty_1 {
    pub sport: __u16,
    pub dport: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rta_session__bindgen_ty_1__bindgen_ty_2 {
    pub type_: __u8,
    pub code: __u8,
    pub ident: __u16,
}
impl Default for rta_session__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for rta_session {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rta_mfc_stats {
    pub mfcs_packets: __u64,
    pub mfcs_bytes: __u64,
    pub mfcs_wrong_if: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rtgenmsg {
    pub rtgen_family: core::ffi::c_uchar,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ifinfomsg {
    pub ifi_family: core::ffi::c_uchar,
    pub __ifi_pad: core::ffi::c_uchar,
    pub ifi_type: core::ffi::c_ushort,
    pub ifi_index: core::ffi::c_int,
    pub ifi_flags: core::ffi::c_uint,
    pub ifi_change: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct prefixmsg {
    pub prefix_family: core::ffi::c_uchar,
    pub prefix_pad1: core::ffi::c_uchar,
    pub prefix_pad2: core::ffi::c_ushort,
    pub prefix_ifindex: core::ffi::c_int,
    pub prefix_type: core::ffi::c_uchar,
    pub prefix_len: core::ffi::c_uchar,
    pub prefix_flags: core::ffi::c_uchar,
    pub prefix_pad3: core::ffi::c_uchar,
}
pub const PREFIX_UNSPEC: core::ffi::c_uint = 0;
pub const PREFIX_ADDRESS: core::ffi::c_uint = 1;
pub const PREFIX_CACHEINFO: core::ffi::c_uint = 2;
pub const __PREFIX_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_280 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct prefix_cacheinfo {
    pub preferred_time: __u32,
    pub valid_time: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcmsg {
    pub tcm_family: core::ffi::c_uchar,
    pub tcm__pad1: core::ffi::c_uchar,
    pub tcm__pad2: core::ffi::c_ushort,
    pub tcm_ifindex: core::ffi::c_int,
    pub tcm_handle: __u32,
    pub tcm_parent: __u32,
    pub tcm_info: __u32,
}
pub const TCA_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_KIND: core::ffi::c_uint = 1;
pub const TCA_OPTIONS: core::ffi::c_uint = 2;
pub const TCA_STATS: core::ffi::c_uint = 3;
pub const TCA_XSTATS: core::ffi::c_uint = 4;
pub const TCA_RATE: core::ffi::c_uint = 5;
pub const TCA_FCNT: core::ffi::c_uint = 6;
pub const TCA_STATS2: core::ffi::c_uint = 7;
pub const TCA_STAB: core::ffi::c_uint = 8;
pub const TCA_PAD: core::ffi::c_uint = 9;
pub const TCA_DUMP_INVISIBLE: core::ffi::c_uint = 10;
pub const TCA_CHAIN: core::ffi::c_uint = 11;
pub const TCA_HW_OFFLOAD: core::ffi::c_uint = 12;
pub const TCA_INGRESS_BLOCK: core::ffi::c_uint = 13;
pub const TCA_EGRESS_BLOCK: core::ffi::c_uint = 14;
pub const TCA_DUMP_FLAGS: core::ffi::c_uint = 15;
pub const __TCA_MAX: core::ffi::c_uint = 16;
pub type _bindgen_ty_281 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nduseroptmsg {
    pub nduseropt_family: core::ffi::c_uchar,
    pub nduseropt_pad1: core::ffi::c_uchar,
    pub nduseropt_opts_len: core::ffi::c_ushort,
    pub nduseropt_ifindex: core::ffi::c_int,
    pub nduseropt_icmp_type: __u8,
    pub nduseropt_icmp_code: __u8,
    pub nduseropt_pad2: core::ffi::c_ushort,
    pub nduseropt_pad3: core::ffi::c_uint,
}
pub const NDUSEROPT_UNSPEC: core::ffi::c_uint = 0;
pub const NDUSEROPT_SRCADDR: core::ffi::c_uint = 1;
pub const __NDUSEROPT_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_282 = core::ffi::c_uint;
pub const rtnetlink_groups_RTNLGRP_NONE: rtnetlink_groups = 0;
pub const rtnetlink_groups_RTNLGRP_LINK: rtnetlink_groups = 1;
pub const rtnetlink_groups_RTNLGRP_NOTIFY: rtnetlink_groups = 2;
pub const rtnetlink_groups_RTNLGRP_NEIGH: rtnetlink_groups = 3;
pub const rtnetlink_groups_RTNLGRP_TC: rtnetlink_groups = 4;
pub const rtnetlink_groups_RTNLGRP_IPV4_IFADDR: rtnetlink_groups = 5;
pub const rtnetlink_groups_RTNLGRP_IPV4_MROUTE: rtnetlink_groups = 6;
pub const rtnetlink_groups_RTNLGRP_IPV4_ROUTE: rtnetlink_groups = 7;
pub const rtnetlink_groups_RTNLGRP_IPV4_RULE: rtnetlink_groups = 8;
pub const rtnetlink_groups_RTNLGRP_IPV6_IFADDR: rtnetlink_groups = 9;
pub const rtnetlink_groups_RTNLGRP_IPV6_MROUTE: rtnetlink_groups = 10;
pub const rtnetlink_groups_RTNLGRP_IPV6_ROUTE: rtnetlink_groups = 11;
pub const rtnetlink_groups_RTNLGRP_IPV6_IFINFO: rtnetlink_groups = 12;
pub const rtnetlink_groups_RTNLGRP_DECnet_IFADDR: rtnetlink_groups = 13;
pub const rtnetlink_groups_RTNLGRP_NOP2: rtnetlink_groups = 14;
pub const rtnetlink_groups_RTNLGRP_DECnet_ROUTE: rtnetlink_groups = 15;
pub const rtnetlink_groups_RTNLGRP_DECnet_RULE: rtnetlink_groups = 16;
pub const rtnetlink_groups_RTNLGRP_NOP4: rtnetlink_groups = 17;
pub const rtnetlink_groups_RTNLGRP_IPV6_PREFIX: rtnetlink_groups = 18;
pub const rtnetlink_groups_RTNLGRP_IPV6_RULE: rtnetlink_groups = 19;
pub const rtnetlink_groups_RTNLGRP_ND_USEROPT: rtnetlink_groups = 20;
pub const rtnetlink_groups_RTNLGRP_PHONET_IFADDR: rtnetlink_groups = 21;
pub const rtnetlink_groups_RTNLGRP_PHONET_ROUTE: rtnetlink_groups = 22;
pub const rtnetlink_groups_RTNLGRP_DCB: rtnetlink_groups = 23;
pub const rtnetlink_groups_RTNLGRP_IPV4_NETCONF: rtnetlink_groups = 24;
pub const rtnetlink_groups_RTNLGRP_IPV6_NETCONF: rtnetlink_groups = 25;
pub const rtnetlink_groups_RTNLGRP_MDB: rtnetlink_groups = 26;
pub const rtnetlink_groups_RTNLGRP_MPLS_ROUTE: rtnetlink_groups = 27;
pub const rtnetlink_groups_RTNLGRP_NSID: rtnetlink_groups = 28;
pub const rtnetlink_groups_RTNLGRP_MPLS_NETCONF: rtnetlink_groups = 29;
pub const rtnetlink_groups_RTNLGRP_IPV4_MROUTE_R: rtnetlink_groups = 30;
pub const rtnetlink_groups_RTNLGRP_IPV6_MROUTE_R: rtnetlink_groups = 31;
pub const rtnetlink_groups_RTNLGRP_NEXTHOP: rtnetlink_groups = 32;
pub const rtnetlink_groups_RTNLGRP_BRVLAN: rtnetlink_groups = 33;
pub const rtnetlink_groups_RTNLGRP_MCTP_IFADDR: rtnetlink_groups = 34;
pub const rtnetlink_groups_RTNLGRP_TUNNEL: rtnetlink_groups = 35;
pub const rtnetlink_groups_RTNLGRP_STATS: rtnetlink_groups = 36;
pub const rtnetlink_groups___RTNLGRP_MAX: rtnetlink_groups = 37;
pub type rtnetlink_groups = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcamsg {
    pub tca_family: core::ffi::c_uchar,
    pub tca__pad1: core::ffi::c_uchar,
    pub tca__pad2: core::ffi::c_ushort,
}
pub const TCA_ROOT_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_ROOT_TAB: core::ffi::c_uint = 1;
pub const TCA_ROOT_FLAGS: core::ffi::c_uint = 2;
pub const TCA_ROOT_COUNT: core::ffi::c_uint = 3;
pub const TCA_ROOT_TIME_DELTA: core::ffi::c_uint = 4;
pub const __TCA_ROOT_MAX: core::ffi::c_uint = 5;
pub type _bindgen_ty_283 = core::ffi::c_uint;
extern "C" {
    pub fn rtnetlink_send(
        skb: *mut sk_buff,
        net: *mut net,
        pid: u32_,
        group: u32_,
        echo: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_unicast(skb: *mut sk_buff, net: *mut net, pid: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_notify(
        skb: *mut sk_buff,
        net: *mut net,
        pid: u32_,
        group: u32_,
        nlh: *mut nlmsghdr,
        flags: gfp_t,
    );
}
extern "C" {
    pub fn rtnl_set_sk_err(net: *mut net, group: u32_, error: core::ffi::c_int);
}
extern "C" {
    pub fn rtnetlink_put_metrics(skb: *mut sk_buff, metrics: *mut u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_put_cacheinfo(
        skb: *mut sk_buff,
        dst: *mut dst_entry,
        id: u32_,
        expires: core::ffi::c_long,
        error: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rtmsg_ifinfo(
        type_: core::ffi::c_int,
        dev: *mut net_device,
        change: core::ffi::c_uint,
        flags: gfp_t,
    );
}
extern "C" {
    pub fn rtmsg_ifinfo_newnet(
        type_: core::ffi::c_int,
        dev: *mut net_device,
        change: core::ffi::c_uint,
        flags: gfp_t,
        new_nsid: *mut core::ffi::c_int,
        new_ifindex: core::ffi::c_int,
    );
}
extern "C" {
    pub fn rtmsg_ifinfo_build_skb(
        type_: core::ffi::c_int,
        dev: *mut net_device,
        change: core::ffi::c_uint,
        event: u32_,
        flags: gfp_t,
        new_nsid: *mut core::ffi::c_int,
        new_ifindex: core::ffi::c_int,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn rtmsg_ifinfo_send(skb: *mut sk_buff, dev: *mut net_device, flags: gfp_t);
}
extern "C" {
    pub fn rtnl_lock();
}
extern "C" {
    pub fn rtnl_unlock();
}
extern "C" {
    pub fn rtnl_trylock() -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_is_locked() -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_lock_killable() -> core::ffi::c_int;
}
extern "C" {
    pub fn refcount_dec_and_rtnl_lock(r: *mut refcount_t) -> bool_;
}
extern "C" {
    pub static mut netdev_unregistering_wq: wait_queue_head_t;
}
extern "C" {
    pub static mut pernet_ops_rwsem: rw_semaphore;
}
extern "C" {
    pub static mut net_rwsem: rw_semaphore;
}
extern "C" {
    pub fn dev_ingress_queue_create(dev: *mut net_device) -> *mut netdev_queue;
}
extern "C" {
    pub fn net_inc_ingress_queue();
}
extern "C" {
    pub fn net_dec_ingress_queue();
}
extern "C" {
    pub fn net_inc_egress_queue();
}
extern "C" {
    pub fn net_dec_egress_queue();
}
extern "C" {
    pub fn netdev_xmit_skip_txqueue(skip: bool_);
}
extern "C" {
    pub fn rtnetlink_init();
}
extern "C" {
    pub fn __rtnl_unlock();
}
extern "C" {
    pub fn rtnl_kfree_skbs(head: *mut sk_buff, tail: *mut sk_buff);
}
extern "C" {
    pub fn ndo_dflt_fdb_dump(
        skb: *mut sk_buff,
        cb: *mut netlink_callback,
        dev: *mut net_device,
        filter_dev: *mut net_device,
        idx: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ndo_dflt_fdb_add(
        ndm: *mut ndmsg,
        tb: *mut *mut nlattr,
        dev: *mut net_device,
        addr: *const core::ffi::c_uchar,
        vid: u16_,
        flags: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ndo_dflt_fdb_del(
        ndm: *mut ndmsg,
        tb: *mut *mut nlattr,
        dev: *mut net_device,
        addr: *const core::ffi::c_uchar,
        vid: u16_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ndo_dflt_bridge_getlink(
        skb: *mut sk_buff,
        pid: u32_,
        seq: u32_,
        dev: *mut net_device,
        mode: u16_,
        flags: u32_,
        mask: u32_,
        nlflags: core::ffi::c_int,
        filter_mask: u32_,
        vlan_fill: ::core::option::Option<
            unsafe extern "C" fn(
                skb: *mut sk_buff,
                dev: *mut net_device,
                filter_mask: u32_,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_offload_xstats_notify(dev: *mut net_device);
}
pub const NLA_UNSPEC: core::ffi::c_uint = 0;
pub const NLA_U8: core::ffi::c_uint = 1;
pub const NLA_U16: core::ffi::c_uint = 2;
pub const NLA_U32: core::ffi::c_uint = 3;
pub const NLA_U64: core::ffi::c_uint = 4;
pub const NLA_STRING: core::ffi::c_uint = 5;
pub const NLA_FLAG: core::ffi::c_uint = 6;
pub const NLA_MSECS: core::ffi::c_uint = 7;
pub const NLA_NESTED: core::ffi::c_uint = 8;
pub const NLA_NESTED_ARRAY: core::ffi::c_uint = 9;
pub const NLA_NUL_STRING: core::ffi::c_uint = 10;
pub const NLA_BINARY: core::ffi::c_uint = 11;
pub const NLA_S8: core::ffi::c_uint = 12;
pub const NLA_S16: core::ffi::c_uint = 13;
pub const NLA_S32: core::ffi::c_uint = 14;
pub const NLA_S64: core::ffi::c_uint = 15;
pub const NLA_BITFIELD32: core::ffi::c_uint = 16;
pub const NLA_REJECT: core::ffi::c_uint = 17;
pub const __NLA_TYPE_MAX: core::ffi::c_uint = 18;
pub type _bindgen_ty_284 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netlink_range_validation {
    pub min: u64_,
    pub max: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netlink_range_validation_signed {
    pub min: s64,
    pub max: s64,
}
pub const nla_policy_validation_NLA_VALIDATE_NONE: nla_policy_validation = 0;
pub const nla_policy_validation_NLA_VALIDATE_RANGE: nla_policy_validation = 1;
pub const nla_policy_validation_NLA_VALIDATE_RANGE_WARN_TOO_LONG: nla_policy_validation = 2;
pub const nla_policy_validation_NLA_VALIDATE_MIN: nla_policy_validation = 3;
pub const nla_policy_validation_NLA_VALIDATE_MAX: nla_policy_validation = 4;
pub const nla_policy_validation_NLA_VALIDATE_MASK: nla_policy_validation = 5;
pub const nla_policy_validation_NLA_VALIDATE_RANGE_PTR: nla_policy_validation = 6;
pub const nla_policy_validation_NLA_VALIDATE_FUNCTION: nla_policy_validation = 7;
pub type nla_policy_validation = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nla_policy {
    pub type_: u8_,
    pub validation_type: u8_,
    pub len: u16_,
    pub __bindgen_anon_1: nla_policy__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union nla_policy__bindgen_ty_1 {
    pub bitfield32_valid: u32_,
    pub mask: u32_,
    pub reject_message: *const core::ffi::c_char,
    pub nested_policy: *const nla_policy,
    pub range: *mut netlink_range_validation,
    pub range_signed: *mut netlink_range_validation_signed,
    pub __bindgen_anon_1: nla_policy__bindgen_ty_1__bindgen_ty_1,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(attr: *const nlattr, extack: *mut netlink_ext_ack) -> core::ffi::c_int,
    >,
    pub strict_start_type: u16_,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nla_policy__bindgen_ty_1__bindgen_ty_1 {
    pub min: s16,
    pub max: s16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl nla_policy__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn network_byte_order(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_network_byte_order(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(network_byte_order: u8_) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let network_byte_order: u8 = unsafe { ::core::mem::transmute(network_byte_order) };
            network_byte_order as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for nla_policy__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for nla_policy {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nl_info {
    pub nlh: *mut nlmsghdr,
    pub nl_net: *mut net,
    pub portid: u32_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
}
impl Default for nl_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl nl_info {
    #[inline]
    pub fn skip_notify(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skip_notify(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_notify_kernel(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skip_notify_kernel(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        skip_notify: u8_,
        skip_notify_kernel: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let skip_notify: u8 = unsafe { ::core::mem::transmute(skip_notify) };
            skip_notify as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_notify_kernel: u8 = unsafe { ::core::mem::transmute(skip_notify_kernel) };
            skip_notify_kernel as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const netlink_validation_NL_VALIDATE_LIBERAL: netlink_validation = 0;
pub const netlink_validation_NL_VALIDATE_TRAILING: netlink_validation = 1;
pub const netlink_validation_NL_VALIDATE_MAXTYPE: netlink_validation = 2;
pub const netlink_validation_NL_VALIDATE_UNSPEC: netlink_validation = 4;
pub const netlink_validation_NL_VALIDATE_STRICT_ATTRS: netlink_validation = 8;
pub const netlink_validation_NL_VALIDATE_NESTED: netlink_validation = 16;
pub type netlink_validation = core::ffi::c_uint;
extern "C" {
    pub fn netlink_rcv_skb(
        skb: *mut sk_buff,
        cb: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut sk_buff,
                arg2: *mut nlmsghdr,
                arg3: *mut netlink_ext_ack,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nlmsg_notify(
        sk: *mut sock,
        skb: *mut sk_buff,
        portid: u32_,
        group: core::ffi::c_uint,
        report: core::ffi::c_int,
        flags: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __nla_validate(
        head: *const nlattr,
        len: core::ffi::c_int,
        maxtype: core::ffi::c_int,
        policy: *const nla_policy,
        validate: core::ffi::c_uint,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __nla_parse(
        tb: *mut *mut nlattr,
        maxtype: core::ffi::c_int,
        head: *const nlattr,
        len: core::ffi::c_int,
        policy: *const nla_policy,
        validate: core::ffi::c_uint,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nla_policy_len(arg1: *const nla_policy, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn nla_find(
        head: *const nlattr,
        len: core::ffi::c_int,
        attrtype: core::ffi::c_int,
    ) -> *mut nlattr;
}
extern "C" {
    pub fn nla_strscpy(dst: *mut core::ffi::c_char, nla: *const nlattr, dstsize: usize) -> isize;
}
extern "C" {
    pub fn nla_strdup(nla: *const nlattr, flags: gfp_t) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn nla_memcpy(
        dest: *mut core::ffi::c_void,
        src: *const nlattr,
        count: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nla_memcmp(
        nla: *const nlattr,
        data: *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nla_strcmp(nla: *const nlattr, str_: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn __nla_reserve(
        skb: *mut sk_buff,
        attrtype: core::ffi::c_int,
        attrlen: core::ffi::c_int,
    ) -> *mut nlattr;
}
extern "C" {
    pub fn __nla_reserve_64bit(
        skb: *mut sk_buff,
        attrtype: core::ffi::c_int,
        attrlen: core::ffi::c_int,
        padattr: core::ffi::c_int,
    ) -> *mut nlattr;
}
extern "C" {
    pub fn __nla_reserve_nohdr(
        skb: *mut sk_buff,
        attrlen: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn nla_reserve(
        skb: *mut sk_buff,
        attrtype: core::ffi::c_int,
        attrlen: core::ffi::c_int,
    ) -> *mut nlattr;
}
extern "C" {
    pub fn nla_reserve_64bit(
        skb: *mut sk_buff,
        attrtype: core::ffi::c_int,
        attrlen: core::ffi::c_int,
        padattr: core::ffi::c_int,
    ) -> *mut nlattr;
}
extern "C" {
    pub fn nla_reserve_nohdr(
        skb: *mut sk_buff,
        attrlen: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn __nla_put(
        skb: *mut sk_buff,
        attrtype: core::ffi::c_int,
        attrlen: core::ffi::c_int,
        data: *const core::ffi::c_void,
    );
}
extern "C" {
    pub fn __nla_put_64bit(
        skb: *mut sk_buff,
        attrtype: core::ffi::c_int,
        attrlen: core::ffi::c_int,
        data: *const core::ffi::c_void,
        padattr: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __nla_put_nohdr(
        skb: *mut sk_buff,
        attrlen: core::ffi::c_int,
        data: *const core::ffi::c_void,
    );
}
extern "C" {
    pub fn nla_put(
        skb: *mut sk_buff,
        attrtype: core::ffi::c_int,
        attrlen: core::ffi::c_int,
        data: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nla_put_64bit(
        skb: *mut sk_buff,
        attrtype: core::ffi::c_int,
        attrlen: core::ffi::c_int,
        data: *const core::ffi::c_void,
        padattr: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nla_put_nohdr(
        skb: *mut sk_buff,
        attrlen: core::ffi::c_int,
        data: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nla_append(
        skb: *mut sk_buff,
        attrlen: core::ffi::c_int,
        data: *const core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nla_get_range_unsigned(pt: *const nla_policy, range: *mut netlink_range_validation);
}
extern "C" {
    pub fn nla_get_range_signed(pt: *const nla_policy, range: *mut netlink_range_validation_signed);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netlink_policy_dump_state {
    _unused: [u8; 0],
}
extern "C" {
    pub fn netlink_policy_dump_add_policy(
        pstate: *mut *mut netlink_policy_dump_state,
        policy: *const nla_policy,
        maxtype: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_policy_dump_get_policy_idx(
        state: *mut netlink_policy_dump_state,
        policy: *const nla_policy,
        maxtype: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_policy_dump_loop(state: *mut netlink_policy_dump_state) -> bool_;
}
extern "C" {
    pub fn netlink_policy_dump_write(
        skb: *mut sk_buff,
        state: *mut netlink_policy_dump_state,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_policy_dump_attr_size_estimate(pt: *const nla_policy) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_policy_dump_write_attr(
        skb: *mut sk_buff,
        pt: *const nla_policy,
        nestattr: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn netlink_policy_dump_free(state: *mut netlink_policy_dump_state);
}
pub type rtnl_doit_func = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut sk_buff,
        arg2: *mut nlmsghdr,
        arg3: *mut netlink_ext_ack,
    ) -> core::ffi::c_int,
>;
pub type rtnl_dumpit_func = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut sk_buff, arg2: *mut netlink_callback) -> core::ffi::c_int,
>;
pub const rtnl_link_flags_RTNL_FLAG_DOIT_UNLOCKED: rtnl_link_flags = 1;
pub const rtnl_link_flags_RTNL_FLAG_BULK_DEL_SUPPORTED: rtnl_link_flags = 2;
pub type rtnl_link_flags = core::ffi::c_uint;
pub const rtnl_kinds_RTNL_KIND_NEW: rtnl_kinds = 0;
pub const rtnl_kinds_RTNL_KIND_DEL: rtnl_kinds = 1;
pub const rtnl_kinds_RTNL_KIND_GET: rtnl_kinds = 2;
pub const rtnl_kinds_RTNL_KIND_SET: rtnl_kinds = 3;
pub type rtnl_kinds = core::ffi::c_uint;
extern "C" {
    pub fn rtnl_register(
        protocol: core::ffi::c_int,
        msgtype: core::ffi::c_int,
        arg1: rtnl_doit_func,
        arg2: rtnl_dumpit_func,
        flags: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn rtnl_register_module(
        owner: *mut module,
        protocol: core::ffi::c_int,
        msgtype: core::ffi::c_int,
        arg1: rtnl_doit_func,
        arg2: rtnl_dumpit_func,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_unregister(
        protocol: core::ffi::c_int,
        msgtype: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_unregister_all(protocol: core::ffi::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtnl_link_ops {
    pub list: list_head,
    pub kind: *const core::ffi::c_char,
    pub priv_size: usize,
    pub alloc: ::core::option::Option<
        unsafe extern "C" fn(
            tb: *mut *mut nlattr,
            ifname: *const core::ffi::c_char,
            name_assign_type: core::ffi::c_uchar,
            num_tx_queues: core::ffi::c_uint,
            num_rx_queues: core::ffi::c_uint,
        ) -> *mut net_device,
    >,
    pub setup: ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device)>,
    pub netns_refund: bool_,
    pub maxtype: core::ffi::c_uint,
    pub policy: *const nla_policy,
    pub validate: ::core::option::Option<
        unsafe extern "C" fn(
            tb: *mut *mut nlattr,
            data: *mut *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub newlink: ::core::option::Option<
        unsafe extern "C" fn(
            src_net: *mut net,
            dev: *mut net_device,
            tb: *mut *mut nlattr,
            data: *mut *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub changelink: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            tb: *mut *mut nlattr,
            data: *mut *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub dellink:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut net_device, head: *mut list_head)>,
    pub get_size: ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> usize>,
    pub fill_info: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, dev: *const net_device) -> core::ffi::c_int,
    >,
    pub get_xstats_size:
        ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> usize>,
    pub fill_xstats: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, dev: *const net_device) -> core::ffi::c_int,
    >,
    pub get_num_tx_queues: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_uint>,
    pub get_num_rx_queues: ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_uint>,
    pub slave_maxtype: core::ffi::c_uint,
    pub slave_policy: *const nla_policy,
    pub slave_changelink: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            slave_dev: *mut net_device,
            tb: *mut *mut nlattr,
            data: *mut *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub get_slave_size: ::core::option::Option<
        unsafe extern "C" fn(dev: *const net_device, slave_dev: *const net_device) -> usize,
    >,
    pub fill_slave_info: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            dev: *const net_device,
            slave_dev: *const net_device,
        ) -> core::ffi::c_int,
    >,
    pub get_link_net:
        ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> *mut net>,
    pub get_linkxstats_size: ::core::option::Option<
        unsafe extern "C" fn(dev: *const net_device, attr: core::ffi::c_int) -> usize,
    >,
    pub fill_linkxstats: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            dev: *const net_device,
            prividx: *mut core::ffi::c_int,
            attr: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
}
impl Default for rtnl_link_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __rtnl_link_register(ops: *mut rtnl_link_ops) -> core::ffi::c_int;
}
extern "C" {
    pub fn __rtnl_link_unregister(ops: *mut rtnl_link_ops);
}
extern "C" {
    pub fn rtnl_link_register(ops: *mut rtnl_link_ops) -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_link_unregister(ops: *mut rtnl_link_ops);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtnl_af_ops {
    pub list: list_head,
    pub family: core::ffi::c_int,
    pub fill_link_af: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            dev: *const net_device,
            ext_filter_mask: u32_,
        ) -> core::ffi::c_int,
    >,
    pub get_link_af_size: ::core::option::Option<
        unsafe extern "C" fn(dev: *const net_device, ext_filter_mask: u32_) -> usize,
    >,
    pub validate_link_af: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *const net_device,
            attr: *const nlattr,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub set_link_af: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            attr: *const nlattr,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub fill_stats_af: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, dev: *const net_device) -> core::ffi::c_int,
    >,
    pub get_stats_af_size:
        ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> usize>,
}
impl Default for rtnl_af_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn rtnl_af_register(ops: *mut rtnl_af_ops);
}
extern "C" {
    pub fn rtnl_af_unregister(ops: *mut rtnl_af_ops);
}
extern "C" {
    pub fn rtnl_link_get_net(src_net: *mut net, tb: *mut *mut nlattr) -> *mut net;
}
extern "C" {
    pub fn rtnl_create_link(
        net: *mut net,
        ifname: *const core::ffi::c_char,
        name_assign_type: core::ffi::c_uchar,
        ops: *const rtnl_link_ops,
        tb: *mut *mut nlattr,
        extack: *mut netlink_ext_ack,
    ) -> *mut net_device;
}
extern "C" {
    pub fn rtnl_delete_link(dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_configure_link(dev: *mut net_device, ifm: *const ifinfomsg) -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_nla_parse_ifla(
        tb: *mut *mut nlattr,
        head: *const nlattr,
        len: core::ffi::c_int,
        exterr: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rtnl_get_net_ns_capable(sk: *mut sock, netnsid: core::ffi::c_int) -> *mut net;
}
pub const NEIGH_VAR_MCAST_PROBES: core::ffi::c_uint = 0;
pub const NEIGH_VAR_UCAST_PROBES: core::ffi::c_uint = 1;
pub const NEIGH_VAR_APP_PROBES: core::ffi::c_uint = 2;
pub const NEIGH_VAR_MCAST_REPROBES: core::ffi::c_uint = 3;
pub const NEIGH_VAR_RETRANS_TIME: core::ffi::c_uint = 4;
pub const NEIGH_VAR_BASE_REACHABLE_TIME: core::ffi::c_uint = 5;
pub const NEIGH_VAR_DELAY_PROBE_TIME: core::ffi::c_uint = 6;
pub const NEIGH_VAR_INTERVAL_PROBE_TIME_MS: core::ffi::c_uint = 7;
pub const NEIGH_VAR_GC_STALETIME: core::ffi::c_uint = 8;
pub const NEIGH_VAR_QUEUE_LEN_BYTES: core::ffi::c_uint = 9;
pub const NEIGH_VAR_PROXY_QLEN: core::ffi::c_uint = 10;
pub const NEIGH_VAR_ANYCAST_DELAY: core::ffi::c_uint = 11;
pub const NEIGH_VAR_PROXY_DELAY: core::ffi::c_uint = 12;
pub const NEIGH_VAR_LOCKTIME: core::ffi::c_uint = 13;
pub const NEIGH_VAR_QUEUE_LEN: core::ffi::c_uint = 14;
pub const NEIGH_VAR_RETRANS_TIME_MS: core::ffi::c_uint = 15;
pub const NEIGH_VAR_BASE_REACHABLE_TIME_MS: core::ffi::c_uint = 16;
pub const NEIGH_VAR_GC_INTERVAL: core::ffi::c_uint = 17;
pub const NEIGH_VAR_GC_THRESH1: core::ffi::c_uint = 18;
pub const NEIGH_VAR_GC_THRESH2: core::ffi::c_uint = 19;
pub const NEIGH_VAR_GC_THRESH3: core::ffi::c_uint = 20;
pub const NEIGH_VAR_MAX: core::ffi::c_uint = 21;
pub type _bindgen_ty_285 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct neigh_parms {
    pub net: possible_net_t,
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub list: list_head,
    pub neigh_setup:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> core::ffi::c_int>,
    pub tbl: *mut neigh_table,
    pub sysctl_table: *mut core::ffi::c_void,
    pub dead: core::ffi::c_int,
    pub refcnt: refcount_t,
    pub callback_head: callback_head,
    pub reachable_time: core::ffi::c_int,
    pub qlen: core::ffi::c_int,
    pub data: [core::ffi::c_int; 14usize],
    pub data_state: [core::ffi::c_ulong; 1usize],
}
impl Default for neigh_parms {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct neigh_statistics {
    pub allocs: core::ffi::c_ulong,
    pub destroys: core::ffi::c_ulong,
    pub hash_grows: core::ffi::c_ulong,
    pub res_failed: core::ffi::c_ulong,
    pub lookups: core::ffi::c_ulong,
    pub hits: core::ffi::c_ulong,
    pub rcv_probes_mcast: core::ffi::c_ulong,
    pub rcv_probes_ucast: core::ffi::c_ulong,
    pub periodic_gc_runs: core::ffi::c_ulong,
    pub forced_gc_runs: core::ffi::c_ulong,
    pub unres_discards: core::ffi::c_ulong,
    pub table_fulls: core::ffi::c_ulong,
}
#[repr(C)]
pub struct neighbour {
    pub next: *mut neighbour,
    pub tbl: *mut neigh_table,
    pub parms: *mut neigh_parms,
    pub confirmed: core::ffi::c_ulong,
    pub updated: core::ffi::c_ulong,
    pub lock: rwlock_t,
    pub refcnt: refcount_t,
    pub arp_queue_len_bytes: core::ffi::c_uint,
    pub arp_queue: sk_buff_head,
    pub timer: timer_list,
    pub used: core::ffi::c_ulong,
    pub probes: atomic_t,
    pub nud_state: u8_,
    pub type_: u8_,
    pub dead: u8_,
    pub protocol: u8_,
    pub flags: u32_,
    pub ha_lock: seqlock_t,
    pub ha: [core::ffi::c_uchar; 32usize],
    pub hh: hh_cache,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub ops: *const neigh_ops,
    pub gc_list: list_head,
    pub managed_list: list_head,
    pub rcu: callback_head,
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub primary_key: __IncompleteArrayField<u8_>,
}
impl Default for neighbour {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct neigh_ops {
    pub family: core::ffi::c_int,
    pub solicit:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
    pub error_report:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff)>,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub connected_output: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut sk_buff) -> core::ffi::c_int,
    >,
}
#[repr(C)]
pub struct pneigh_entry {
    pub next: *mut pneigh_entry,
    pub net: possible_net_t,
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub flags: u32_,
    pub protocol: u8_,
    pub key: __IncompleteArrayField<u8_>,
}
impl Default for pneigh_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct neigh_hash_table {
    pub hash_buckets: *mut *mut neighbour,
    pub hash_shift: core::ffi::c_uint,
    pub hash_rnd: [__u32; 4usize],
    pub rcu: callback_head,
}
impl Default for neigh_hash_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct neigh_table {
    pub family: core::ffi::c_int,
    pub entry_size: core::ffi::c_uint,
    pub key_len: core::ffi::c_uint,
    pub protocol: __be16,
    pub hash: ::core::option::Option<
        unsafe extern "C" fn(
            pkey: *const core::ffi::c_void,
            dev: *const net_device,
            hash_rnd: *mut __u32,
        ) -> __u32,
    >,
    pub key_eq: ::core::option::Option<
        unsafe extern "C" fn(arg1: *const neighbour, pkey: *const core::ffi::c_void) -> bool_,
    >,
    pub constructor:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> core::ffi::c_int>,
    pub pconstructor:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut pneigh_entry) -> core::ffi::c_int>,
    pub pdestructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pneigh_entry)>,
    pub proxy_redo: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
    pub is_multicast: ::core::option::Option<
        unsafe extern "C" fn(pkey: *const core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub allow_add: ::core::option::Option<
        unsafe extern "C" fn(dev: *const net_device, extack: *mut netlink_ext_ack) -> bool_,
    >,
    pub id: *mut core::ffi::c_char,
    pub parms: neigh_parms,
    pub parms_list: list_head,
    pub gc_interval: core::ffi::c_int,
    pub gc_thresh1: core::ffi::c_int,
    pub gc_thresh2: core::ffi::c_int,
    pub gc_thresh3: core::ffi::c_int,
    pub last_flush: core::ffi::c_ulong,
    pub gc_work: delayed_work,
    pub managed_work: delayed_work,
    pub proxy_timer: timer_list,
    pub proxy_queue: sk_buff_head,
    pub entries: atomic_t,
    pub gc_entries: atomic_t,
    pub gc_list: list_head,
    pub managed_list: list_head,
    pub lock: rwlock_t,
    pub last_rand: core::ffi::c_ulong,
    pub stats: *mut neigh_statistics,
    pub nht: *mut neigh_hash_table,
    pub phash_buckets: *mut *mut pneigh_entry,
}
impl Default for neigh_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const NEIGH_ARP_TABLE: core::ffi::c_uint = 0;
pub const NEIGH_ND_TABLE: core::ffi::c_uint = 1;
pub const NEIGH_DN_TABLE: core::ffi::c_uint = 2;
pub const NEIGH_NR_TABLES: core::ffi::c_uint = 3;
pub const NEIGH_LINK_TABLE: core::ffi::c_uint = 3;
pub type _bindgen_ty_286 = core::ffi::c_uint;
extern "C" {
    pub static mut nda_policy: [nla_policy; 0usize];
}
extern "C" {
    pub fn neigh_table_init(index: core::ffi::c_int, tbl: *mut neigh_table);
}
extern "C" {
    pub fn neigh_table_clear(index: core::ffi::c_int, tbl: *mut neigh_table) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_lookup(
        tbl: *mut neigh_table,
        pkey: *const core::ffi::c_void,
        dev: *mut net_device,
    ) -> *mut neighbour;
}
extern "C" {
    pub fn neigh_lookup_nodev(
        tbl: *mut neigh_table,
        net: *mut net,
        pkey: *const core::ffi::c_void,
    ) -> *mut neighbour;
}
extern "C" {
    pub fn __neigh_create(
        tbl: *mut neigh_table,
        pkey: *const core::ffi::c_void,
        dev: *mut net_device,
        want_ref: bool_,
    ) -> *mut neighbour;
}
extern "C" {
    pub fn neigh_destroy(neigh: *mut neighbour);
}
extern "C" {
    pub fn __neigh_event_send(
        neigh: *mut neighbour,
        skb: *mut sk_buff,
        immediate_ok: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_update(
        neigh: *mut neighbour,
        lladdr: *const u8_,
        new: u8_,
        flags: u32_,
        nlmsg_pid: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __neigh_set_probe_once(neigh: *mut neighbour);
}
extern "C" {
    pub fn neigh_remove_one(ndel: *mut neighbour, tbl: *mut neigh_table) -> bool_;
}
extern "C" {
    pub fn neigh_changeaddr(tbl: *mut neigh_table, dev: *mut net_device);
}
extern "C" {
    pub fn neigh_ifdown(tbl: *mut neigh_table, dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_carrier_down(tbl: *mut neigh_table, dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_resolve_output(neigh: *mut neighbour, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_connected_output(neigh: *mut neighbour, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_direct_output(neigh: *mut neighbour, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_event_ns(
        tbl: *mut neigh_table,
        lladdr: *mut u8_,
        saddr: *mut core::ffi::c_void,
        dev: *mut net_device,
    ) -> *mut neighbour;
}
extern "C" {
    pub fn neigh_parms_alloc(dev: *mut net_device, tbl: *mut neigh_table) -> *mut neigh_parms;
}
extern "C" {
    pub fn neigh_parms_release(tbl: *mut neigh_table, parms: *mut neigh_parms);
}
extern "C" {
    pub fn neigh_rand_reach_time(base: core::ffi::c_ulong) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn pneigh_enqueue(tbl: *mut neigh_table, p: *mut neigh_parms, skb: *mut sk_buff);
}
extern "C" {
    pub fn pneigh_lookup(
        tbl: *mut neigh_table,
        net: *mut net,
        key: *const core::ffi::c_void,
        dev: *mut net_device,
        creat: core::ffi::c_int,
    ) -> *mut pneigh_entry;
}
extern "C" {
    pub fn __pneigh_lookup(
        tbl: *mut neigh_table,
        net: *mut net,
        key: *const core::ffi::c_void,
        dev: *mut net_device,
    ) -> *mut pneigh_entry;
}
extern "C" {
    pub fn pneigh_delete(
        tbl: *mut neigh_table,
        net: *mut net,
        key: *const core::ffi::c_void,
        dev: *mut net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_app_ns(n: *mut neighbour);
}
extern "C" {
    pub fn neigh_for_each(
        tbl: *mut neigh_table,
        cb: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut neighbour, arg2: *mut core::ffi::c_void),
        >,
        cookie: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn __neigh_for_each_release(
        tbl: *mut neigh_table,
        cb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut neighbour) -> core::ffi::c_int>,
    );
}
extern "C" {
    pub fn neigh_xmit(
        fam: core::ffi::c_int,
        arg1: *mut net_device,
        arg2: *const core::ffi::c_void,
        arg3: *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn pneigh_for_each(
        tbl: *mut neigh_table,
        cb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut pneigh_entry)>,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct neigh_seq_state {
    pub p: seq_net_private,
    pub tbl: *mut neigh_table,
    pub nht: *mut neigh_hash_table,
    pub neigh_sub_iter: ::core::option::Option<
        unsafe extern "C" fn(
            state: *mut neigh_seq_state,
            n: *mut neighbour,
            pos: *mut loff_t,
        ) -> *mut core::ffi::c_void,
    >,
    pub bucket: core::ffi::c_uint,
    pub flags: core::ffi::c_uint,
}
impl Default for neigh_seq_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn neigh_seq_start(
        arg1: *mut seq_file,
        arg2: *mut loff_t,
        arg3: *mut neigh_table,
        arg4: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn neigh_seq_next(
        arg1: *mut seq_file,
        arg2: *mut core::ffi::c_void,
        arg3: *mut loff_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn neigh_seq_stop(arg1: *mut seq_file, arg2: *mut core::ffi::c_void);
}
extern "C" {
    pub fn neigh_proc_dointvec(
        ctl: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_proc_dointvec_jiffies(
        ctl: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_proc_dointvec_ms_jiffies(
        ctl: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_sysctl_register(
        dev: *mut net_device,
        p: *mut neigh_parms,
        proc_handler: proc_handler,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn neigh_sysctl_unregister(p: *mut neigh_parms);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct neighbour_cb {
    pub sched_next: core::ffi::c_ulong,
    pub flags: core::ffi::c_uint,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dst_entry {
    pub dev: *mut net_device,
    pub ops: *mut dst_ops,
    pub _metrics: core::ffi::c_ulong,
    pub expires: core::ffi::c_ulong,
    pub xfrm: *mut xfrm_state,
    pub input: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff) -> core::ffi::c_int>,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub flags: core::ffi::c_ushort,
    pub obsolete: core::ffi::c_short,
    pub header_len: core::ffi::c_ushort,
    pub trailer_len: core::ffi::c_ushort,
    pub __refcnt: atomic_t,
    pub __use: core::ffi::c_int,
    pub lastuse: core::ffi::c_ulong,
    pub lwtstate: *mut lwtunnel_state,
    pub callback_head: callback_head,
    pub error: core::ffi::c_short,
    pub __pad: core::ffi::c_short,
    pub tclassid: __u32,
    pub dev_tracker: netdevice_tracker,
}
impl Default for dst_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dst_metrics {
    pub metrics: [u32_; 17usize],
    pub refcnt: refcount_t,
}
extern "C" {
    pub static dst_default_metrics: dst_metrics;
}
extern "C" {
    pub fn dst_cow_metrics_generic(dst: *mut dst_entry, old: core::ffi::c_ulong) -> *mut u32_;
}
extern "C" {
    pub fn __dst_destroy_metrics_generic(dst: *mut dst_entry, old: core::ffi::c_ulong);
}
extern "C" {
    pub fn dst_release(dst: *mut dst_entry);
}
extern "C" {
    pub fn dst_release_immediate(dst: *mut dst_entry);
}
extern "C" {
    pub fn dst_discard_out(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn dst_alloc(
        ops: *mut dst_ops,
        dev: *mut net_device,
        initial_ref: core::ffi::c_int,
        initial_obsolete: core::ffi::c_int,
        flags: core::ffi::c_ushort,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn dst_init(
        dst: *mut dst_entry,
        ops: *mut dst_ops,
        dev: *mut net_device,
        initial_ref: core::ffi::c_int,
        initial_obsolete: core::ffi::c_int,
        flags: core::ffi::c_ushort,
    );
}
extern "C" {
    pub fn dst_destroy(dst: *mut dst_entry) -> *mut dst_entry;
}
extern "C" {
    pub fn dst_dev_put(dst: *mut dst_entry);
}
pub const XFRM_LOOKUP_ICMP: core::ffi::c_uint = 1;
pub const XFRM_LOOKUP_QUEUE: core::ffi::c_uint = 2;
pub const XFRM_LOOKUP_KEEP_DST_REF: core::ffi::c_uint = 4;
pub type _bindgen_ty_287 = core::ffi::c_uint;
extern "C" {
    pub fn xfrm_lookup(
        net: *mut net,
        dst_orig: *mut dst_entry,
        fl: *const flowi,
        sk: *const sock,
        flags: core::ffi::c_int,
    ) -> *mut dst_entry;
}
extern "C" {
    pub fn xfrm_lookup_with_ifid(
        net: *mut net,
        dst_orig: *mut dst_entry,
        fl: *const flowi,
        sk: *const sock,
        flags: core::ffi::c_int,
        if_id: u32_,
    ) -> *mut dst_entry;
}
extern "C" {
    pub fn xfrm_lookup_route(
        net: *mut net,
        dst_orig: *mut dst_entry,
        fl: *const flowi,
        sk: *const sock,
        flags: core::ffi::c_int,
    ) -> *mut dst_entry;
}
extern "C" {
    pub fn dst_blackhole_check(dst: *mut dst_entry, cookie: u32_) -> *mut dst_entry;
}
extern "C" {
    pub fn dst_blackhole_update_pmtu(
        dst: *mut dst_entry,
        sk: *mut sock,
        skb: *mut sk_buff,
        mtu: u32_,
        confirm_neigh: bool_,
    );
}
extern "C" {
    pub fn dst_blackhole_redirect(dst: *mut dst_entry, sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn dst_blackhole_cow_metrics(dst: *mut dst_entry, old: core::ffi::c_ulong) -> *mut u32_;
}
extern "C" {
    pub fn dst_blackhole_neigh_lookup(
        dst: *const dst_entry,
        skb: *mut sk_buff,
        daddr: *const core::ffi::c_void,
    ) -> *mut neighbour;
}
extern "C" {
    pub fn dst_blackhole_mtu(dst: *const dst_entry) -> core::ffi::c_uint;
}
pub const TCP_ESTABLISHED: core::ffi::c_uint = 1;
pub const TCP_SYN_SENT: core::ffi::c_uint = 2;
pub const TCP_SYN_RECV: core::ffi::c_uint = 3;
pub const TCP_FIN_WAIT1: core::ffi::c_uint = 4;
pub const TCP_FIN_WAIT2: core::ffi::c_uint = 5;
pub const TCP_TIME_WAIT: core::ffi::c_uint = 6;
pub const TCP_CLOSE: core::ffi::c_uint = 7;
pub const TCP_CLOSE_WAIT: core::ffi::c_uint = 8;
pub const TCP_LAST_ACK: core::ffi::c_uint = 9;
pub const TCP_LISTEN: core::ffi::c_uint = 10;
pub const TCP_CLOSING: core::ffi::c_uint = 11;
pub const TCP_NEW_SYN_RECV: core::ffi::c_uint = 12;
pub const TCP_MAX_STATES: core::ffi::c_uint = 13;
pub type _bindgen_ty_288 = core::ffi::c_uint;
pub const TCPF_ESTABLISHED: core::ffi::c_uint = 2;
pub const TCPF_SYN_SENT: core::ffi::c_uint = 4;
pub const TCPF_SYN_RECV: core::ffi::c_uint = 8;
pub const TCPF_FIN_WAIT1: core::ffi::c_uint = 16;
pub const TCPF_FIN_WAIT2: core::ffi::c_uint = 32;
pub const TCPF_TIME_WAIT: core::ffi::c_uint = 64;
pub const TCPF_CLOSE: core::ffi::c_uint = 128;
pub const TCPF_CLOSE_WAIT: core::ffi::c_uint = 256;
pub const TCPF_LAST_ACK: core::ffi::c_uint = 512;
pub const TCPF_LISTEN: core::ffi::c_uint = 1024;
pub const TCPF_CLOSING: core::ffi::c_uint = 2048;
pub const TCPF_NEW_SYN_RECV: core::ffi::c_uint = 4096;
pub type _bindgen_ty_289 = core::ffi::c_uint;
pub const SOF_TIMESTAMPING_TX_HARDWARE: core::ffi::c_uint = 1;
pub const SOF_TIMESTAMPING_TX_SOFTWARE: core::ffi::c_uint = 2;
pub const SOF_TIMESTAMPING_RX_HARDWARE: core::ffi::c_uint = 4;
pub const SOF_TIMESTAMPING_RX_SOFTWARE: core::ffi::c_uint = 8;
pub const SOF_TIMESTAMPING_SOFTWARE: core::ffi::c_uint = 16;
pub const SOF_TIMESTAMPING_SYS_HARDWARE: core::ffi::c_uint = 32;
pub const SOF_TIMESTAMPING_RAW_HARDWARE: core::ffi::c_uint = 64;
pub const SOF_TIMESTAMPING_OPT_ID: core::ffi::c_uint = 128;
pub const SOF_TIMESTAMPING_TX_SCHED: core::ffi::c_uint = 256;
pub const SOF_TIMESTAMPING_TX_ACK: core::ffi::c_uint = 512;
pub const SOF_TIMESTAMPING_OPT_CMSG: core::ffi::c_uint = 1024;
pub const SOF_TIMESTAMPING_OPT_TSONLY: core::ffi::c_uint = 2048;
pub const SOF_TIMESTAMPING_OPT_STATS: core::ffi::c_uint = 4096;
pub const SOF_TIMESTAMPING_OPT_PKTINFO: core::ffi::c_uint = 8192;
pub const SOF_TIMESTAMPING_OPT_TX_SWHW: core::ffi::c_uint = 16384;
pub const SOF_TIMESTAMPING_BIND_PHC: core::ffi::c_uint = 32768;
pub const SOF_TIMESTAMPING_LAST: core::ffi::c_uint = 32768;
pub const SOF_TIMESTAMPING_MASK: core::ffi::c_uint = 65535;
pub type _bindgen_ty_290 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct so_timestamping {
    pub flags: core::ffi::c_int,
    pub bind_phc: core::ffi::c_int,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hwtstamp_config {
    pub flags: core::ffi::c_int,
    pub tx_type: core::ffi::c_int,
    pub rx_filter: core::ffi::c_int,
}
pub const hwtstamp_flags_HWTSTAMP_FLAG_BONDED_PHC_INDEX: hwtstamp_flags = 1;
pub const hwtstamp_flags_HWTSTAMP_FLAG_LAST: hwtstamp_flags = 1;
pub const hwtstamp_flags_HWTSTAMP_FLAG_MASK: hwtstamp_flags = 1;
pub type hwtstamp_flags = core::ffi::c_uint;
pub const hwtstamp_tx_types_HWTSTAMP_TX_OFF: hwtstamp_tx_types = 0;
pub const hwtstamp_tx_types_HWTSTAMP_TX_ON: hwtstamp_tx_types = 1;
pub const hwtstamp_tx_types_HWTSTAMP_TX_ONESTEP_SYNC: hwtstamp_tx_types = 2;
pub const hwtstamp_tx_types_HWTSTAMP_TX_ONESTEP_P2P: hwtstamp_tx_types = 3;
pub const hwtstamp_tx_types___HWTSTAMP_TX_CNT: hwtstamp_tx_types = 4;
pub type hwtstamp_tx_types = core::ffi::c_uint;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_NONE: hwtstamp_rx_filters = 0;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_ALL: hwtstamp_rx_filters = 1;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_SOME: hwtstamp_rx_filters = 2;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V1_L4_EVENT: hwtstamp_rx_filters = 3;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V1_L4_SYNC: hwtstamp_rx_filters = 4;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ: hwtstamp_rx_filters = 5;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L4_EVENT: hwtstamp_rx_filters = 6;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L4_SYNC: hwtstamp_rx_filters = 7;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ: hwtstamp_rx_filters = 8;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L2_EVENT: hwtstamp_rx_filters = 9;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L2_SYNC: hwtstamp_rx_filters = 10;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ: hwtstamp_rx_filters = 11;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_EVENT: hwtstamp_rx_filters = 12;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_SYNC: hwtstamp_rx_filters = 13;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_PTP_V2_DELAY_REQ: hwtstamp_rx_filters = 14;
pub const hwtstamp_rx_filters_HWTSTAMP_FILTER_NTP_ALL: hwtstamp_rx_filters = 15;
pub const hwtstamp_rx_filters___HWTSTAMP_FILTER_CNT: hwtstamp_rx_filters = 16;
pub type hwtstamp_rx_filters = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct scm_ts_pktinfo {
    pub if_index: __u32,
    pub pkt_length: __u32,
    pub reserved: [__u32; 2usize],
}
pub const txtime_flags_SOF_TXTIME_DEADLINE_MODE: txtime_flags = 1;
pub const txtime_flags_SOF_TXTIME_REPORT_ERRORS: txtime_flags = 2;
pub const txtime_flags_SOF_TXTIME_FLAGS_LAST: txtime_flags = 2;
pub const txtime_flags_SOF_TXTIME_FLAGS_MASK: txtime_flags = 3;
pub type txtime_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sock_txtime {
    pub clockid: __kernel_clockid_t,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fib_rule_hdr {
    pub family: __u8,
    pub dst_len: __u8,
    pub src_len: __u8,
    pub tos: __u8,
    pub table: __u8,
    pub res1: __u8,
    pub res2: __u8,
    pub action: __u8,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fib_rule_uid_range {
    pub start: __u32,
    pub end: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fib_rule_port_range {
    pub start: __u16,
    pub end: __u16,
}
pub const FRA_UNSPEC: core::ffi::c_uint = 0;
pub const FRA_DST: core::ffi::c_uint = 1;
pub const FRA_SRC: core::ffi::c_uint = 2;
pub const FRA_IIFNAME: core::ffi::c_uint = 3;
pub const FRA_GOTO: core::ffi::c_uint = 4;
pub const FRA_UNUSED2: core::ffi::c_uint = 5;
pub const FRA_PRIORITY: core::ffi::c_uint = 6;
pub const FRA_UNUSED3: core::ffi::c_uint = 7;
pub const FRA_UNUSED4: core::ffi::c_uint = 8;
pub const FRA_UNUSED5: core::ffi::c_uint = 9;
pub const FRA_FWMARK: core::ffi::c_uint = 10;
pub const FRA_FLOW: core::ffi::c_uint = 11;
pub const FRA_TUN_ID: core::ffi::c_uint = 12;
pub const FRA_SUPPRESS_IFGROUP: core::ffi::c_uint = 13;
pub const FRA_SUPPRESS_PREFIXLEN: core::ffi::c_uint = 14;
pub const FRA_TABLE: core::ffi::c_uint = 15;
pub const FRA_FWMASK: core::ffi::c_uint = 16;
pub const FRA_OIFNAME: core::ffi::c_uint = 17;
pub const FRA_PAD: core::ffi::c_uint = 18;
pub const FRA_L3MDEV: core::ffi::c_uint = 19;
pub const FRA_UID_RANGE: core::ffi::c_uint = 20;
pub const FRA_PROTOCOL: core::ffi::c_uint = 21;
pub const FRA_IP_PROTO: core::ffi::c_uint = 22;
pub const FRA_SPORT_RANGE: core::ffi::c_uint = 23;
pub const FRA_DPORT_RANGE: core::ffi::c_uint = 24;
pub const __FRA_MAX: core::ffi::c_uint = 25;
pub type _bindgen_ty_291 = core::ffi::c_uint;
pub const FR_ACT_UNSPEC: core::ffi::c_uint = 0;
pub const FR_ACT_TO_TBL: core::ffi::c_uint = 1;
pub const FR_ACT_GOTO: core::ffi::c_uint = 2;
pub const FR_ACT_NOP: core::ffi::c_uint = 3;
pub const FR_ACT_RES3: core::ffi::c_uint = 4;
pub const FR_ACT_RES4: core::ffi::c_uint = 5;
pub const FR_ACT_BLACKHOLE: core::ffi::c_uint = 6;
pub const FR_ACT_UNREACHABLE: core::ffi::c_uint = 7;
pub const FR_ACT_PROHIBIT: core::ffi::c_uint = 8;
pub const __FR_ACT_MAX: core::ffi::c_uint = 9;
pub type _bindgen_ty_292 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_notifier_info {
    pub family: core::ffi::c_int,
    pub extack: *mut netlink_ext_ack,
}
impl Default for fib_notifier_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const fib_event_type_FIB_EVENT_ENTRY_REPLACE: fib_event_type = 0;
pub const fib_event_type_FIB_EVENT_ENTRY_APPEND: fib_event_type = 1;
pub const fib_event_type_FIB_EVENT_ENTRY_ADD: fib_event_type = 2;
pub const fib_event_type_FIB_EVENT_ENTRY_DEL: fib_event_type = 3;
pub const fib_event_type_FIB_EVENT_RULE_ADD: fib_event_type = 4;
pub const fib_event_type_FIB_EVENT_RULE_DEL: fib_event_type = 5;
pub const fib_event_type_FIB_EVENT_NH_ADD: fib_event_type = 6;
pub const fib_event_type_FIB_EVENT_NH_DEL: fib_event_type = 7;
pub const fib_event_type_FIB_EVENT_VIF_ADD: fib_event_type = 8;
pub const fib_event_type_FIB_EVENT_VIF_DEL: fib_event_type = 9;
pub type fib_event_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_notifier_ops {
    pub family: core::ffi::c_int,
    pub list: list_head,
    pub fib_seq_read:
        ::core::option::Option<unsafe extern "C" fn(net: *mut net) -> core::ffi::c_uint>,
    pub fib_dump: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            nb: *mut notifier_block,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub owner: *mut module,
    pub rcu: callback_head,
}
impl Default for fib_notifier_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn call_fib_notifier(
        nb: *mut notifier_block,
        event_type: fib_event_type,
        info: *mut fib_notifier_info,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn call_fib_notifiers(
        net: *mut net,
        event_type: fib_event_type,
        info: *mut fib_notifier_info,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn register_fib_notifier(
        net: *mut net,
        nb: *mut notifier_block,
        cb: ::core::option::Option<unsafe extern "C" fn(nb: *mut notifier_block)>,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_fib_notifier(net: *mut net, nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_notifier_ops_register(
        tmpl: *const fib_notifier_ops,
        net: *mut net,
    ) -> *mut fib_notifier_ops;
}
extern "C" {
    pub fn fib_notifier_ops_unregister(ops: *mut fib_notifier_ops);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fib_kuid_range {
    pub start: kuid_t,
    pub end: kuid_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_rule {
    pub list: list_head,
    pub iifindex: core::ffi::c_int,
    pub oifindex: core::ffi::c_int,
    pub mark: u32_,
    pub mark_mask: u32_,
    pub flags: u32_,
    pub table: u32_,
    pub action: u8_,
    pub l3mdev: u8_,
    pub proto: u8_,
    pub ip_proto: u8_,
    pub target: u32_,
    pub tun_id: __be64,
    pub ctarget: *mut fib_rule,
    pub fr_net: *mut net,
    pub refcnt: refcount_t,
    pub pref: u32_,
    pub suppress_ifgroup: core::ffi::c_int,
    pub suppress_prefixlen: core::ffi::c_int,
    pub iifname: [core::ffi::c_char; 16usize],
    pub oifname: [core::ffi::c_char; 16usize],
    pub uid_range: fib_kuid_range,
    pub sport_range: fib_rule_port_range,
    pub dport_range: fib_rule_port_range,
    pub rcu: callback_head,
}
impl Default for fib_rule {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_lookup_arg {
    pub lookup_ptr: *mut core::ffi::c_void,
    pub lookup_data: *const core::ffi::c_void,
    pub result: *mut core::ffi::c_void,
    pub rule: *mut fib_rule,
    pub table: u32_,
    pub flags: core::ffi::c_int,
}
impl Default for fib_lookup_arg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_rules_ops {
    pub family: core::ffi::c_int,
    pub list: list_head,
    pub rule_size: core::ffi::c_int,
    pub addr_size: core::ffi::c_int,
    pub unresolved_rules: core::ffi::c_int,
    pub nr_goto_rules: core::ffi::c_int,
    pub fib_rules_seq: core::ffi::c_uint,
    pub action: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut flowi,
            arg3: core::ffi::c_int,
            arg4: *mut fib_lookup_arg,
        ) -> core::ffi::c_int,
    >,
    pub suppress: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: core::ffi::c_int,
            arg3: *mut fib_lookup_arg,
        ) -> bool_,
    >,
    pub match_: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut flowi,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub configure: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut sk_buff,
            arg3: *mut fib_rule_hdr,
            arg4: *mut *mut nlattr,
            arg5: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub delete:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> core::ffi::c_int>,
    pub compare: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut fib_rule_hdr,
            arg3: *mut *mut nlattr,
        ) -> core::ffi::c_int,
    >,
    pub fill: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut fib_rule,
            arg2: *mut sk_buff,
            arg3: *mut fib_rule_hdr,
        ) -> core::ffi::c_int,
    >,
    pub nlmsg_payload: ::core::option::Option<unsafe extern "C" fn(arg1: *mut fib_rule) -> usize>,
    pub flush_cache: ::core::option::Option<unsafe extern "C" fn(ops: *mut fib_rules_ops)>,
    pub nlgroup: core::ffi::c_int,
    pub rules_list: list_head,
    pub owner: *mut module,
    pub fro_net: *mut net,
    pub rcu: callback_head,
}
impl Default for fib_rules_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_rule_notifier_info {
    pub info: fib_notifier_info,
    pub rule: *mut fib_rule,
}
impl Default for fib_rule_notifier_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn fib_rules_register(arg1: *const fib_rules_ops, arg2: *mut net) -> *mut fib_rules_ops;
}
extern "C" {
    pub fn fib_rules_unregister(arg1: *mut fib_rules_ops);
}
extern "C" {
    pub fn fib_rules_lookup(
        arg1: *mut fib_rules_ops,
        arg2: *mut flowi,
        flags: core::ffi::c_int,
        arg3: *mut fib_lookup_arg,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_default_rule_add(
        arg1: *mut fib_rules_ops,
        pref: u32_,
        table: u32_,
        flags: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_rule_matchall(rule: *const fib_rule) -> bool_;
}
extern "C" {
    pub fn fib_rules_dump(
        net: *mut net,
        nb: *mut notifier_block,
        family: core::ffi::c_int,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_rules_seq_read(net: *mut net, family: core::ffi::c_int) -> core::ffi::c_uint;
}
extern "C" {
    pub fn fib_nl_newrule(
        skb: *mut sk_buff,
        nlh: *mut nlmsghdr,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_nl_delrule(
        skb: *mut sk_buff,
        nlh: *mut nlmsghdr,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
pub const l3mdev_type_L3MDEV_TYPE_UNSPEC: l3mdev_type = 0;
pub const l3mdev_type_L3MDEV_TYPE_VRF: l3mdev_type = 1;
pub const l3mdev_type___L3MDEV_TYPE_MAX: l3mdev_type = 2;
pub type l3mdev_type = core::ffi::c_uint;
pub type lookup_by_table_id_t =
    ::core::option::Option<unsafe extern "C" fn(net: *mut net, table_d: u32_) -> core::ffi::c_int>;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct l3mdev_ops {
    pub l3mdev_fib_table:
        ::core::option::Option<unsafe extern "C" fn(dev: *const net_device) -> u32_>,
    pub l3mdev_l3_rcv: ::core::option::Option<
        unsafe extern "C" fn(dev: *mut net_device, skb: *mut sk_buff, proto: u16_) -> *mut sk_buff,
    >,
    pub l3mdev_l3_out: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            sk: *mut sock,
            skb: *mut sk_buff,
            proto: u16_,
        ) -> *mut sk_buff,
    >,
    pub l3mdev_link_scope_lookup: ::core::option::Option<
        unsafe extern "C" fn(dev: *const net_device, fl6: *mut flowi6) -> *mut dst_entry,
    >,
}
extern "C" {
    pub fn l3mdev_table_lookup_register(
        l3type: l3mdev_type,
        fn_: lookup_by_table_id_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn l3mdev_table_lookup_unregister(l3type: l3mdev_type, fn_: lookup_by_table_id_t);
}
extern "C" {
    pub fn l3mdev_ifindex_lookup_by_table_id(
        l3type: l3mdev_type,
        net: *mut net,
        table_id: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn l3mdev_fib_rule_match(
        net: *mut net,
        fl: *mut flowi,
        arg: *mut fib_lookup_arg,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn l3mdev_update_flow(net: *mut net, fl: *mut flowi);
}
extern "C" {
    pub fn l3mdev_master_ifindex_rcu(dev: *const net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn l3mdev_master_upper_ifindex_by_index_rcu(
        net: *mut net,
        ifindex: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn l3mdev_fib_table_rcu(dev: *const net_device) -> u32_;
}
extern "C" {
    pub fn l3mdev_fib_table_by_index(net: *mut net, ifindex: core::ffi::c_int) -> u32_;
}
extern "C" {
    pub fn l3mdev_link_scope_lookup(net: *mut net, fl6: *mut flowi6) -> *mut dst_entry;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct socket_lock_t {
    pub slock: spinlock_t,
    pub owned: core::ffi::c_int,
    pub wq: wait_queue_head_t,
}
impl Default for socket_lock_t {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type __portpair = __u32;
pub type __addrpair = __u64;
#[repr(C)]
pub struct sock_common {
    pub __bindgen_anon_1: sock_common__bindgen_ty_1,
    pub __bindgen_anon_2: sock_common__bindgen_ty_2,
    pub __bindgen_anon_3: sock_common__bindgen_ty_3,
    pub skc_family: core::ffi::c_ushort,
    pub skc_state: core::ffi::c_uchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub skc_bound_dev_if: core::ffi::c_int,
    pub __bindgen_anon_4: sock_common__bindgen_ty_4,
    pub skc_prot: *mut proto,
    pub skc_net: possible_net_t,
    pub skc_v6_daddr: in6_addr,
    pub skc_v6_rcv_saddr: in6_addr,
    pub skc_cookie: atomic64_t,
    pub __bindgen_anon_5: sock_common__bindgen_ty_5,
    pub skc_dontcopy_begin: __IncompleteArrayField<core::ffi::c_int>,
    pub __bindgen_anon_6: sock_common__bindgen_ty_6,
    pub skc_tx_queue_mapping: core::ffi::c_ushort,
    pub skc_rx_queue_mapping: core::ffi::c_ushort,
    pub __bindgen_anon_7: sock_common__bindgen_ty_7,
    pub skc_refcnt: refcount_t,
    pub skc_dontcopy_end: __IncompleteArrayField<core::ffi::c_int>,
    pub __bindgen_anon_8: sock_common__bindgen_ty_8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_1 {
    pub skc_addrpair: __addrpair,
    pub __bindgen_anon_1: sock_common__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sock_common__bindgen_ty_1__bindgen_ty_1 {
    pub skc_daddr: __be32,
    pub skc_rcv_saddr: __be32,
}
impl Default for sock_common__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_2 {
    pub skc_hash: core::ffi::c_uint,
    pub skc_u16hashes: [__u16; 2usize],
    _bindgen_union_align: u32,
}
impl Default for sock_common__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_3 {
    pub skc_portpair: __portpair,
    pub __bindgen_anon_1: sock_common__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sock_common__bindgen_ty_3__bindgen_ty_1 {
    pub skc_dport: __be16,
    pub skc_num: __u16,
}
impl Default for sock_common__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_4 {
    pub skc_bind_node: hlist_node,
    pub skc_portaddr_node: hlist_node,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for sock_common__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_5 {
    pub skc_flags: core::ffi::c_ulong,
    pub skc_listener: *mut sock,
    pub skc_tw_dr: *mut inet_timewait_death_row,
    _bindgen_union_align: u64,
}
impl Default for sock_common__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_6 {
    pub skc_node: hlist_node,
    pub skc_nulls_node: hlist_nulls_node,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for sock_common__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_7 {
    pub skc_incoming_cpu: core::ffi::c_int,
    pub skc_rcv_wnd: u32_,
    pub skc_tw_rcv_nxt: u32_,
    _bindgen_union_align: u32,
}
impl Default for sock_common__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock_common__bindgen_ty_8 {
    pub skc_rxhash: u32_,
    pub skc_window_clamp: u32_,
    pub skc_tw_snd_nxt: u32_,
    _bindgen_union_align: u32,
}
impl Default for sock_common__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sock_common {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sock_common {
    #[inline]
    pub fn skc_reuse(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_skc_reuse(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_reuseport(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_reuseport(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_ipv6only(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_ipv6only(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skc_net_refcnt(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_skc_net_refcnt(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        skc_reuse: core::ffi::c_uchar,
        skc_reuseport: core::ffi::c_uchar,
        skc_ipv6only: core::ffi::c_uchar,
        skc_net_refcnt: core::ffi::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let skc_reuse: u8 = unsafe { ::core::mem::transmute(skc_reuse) };
            skc_reuse as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let skc_reuseport: u8 = unsafe { ::core::mem::transmute(skc_reuseport) };
            skc_reuseport as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let skc_ipv6only: u8 = unsafe { ::core::mem::transmute(skc_ipv6only) };
            skc_ipv6only as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let skc_net_refcnt: u8 = unsafe { ::core::mem::transmute(skc_net_refcnt) };
            skc_net_refcnt as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct sock {
    pub __sk_common: sock_common,
    pub sk_rx_dst: *mut dst_entry,
    pub sk_rx_dst_ifindex: core::ffi::c_int,
    pub sk_rx_dst_cookie: u32_,
    pub sk_lock: socket_lock_t,
    pub sk_drops: atomic_t,
    pub sk_rcvlowat: core::ffi::c_int,
    pub sk_error_queue: sk_buff_head,
    pub sk_receive_queue: sk_buff_head,
    pub sk_backlog: sock__bindgen_ty_1,
    pub sk_forward_alloc: core::ffi::c_int,
    pub sk_reserved_mem: u32_,
    pub sk_ll_usec: core::ffi::c_uint,
    pub sk_napi_id: core::ffi::c_uint,
    pub sk_rcvbuf: core::ffi::c_int,
    pub sk_filter: *mut sk_filter,
    pub __bindgen_anon_1: sock__bindgen_ty_2,
    pub sk_policy: [*mut xfrm_policy; 2usize],
    pub sk_dst_cache: *mut dst_entry,
    pub sk_omem_alloc: atomic_t,
    pub sk_sndbuf: core::ffi::c_int,
    pub sk_wmem_queued: core::ffi::c_int,
    pub sk_wmem_alloc: refcount_t,
    pub sk_tsq_flags: core::ffi::c_ulong,
    pub __bindgen_anon_2: sock__bindgen_ty_3,
    pub sk_write_queue: sk_buff_head,
    pub sk_peek_off: __s32,
    pub sk_write_pending: core::ffi::c_int,
    pub sk_dst_pending_confirm: __u32,
    pub sk_pacing_status: u32_,
    pub sk_sndtimeo: core::ffi::c_long,
    pub sk_timer: timer_list,
    pub sk_priority: __u32,
    pub sk_mark: __u32,
    pub sk_pacing_rate: core::ffi::c_ulong,
    pub sk_max_pacing_rate: core::ffi::c_ulong,
    pub sk_frag: page_frag,
    pub sk_route_caps: netdev_features_t,
    pub sk_gso_type: core::ffi::c_int,
    pub sk_gso_max_size: core::ffi::c_uint,
    pub sk_allocation: gfp_t,
    pub sk_txhash: __u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub sk_pacing_shift: u8_,
    pub sk_type: u16_,
    pub sk_protocol: u16_,
    pub sk_gso_max_segs: u16_,
    pub sk_lingertime: core::ffi::c_ulong,
    pub sk_prot_creator: *mut proto,
    pub sk_callback_lock: rwlock_t,
    pub sk_err: core::ffi::c_int,
    pub sk_err_soft: core::ffi::c_int,
    pub sk_ack_backlog: u32_,
    pub sk_max_ack_backlog: u32_,
    pub sk_uid: kuid_t,
    pub sk_txrehash: u8_,
    pub sk_prefer_busy_poll: u8_,
    pub sk_busy_poll_budget: u16_,
    pub sk_peer_lock: spinlock_t,
    pub sk_bind_phc: core::ffi::c_int,
    pub sk_peer_pid: *mut pid,
    pub sk_peer_cred: *const cred,
    pub sk_rcvtimeo: core::ffi::c_long,
    pub sk_stamp: ktime_t,
    pub sk_tsflags: u16_,
    pub sk_shutdown: u8_,
    pub sk_tskey: atomic_t,
    pub sk_zckey: atomic_t,
    pub sk_clockid: u8_,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub sk_socket: *mut socket,
    pub sk_user_data: *mut core::ffi::c_void,
    pub sk_security: *mut core::ffi::c_void,
    pub sk_cgrp_data: sock_cgroup_data,
    pub sk_memcg: *mut mem_cgroup,
    pub sk_state_change: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub sk_data_ready: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub sk_write_space: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub sk_error_report: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub sk_backlog_rcv: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub sk_destruct: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub sk_reuseport_cb: *mut sock_reuseport,
    pub sk_bpf_storage: *mut bpf_local_storage,
    pub sk_rcu: callback_head,
    pub ns_tracker: netns_tracker,
    pub sk_bind2_node: hlist_node,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock__bindgen_ty_1 {
    pub rmem_alloc: atomic_t,
    pub len: core::ffi::c_int,
    pub head: *mut sk_buff,
    pub tail: *mut sk_buff,
}
impl Default for sock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock__bindgen_ty_2 {
    pub sk_wq: *mut socket_wq,
    pub sk_wq_raw: *mut socket_wq,
    _bindgen_union_align: u64,
}
impl Default for sock__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sock__bindgen_ty_3 {
    pub sk_send_head: *mut sk_buff,
    pub tcp_rtx_queue: rb_root,
    _bindgen_union_align: u64,
}
impl Default for sock__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sock {
    #[inline]
    pub fn sk_gso_disabled(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_gso_disabled(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_kern_sock(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_kern_sock(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_no_check_tx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_no_check_tx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_no_check_rx(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_no_check_rx(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_userlocks(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_sk_userlocks(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        sk_gso_disabled: u8_,
        sk_kern_sock: u8_,
        sk_no_check_tx: u8_,
        sk_no_check_rx: u8_,
        sk_userlocks: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sk_gso_disabled: u8 = unsafe { ::core::mem::transmute(sk_gso_disabled) };
            sk_gso_disabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sk_kern_sock: u8 = unsafe { ::core::mem::transmute(sk_kern_sock) };
            sk_kern_sock as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let sk_no_check_tx: u8 = unsafe { ::core::mem::transmute(sk_no_check_tx) };
            sk_no_check_tx as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let sk_no_check_rx: u8 = unsafe { ::core::mem::transmute(sk_no_check_rx) };
            sk_no_check_rx as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let sk_userlocks: u8 = unsafe { ::core::mem::transmute(sk_userlocks) };
            sk_userlocks as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn sk_txtime_deadline_mode(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_deadline_mode(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_txtime_report_errors(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_report_errors(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sk_txtime_unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_sk_txtime_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        sk_txtime_deadline_mode: u8_,
        sk_txtime_report_errors: u8_,
        sk_txtime_unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let sk_txtime_deadline_mode: u8 =
                unsafe { ::core::mem::transmute(sk_txtime_deadline_mode) };
            sk_txtime_deadline_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sk_txtime_report_errors: u8 =
                unsafe { ::core::mem::transmute(sk_txtime_report_errors) };
            sk_txtime_report_errors as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let sk_txtime_unused: u8 = unsafe { ::core::mem::transmute(sk_txtime_unused) };
            sk_txtime_unused as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const sk_pacing_SK_PACING_NONE: sk_pacing = 0;
pub const sk_pacing_SK_PACING_NEEDED: sk_pacing = 1;
pub const sk_pacing_SK_PACING_FQ: sk_pacing = 2;
pub type sk_pacing = core::ffi::c_uint;
extern "C" {
    pub fn sk_set_peek_off(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int;
}
pub const sock_flags_SOCK_DEAD: sock_flags = 0;
pub const sock_flags_SOCK_DONE: sock_flags = 1;
pub const sock_flags_SOCK_URGINLINE: sock_flags = 2;
pub const sock_flags_SOCK_KEEPOPEN: sock_flags = 3;
pub const sock_flags_SOCK_LINGER: sock_flags = 4;
pub const sock_flags_SOCK_DESTROY: sock_flags = 5;
pub const sock_flags_SOCK_BROADCAST: sock_flags = 6;
pub const sock_flags_SOCK_TIMESTAMP: sock_flags = 7;
pub const sock_flags_SOCK_ZAPPED: sock_flags = 8;
pub const sock_flags_SOCK_USE_WRITE_QUEUE: sock_flags = 9;
pub const sock_flags_SOCK_DBG: sock_flags = 10;
pub const sock_flags_SOCK_RCVTSTAMP: sock_flags = 11;
pub const sock_flags_SOCK_RCVTSTAMPNS: sock_flags = 12;
pub const sock_flags_SOCK_LOCALROUTE: sock_flags = 13;
pub const sock_flags_SOCK_MEMALLOC: sock_flags = 14;
pub const sock_flags_SOCK_TIMESTAMPING_RX_SOFTWARE: sock_flags = 15;
pub const sock_flags_SOCK_FASYNC: sock_flags = 16;
pub const sock_flags_SOCK_RXQ_OVFL: sock_flags = 17;
pub const sock_flags_SOCK_ZEROCOPY: sock_flags = 18;
pub const sock_flags_SOCK_WIFI_STATUS: sock_flags = 19;
pub const sock_flags_SOCK_NOFCS: sock_flags = 20;
pub const sock_flags_SOCK_FILTER_LOCKED: sock_flags = 21;
pub const sock_flags_SOCK_SELECT_ERR_QUEUE: sock_flags = 22;
pub const sock_flags_SOCK_RCU_FREE: sock_flags = 23;
pub const sock_flags_SOCK_TXTIME: sock_flags = 24;
pub const sock_flags_SOCK_XDP: sock_flags = 25;
pub const sock_flags_SOCK_TSTAMP_NEW: sock_flags = 26;
pub const sock_flags_SOCK_RCVMARK: sock_flags = 27;
pub type sock_flags = core::ffi::c_uint;
extern "C" {
    pub static mut memalloc_socks_key: static_key_false;
}
extern "C" {
    pub fn __receive_sock(file: *mut file);
}
extern "C" {
    pub fn sk_stream_write_space(sk: *mut sock);
}
extern "C" {
    pub fn __sk_backlog_rcv(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_stream_wait_connect(
        sk: *mut sock,
        timeo_p: *mut core::ffi::c_long,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_stream_wait_memory(
        sk: *mut sock,
        timeo_p: *mut core::ffi::c_long,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_stream_wait_close(sk: *mut sock, timeo_p: core::ffi::c_long);
}
extern "C" {
    pub fn sk_stream_error(
        sk: *mut sock,
        flags: core::ffi::c_int,
        err: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_stream_kill_queues(sk: *mut sock);
}
extern "C" {
    pub fn sk_set_memalloc(sk: *mut sock);
}
extern "C" {
    pub fn sk_clear_memalloc(sk: *mut sock);
}
extern "C" {
    pub fn __sk_flush_backlog(sk: *mut sock);
}
extern "C" {
    pub fn sk_wait_data(
        sk: *mut sock,
        timeo: *mut core::ffi::c_long,
        skb: *const sk_buff,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raw_hashinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct smc_hashinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_psock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct proto {
    pub close:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, timeout: core::ffi::c_long)>,
    pub pre_connect: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            uaddr: *mut sockaddr,
            addr_len: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub connect: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            uaddr: *mut sockaddr,
            addr_len: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub disconnect: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, flags: core::ffi::c_int) -> core::ffi::c_int,
    >,
    pub accept: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            flags: core::ffi::c_int,
            err: *mut core::ffi::c_int,
            kern: bool_,
        ) -> *mut sock,
    >,
    pub ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            cmd: core::ffi::c_int,
            arg: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub init: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> core::ffi::c_int>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub shutdown:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, how: core::ffi::c_int)>,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            level: core::ffi::c_int,
            optname: core::ffi::c_int,
            optval: sockptr_t,
            optlen: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            level: core::ffi::c_int,
            optname: core::ffi::c_int,
            optval: *mut core::ffi::c_char,
            option: *mut core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub keepalive:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, valbool: core::ffi::c_int)>,
    pub compat_ioctl: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            cmd: core::ffi::c_uint,
            arg: core::ffi::c_ulong,
        ) -> core::ffi::c_int,
    >,
    pub sendmsg: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, msg: *mut msghdr, len: usize) -> core::ffi::c_int,
    >,
    pub recvmsg: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            msg: *mut msghdr,
            len: usize,
            flags: core::ffi::c_int,
            addr_len: *mut core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub sendpage: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            page: *mut page,
            offset: core::ffi::c_int,
            size: usize,
            flags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub bind: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            addr: *mut sockaddr,
            addr_len: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub bind_add: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            addr: *mut sockaddr,
            addr_len: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub backlog_rcv: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub bpf_bypass_getsockopt: ::core::option::Option<
        unsafe extern "C" fn(level: core::ffi::c_int, optname: core::ffi::c_int) -> bool_,
    >,
    pub release_cb: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub hash: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> core::ffi::c_int>,
    pub unhash: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub rehash: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub get_port: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, snum: core::ffi::c_ushort) -> core::ffi::c_int,
    >,
    pub put_port: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub psock_update_sk_prot: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            psock: *mut sk_psock,
            restore: bool_,
        ) -> core::ffi::c_int,
    >,
    pub inuse_idx: core::ffi::c_uint,
    pub stream_memory_free: ::core::option::Option<
        unsafe extern "C" fn(sk: *const sock, wake: core::ffi::c_int) -> bool_,
    >,
    pub sock_is_readable: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> bool_>,
    pub enter_memory_pressure: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub leave_memory_pressure: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub memory_allocated: *mut atomic_long_t,
    pub per_cpu_fw_alloc: *mut core::ffi::c_int,
    pub sockets_allocated: *mut percpu_counter,
    pub memory_pressure: *mut core::ffi::c_ulong,
    pub sysctl_mem: *mut core::ffi::c_long,
    pub sysctl_wmem: *mut core::ffi::c_int,
    pub sysctl_rmem: *mut core::ffi::c_int,
    pub sysctl_wmem_offset: u32_,
    pub sysctl_rmem_offset: u32_,
    pub max_header: core::ffi::c_int,
    pub no_autobind: bool_,
    pub slab: *mut kmem_cache,
    pub obj_size: core::ffi::c_uint,
    pub slab_flags: slab_flags_t,
    pub useroffset: core::ffi::c_uint,
    pub usersize: core::ffi::c_uint,
    pub orphan_count: *mut core::ffi::c_uint,
    pub rsk_prot: *mut request_sock_ops,
    pub twsk_prot: *mut timewait_sock_ops,
    pub h: proto__bindgen_ty_1,
    pub owner: *mut module,
    pub name: [core::ffi::c_char; 32usize],
    pub node: list_head,
    pub diag_destroy: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, err: core::ffi::c_int) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union proto__bindgen_ty_1 {
    pub hashinfo: *mut inet_hashinfo,
    pub udp_table: *mut udp_table,
    pub raw_hash: *mut raw_hashinfo,
    pub smc_hash: *mut smc_hashinfo,
    _bindgen_union_align: u64,
}
impl Default for proto__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for proto {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn proto_register(prot: *mut proto, alloc_slab: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn proto_unregister(prot: *mut proto);
}
extern "C" {
    pub fn sock_load_diag_module(
        family: core::ffi::c_int,
        protocol: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prot_inuse {
    pub all: core::ffi::c_int,
    pub val: [core::ffi::c_int; 64usize],
}
impl Default for prot_inuse {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn sock_prot_inuse_get(net: *mut net, proto: *mut proto) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_inuse_get(net: *mut net) -> core::ffi::c_int;
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct socket_alloc {
    pub socket: socket,
    pub vfs_inode: inode,
}
impl Default for socket_alloc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __sk_mem_raise_allocated(
        sk: *mut sock,
        size: core::ffi::c_int,
        amt: core::ffi::c_int,
        kind: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sk_mem_schedule(
        sk: *mut sock,
        size: core::ffi::c_int,
        kind: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sk_mem_reduce_allocated(sk: *mut sock, amount: core::ffi::c_int);
}
extern "C" {
    pub fn __sk_mem_reclaim(sk: *mut sock, amount: core::ffi::c_int);
}
extern "C" {
    pub fn lock_sock_nested(sk: *mut sock, subclass: core::ffi::c_int);
}
extern "C" {
    pub fn __lock_sock(sk: *mut sock);
}
extern "C" {
    pub fn __release_sock(sk: *mut sock);
}
extern "C" {
    pub fn release_sock(sk: *mut sock);
}
extern "C" {
    pub fn __lock_sock_fast(sk: *mut sock) -> bool_;
}
extern "C" {
    pub fn sockopt_lock_sock(sk: *mut sock);
}
extern "C" {
    pub fn sockopt_release_sock(sk: *mut sock);
}
extern "C" {
    pub fn sockopt_ns_capable(ns: *mut user_namespace, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn sockopt_capable(cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn sk_alloc(
        net: *mut net,
        family: core::ffi::c_int,
        priority: gfp_t,
        prot: *mut proto,
        kern: core::ffi::c_int,
    ) -> *mut sock;
}
extern "C" {
    pub fn sk_free(sk: *mut sock);
}
extern "C" {
    pub fn sk_destruct(sk: *mut sock);
}
extern "C" {
    pub fn sk_clone_lock(sk: *const sock, priority: gfp_t) -> *mut sock;
}
extern "C" {
    pub fn sk_free_unlock_clone(sk: *mut sock);
}
extern "C" {
    pub fn sock_wmalloc(
        sk: *mut sock,
        size: core::ffi::c_ulong,
        force: core::ffi::c_int,
        priority: gfp_t,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn __sock_wfree(skb: *mut sk_buff);
}
extern "C" {
    pub fn sock_wfree(skb: *mut sk_buff);
}
extern "C" {
    pub fn sock_omalloc(sk: *mut sock, size: core::ffi::c_ulong, priority: gfp_t) -> *mut sk_buff;
}
extern "C" {
    pub fn skb_orphan_partial(skb: *mut sk_buff);
}
extern "C" {
    pub fn sock_rfree(skb: *mut sk_buff);
}
extern "C" {
    pub fn sock_efree(skb: *mut sk_buff);
}
extern "C" {
    pub fn sock_edemux(skb: *mut sk_buff);
}
extern "C" {
    pub fn sock_pfree(skb: *mut sk_buff);
}
extern "C" {
    pub fn sk_setsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_setsockopt(
        sock: *mut socket,
        level: core::ffi::c_int,
        op: core::ffi::c_int,
        optval: sockptr_t,
        optlen: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_getsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: sockptr_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_getsockopt(
        sock: *mut socket,
        level: core::ffi::c_int,
        op: core::ffi::c_int,
        optval: *mut core::ffi::c_char,
        optlen: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_gettstamp(
        sock: *mut socket,
        userstamp: *mut core::ffi::c_void,
        timeval: bool_,
        time32: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_alloc_send_pskb(
        sk: *mut sock,
        header_len: core::ffi::c_ulong,
        data_len: core::ffi::c_ulong,
        noblock: core::ffi::c_int,
        errcode: *mut core::ffi::c_int,
        max_page_order: core::ffi::c_int,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn sock_kmalloc(
        sk: *mut sock,
        size: core::ffi::c_int,
        priority: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn sock_kfree_s(sk: *mut sock, mem: *mut core::ffi::c_void, size: core::ffi::c_int);
}
extern "C" {
    pub fn sock_kzfree_s(sk: *mut sock, mem: *mut core::ffi::c_void, size: core::ffi::c_int);
}
extern "C" {
    pub fn sk_send_sigurg(sk: *mut sock);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sockcm_cookie {
    pub transmit_time: u64_,
    pub mark: u32_,
    pub tsflags: u16_,
}
extern "C" {
    pub fn __sock_cmsg_send(
        sk: *mut sock,
        msg: *mut msghdr,
        cmsg: *mut cmsghdr,
        sockc: *mut sockcm_cookie,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_cmsg_send(
        sk: *mut sock,
        msg: *mut msghdr,
        sockc: *mut sockcm_cookie,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_bind(
        arg1: *mut socket,
        arg2: *mut sockaddr,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_connect(
        arg1: *mut socket,
        arg2: *mut sockaddr,
        arg3: core::ffi::c_int,
        arg4: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_socketpair(arg1: *mut socket, arg2: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_accept(
        arg1: *mut socket,
        arg2: *mut socket,
        arg3: core::ffi::c_int,
        arg4: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_getname(
        arg1: *mut socket,
        arg2: *mut sockaddr,
        arg3: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_ioctl(
        arg1: *mut socket,
        arg2: core::ffi::c_uint,
        arg3: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_listen(arg1: *mut socket, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_shutdown(arg1: *mut socket, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_sendmsg(arg1: *mut socket, arg2: *mut msghdr, arg3: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_sendmsg_locked(sk: *mut sock, msg: *mut msghdr, len: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_recvmsg(
        arg1: *mut socket,
        arg2: *mut msghdr,
        arg3: usize,
        arg4: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_mmap(
        file: *mut file,
        sock: *mut socket,
        vma: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_no_sendpage(
        sock: *mut socket,
        page: *mut page,
        offset: core::ffi::c_int,
        size: usize,
        flags: core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sock_no_sendpage_locked(
        sk: *mut sock,
        page: *mut page,
        offset: core::ffi::c_int,
        size: usize,
        flags: core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn sock_common_getsockopt(
        sock: *mut socket,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: *mut core::ffi::c_char,
        optlen: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_common_recvmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_common_setsockopt(
        sock: *mut socket,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_common_release(sk: *mut sock);
}
extern "C" {
    pub fn sock_init_data(sock: *mut socket, sk: *mut sock);
}
extern "C" {
    pub fn sock_gen_put(sk: *mut sock);
}
extern "C" {
    pub fn __sk_receive_skb(
        sk: *mut sock,
        skb: *mut sk_buff,
        nested: core::ffi::c_int,
        trim_cap: core::ffi::c_uint,
        refcounted: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_i_uid(sk: *mut sock) -> kuid_t;
}
extern "C" {
    pub fn sock_i_ino(sk: *mut sock) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn __sk_dst_check(sk: *mut sock, cookie: u32_) -> *mut dst_entry;
}
extern "C" {
    pub fn sk_dst_check(sk: *mut sock, cookie: u32_) -> *mut dst_entry;
}
extern "C" {
    pub fn sk_mc_loop(sk: *mut sock) -> bool_;
}
extern "C" {
    pub fn sk_setup_caps(sk: *mut sock, dst: *mut dst_entry);
}
extern "C" {
    pub fn skb_set_owner_w(skb: *mut sk_buff, sk: *mut sock);
}
extern "C" {
    pub fn sk_reset_timer(sk: *mut sock, timer: *mut timer_list, expires: core::ffi::c_ulong);
}
extern "C" {
    pub fn sk_stop_timer(sk: *mut sock, timer: *mut timer_list);
}
extern "C" {
    pub fn sk_stop_timer_sync(sk: *mut sock, timer: *mut timer_list);
}
extern "C" {
    pub fn __sk_queue_drop_skb(
        sk: *mut sock,
        sk_queue: *mut sk_buff_head,
        skb: *mut sk_buff,
        flags: core::ffi::c_uint,
        destructor: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff)>,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __sock_queue_rcv_skb(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_queue_rcv_skb_reason(
        sk: *mut sock,
        skb: *mut sk_buff,
        reason: *mut skb_drop_reason,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_queue_err_skb(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_dequeue_err_skb(sk: *mut sock) -> *mut sk_buff;
}
extern "C" {
    pub fn sk_error_report(sk: *mut sock);
}
extern "C" {
    pub fn sk_page_frag_refill(sk: *mut sock, pfrag: *mut page_frag) -> bool_;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sock_skb_cb {
    pub dropcount: u32_,
}
extern "C" {
    pub fn __sock_recv_timestamp(msg: *mut msghdr, sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn __sock_recv_wifi_status(msg: *mut msghdr, sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn __sock_recv_cmsgs(msg: *mut msghdr, sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn __sock_tx_timestamp(tsflags: __u16, tx_flags: *mut __u8);
}
extern "C" {
    pub fn sock_enable_timestamp(sk: *mut sock, flag: sock_flags);
}
extern "C" {
    pub fn sock_recv_errqueue(
        sk: *mut sock,
        msg: *mut msghdr,
        len: core::ffi::c_int,
        level: core::ffi::c_int,
        type_: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_ns_capable(
        sk: *const sock,
        user_ns: *mut user_namespace,
        cap: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn sk_capable(sk: *const sock, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn sk_net_capable(sk: *const sock, cap: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn sk_get_meminfo(sk: *const sock, meminfo: *mut u32_);
}
extern "C" {
    pub static mut sysctl_wmem_max: __u32;
}
extern "C" {
    pub static mut sysctl_rmem_max: __u32;
}
extern "C" {
    pub static mut sysctl_tstamp_allow_data: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_optmem_max: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_wmem_default: __u32;
}
extern "C" {
    pub static mut sysctl_rmem_default: __u32;
}
extern "C" {
    pub static mut net_high_order_alloc_disable_key: static_key_false;
}
extern "C" {
    pub fn sock_def_readable(sk: *mut sock);
}
extern "C" {
    pub fn sock_bindtoindex(
        sk: *mut sock,
        ifindex: core::ffi::c_int,
        lock_sk: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_set_timestamp(sk: *mut sock, optname: core::ffi::c_int, valbool: bool_);
}
extern "C" {
    pub fn sock_set_timestamping(
        sk: *mut sock,
        optname: core::ffi::c_int,
        timestamping: so_timestamping,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_enable_timestamps(sk: *mut sock);
}
extern "C" {
    pub fn sock_no_linger(sk: *mut sock);
}
extern "C" {
    pub fn sock_set_keepalive(sk: *mut sock);
}
extern "C" {
    pub fn sock_set_priority(sk: *mut sock, priority: u32_);
}
extern "C" {
    pub fn sock_set_rcvbuf(sk: *mut sock, val: core::ffi::c_int);
}
extern "C" {
    pub fn sock_set_mark(sk: *mut sock, val: u32_);
}
extern "C" {
    pub fn sock_set_reuseaddr(sk: *mut sock);
}
extern "C" {
    pub fn sock_set_reuseport(sk: *mut sock);
}
extern "C" {
    pub fn sock_set_sndtimeo(sk: *mut sock, secs: s64);
}
extern "C" {
    pub fn sock_bind_add(
        sk: *mut sock,
        addr: *mut sockaddr,
        addr_len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_get_timeout(
        timeo: core::ffi::c_long,
        optval: *mut core::ffi::c_void,
        old_timeval: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_copy_user_timeval(
        tv: *mut __kernel_sock_timeval,
        optval: sockptr_t,
        optlen: core::ffi::c_int,
        old_timeval: bool_,
    ) -> core::ffi::c_int;
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct __una_u16 {
    pub x: u16_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct __una_u32 {
    pub x: u32_,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct __una_u64 {
    pub x: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_sock_ops {
    pub family: core::ffi::c_int,
    pub obj_size: core::ffi::c_uint,
    pub slab: *mut kmem_cache,
    pub slab_name: *mut core::ffi::c_char,
    pub rtx_syn_ack: ::core::option::Option<
        unsafe extern "C" fn(sk: *const sock, req: *mut request_sock) -> core::ffi::c_int,
    >,
    pub send_ack: ::core::option::Option<
        unsafe extern "C" fn(sk: *const sock, skb: *mut sk_buff, req: *mut request_sock),
    >,
    pub send_reset:
        ::core::option::Option<unsafe extern "C" fn(sk: *const sock, skb: *mut sk_buff)>,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(req: *mut request_sock)>,
    pub syn_ack_timeout: ::core::option::Option<unsafe extern "C" fn(req: *const request_sock)>,
}
impl Default for request_sock_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn inet_rtx_syn_ack(parent: *const sock, req: *mut request_sock) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default)]
pub struct saved_syn {
    pub mac_hdrlen: u32_,
    pub network_hdrlen: u32_,
    pub tcp_hdrlen: u32_,
    pub data: __IncompleteArrayField<u8_>,
}
#[repr(C)]
pub struct request_sock {
    pub __req_common: sock_common,
    pub dl_next: *mut request_sock,
    pub mss: u16_,
    pub num_retrans: u8_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub ts_recent: u32_,
    pub rsk_timer: timer_list,
    pub rsk_ops: *const request_sock_ops,
    pub sk: *mut sock,
    pub saved_syn: *mut saved_syn,
    pub secid: u32_,
    pub peer_secid: u32_,
    pub timeout: u32_,
}
impl Default for request_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl request_sock {
    #[inline]
    pub fn syncookie(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syncookie(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_timeout(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_num_timeout(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        syncookie: u8_,
        num_timeout: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let syncookie: u8 = unsafe { ::core::mem::transmute(syncookie) };
            syncookie as u64
        });
        __bindgen_bitfield_unit.set(1usize, 7u8, {
            let num_timeout: u8 = unsafe { ::core::mem::transmute(num_timeout) };
            num_timeout as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fastopen_queue {
    pub rskq_rst_head: *mut request_sock,
    pub rskq_rst_tail: *mut request_sock,
    pub lock: spinlock_t,
    pub qlen: core::ffi::c_int,
    pub max_qlen: core::ffi::c_int,
    pub ctx: *mut tcp_fastopen_context,
}
impl Default for fastopen_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct request_sock_queue {
    pub rskq_lock: spinlock_t,
    pub rskq_defer_accept: u8_,
    pub synflood_warned: u32_,
    pub qlen: atomic_t,
    pub young: atomic_t,
    pub rskq_accept_head: *mut request_sock,
    pub rskq_accept_tail: *mut request_sock,
    pub fastopenq: fastopen_queue,
}
impl Default for request_sock_queue {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn reqsk_queue_alloc(queue: *mut request_sock_queue);
}
extern "C" {
    pub fn reqsk_fastopen_remove(sk: *mut sock, req: *mut request_sock, reset: bool_);
}
#[repr(C)]
#[derive(Default)]
pub struct ip_options {
    pub faddr: __be32,
    pub nexthop: __be32,
    pub optlen: core::ffi::c_uchar,
    pub srr: core::ffi::c_uchar,
    pub rr: core::ffi::c_uchar,
    pub ts: core::ffi::c_uchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub router_alert: core::ffi::c_uchar,
    pub cipso: core::ffi::c_uchar,
    pub __pad2: core::ffi::c_uchar,
    pub __data: __IncompleteArrayField<core::ffi::c_uchar>,
}
impl ip_options {
    #[inline]
    pub fn is_strictroute(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_strictroute(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn srr_is_hit(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_srr_is_hit(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_changed(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_changed(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rr_needaddr(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rr_needaddr(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ts_needtime(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ts_needtime(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ts_needaddr(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ts_needaddr(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_strictroute: core::ffi::c_uchar,
        srr_is_hit: core::ffi::c_uchar,
        is_changed: core::ffi::c_uchar,
        rr_needaddr: core::ffi::c_uchar,
        ts_needtime: core::ffi::c_uchar,
        ts_needaddr: core::ffi::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_strictroute: u8 = unsafe { ::core::mem::transmute(is_strictroute) };
            is_strictroute as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let srr_is_hit: u8 = unsafe { ::core::mem::transmute(srr_is_hit) };
            srr_is_hit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_changed: u8 = unsafe { ::core::mem::transmute(is_changed) };
            is_changed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rr_needaddr: u8 = unsafe { ::core::mem::transmute(rr_needaddr) };
            rr_needaddr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ts_needtime: u8 = unsafe { ::core::mem::transmute(ts_needtime) };
            ts_needtime as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ts_needaddr: u8 = unsafe { ::core::mem::transmute(ts_needaddr) };
            ts_needaddr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct ip_options_rcu {
    pub rcu: callback_head,
    pub opt: ip_options,
}
impl Default for ip_options_rcu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct ip_options_data {
    pub opt: ip_options_rcu,
    pub data: [core::ffi::c_char; 40usize],
}
impl Default for ip_options_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct inet_request_sock {
    pub req: request_sock,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub ir_mark: u32_,
    pub __bindgen_anon_1: inet_request_sock__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inet_request_sock__bindgen_ty_1 {
    pub ireq_opt: *mut ip_options_rcu,
    pub __bindgen_anon_1: inet_request_sock__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_request_sock__bindgen_ty_1__bindgen_ty_1 {
    pub ipv6_opt: *mut ipv6_txoptions,
    pub pktopts: *mut sk_buff,
}
impl Default for inet_request_sock__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for inet_request_sock__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for inet_request_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl inet_request_sock {
    #[inline]
    pub fn snd_wscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_snd_wscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rcv_wscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_rcv_wscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tstamp_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_tstamp_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sack_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_sack_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wscale_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_wscale_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ecn_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ecn_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn acked(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_acked(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_srccheck(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_no_srccheck(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn smc_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_smc_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        snd_wscale: u16_,
        rcv_wscale: u16_,
        tstamp_ok: u16_,
        sack_ok: u16_,
        wscale_ok: u16_,
        ecn_ok: u16_,
        acked: u16_,
        no_srccheck: u16_,
        smc_ok: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let snd_wscale: u16 = unsafe { ::core::mem::transmute(snd_wscale) };
            snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let rcv_wscale: u16 = unsafe { ::core::mem::transmute(rcv_wscale) };
            rcv_wscale as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tstamp_ok: u16 = unsafe { ::core::mem::transmute(tstamp_ok) };
            tstamp_ok as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let sack_ok: u16 = unsafe { ::core::mem::transmute(sack_ok) };
            sack_ok as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let wscale_ok: u16 = unsafe { ::core::mem::transmute(wscale_ok) };
            wscale_ok as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ecn_ok: u16 = unsafe { ::core::mem::transmute(ecn_ok) };
            ecn_ok as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let acked: u16 = unsafe { ::core::mem::transmute(acked) };
            acked as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let no_srccheck: u16 = unsafe { ::core::mem::transmute(no_srccheck) };
            no_srccheck as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let smc_ok: u16 = unsafe { ::core::mem::transmute(smc_ok) };
            smc_ok as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_cork {
    pub flags: core::ffi::c_uint,
    pub addr: __be32,
    pub opt: *mut ip_options,
    pub fragsize: core::ffi::c_uint,
    pub length: core::ffi::c_int,
    pub dst: *mut dst_entry,
    pub tx_flags: u8_,
    pub ttl: __u8,
    pub tos: __s16,
    pub priority: core::ffi::c_char,
    pub gso_size: __u16,
    pub transmit_time: u64_,
    pub mark: u32_,
}
impl Default for inet_cork {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_cork_full {
    pub base: inet_cork,
    pub fl: flowi,
}
impl Default for inet_cork_full {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_mc_socklist {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct inet_sock {
    pub sk: sock,
    pub pinet6: *mut ipv6_pinfo,
    pub inet_saddr: __be32,
    pub uc_ttl: __s16,
    pub cmsg_flags: __u16,
    pub inet_opt: *mut ip_options_rcu,
    pub inet_sport: __be16,
    pub inet_id: __u16,
    pub tos: __u8,
    pub min_ttl: __u8,
    pub mc_ttl: __u8,
    pub pmtudisc: __u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub rcv_tos: __u8,
    pub convert_csum: __u8,
    pub uc_index: core::ffi::c_int,
    pub mc_index: core::ffi::c_int,
    pub mc_addr: __be32,
    pub mc_list: *mut ip_mc_socklist,
    pub cork: inet_cork_full,
}
impl Default for inet_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl inet_sock {
    #[inline]
    pub fn recverr(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_recverr(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_icsk(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_icsk(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn freebind(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_freebind(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hdrincl(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hdrincl(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mc_loop(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mc_loop(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transparent(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_transparent(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mc_all(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mc_all(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn nodefrag(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_nodefrag(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bind_address_no_port(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bind_address_no_port(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recverr_rfc4884(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_recverr_rfc4884(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn defer_connect(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_defer_connect(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        recverr: __u8,
        is_icsk: __u8,
        freebind: __u8,
        hdrincl: __u8,
        mc_loop: __u8,
        transparent: __u8,
        mc_all: __u8,
        nodefrag: __u8,
        bind_address_no_port: __u8,
        recverr_rfc4884: __u8,
        defer_connect: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let recverr: u8 = unsafe { ::core::mem::transmute(recverr) };
            recverr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_icsk: u8 = unsafe { ::core::mem::transmute(is_icsk) };
            is_icsk as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let freebind: u8 = unsafe { ::core::mem::transmute(freebind) };
            freebind as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let hdrincl: u8 = unsafe { ::core::mem::transmute(hdrincl) };
            hdrincl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let mc_loop: u8 = unsafe { ::core::mem::transmute(mc_loop) };
            mc_loop as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let transparent: u8 = unsafe { ::core::mem::transmute(transparent) };
            transparent as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let mc_all: u8 = unsafe { ::core::mem::transmute(mc_all) };
            mc_all as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let nodefrag: u8 = unsafe { ::core::mem::transmute(nodefrag) };
            nodefrag as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bind_address_no_port: u8 = unsafe { ::core::mem::transmute(bind_address_no_port) };
            bind_address_no_port as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let recverr_rfc4884: u8 = unsafe { ::core::mem::transmute(recverr_rfc4884) };
            recverr_rfc4884 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let defer_connect: u8 = unsafe { ::core::mem::transmute(defer_connect) };
            defer_connect as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn inet_sk_rebuild_header(sk: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_sk_state_store(sk: *mut sock, newstate: core::ffi::c_int);
}
extern "C" {
    pub fn inet_sk_set_state(sk: *mut sock, state: core::ffi::c_int);
}
extern "C" {
    pub fn inet_reqsk_alloc(
        ops: *const request_sock_ops,
        sk_listener: *mut sock,
        attach_listener: bool_,
    ) -> *mut request_sock;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct inet_connection_sock_af_ops {
    pub queue_xmit: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff, fl: *mut flowi) -> core::ffi::c_int,
    >,
    pub send_check: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff)>,
    pub rebuild_header:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> core::ffi::c_int>,
    pub sk_rx_dst_set:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, skb: *const sk_buff)>,
    pub conn_request: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub syn_recv_sock: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *const sock,
            skb: *mut sk_buff,
            req: *mut request_sock,
            dst: *mut dst_entry,
            req_unhash: *mut request_sock,
            own_req: *mut bool_,
        ) -> *mut sock,
    >,
    pub net_header_len: u16_,
    pub net_frag_header_len: u16_,
    pub sockaddr_len: u16_,
    pub setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            level: core::ffi::c_int,
            optname: core::ffi::c_int,
            optval: sockptr_t,
            optlen: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            level: core::ffi::c_int,
            optname: core::ffi::c_int,
            optval: *mut core::ffi::c_char,
            optlen: *mut core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub addr2sockaddr:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, arg1: *mut sockaddr)>,
    pub mtu_reduced: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
}
#[repr(C)]
pub struct inet_connection_sock {
    pub icsk_inet: inet_sock,
    pub icsk_accept_queue: request_sock_queue,
    pub icsk_bind_hash: *mut inet_bind_bucket,
    pub icsk_bind2_hash: *mut inet_bind2_bucket,
    pub icsk_timeout: core::ffi::c_ulong,
    pub icsk_retransmit_timer: timer_list,
    pub icsk_delack_timer: timer_list,
    pub icsk_rto: __u32,
    pub icsk_rto_min: __u32,
    pub icsk_delack_max: __u32,
    pub icsk_pmtu_cookie: __u32,
    pub icsk_ca_ops: *const tcp_congestion_ops,
    pub icsk_af_ops: *const inet_connection_sock_af_ops,
    pub icsk_ulp_ops: *const tcp_ulp_ops,
    pub icsk_ulp_data: *mut core::ffi::c_void,
    pub icsk_clean_acked:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, acked_seq: u32_)>,
    pub icsk_sync_mss: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, pmtu: u32_) -> core::ffi::c_uint,
    >,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub icsk_retransmits: __u8,
    pub icsk_pending: __u8,
    pub icsk_backoff: __u8,
    pub icsk_syn_retries: __u8,
    pub icsk_probes_out: __u8,
    pub icsk_ext_hdr_len: __u16,
    pub icsk_ack: inet_connection_sock__bindgen_ty_1,
    pub icsk_mtup: inet_connection_sock__bindgen_ty_2,
    pub icsk_probes_tstamp: u32_,
    pub icsk_user_timeout: u32_,
    pub icsk_ca_priv: [u64_; 13usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct inet_connection_sock__bindgen_ty_1 {
    pub pending: __u8,
    pub quick: __u8,
    pub pingpong: __u8,
    pub retry: __u8,
    pub ato: __u32,
    pub timeout: core::ffi::c_ulong,
    pub lrcvtime: __u32,
    pub last_seg_size: __u16,
    pub rcv_mss: __u16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct inet_connection_sock__bindgen_ty_2 {
    pub search_high: core::ffi::c_int,
    pub search_low: core::ffi::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub probe_timestamp: u32_,
}
impl inet_connection_sock__bindgen_ty_2 {
    #[inline]
    pub fn probe_size(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_probe_size(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn enabled(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        probe_size: u32_,
        enabled: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let probe_size: u32 = unsafe { ::core::mem::transmute(probe_size) };
            probe_size as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let enabled: u32 = unsafe { ::core::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for inet_connection_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl inet_connection_sock {
    #[inline]
    pub fn icsk_ca_state(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_icsk_ca_state(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn icsk_ca_initialized(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_icsk_ca_initialized(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icsk_ca_setsockopt(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_icsk_ca_setsockopt(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn icsk_ca_dst_locked(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_icsk_ca_dst_locked(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        icsk_ca_state: __u8,
        icsk_ca_initialized: __u8,
        icsk_ca_setsockopt: __u8,
        icsk_ca_dst_locked: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let icsk_ca_state: u8 = unsafe { ::core::mem::transmute(icsk_ca_state) };
            icsk_ca_state as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let icsk_ca_initialized: u8 = unsafe { ::core::mem::transmute(icsk_ca_initialized) };
            icsk_ca_initialized as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let icsk_ca_setsockopt: u8 = unsafe { ::core::mem::transmute(icsk_ca_setsockopt) };
            icsk_ca_setsockopt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let icsk_ca_dst_locked: u8 = unsafe { ::core::mem::transmute(icsk_ca_dst_locked) };
            icsk_ca_dst_locked as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn inet_csk_clone_lock(
        sk: *const sock,
        req: *const request_sock,
        priority: gfp_t,
    ) -> *mut sock;
}
pub const inet_csk_ack_state_t_ICSK_ACK_SCHED: inet_csk_ack_state_t = 1;
pub const inet_csk_ack_state_t_ICSK_ACK_TIMER: inet_csk_ack_state_t = 2;
pub const inet_csk_ack_state_t_ICSK_ACK_PUSHED: inet_csk_ack_state_t = 4;
pub const inet_csk_ack_state_t_ICSK_ACK_PUSHED2: inet_csk_ack_state_t = 8;
pub const inet_csk_ack_state_t_ICSK_ACK_NOW: inet_csk_ack_state_t = 16;
pub type inet_csk_ack_state_t = core::ffi::c_uint;
extern "C" {
    pub fn inet_csk_init_xmit_timers(
        sk: *mut sock,
        retransmit_handler: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
        delack_handler: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
        keepalive_handler: ::core::option::Option<unsafe extern "C" fn(arg1: *mut timer_list)>,
    );
}
extern "C" {
    pub fn inet_csk_clear_xmit_timers(sk: *mut sock);
}
extern "C" {
    pub fn inet_csk_delete_keepalive_timer(sk: *mut sock);
}
extern "C" {
    pub fn inet_csk_reset_keepalive_timer(sk: *mut sock, timeout: core::ffi::c_ulong);
}
extern "C" {
    pub fn inet_csk_accept(
        sk: *mut sock,
        flags: core::ffi::c_int,
        err: *mut core::ffi::c_int,
        kern: bool_,
    ) -> *mut sock;
}
extern "C" {
    pub fn inet_csk_get_port(sk: *mut sock, snum: core::ffi::c_ushort) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_csk_route_req(
        sk: *const sock,
        fl4: *mut flowi4,
        req: *const request_sock,
    ) -> *mut dst_entry;
}
extern "C" {
    pub fn inet_csk_route_child_sock(
        sk: *const sock,
        newsk: *mut sock,
        req: *const request_sock,
    ) -> *mut dst_entry;
}
extern "C" {
    pub fn inet_csk_reqsk_queue_add(
        sk: *mut sock,
        req: *mut request_sock,
        child: *mut sock,
    ) -> *mut sock;
}
extern "C" {
    pub fn inet_csk_reqsk_queue_hash_add(
        sk: *mut sock,
        req: *mut request_sock,
        timeout: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn inet_csk_complete_hashdance(
        sk: *mut sock,
        child: *mut sock,
        req: *mut request_sock,
        own_req: bool_,
    ) -> *mut sock;
}
extern "C" {
    pub fn inet_csk_reqsk_queue_drop(sk: *mut sock, req: *mut request_sock) -> bool_;
}
extern "C" {
    pub fn inet_csk_reqsk_queue_drop_and_put(sk: *mut sock, req: *mut request_sock);
}
extern "C" {
    pub fn inet_csk_destroy_sock(sk: *mut sock);
}
extern "C" {
    pub fn inet_csk_prepare_forced_close(sk: *mut sock);
}
extern "C" {
    pub fn inet_csk_listen_start(sk: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_csk_listen_stop(sk: *mut sock);
}
extern "C" {
    pub fn inet_csk_addr2sockaddr(sk: *mut sock, uaddr: *mut sockaddr);
}
extern "C" {
    pub fn inet_csk_update_fastreuse(tb: *mut inet_bind_bucket, sk: *mut sock);
}
extern "C" {
    pub fn inet_csk_update_pmtu(sk: *mut sock, mtu: u32_) -> *mut dst_entry;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timewait_sock_ops {
    pub twsk_slab: *mut kmem_cache,
    pub twsk_slab_name: *mut core::ffi::c_char,
    pub twsk_obj_size: core::ffi::c_uint,
    pub twsk_unique: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            sktw: *mut sock,
            twp: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub twsk_destructor: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
}
impl Default for timewait_sock_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct inet_timewait_sock {
    pub __tw_common: sock_common,
    pub tw_mark: __u32,
    pub tw_substate: core::ffi::c_uchar,
    pub tw_rcv_wscale: core::ffi::c_uchar,
    pub tw_sport: __be16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub tw_txhash: u32_,
    pub tw_priority: u32_,
    pub tw_timer: timer_list,
    pub tw_tb: *mut inet_bind_bucket,
}
impl Default for inet_timewait_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl inet_timewait_sock {
    #[inline]
    pub fn tw_transparent(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tw_transparent(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tw_flowlabel(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_tw_flowlabel(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn tw_pad(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_tw_pad(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn tw_tos(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_tw_tos(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tw_transparent: core::ffi::c_uint,
        tw_flowlabel: core::ffi::c_uint,
        tw_pad: core::ffi::c_uint,
        tw_tos: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let tw_transparent: u32 = unsafe { ::core::mem::transmute(tw_transparent) };
            tw_transparent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 20u8, {
            let tw_flowlabel: u32 = unsafe { ::core::mem::transmute(tw_flowlabel) };
            tw_flowlabel as u64
        });
        __bindgen_bitfield_unit.set(21usize, 3u8, {
            let tw_pad: u32 = unsafe { ::core::mem::transmute(tw_pad) };
            tw_pad as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let tw_tos: u32 = unsafe { ::core::mem::transmute(tw_tos) };
            tw_tos as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn inet_twsk_free(tw: *mut inet_timewait_sock);
}
extern "C" {
    pub fn inet_twsk_put(tw: *mut inet_timewait_sock);
}
extern "C" {
    pub fn inet_twsk_bind_unhash(tw: *mut inet_timewait_sock, hashinfo: *mut inet_hashinfo);
}
extern "C" {
    pub fn inet_twsk_alloc(
        sk: *const sock,
        dr: *mut inet_timewait_death_row,
        state: core::ffi::c_int,
    ) -> *mut inet_timewait_sock;
}
extern "C" {
    pub fn inet_twsk_hashdance(
        tw: *mut inet_timewait_sock,
        sk: *mut sock,
        hashinfo: *mut inet_hashinfo,
    );
}
extern "C" {
    pub fn __inet_twsk_schedule(tw: *mut inet_timewait_sock, timeo: core::ffi::c_int, rearm: bool_);
}
extern "C" {
    pub fn inet_twsk_deschedule_put(tw: *mut inet_timewait_sock);
}
extern "C" {
    pub fn inet_twsk_purge(hashinfo: *mut inet_hashinfo, family: core::ffi::c_int);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcphdr {
    pub source: __be16,
    pub dest: __be16,
    pub seq: __be32,
    pub ack_seq: __be32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub window: __be16,
    pub check: __sum16,
    pub urg_ptr: __be16,
}
impl tcphdr {
    #[inline]
    pub fn res1(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_res1(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn doff(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_doff(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn fin(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fin(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_syn(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rst(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rst(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn psh(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_psh(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ack(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn urg(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_urg(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ece(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ece(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cwr(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cwr(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        res1: __u16,
        doff: __u16,
        fin: __u16,
        syn: __u16,
        rst: __u16,
        psh: __u16,
        ack: __u16,
        urg: __u16,
        ece: __u16,
        cwr: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let res1: u16 = unsafe { ::core::mem::transmute(res1) };
            res1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let doff: u16 = unsafe { ::core::mem::transmute(doff) };
            doff as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let fin: u16 = unsafe { ::core::mem::transmute(fin) };
            fin as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let syn: u16 = unsafe { ::core::mem::transmute(syn) };
            syn as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rst: u16 = unsafe { ::core::mem::transmute(rst) };
            rst as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let psh: u16 = unsafe { ::core::mem::transmute(psh) };
            psh as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ack: u16 = unsafe { ::core::mem::transmute(ack) };
            ack as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let urg: u16 = unsafe { ::core::mem::transmute(urg) };
            urg as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ece: u16 = unsafe { ::core::mem::transmute(ece) };
            ece as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let cwr: u16 = unsafe { ::core::mem::transmute(cwr) };
            cwr as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcp_word_hdr {
    pub hdr: tcphdr,
    pub words: [__be32; 5usize],
    _bindgen_union_align: [u32; 5usize],
}
impl Default for tcp_word_hdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const TCP_FLAG_CWR: core::ffi::c_uint = 32768;
pub const TCP_FLAG_ECE: core::ffi::c_uint = 16384;
pub const TCP_FLAG_URG: core::ffi::c_uint = 8192;
pub const TCP_FLAG_ACK: core::ffi::c_uint = 4096;
pub const TCP_FLAG_PSH: core::ffi::c_uint = 2048;
pub const TCP_FLAG_RST: core::ffi::c_uint = 1024;
pub const TCP_FLAG_SYN: core::ffi::c_uint = 512;
pub const TCP_FLAG_FIN: core::ffi::c_uint = 256;
pub const TCP_RESERVED_BITS: core::ffi::c_uint = 15;
pub const TCP_DATA_OFFSET: core::ffi::c_uint = 240;
pub type _bindgen_ty_293 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_repair_opt {
    pub opt_code: __u32,
    pub opt_val: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_repair_window {
    pub snd_wl1: __u32,
    pub snd_wnd: __u32,
    pub max_window: __u32,
    pub rcv_wnd: __u32,
    pub rcv_wup: __u32,
}
pub const TCP_NO_QUEUE: core::ffi::c_uint = 0;
pub const TCP_RECV_QUEUE: core::ffi::c_uint = 1;
pub const TCP_SEND_QUEUE: core::ffi::c_uint = 2;
pub const TCP_QUEUES_NR: core::ffi::c_uint = 3;
pub type _bindgen_ty_294 = core::ffi::c_uint;
pub const tcp_fastopen_client_fail_TFO_STATUS_UNSPEC: tcp_fastopen_client_fail = 0;
pub const tcp_fastopen_client_fail_TFO_COOKIE_UNAVAILABLE: tcp_fastopen_client_fail = 1;
pub const tcp_fastopen_client_fail_TFO_DATA_NOT_ACKED: tcp_fastopen_client_fail = 2;
pub const tcp_fastopen_client_fail_TFO_SYN_RETRANSMITTED: tcp_fastopen_client_fail = 3;
pub type tcp_fastopen_client_fail = core::ffi::c_uint;
pub const tcp_ca_state_TCP_CA_Open: tcp_ca_state = 0;
pub const tcp_ca_state_TCP_CA_Disorder: tcp_ca_state = 1;
pub const tcp_ca_state_TCP_CA_CWR: tcp_ca_state = 2;
pub const tcp_ca_state_TCP_CA_Recovery: tcp_ca_state = 3;
pub const tcp_ca_state_TCP_CA_Loss: tcp_ca_state = 4;
pub type tcp_ca_state = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_info {
    pub tcpi_state: __u8,
    pub tcpi_ca_state: __u8,
    pub tcpi_retransmits: __u8,
    pub tcpi_probes: __u8,
    pub tcpi_backoff: __u8,
    pub tcpi_options: __u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub tcpi_rto: __u32,
    pub tcpi_ato: __u32,
    pub tcpi_snd_mss: __u32,
    pub tcpi_rcv_mss: __u32,
    pub tcpi_unacked: __u32,
    pub tcpi_sacked: __u32,
    pub tcpi_lost: __u32,
    pub tcpi_retrans: __u32,
    pub tcpi_fackets: __u32,
    pub tcpi_last_data_sent: __u32,
    pub tcpi_last_ack_sent: __u32,
    pub tcpi_last_data_recv: __u32,
    pub tcpi_last_ack_recv: __u32,
    pub tcpi_pmtu: __u32,
    pub tcpi_rcv_ssthresh: __u32,
    pub tcpi_rtt: __u32,
    pub tcpi_rttvar: __u32,
    pub tcpi_snd_ssthresh: __u32,
    pub tcpi_snd_cwnd: __u32,
    pub tcpi_advmss: __u32,
    pub tcpi_reordering: __u32,
    pub tcpi_rcv_rtt: __u32,
    pub tcpi_rcv_space: __u32,
    pub tcpi_total_retrans: __u32,
    pub tcpi_pacing_rate: __u64,
    pub tcpi_max_pacing_rate: __u64,
    pub tcpi_bytes_acked: __u64,
    pub tcpi_bytes_received: __u64,
    pub tcpi_segs_out: __u32,
    pub tcpi_segs_in: __u32,
    pub tcpi_notsent_bytes: __u32,
    pub tcpi_min_rtt: __u32,
    pub tcpi_data_segs_in: __u32,
    pub tcpi_data_segs_out: __u32,
    pub tcpi_delivery_rate: __u64,
    pub tcpi_busy_time: __u64,
    pub tcpi_rwnd_limited: __u64,
    pub tcpi_sndbuf_limited: __u64,
    pub tcpi_delivered: __u32,
    pub tcpi_delivered_ce: __u32,
    pub tcpi_bytes_sent: __u64,
    pub tcpi_bytes_retrans: __u64,
    pub tcpi_dsack_dups: __u32,
    pub tcpi_reord_seen: __u32,
    pub tcpi_rcv_ooopack: __u32,
    pub tcpi_snd_wnd: __u32,
}
impl tcp_info {
    #[inline]
    pub fn tcpi_snd_wscale(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_snd_wscale(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_rcv_wscale(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_rcv_wscale(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_delivery_rate_app_limited(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_delivery_rate_app_limited(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tcpi_fastopen_client_fail(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_tcpi_fastopen_client_fail(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        tcpi_snd_wscale: __u8,
        tcpi_rcv_wscale: __u8,
        tcpi_delivery_rate_app_limited: __u8,
        tcpi_fastopen_client_fail: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let tcpi_snd_wscale: u8 = unsafe { ::core::mem::transmute(tcpi_snd_wscale) };
            tcpi_snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let tcpi_rcv_wscale: u8 = unsafe { ::core::mem::transmute(tcpi_rcv_wscale) };
            tcpi_rcv_wscale as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let tcpi_delivery_rate_app_limited: u8 =
                unsafe { ::core::mem::transmute(tcpi_delivery_rate_app_limited) };
            tcpi_delivery_rate_app_limited as u64
        });
        __bindgen_bitfield_unit.set(9usize, 2u8, {
            let tcpi_fastopen_client_fail: u8 =
                unsafe { ::core::mem::transmute(tcpi_fastopen_client_fail) };
            tcpi_fastopen_client_fail as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const TCP_NLA_PAD: core::ffi::c_uint = 0;
pub const TCP_NLA_BUSY: core::ffi::c_uint = 1;
pub const TCP_NLA_RWND_LIMITED: core::ffi::c_uint = 2;
pub const TCP_NLA_SNDBUF_LIMITED: core::ffi::c_uint = 3;
pub const TCP_NLA_DATA_SEGS_OUT: core::ffi::c_uint = 4;
pub const TCP_NLA_TOTAL_RETRANS: core::ffi::c_uint = 5;
pub const TCP_NLA_PACING_RATE: core::ffi::c_uint = 6;
pub const TCP_NLA_DELIVERY_RATE: core::ffi::c_uint = 7;
pub const TCP_NLA_SND_CWND: core::ffi::c_uint = 8;
pub const TCP_NLA_REORDERING: core::ffi::c_uint = 9;
pub const TCP_NLA_MIN_RTT: core::ffi::c_uint = 10;
pub const TCP_NLA_RECUR_RETRANS: core::ffi::c_uint = 11;
pub const TCP_NLA_DELIVERY_RATE_APP_LMT: core::ffi::c_uint = 12;
pub const TCP_NLA_SNDQ_SIZE: core::ffi::c_uint = 13;
pub const TCP_NLA_CA_STATE: core::ffi::c_uint = 14;
pub const TCP_NLA_SND_SSTHRESH: core::ffi::c_uint = 15;
pub const TCP_NLA_DELIVERED: core::ffi::c_uint = 16;
pub const TCP_NLA_DELIVERED_CE: core::ffi::c_uint = 17;
pub const TCP_NLA_BYTES_SENT: core::ffi::c_uint = 18;
pub const TCP_NLA_BYTES_RETRANS: core::ffi::c_uint = 19;
pub const TCP_NLA_DSACK_DUPS: core::ffi::c_uint = 20;
pub const TCP_NLA_REORD_SEEN: core::ffi::c_uint = 21;
pub const TCP_NLA_SRTT: core::ffi::c_uint = 22;
pub const TCP_NLA_TIMEOUT_REHASH: core::ffi::c_uint = 23;
pub const TCP_NLA_BYTES_NOTSENT: core::ffi::c_uint = 24;
pub const TCP_NLA_EDT: core::ffi::c_uint = 25;
pub const TCP_NLA_TTL: core::ffi::c_uint = 26;
pub type _bindgen_ty_295 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_md5sig {
    pub tcpm_addr: __kernel_sockaddr_storage,
    pub tcpm_flags: __u8,
    pub tcpm_prefixlen: __u8,
    pub tcpm_keylen: __u16,
    pub tcpm_ifindex: core::ffi::c_int,
    pub tcpm_key: [__u8; 80usize],
}
impl Default for tcp_md5sig {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_diag_md5sig {
    pub tcpm_family: __u8,
    pub tcpm_prefixlen: __u8,
    pub tcpm_keylen: __u16,
    pub tcpm_addr: [__be32; 4usize],
    pub tcpm_key: [__u8; 80usize],
}
impl Default for tcp_diag_md5sig {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_zerocopy_receive {
    pub address: __u64,
    pub length: __u32,
    pub recv_skip_hint: __u32,
    pub inq: __u32,
    pub err: __s32,
    pub copybuf_address: __u64,
    pub copybuf_len: __s32,
    pub flags: __u32,
    pub msg_control: __u64,
    pub msg_controllen: __u64,
    pub msg_flags: __u32,
    pub reserved: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_fastopen_cookie {
    pub val: [__le64; 2usize],
    pub len: s8,
    pub exp: bool_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_sack_block_wire {
    pub start_seq: __be32,
    pub end_seq: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_sack_block {
    pub start_seq: u32_,
    pub end_seq: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_options_received {
    pub ts_recent_stamp: core::ffi::c_int,
    pub ts_recent: u32_,
    pub rcv_tsval: u32_,
    pub rcv_tsecr: u32_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub num_sacks: u8_,
    pub user_mss: u16_,
    pub mss_clamp: u16_,
}
impl tcp_options_received {
    #[inline]
    pub fn saw_tstamp(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_saw_tstamp(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tstamp_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_tstamp_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsack(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dsack(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn wscale_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_wscale_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sack_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_sack_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn smc_ok(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_smc_ok(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn snd_wscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_snd_wscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn rcv_wscale(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_rcv_wscale(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn saw_unknown(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_saw_unknown(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        saw_tstamp: u16_,
        tstamp_ok: u16_,
        dsack: u16_,
        wscale_ok: u16_,
        sack_ok: u16_,
        smc_ok: u16_,
        snd_wscale: u16_,
        rcv_wscale: u16_,
        saw_unknown: u8_,
        unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let saw_tstamp: u16 = unsafe { ::core::mem::transmute(saw_tstamp) };
            saw_tstamp as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let tstamp_ok: u16 = unsafe { ::core::mem::transmute(tstamp_ok) };
            tstamp_ok as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dsack: u16 = unsafe { ::core::mem::transmute(dsack) };
            dsack as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let wscale_ok: u16 = unsafe { ::core::mem::transmute(wscale_ok) };
            wscale_ok as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let sack_ok: u16 = unsafe { ::core::mem::transmute(sack_ok) };
            sack_ok as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let smc_ok: u16 = unsafe { ::core::mem::transmute(smc_ok) };
            smc_ok as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let snd_wscale: u16 = unsafe { ::core::mem::transmute(snd_wscale) };
            snd_wscale as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let rcv_wscale: u16 = unsafe { ::core::mem::transmute(rcv_wscale) };
            rcv_wscale as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let saw_unknown: u8 = unsafe { ::core::mem::transmute(saw_unknown) };
            saw_unknown as u64
        });
        __bindgen_bitfield_unit.set(17usize, 7u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct tcp_request_sock {
    pub req: inet_request_sock,
    pub af_specific: *const tcp_request_sock_ops,
    pub snt_synack: u64_,
    pub tfo_listener: bool_,
    pub is_mptcp: bool_,
    pub txhash: u32_,
    pub rcv_isn: u32_,
    pub snt_isn: u32_,
    pub ts_off: u32_,
    pub last_oow_ack_time: u32_,
    pub rcv_nxt: u32_,
    pub syn_tos: u8_,
}
impl Default for tcp_request_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct tcp_sock {
    pub inet_conn: inet_connection_sock,
    pub tcp_header_len: u16_,
    pub gso_segs: u16_,
    pub pred_flags: __be32,
    pub bytes_received: u64_,
    pub segs_in: u32_,
    pub data_segs_in: u32_,
    pub rcv_nxt: u32_,
    pub copied_seq: u32_,
    pub rcv_wup: u32_,
    pub snd_nxt: u32_,
    pub segs_out: u32_,
    pub data_segs_out: u32_,
    pub bytes_sent: u64_,
    pub bytes_acked: u64_,
    pub dsack_dups: u32_,
    pub snd_una: u32_,
    pub snd_sml: u32_,
    pub rcv_tstamp: u32_,
    pub lsndtime: u32_,
    pub last_oow_ack_time: u32_,
    pub compressed_ack_rcv_nxt: u32_,
    pub tsoffset: u32_,
    pub tsq_node: list_head,
    pub tsorted_sent_queue: list_head,
    pub snd_wl1: u32_,
    pub snd_wnd: u32_,
    pub max_window: u32_,
    pub mss_cache: u32_,
    pub window_clamp: u32_,
    pub rcv_ssthresh: u32_,
    pub rack: tcp_sock_tcp_rack,
    pub advmss: u16_,
    pub compressed_ack: u8_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub chrono_start: u32_,
    pub chrono_stat: [u32_; 3usize],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub repair_queue: u8_,
    pub _bitfield_3: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub tlp_high_seq: u32_,
    pub tcp_tx_delay: u32_,
    pub tcp_wstamp_ns: u64_,
    pub tcp_clock_cache: u64_,
    pub tcp_mstamp: u64_,
    pub srtt_us: u32_,
    pub mdev_us: u32_,
    pub mdev_max_us: u32_,
    pub rttvar_us: u32_,
    pub rtt_seq: u32_,
    pub rtt_min: minmax,
    pub packets_out: u32_,
    pub retrans_out: u32_,
    pub max_packets_out: u32_,
    pub cwnd_usage_seq: u32_,
    pub urg_data: u16_,
    pub ecn_flags: u8_,
    pub keepalive_probes: u8_,
    pub reordering: u32_,
    pub reord_seen: u32_,
    pub snd_up: u32_,
    pub rx_opt: tcp_options_received,
    pub snd_ssthresh: u32_,
    pub snd_cwnd: u32_,
    pub snd_cwnd_cnt: u32_,
    pub snd_cwnd_clamp: u32_,
    pub snd_cwnd_used: u32_,
    pub snd_cwnd_stamp: u32_,
    pub prior_cwnd: u32_,
    pub prr_delivered: u32_,
    pub prr_out: u32_,
    pub delivered: u32_,
    pub delivered_ce: u32_,
    pub lost: u32_,
    pub app_limited: u32_,
    pub first_tx_mstamp: u64_,
    pub delivered_mstamp: u64_,
    pub rate_delivered: u32_,
    pub rate_interval_us: u32_,
    pub rcv_wnd: u32_,
    pub write_seq: u32_,
    pub notsent_lowat: u32_,
    pub pushed_seq: u32_,
    pub lost_out: u32_,
    pub sacked_out: u32_,
    pub pacing_timer: hrtimer,
    pub compressed_ack_timer: hrtimer,
    pub lost_skb_hint: *mut sk_buff,
    pub retransmit_skb_hint: *mut sk_buff,
    pub out_of_order_queue: rb_root,
    pub ooo_last_skb: *mut sk_buff,
    pub duplicate_sack: [tcp_sack_block; 1usize],
    pub selective_acks: [tcp_sack_block; 4usize],
    pub recv_sack_cache: [tcp_sack_block; 4usize],
    pub highest_sack: *mut sk_buff,
    pub lost_cnt_hint: core::ffi::c_int,
    pub prior_ssthresh: u32_,
    pub high_seq: u32_,
    pub retrans_stamp: u32_,
    pub undo_marker: u32_,
    pub undo_retrans: core::ffi::c_int,
    pub bytes_retrans: u64_,
    pub total_retrans: u32_,
    pub urg_seq: u32_,
    pub keepalive_time: core::ffi::c_uint,
    pub keepalive_intvl: core::ffi::c_uint,
    pub linger2: core::ffi::c_int,
    pub bpf_sock_ops_cb_flags: u8_,
    pub _bitfield_4: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub timeout_rehash: u16_,
    pub rcv_ooopack: u32_,
    pub rcv_rtt_last_tsecr: u32_,
    pub rcv_rtt_est: tcp_sock__bindgen_ty_1,
    pub rcvq_space: tcp_sock__bindgen_ty_2,
    pub mtu_probe: tcp_sock__bindgen_ty_3,
    pub mtu_info: u32_,
    pub fastopen_req: *mut tcp_fastopen_request,
    pub fastopen_rsk: *mut request_sock,
    pub saved_syn: *mut saved_syn,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_sock_tcp_rack {
    pub mstamp: u64_,
    pub rtt_us: u32_,
    pub end_seq: u32_,
    pub last_delivered: u32_,
    pub reo_wnd_steps: u8_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u16,
}
impl tcp_sock_tcp_rack {
    #[inline]
    pub fn reo_wnd_persist(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reo_wnd_persist(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn dsack_seen(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dsack_seen(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn advanced(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_advanced(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reo_wnd_persist: u8_,
        dsack_seen: u8_,
        advanced: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let reo_wnd_persist: u8 = unsafe { ::core::mem::transmute(reo_wnd_persist) };
            reo_wnd_persist as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsack_seen: u8 = unsafe { ::core::mem::transmute(dsack_seen) };
            dsack_seen as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let advanced: u8 = unsafe { ::core::mem::transmute(advanced) };
            advanced as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_sock__bindgen_ty_1 {
    pub rtt_us: u32_,
    pub seq: u32_,
    pub time: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_sock__bindgen_ty_2 {
    pub space: u32_,
    pub seq: u32_,
    pub time: u64_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_sock__bindgen_ty_3 {
    pub probe_seq_start: u32_,
    pub probe_seq_end: u32_,
}
impl Default for tcp_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl tcp_sock {
    #[inline]
    pub fn dup_ack_counter(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_dup_ack_counter(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn tlp_retrans(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_tlp_retrans(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        dup_ack_counter: u8_,
        tlp_retrans: u8_,
        unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let dup_ack_counter: u8 = unsafe { ::core::mem::transmute(dup_ack_counter) };
            dup_ack_counter as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tlp_retrans: u8 = unsafe { ::core::mem::transmute(tlp_retrans) };
            tlp_retrans as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn chrono_type(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_chrono_type(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn rate_app_limited(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rate_app_limited(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastopen_connect(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fastopen_connect(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastopen_no_cookie(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fastopen_no_cookie(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_sack_reneg(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_sack_reneg(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fastopen_client_fail(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_fastopen_client_fail(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn nonagle(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_nonagle(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn thin_lto(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_thin_lto(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recvmsg_inq(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_recvmsg_inq(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repair(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_repair(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frto(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frto(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        chrono_type: u8_,
        rate_app_limited: u8_,
        fastopen_connect: u8_,
        fastopen_no_cookie: u8_,
        is_sack_reneg: u8_,
        fastopen_client_fail: u8_,
        nonagle: u8_,
        thin_lto: u8_,
        recvmsg_inq: u8_,
        repair: u8_,
        frto: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let chrono_type: u8 = unsafe { ::core::mem::transmute(chrono_type) };
            chrono_type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rate_app_limited: u8 = unsafe { ::core::mem::transmute(rate_app_limited) };
            rate_app_limited as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let fastopen_connect: u8 = unsafe { ::core::mem::transmute(fastopen_connect) };
            fastopen_connect as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fastopen_no_cookie: u8 = unsafe { ::core::mem::transmute(fastopen_no_cookie) };
            fastopen_no_cookie as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_sack_reneg: u8 = unsafe { ::core::mem::transmute(is_sack_reneg) };
            is_sack_reneg as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let fastopen_client_fail: u8 = unsafe { ::core::mem::transmute(fastopen_client_fail) };
            fastopen_client_fail as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let nonagle: u8 = unsafe { ::core::mem::transmute(nonagle) };
            nonagle as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let thin_lto: u8 = unsafe { ::core::mem::transmute(thin_lto) };
            thin_lto as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let recvmsg_inq: u8 = unsafe { ::core::mem::transmute(recvmsg_inq) };
            recvmsg_inq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let repair: u8 = unsafe { ::core::mem::transmute(repair) };
            repair as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let frto: u8 = unsafe { ::core::mem::transmute(frto) };
            frto as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn save_syn(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_save_syn(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn syn_data(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syn_data(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn_fastopen(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syn_fastopen(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn_fastopen_exp(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syn_fastopen_exp(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn_fastopen_ch(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syn_fastopen_ch(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn syn_data_acked(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_syn_data_acked(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_cwnd_limited(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_3.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_cwnd_limited(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_3.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_3(
        save_syn: u8_,
        syn_data: u8_,
        syn_fastopen: u8_,
        syn_fastopen_exp: u8_,
        syn_fastopen_ch: u8_,
        syn_data_acked: u8_,
        is_cwnd_limited: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let save_syn: u8 = unsafe { ::core::mem::transmute(save_syn) };
            save_syn as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let syn_data: u8 = unsafe { ::core::mem::transmute(syn_data) };
            syn_data as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let syn_fastopen: u8 = unsafe { ::core::mem::transmute(syn_fastopen) };
            syn_fastopen as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let syn_fastopen_exp: u8 = unsafe { ::core::mem::transmute(syn_fastopen_exp) };
            syn_fastopen_exp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let syn_fastopen_ch: u8 = unsafe { ::core::mem::transmute(syn_fastopen_ch) };
            syn_fastopen_ch as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let syn_data_acked: u8 = unsafe { ::core::mem::transmute(syn_data_acked) };
            syn_data_acked as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_cwnd_limited: u8 = unsafe { ::core::mem::transmute(is_cwnd_limited) };
            is_cwnd_limited as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn bpf_chg_cc_inprogress(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_4.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bpf_chg_cc_inprogress(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_4.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_4(bpf_chg_cc_inprogress: u8_) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bpf_chg_cc_inprogress: u8 =
                unsafe { ::core::mem::transmute(bpf_chg_cc_inprogress) };
            bpf_chg_cc_inprogress as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const tsq_enum_TSQ_THROTTLED: tsq_enum = 0;
pub const tsq_enum_TSQ_QUEUED: tsq_enum = 1;
pub const tsq_enum_TCP_TSQ_DEFERRED: tsq_enum = 2;
pub const tsq_enum_TCP_WRITE_TIMER_DEFERRED: tsq_enum = 3;
pub const tsq_enum_TCP_DELACK_TIMER_DEFERRED: tsq_enum = 4;
pub const tsq_enum_TCP_MTU_REDUCED_DEFERRED: tsq_enum = 5;
pub type tsq_enum = core::ffi::c_uint;
pub const tsq_flags_TSQF_THROTTLED: tsq_flags = 1;
pub const tsq_flags_TSQF_QUEUED: tsq_flags = 2;
pub const tsq_flags_TCPF_TSQ_DEFERRED: tsq_flags = 4;
pub const tsq_flags_TCPF_WRITE_TIMER_DEFERRED: tsq_flags = 8;
pub const tsq_flags_TCPF_DELACK_TIMER_DEFERRED: tsq_flags = 16;
pub const tsq_flags_TCPF_MTU_REDUCED_DEFERRED: tsq_flags = 32;
pub type tsq_flags = core::ffi::c_uint;
#[repr(C)]
pub struct tcp_timewait_sock {
    pub tw_sk: inet_timewait_sock,
    pub tw_rcv_wnd: u32_,
    pub tw_ts_offset: u32_,
    pub tw_ts_recent: u32_,
    pub tw_last_oow_ack_time: u32_,
    pub tw_ts_recent_stamp: core::ffi::c_int,
    pub tw_tx_delay: u32_,
}
impl Default for tcp_timewait_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn tcp_get_timestamping_opt_stats(
        sk: *const sock,
        orig_skb: *const sk_buff,
        ack_skb: *const sk_buff,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn tcp_skb_shift(
        to: *mut sk_buff,
        from: *mut sk_buff,
        pcount: core::ffi::c_int,
        shiftlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __tcp_sock_set_cork(sk: *mut sock, on: bool_);
}
extern "C" {
    pub fn tcp_sock_set_cork(sk: *mut sock, on: bool_);
}
extern "C" {
    pub fn tcp_sock_set_keepcnt(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_sock_set_keepidle_locked(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_sock_set_keepidle(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_sock_set_keepintvl(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn __tcp_sock_set_nodelay(sk: *mut sock, on: bool_);
}
extern "C" {
    pub fn tcp_sock_set_nodelay(sk: *mut sock);
}
extern "C" {
    pub fn tcp_sock_set_quickack(sk: *mut sock, val: core::ffi::c_int);
}
extern "C" {
    pub fn tcp_sock_set_syncnt(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_sock_set_user_timeout(sk: *mut sock, val: u32_);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct iphdr {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub tos: __u8,
    pub tot_len: __be16,
    pub id: __be16,
    pub frag_off: __be16,
    pub ttl: __u8,
    pub protocol: __u8,
    pub check: __sum16,
    pub saddr: __be32,
    pub daddr: __be32,
}
impl iphdr {
    #[inline]
    pub fn ihl(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ihl(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ihl: __u8, version: __u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ihl: u8 = unsafe { ::core::mem::transmute(ihl) };
            ihl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::core::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default)]
pub struct ip_auth_hdr {
    pub nexthdr: __u8,
    pub hdrlen: __u8,
    pub reserved: __be16,
    pub spi: __be32,
    pub seq_no: __be32,
    pub auth_data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default)]
pub struct ip_esp_hdr {
    pub spi: __be32,
    pub seq_no: __be32,
    pub enc_data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_comp_hdr {
    pub nexthdr: __u8,
    pub flags: __u8,
    pub cpi: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_beet_phdr {
    pub nexthdr: __u8,
    pub hdrlen: __u8,
    pub padlen: __u8,
    pub reserved: __u8,
}
pub const IPV4_DEVCONF_FORWARDING: core::ffi::c_uint = 1;
pub const IPV4_DEVCONF_MC_FORWARDING: core::ffi::c_uint = 2;
pub const IPV4_DEVCONF_PROXY_ARP: core::ffi::c_uint = 3;
pub const IPV4_DEVCONF_ACCEPT_REDIRECTS: core::ffi::c_uint = 4;
pub const IPV4_DEVCONF_SECURE_REDIRECTS: core::ffi::c_uint = 5;
pub const IPV4_DEVCONF_SEND_REDIRECTS: core::ffi::c_uint = 6;
pub const IPV4_DEVCONF_SHARED_MEDIA: core::ffi::c_uint = 7;
pub const IPV4_DEVCONF_RP_FILTER: core::ffi::c_uint = 8;
pub const IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE: core::ffi::c_uint = 9;
pub const IPV4_DEVCONF_BOOTP_RELAY: core::ffi::c_uint = 10;
pub const IPV4_DEVCONF_LOG_MARTIANS: core::ffi::c_uint = 11;
pub const IPV4_DEVCONF_TAG: core::ffi::c_uint = 12;
pub const IPV4_DEVCONF_ARPFILTER: core::ffi::c_uint = 13;
pub const IPV4_DEVCONF_MEDIUM_ID: core::ffi::c_uint = 14;
pub const IPV4_DEVCONF_NOXFRM: core::ffi::c_uint = 15;
pub const IPV4_DEVCONF_NOPOLICY: core::ffi::c_uint = 16;
pub const IPV4_DEVCONF_FORCE_IGMP_VERSION: core::ffi::c_uint = 17;
pub const IPV4_DEVCONF_ARP_ANNOUNCE: core::ffi::c_uint = 18;
pub const IPV4_DEVCONF_ARP_IGNORE: core::ffi::c_uint = 19;
pub const IPV4_DEVCONF_PROMOTE_SECONDARIES: core::ffi::c_uint = 20;
pub const IPV4_DEVCONF_ARP_ACCEPT: core::ffi::c_uint = 21;
pub const IPV4_DEVCONF_ARP_NOTIFY: core::ffi::c_uint = 22;
pub const IPV4_DEVCONF_ACCEPT_LOCAL: core::ffi::c_uint = 23;
pub const IPV4_DEVCONF_SRC_VMARK: core::ffi::c_uint = 24;
pub const IPV4_DEVCONF_PROXY_ARP_PVLAN: core::ffi::c_uint = 25;
pub const IPV4_DEVCONF_ROUTE_LOCALNET: core::ffi::c_uint = 26;
pub const IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL: core::ffi::c_uint = 27;
pub const IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL: core::ffi::c_uint = 28;
pub const IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN: core::ffi::c_uint = 29;
pub const IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST: core::ffi::c_uint = 30;
pub const IPV4_DEVCONF_DROP_GRATUITOUS_ARP: core::ffi::c_uint = 31;
pub const IPV4_DEVCONF_BC_FORWARDING: core::ffi::c_uint = 32;
pub const IPV4_DEVCONF_ARP_EVICT_NOCARRIER: core::ffi::c_uint = 33;
pub const __IPV4_DEVCONF_MAX: core::ffi::c_uint = 34;
pub type _bindgen_ty_296 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: core::ffi::c_int,
}
impl Default for in6_pktinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: __u32,
}
impl Default for ip6_mtuinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_ifreq {
    pub ifr6_addr: in6_addr,
    pub ifr6_prefixlen: __u32,
    pub ifr6_ifindex: core::ffi::c_int,
}
impl Default for in6_ifreq {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ipv6_rt_hdr {
    pub nexthdr: __u8,
    pub hdrlen: __u8,
    pub type_: __u8,
    pub segments_left: __u8,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct ipv6_opt_hdr {
    pub nexthdr: __u8,
    pub hdrlen: __u8,
}
#[repr(C)]
pub struct rt0_hdr {
    pub rt_hdr: ipv6_rt_hdr,
    pub reserved: __u32,
    pub addr: __IncompleteArrayField<in6_addr>,
}
impl Default for rt0_hdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt2_hdr {
    pub rt_hdr: ipv6_rt_hdr,
    pub reserved: __u32,
    pub addr: in6_addr,
}
impl Default for rt2_hdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct ipv6_destopt_hao {
    pub type_: __u8,
    pub length: __u8,
    pub addr: in6_addr,
}
impl Default for ipv6_destopt_hao {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6hdr {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub flow_lbl: [__u8; 3usize],
    pub payload_len: __be16,
    pub nexthdr: __u8,
    pub hop_limit: __u8,
    pub saddr: in6_addr,
    pub daddr: in6_addr,
}
impl Default for ipv6hdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ipv6hdr {
    #[inline]
    pub fn priority(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_priority(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn version(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_version(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        priority: __u8,
        version: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let priority: u8 = unsafe { ::core::mem::transmute(priority) };
            priority as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let version: u8 = unsafe { ::core::mem::transmute(version) };
            version as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const DEVCONF_FORWARDING: core::ffi::c_uint = 0;
pub const DEVCONF_HOPLIMIT: core::ffi::c_uint = 1;
pub const DEVCONF_MTU6: core::ffi::c_uint = 2;
pub const DEVCONF_ACCEPT_RA: core::ffi::c_uint = 3;
pub const DEVCONF_ACCEPT_REDIRECTS: core::ffi::c_uint = 4;
pub const DEVCONF_AUTOCONF: core::ffi::c_uint = 5;
pub const DEVCONF_DAD_TRANSMITS: core::ffi::c_uint = 6;
pub const DEVCONF_RTR_SOLICITS: core::ffi::c_uint = 7;
pub const DEVCONF_RTR_SOLICIT_INTERVAL: core::ffi::c_uint = 8;
pub const DEVCONF_RTR_SOLICIT_DELAY: core::ffi::c_uint = 9;
pub const DEVCONF_USE_TEMPADDR: core::ffi::c_uint = 10;
pub const DEVCONF_TEMP_VALID_LFT: core::ffi::c_uint = 11;
pub const DEVCONF_TEMP_PREFERED_LFT: core::ffi::c_uint = 12;
pub const DEVCONF_REGEN_MAX_RETRY: core::ffi::c_uint = 13;
pub const DEVCONF_MAX_DESYNC_FACTOR: core::ffi::c_uint = 14;
pub const DEVCONF_MAX_ADDRESSES: core::ffi::c_uint = 15;
pub const DEVCONF_FORCE_MLD_VERSION: core::ffi::c_uint = 16;
pub const DEVCONF_ACCEPT_RA_DEFRTR: core::ffi::c_uint = 17;
pub const DEVCONF_ACCEPT_RA_PINFO: core::ffi::c_uint = 18;
pub const DEVCONF_ACCEPT_RA_RTR_PREF: core::ffi::c_uint = 19;
pub const DEVCONF_RTR_PROBE_INTERVAL: core::ffi::c_uint = 20;
pub const DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN: core::ffi::c_uint = 21;
pub const DEVCONF_PROXY_NDP: core::ffi::c_uint = 22;
pub const DEVCONF_OPTIMISTIC_DAD: core::ffi::c_uint = 23;
pub const DEVCONF_ACCEPT_SOURCE_ROUTE: core::ffi::c_uint = 24;
pub const DEVCONF_MC_FORWARDING: core::ffi::c_uint = 25;
pub const DEVCONF_DISABLE_IPV6: core::ffi::c_uint = 26;
pub const DEVCONF_ACCEPT_DAD: core::ffi::c_uint = 27;
pub const DEVCONF_FORCE_TLLAO: core::ffi::c_uint = 28;
pub const DEVCONF_NDISC_NOTIFY: core::ffi::c_uint = 29;
pub const DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL: core::ffi::c_uint = 30;
pub const DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL: core::ffi::c_uint = 31;
pub const DEVCONF_SUPPRESS_FRAG_NDISC: core::ffi::c_uint = 32;
pub const DEVCONF_ACCEPT_RA_FROM_LOCAL: core::ffi::c_uint = 33;
pub const DEVCONF_USE_OPTIMISTIC: core::ffi::c_uint = 34;
pub const DEVCONF_ACCEPT_RA_MTU: core::ffi::c_uint = 35;
pub const DEVCONF_STABLE_SECRET: core::ffi::c_uint = 36;
pub const DEVCONF_USE_OIF_ADDRS_ONLY: core::ffi::c_uint = 37;
pub const DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT: core::ffi::c_uint = 38;
pub const DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN: core::ffi::c_uint = 39;
pub const DEVCONF_DROP_UNICAST_IN_L2_MULTICAST: core::ffi::c_uint = 40;
pub const DEVCONF_DROP_UNSOLICITED_NA: core::ffi::c_uint = 41;
pub const DEVCONF_KEEP_ADDR_ON_DOWN: core::ffi::c_uint = 42;
pub const DEVCONF_RTR_SOLICIT_MAX_INTERVAL: core::ffi::c_uint = 43;
pub const DEVCONF_SEG6_ENABLED: core::ffi::c_uint = 44;
pub const DEVCONF_SEG6_REQUIRE_HMAC: core::ffi::c_uint = 45;
pub const DEVCONF_ENHANCED_DAD: core::ffi::c_uint = 46;
pub const DEVCONF_ADDR_GEN_MODE: core::ffi::c_uint = 47;
pub const DEVCONF_DISABLE_POLICY: core::ffi::c_uint = 48;
pub const DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN: core::ffi::c_uint = 49;
pub const DEVCONF_NDISC_TCLASS: core::ffi::c_uint = 50;
pub const DEVCONF_RPL_SEG_ENABLED: core::ffi::c_uint = 51;
pub const DEVCONF_RA_DEFRTR_METRIC: core::ffi::c_uint = 52;
pub const DEVCONF_IOAM6_ENABLED: core::ffi::c_uint = 53;
pub const DEVCONF_IOAM6_ID: core::ffi::c_uint = 54;
pub const DEVCONF_IOAM6_ID_WIDE: core::ffi::c_uint = 55;
pub const DEVCONF_NDISC_EVICT_NOCARRIER: core::ffi::c_uint = 56;
pub const DEVCONF_ACCEPT_UNTRACKED_NA: core::ffi::c_uint = 57;
pub const DEVCONF_MAX: core::ffi::c_uint = 58;
pub type _bindgen_ty_297 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_devconf {
    pub forwarding: __s32,
    pub hop_limit: __s32,
    pub mtu6: __s32,
    pub accept_ra: __s32,
    pub accept_redirects: __s32,
    pub autoconf: __s32,
    pub dad_transmits: __s32,
    pub rtr_solicits: __s32,
    pub rtr_solicit_interval: __s32,
    pub rtr_solicit_max_interval: __s32,
    pub rtr_solicit_delay: __s32,
    pub force_mld_version: __s32,
    pub mldv1_unsolicited_report_interval: __s32,
    pub mldv2_unsolicited_report_interval: __s32,
    pub use_tempaddr: __s32,
    pub temp_valid_lft: __s32,
    pub temp_prefered_lft: __s32,
    pub regen_max_retry: __s32,
    pub max_desync_factor: __s32,
    pub max_addresses: __s32,
    pub accept_ra_defrtr: __s32,
    pub ra_defrtr_metric: __u32,
    pub accept_ra_min_hop_limit: __s32,
    pub accept_ra_pinfo: __s32,
    pub ignore_routes_with_linkdown: __s32,
    pub proxy_ndp: __s32,
    pub accept_source_route: __s32,
    pub accept_ra_from_local: __s32,
    pub disable_ipv6: __s32,
    pub drop_unicast_in_l2_multicast: __s32,
    pub accept_dad: __s32,
    pub force_tllao: __s32,
    pub ndisc_notify: __s32,
    pub suppress_frag_ndisc: __s32,
    pub accept_ra_mtu: __s32,
    pub drop_unsolicited_na: __s32,
    pub accept_untracked_na: __s32,
    pub stable_secret: ipv6_devconf_ipv6_stable_secret,
    pub use_oif_addrs_only: __s32,
    pub keep_addr_on_down: __s32,
    pub seg6_enabled: __s32,
    pub enhanced_dad: __u32,
    pub addr_gen_mode: __u32,
    pub disable_policy: __s32,
    pub ndisc_tclass: __s32,
    pub rpl_seg_enabled: __s32,
    pub ioam6_id: __u32,
    pub ioam6_id_wide: __u32,
    pub ioam6_enabled: __u8,
    pub ndisc_evict_nocarrier: __u8,
    pub sysctl_header: *mut ctl_table_header,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_devconf_ipv6_stable_secret {
    pub initialized: bool_,
    pub secret: in6_addr,
}
impl Default for ipv6_devconf_ipv6_stable_secret {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for ipv6_devconf {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ipv6_params {
    pub disable_ipv6: __s32,
    pub autoconf: __s32,
}
extern "C" {
    pub static mut ipv6_defaults: ipv6_params;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct udphdr {
    pub source: __be16,
    pub dest: __be16,
    pub len: __be16,
    pub check: __sum16,
}
#[repr(C)]
#[repr(align(64))]
pub struct udp_sock {
    pub inet: inet_sock,
    pub pending: core::ffi::c_int,
    pub corkflag: core::ffi::c_uint,
    pub encap_type: __u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub len: __u16,
    pub gso_size: __u16,
    pub pcslen: __u16,
    pub pcrlen: __u16,
    pub pcflag: __u8,
    pub unused: [__u8; 3usize],
    pub encap_rcv: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub encap_err_rcv: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff, udp_offset: core::ffi::c_uint),
    >,
    pub encap_err_lookup: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub encap_destroy: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub gro_receive: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            head: *mut list_head,
            skb: *mut sk_buff,
        ) -> *mut sk_buff,
    >,
    pub gro_complete: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            skb: *mut sk_buff,
            nhoff: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub __bindgen_padding_0: [u64; 2usize],
    pub reader_queue: sk_buff_head,
    pub forward_deficit: core::ffi::c_int,
}
impl Default for udp_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl udp_sock {
    #[inline]
    pub fn no_check6_tx(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_check6_tx(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn no_check6_rx(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_no_check6_rx(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encap_enabled(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encap_enabled(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gro_enabled(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_gro_enabled(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accept_udp_l4(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_accept_udp_l4(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accept_udp_fraglist(&self) -> core::ffi::c_uchar {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_accept_udp_fraglist(&mut self, val: core::ffi::c_uchar) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        no_check6_tx: core::ffi::c_uchar,
        no_check6_rx: core::ffi::c_uchar,
        encap_enabled: core::ffi::c_uchar,
        gro_enabled: core::ffi::c_uchar,
        accept_udp_l4: core::ffi::c_uchar,
        accept_udp_fraglist: core::ffi::c_uchar,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let no_check6_tx: u8 = unsafe { ::core::mem::transmute(no_check6_tx) };
            no_check6_tx as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let no_check6_rx: u8 = unsafe { ::core::mem::transmute(no_check6_rx) };
            no_check6_rx as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let encap_enabled: u8 = unsafe { ::core::mem::transmute(encap_enabled) };
            encap_enabled as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let gro_enabled: u8 = unsafe { ::core::mem::transmute(gro_enabled) };
            gro_enabled as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let accept_udp_l4: u8 = unsafe { ::core::mem::transmute(accept_udp_l4) };
            accept_udp_l4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let accept_udp_fraglist: u8 = unsafe { ::core::mem::transmute(accept_udp_fraglist) };
            accept_udp_fraglist as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct inet6_skb_parm {
    pub iif: core::ffi::c_int,
    pub ra: __be16,
    pub dst0: __u16,
    pub srcrt: __u16,
    pub dst1: __u16,
    pub lastopt: __u16,
    pub nhoff: __u16,
    pub flags: __u16,
    pub frag_max_size: __u16,
    pub srhoff: __u16,
}
#[repr(C)]
pub struct tcp6_request_sock {
    pub tcp6rsk_tcp: tcp_request_sock,
}
impl Default for tcp6_request_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet6_cork {
    pub opt: *mut ipv6_txoptions,
    pub hop_limit: u8_,
    pub tclass: u8_,
}
impl Default for inet6_cork {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_pinfo {
    pub saddr: in6_addr,
    pub sticky_pktinfo: in6_pktinfo,
    pub daddr_cache: *const in6_addr,
    pub flow_label: __be32,
    pub frag_size: __u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub ucast_oif: core::ffi::c_int,
    pub mcast_oif: core::ffi::c_int,
    pub rxopt: ipv6_pinfo__bindgen_ty_1,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub min_hopcount: __u8,
    pub tclass: __u8,
    pub rcv_flowinfo: __be32,
    pub dst_cookie: __u32,
    pub ipv6_mc_list: *mut ipv6_mc_socklist,
    pub ipv6_ac_list: *mut ipv6_ac_socklist,
    pub ipv6_fl_list: *mut ipv6_fl_socklist,
    pub opt: *mut ipv6_txoptions,
    pub pktoptions: *mut sk_buff,
    pub rxpmtu: *mut sk_buff,
    pub cork: inet6_cork,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ipv6_pinfo__bindgen_ty_1 {
    pub bits: ipv6_pinfo__bindgen_ty_1__bindgen_ty_1,
    pub all: __u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Default, Copy, Clone)]
pub struct ipv6_pinfo__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
impl ipv6_pinfo__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn srcrt(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_srcrt(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn osrcrt(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_osrcrt(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxinfo(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxinfo(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxoinfo(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxoinfo(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxhlim(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxhlim(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxohlim(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxohlim(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hopopts(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_hopopts(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ohopopts(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ohopopts(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dstopts(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dstopts(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn odstopts(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_odstopts(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxflow(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxflow(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxtclass(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxtclass(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxpmtu(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxpmtu(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rxorigdstaddr(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rxorigdstaddr(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recvfragsize(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_recvfragsize(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        srcrt: __u16,
        osrcrt: __u16,
        rxinfo: __u16,
        rxoinfo: __u16,
        rxhlim: __u16,
        rxohlim: __u16,
        hopopts: __u16,
        ohopopts: __u16,
        dstopts: __u16,
        odstopts: __u16,
        rxflow: __u16,
        rxtclass: __u16,
        rxpmtu: __u16,
        rxorigdstaddr: __u16,
        recvfragsize: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let srcrt: u16 = unsafe { ::core::mem::transmute(srcrt) };
            srcrt as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let osrcrt: u16 = unsafe { ::core::mem::transmute(osrcrt) };
            osrcrt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let rxinfo: u16 = unsafe { ::core::mem::transmute(rxinfo) };
            rxinfo as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let rxoinfo: u16 = unsafe { ::core::mem::transmute(rxoinfo) };
            rxoinfo as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let rxhlim: u16 = unsafe { ::core::mem::transmute(rxhlim) };
            rxhlim as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let rxohlim: u16 = unsafe { ::core::mem::transmute(rxohlim) };
            rxohlim as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hopopts: u16 = unsafe { ::core::mem::transmute(hopopts) };
            hopopts as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ohopopts: u16 = unsafe { ::core::mem::transmute(ohopopts) };
            ohopopts as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let dstopts: u16 = unsafe { ::core::mem::transmute(dstopts) };
            dstopts as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let odstopts: u16 = unsafe { ::core::mem::transmute(odstopts) };
            odstopts as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let rxflow: u16 = unsafe { ::core::mem::transmute(rxflow) };
            rxflow as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let rxtclass: u16 = unsafe { ::core::mem::transmute(rxtclass) };
            rxtclass as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let rxpmtu: u16 = unsafe { ::core::mem::transmute(rxpmtu) };
            rxpmtu as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let rxorigdstaddr: u16 = unsafe { ::core::mem::transmute(rxorigdstaddr) };
            rxorigdstaddr as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let recvfragsize: u16 = unsafe { ::core::mem::transmute(recvfragsize) };
            recvfragsize as u64
        });
        __bindgen_bitfield_unit
    }
}
impl Default for ipv6_pinfo__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for ipv6_pinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl ipv6_pinfo {
    #[inline]
    pub fn __unused_1(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set___unused_1(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn hop_limit(&self) -> __s16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_hop_limit(&mut self, val: __s16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn mc_loop(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_mc_loop(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __unused_2(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set___unused_2(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn mcast_hops(&self) -> __s16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_mcast_hops(&mut self, val: __s16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __unused_1: __u16,
        hop_limit: __s16,
        mc_loop: __u16,
        __unused_2: __u16,
        mcast_hops: __s16,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __unused_1: u16 = unsafe { ::core::mem::transmute(__unused_1) };
            __unused_1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 9u8, {
            let hop_limit: u16 = unsafe { ::core::mem::transmute(hop_limit) };
            hop_limit as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mc_loop: u16 = unsafe { ::core::mem::transmute(mc_loop) };
            mc_loop as u64
        });
        __bindgen_bitfield_unit.set(17usize, 6u8, {
            let __unused_2: u16 = unsafe { ::core::mem::transmute(__unused_2) };
            __unused_2 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let mcast_hops: u16 = unsafe { ::core::mem::transmute(mcast_hops) };
            mcast_hops as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn recverr(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_recverr(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sndflow(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_sndflow(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn repflow(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_repflow(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pmtudisc(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(3usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_pmtudisc(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn padding(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_padding(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn srcprefs(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(7usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_srcprefs(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(7usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn dontfrag(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dontfrag(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autoflowlabel(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_autoflowlabel(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autoflowlabel_set(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_autoflowlabel_set(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mc_all(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_mc_all(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn recverr_rfc4884(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_recverr_rfc4884(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rtalert_isolate(&self) -> __u16 {
        unsafe { ::core::mem::transmute(self._bitfield_2.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_rtalert_isolate(&mut self, val: __u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_2.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        recverr: __u16,
        sndflow: __u16,
        repflow: __u16,
        pmtudisc: __u16,
        padding: __u16,
        srcprefs: __u16,
        dontfrag: __u16,
        autoflowlabel: __u16,
        autoflowlabel_set: __u16,
        mc_all: __u16,
        recverr_rfc4884: __u16,
        rtalert_isolate: __u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let recverr: u16 = unsafe { ::core::mem::transmute(recverr) };
            recverr as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let sndflow: u16 = unsafe { ::core::mem::transmute(sndflow) };
            sndflow as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let repflow: u16 = unsafe { ::core::mem::transmute(repflow) };
            repflow as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let pmtudisc: u16 = unsafe { ::core::mem::transmute(pmtudisc) };
            pmtudisc as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let padding: u16 = unsafe { ::core::mem::transmute(padding) };
            padding as u64
        });
        __bindgen_bitfield_unit.set(7usize, 3u8, {
            let srcprefs: u16 = unsafe { ::core::mem::transmute(srcprefs) };
            srcprefs as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let dontfrag: u16 = unsafe { ::core::mem::transmute(dontfrag) };
            dontfrag as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let autoflowlabel: u16 = unsafe { ::core::mem::transmute(autoflowlabel) };
            autoflowlabel as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let autoflowlabel_set: u16 = unsafe { ::core::mem::transmute(autoflowlabel_set) };
            autoflowlabel_set as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let mc_all: u16 = unsafe { ::core::mem::transmute(mc_all) };
            mc_all as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let recverr_rfc4884: u16 = unsafe { ::core::mem::transmute(recverr_rfc4884) };
            recverr_rfc4884 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let rtalert_isolate: u16 = unsafe { ::core::mem::transmute(rtalert_isolate) };
            rtalert_isolate as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct raw6_sock {
    pub inet: inet_sock,
    pub checksum: __u32,
    pub offset: __u32,
    pub filter: icmp6_filter,
    pub ip6mr_table: __u32,
    pub inet6: ipv6_pinfo,
}
impl Default for raw6_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct udp6_sock {
    pub udp: udp_sock,
    pub inet6: ipv6_pinfo,
}
impl Default for udp6_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct tcp6_sock {
    pub tcp: tcp_sock,
    pub inet6: ipv6_pinfo,
}
impl Default for tcp6_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn inet6_sk_rebuild_header(sk: *mut sock) -> core::ffi::c_int;
}
#[repr(C)]
pub struct tcp6_timewait_sock {
    pub tcp6tw_tcp: tcp_timewait_sock,
}
impl Default for tcp6_timewait_sock {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ipv6_mod_enabled() -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_deferred {
    pub key: static_key,
    pub timeout: core::ffi::c_ulong,
    pub work: delayed_work,
}
impl Default for static_key_deferred {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_true_deferred {
    pub key: static_key_true,
    pub timeout: core::ffi::c_ulong,
    pub work: delayed_work,
}
impl Default for static_key_true_deferred {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct static_key_false_deferred {
    pub key: static_key_false,
    pub timeout: core::ffi::c_ulong,
    pub work: delayed_work,
}
impl Default for static_key_false_deferred {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __static_key_slow_dec_deferred(
        key: *mut static_key,
        work: *mut delayed_work,
        timeout: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn __static_key_deferred_flush(key: *mut core::ffi::c_void, work: *mut delayed_work);
}
extern "C" {
    pub fn jump_label_rate_limit(key: *mut static_key_deferred, rl: core::ffi::c_ulong);
}
extern "C" {
    pub fn jump_label_update_timeout(work: *mut work_struct);
}
pub const INET6_IFADDR_STATE_PREDAD: core::ffi::c_uint = 0;
pub const INET6_IFADDR_STATE_DAD: core::ffi::c_uint = 1;
pub const INET6_IFADDR_STATE_POSTDAD: core::ffi::c_uint = 2;
pub const INET6_IFADDR_STATE_ERRDAD: core::ffi::c_uint = 3;
pub const INET6_IFADDR_STATE_DEAD: core::ffi::c_uint = 4;
pub type _bindgen_ty_298 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet6_ifaddr {
    pub addr: in6_addr,
    pub prefix_len: __u32,
    pub rt_priority: __u32,
    pub valid_lft: __u32,
    pub prefered_lft: __u32,
    pub refcnt: refcount_t,
    pub lock: spinlock_t,
    pub state: core::ffi::c_int,
    pub flags: __u32,
    pub dad_probes: __u8,
    pub stable_privacy_retry: __u8,
    pub scope: __u16,
    pub dad_nonce: __u64,
    pub cstamp: core::ffi::c_ulong,
    pub tstamp: core::ffi::c_ulong,
    pub dad_work: delayed_work,
    pub idev: *mut inet6_dev,
    pub rt: *mut fib6_info,
    pub addr_lst: hlist_node,
    pub if_list: list_head,
    pub if_list_aux: list_head,
    pub tmp_list: list_head,
    pub ifpub: *mut inet6_ifaddr,
    pub regen_count: core::ffi::c_int,
    pub tokenized: bool_,
    pub ifa_proto: u8_,
    pub rcu: callback_head,
    pub peer_addr: in6_addr,
}
impl Default for inet6_ifaddr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct ip6_sf_socklist {
    pub sl_max: core::ffi::c_uint,
    pub sl_count: core::ffi::c_uint,
    pub rcu: callback_head,
    pub sl_addr: __IncompleteArrayField<in6_addr>,
}
impl Default for ip6_sf_socklist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mc_socklist {
    pub addr: in6_addr,
    pub ifindex: core::ffi::c_int,
    pub sfmode: core::ffi::c_uint,
    pub next: *mut ipv6_mc_socklist,
    pub sflist: *mut ip6_sf_socklist,
    pub rcu: callback_head,
}
impl Default for ipv6_mc_socklist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_sf_list {
    pub sf_next: *mut ip6_sf_list,
    pub sf_addr: in6_addr,
    pub sf_count: [core::ffi::c_ulong; 2usize],
    pub sf_gsresp: core::ffi::c_uchar,
    pub sf_oldin: core::ffi::c_uchar,
    pub sf_crcount: core::ffi::c_uchar,
    pub rcu: callback_head,
}
impl Default for ip6_sf_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifmcaddr6 {
    pub mca_addr: in6_addr,
    pub idev: *mut inet6_dev,
    pub next: *mut ifmcaddr6,
    pub mca_sources: *mut ip6_sf_list,
    pub mca_tomb: *mut ip6_sf_list,
    pub mca_sfmode: core::ffi::c_uint,
    pub mca_crcount: core::ffi::c_uchar,
    pub mca_sfcount: [core::ffi::c_ulong; 2usize],
    pub mca_work: delayed_work,
    pub mca_flags: core::ffi::c_uint,
    pub mca_users: core::ffi::c_int,
    pub mca_refcnt: refcount_t,
    pub mca_cstamp: core::ffi::c_ulong,
    pub mca_tstamp: core::ffi::c_ulong,
    pub rcu: callback_head,
}
impl Default for ifmcaddr6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_ac_socklist {
    pub acl_addr: in6_addr,
    pub acl_ifindex: core::ffi::c_int,
    pub acl_next: *mut ipv6_ac_socklist,
}
impl Default for ipv6_ac_socklist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifacaddr6 {
    pub aca_addr: in6_addr,
    pub aca_rt: *mut fib6_info,
    pub aca_next: *mut ifacaddr6,
    pub aca_addr_lst: hlist_node,
    pub aca_users: core::ffi::c_int,
    pub aca_refcnt: refcount_t,
    pub aca_cstamp: core::ffi::c_ulong,
    pub aca_tstamp: core::ffi::c_ulong,
    pub rcu: callback_head,
}
impl Default for ifacaddr6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_devstat {
    pub proc_dir_entry: *mut proc_dir_entry,
    pub ipv6: *mut ipstats_mib,
    pub icmpv6dev: *mut icmpv6_mib_device,
    pub icmpv6msgdev: *mut icmpv6msg_mib_device,
}
impl Default for ipv6_devstat {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet6_dev {
    pub dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub addr_list: list_head,
    pub mc_list: *mut ifmcaddr6,
    pub mc_tomb: *mut ifmcaddr6,
    pub mc_qrv: core::ffi::c_uchar,
    pub mc_gq_running: core::ffi::c_uchar,
    pub mc_ifc_count: core::ffi::c_uchar,
    pub mc_dad_count: core::ffi::c_uchar,
    pub mc_v1_seen: core::ffi::c_ulong,
    pub mc_qi: core::ffi::c_ulong,
    pub mc_qri: core::ffi::c_ulong,
    pub mc_maxdelay: core::ffi::c_ulong,
    pub mc_gq_work: delayed_work,
    pub mc_ifc_work: delayed_work,
    pub mc_dad_work: delayed_work,
    pub mc_query_work: delayed_work,
    pub mc_report_work: delayed_work,
    pub mc_query_queue: sk_buff_head,
    pub mc_report_queue: sk_buff_head,
    pub mc_query_lock: spinlock_t,
    pub mc_report_lock: spinlock_t,
    pub mc_lock: mutex,
    pub ac_list: *mut ifacaddr6,
    pub lock: rwlock_t,
    pub refcnt: refcount_t,
    pub if_flags: __u32,
    pub dead: core::ffi::c_int,
    pub desync_factor: u32_,
    pub tempaddr_list: list_head,
    pub token: in6_addr,
    pub nd_parms: *mut neigh_parms,
    pub cnf: ipv6_devconf,
    pub stats: ipv6_devstat,
    pub rs_timer: timer_list,
    pub rs_interval: __s32,
    pub rs_probes: __u8,
    pub tstamp: core::ffi::c_ulong,
    pub rcu: callback_head,
    pub ra_mtu: core::ffi::c_uint,
}
impl Default for inet6_dev {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type dscp_t = u8_;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_tunnel_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct frag_hdr {
    pub nexthdr: __u8,
    pub reserved: __u8,
    pub frag_off: __be16,
    pub identification: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct hop_jumbo_hdr {
    pub nexthdr: u8_,
    pub hdrlen: u8_,
    pub tlv_type: u8_,
    pub tlv_len: u8_,
    pub jumbo_payload_len: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_fraglist_iter {
    pub tmp_hdr: *mut ipv6hdr,
    pub frag: *mut sk_buff,
    pub offset: core::ffi::c_int,
    pub hlen: core::ffi::c_uint,
    pub frag_id: __be32,
    pub nexthdr: u8_,
}
impl Default for ip6_fraglist_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ip6_fraglist_init(
        skb: *mut sk_buff,
        hlen: core::ffi::c_uint,
        prevhdr: *mut u8_,
        nexthdr: u8_,
        frag_id: __be32,
        iter: *mut ip6_fraglist_iter,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_fraglist_prepare(skb: *mut sk_buff, iter: *mut ip6_fraglist_iter);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_frag_state {
    pub prevhdr: *mut u8_,
    pub hlen: core::ffi::c_uint,
    pub mtu: core::ffi::c_uint,
    pub left: core::ffi::c_uint,
    pub offset: core::ffi::c_int,
    pub ptr: core::ffi::c_int,
    pub hroom: core::ffi::c_int,
    pub troom: core::ffi::c_int,
    pub frag_id: __be32,
    pub nexthdr: u8_,
}
impl Default for ip6_frag_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ip6_frag_init(
        skb: *mut sk_buff,
        hlen: core::ffi::c_uint,
        mtu: core::ffi::c_uint,
        needed_tailroom: core::ffi::c_ushort,
        hdr_room: core::ffi::c_int,
        prevhdr: *mut u8_,
        nexthdr: u8_,
        frag_id: __be32,
        state: *mut ip6_frag_state,
    );
}
extern "C" {
    pub fn ip6_frag_next(skb: *mut sk_buff, state: *mut ip6_frag_state) -> *mut sk_buff;
}
extern "C" {
    pub static mut sysctl_mld_max_msf: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_mld_qrv: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_ra_chain {
    pub next: *mut ip6_ra_chain,
    pub sk: *mut sock,
    pub sel: core::ffi::c_int,
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
}
impl Default for ip6_ra_chain {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut ip6_ra_chain: *mut ip6_ra_chain;
}
extern "C" {
    pub static mut ip6_ra_lock: rwlock_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_txoptions {
    pub refcnt: refcount_t,
    pub tot_len: core::ffi::c_int,
    pub opt_flen: __u16,
    pub opt_nflen: __u16,
    pub hopopt: *mut ipv6_opt_hdr,
    pub dst0opt: *mut ipv6_opt_hdr,
    pub srcrt: *mut ipv6_rt_hdr,
    pub dst1opt: *mut ipv6_opt_hdr,
    pub rcu: callback_head,
}
impl Default for ipv6_txoptions {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const flowlabel_reflect_FLOWLABEL_REFLECT_ESTABLISHED: flowlabel_reflect = 1;
pub const flowlabel_reflect_FLOWLABEL_REFLECT_TCP_RESET: flowlabel_reflect = 2;
pub const flowlabel_reflect_FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES: flowlabel_reflect = 4;
pub type flowlabel_reflect = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_flowlabel {
    pub next: *mut ip6_flowlabel,
    pub label: __be32,
    pub users: atomic_t,
    pub dst: in6_addr,
    pub opt: *mut ipv6_txoptions,
    pub linger: core::ffi::c_ulong,
    pub rcu: callback_head,
    pub share: u8_,
    pub owner: ip6_flowlabel__bindgen_ty_1,
    pub lastuse: core::ffi::c_ulong,
    pub expires: core::ffi::c_ulong,
    pub fl_net: *mut net,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip6_flowlabel__bindgen_ty_1 {
    pub pid: *mut pid,
    pub uid: kuid_t,
    _bindgen_union_align: u64,
}
impl Default for ip6_flowlabel__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for ip6_flowlabel {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_fl_socklist {
    pub next: *mut ipv6_fl_socklist,
    pub fl: *mut ip6_flowlabel,
    pub rcu: callback_head,
}
impl Default for ipv6_fl_socklist {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipcm6_cookie {
    pub sockc: sockcm_cookie,
    pub hlimit: __s16,
    pub tclass: __s16,
    pub gso_size: __u16,
    pub dontfrag: __s8,
    pub opt: *mut ipv6_txoptions,
}
impl Default for ipcm6_cookie {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __fl6_sock_lookup(sk: *mut sock, label: __be32) -> *mut ip6_flowlabel;
}
extern "C" {
    pub static mut ipv6_flowlabel_exclusive: static_key_false_deferred;
}
extern "C" {
    pub fn fl6_merge_options(
        opt_space: *mut ipv6_txoptions,
        fl: *mut ip6_flowlabel,
        fopt: *mut ipv6_txoptions,
    ) -> *mut ipv6_txoptions;
}
extern "C" {
    pub fn fl6_free_socklist(sk: *mut sock);
}
extern "C" {
    pub fn ipv6_flowlabel_opt(
        sk: *mut sock,
        optval: sockptr_t,
        optlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_flowlabel_opt_get(
        sk: *mut sock,
        freq: *mut in6_flowlabel_req,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_flowlabel_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_flowlabel_cleanup();
}
extern "C" {
    pub fn ip6_autoflowlabel(net: *mut net, np: *const ipv6_pinfo) -> bool_;
}
extern "C" {
    pub fn icmpv6_notify(skb: *mut sk_buff, type_: u8_, code: u8_, info: __be32);
}
extern "C" {
    pub fn icmpv6_push_pending_frames(
        sk: *mut sock,
        fl6: *mut flowi6,
        thdr: *mut icmp6hdr,
        len: core::ffi::c_int,
    );
}
extern "C" {
    pub fn ip6_ra_control(sk: *mut sock, sel: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_parse_hopopts(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_dup_options(sk: *mut sock, opt: *mut ipv6_txoptions) -> *mut ipv6_txoptions;
}
extern "C" {
    pub fn ipv6_renew_options(
        sk: *mut sock,
        opt: *mut ipv6_txoptions,
        newtype: core::ffi::c_int,
        newopt: *mut ipv6_opt_hdr,
    ) -> *mut ipv6_txoptions;
}
extern "C" {
    pub fn __ipv6_fixup_options(
        opt_space: *mut ipv6_txoptions,
        opt: *mut ipv6_txoptions,
    ) -> *mut ipv6_txoptions;
}
extern "C" {
    pub fn ipv6_opt_accepted(
        sk: *const sock,
        skb: *const sk_buff,
        opt: *const inet6_skb_parm,
    ) -> bool_;
}
extern "C" {
    pub fn ipv6_update_options(sk: *mut sock, opt: *mut ipv6_txoptions) -> *mut ipv6_txoptions;
}
extern "C" {
    pub fn __ipv6_addr_type(addr: *const in6_addr) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_select_ident(
        net: *mut net,
        daddr: *const in6_addr,
        saddr: *const in6_addr,
    ) -> __be32;
}
extern "C" {
    pub fn ipv6_proxy_select_ident(net: *mut net, skb: *mut sk_buff) -> __be32;
}
extern "C" {
    pub fn ip6_dst_hoplimit(dst: *mut dst_entry) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_rcv(
        skb: *mut sk_buff,
        dev: *mut net_device,
        pt: *mut packet_type,
        orig_dev: *mut net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_list_rcv(head: *mut list_head, pt: *mut packet_type, orig_dev: *mut net_device);
}
extern "C" {
    pub fn ip6_rcv_finish(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_xmit(
        sk: *const sock,
        skb: *mut sk_buff,
        fl6: *mut flowi6,
        mark: __u32,
        opt: *mut ipv6_txoptions,
        tclass: core::ffi::c_int,
        priority: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_find_1stfragopt(skb: *mut sk_buff, nexthdr: *mut *mut u8_) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_append_data(
        sk: *mut sock,
        getfrag: ::core::option::Option<
            unsafe extern "C" fn(
                from: *mut core::ffi::c_void,
                to: *mut core::ffi::c_char,
                offset: core::ffi::c_int,
                len: core::ffi::c_int,
                odd: core::ffi::c_int,
                skb: *mut sk_buff,
            ) -> core::ffi::c_int,
        >,
        from: *mut core::ffi::c_void,
        length: usize,
        transhdrlen: core::ffi::c_int,
        ipc6: *mut ipcm6_cookie,
        fl6: *mut flowi6,
        rt: *mut rt6_info,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_push_pending_frames(sk: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_flush_pending_frames(sk: *mut sock);
}
extern "C" {
    pub fn ip6_send_skb(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn __ip6_make_skb(
        sk: *mut sock,
        queue: *mut sk_buff_head,
        cork: *mut inet_cork_full,
        v6_cork: *mut inet6_cork,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn ip6_make_skb(
        sk: *mut sock,
        getfrag: ::core::option::Option<
            unsafe extern "C" fn(
                from: *mut core::ffi::c_void,
                to: *mut core::ffi::c_char,
                offset: core::ffi::c_int,
                len: core::ffi::c_int,
                odd: core::ffi::c_int,
                skb: *mut sk_buff,
            ) -> core::ffi::c_int,
        >,
        from: *mut core::ffi::c_void,
        length: usize,
        transhdrlen: core::ffi::c_int,
        ipc6: *mut ipcm6_cookie,
        rt: *mut rt6_info,
        flags: core::ffi::c_uint,
        cork: *mut inet_cork_full,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn ip6_dst_lookup(
        net: *mut net,
        sk: *mut sock,
        dst: *mut *mut dst_entry,
        fl6: *mut flowi6,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_dst_lookup_flow(
        net: *mut net,
        sk: *const sock,
        fl6: *mut flowi6,
        final_dst: *const in6_addr,
    ) -> *mut dst_entry;
}
extern "C" {
    pub fn ip6_sk_dst_lookup_flow(
        sk: *mut sock,
        fl6: *mut flowi6,
        final_dst: *const in6_addr,
        connected: bool_,
    ) -> *mut dst_entry;
}
extern "C" {
    pub fn ip6_dst_lookup_tunnel(
        skb: *mut sk_buff,
        dev: *mut net_device,
        net: *mut net,
        sock: *mut socket,
        saddr: *mut in6_addr,
        info: *const ip_tunnel_info,
        protocol: u8_,
        use_cache: bool_,
    ) -> *mut dst_entry;
}
extern "C" {
    pub fn ip6_blackhole_route(net: *mut net, orig_dst: *mut dst_entry) -> *mut dst_entry;
}
extern "C" {
    pub fn ip6_output(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_forward(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_input(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_mc_input(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_protocol_deliver_rcu(
        net: *mut net,
        skb: *mut sk_buff,
        nexthdr: core::ffi::c_int,
        have_final: bool_,
    );
}
extern "C" {
    pub fn __ip6_local_out(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_local_out(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_push_nfrag_opts(
        skb: *mut sk_buff,
        opt: *mut ipv6_txoptions,
        proto: *mut u8_,
        daddr_p: *mut *mut in6_addr,
        saddr: *mut in6_addr,
    );
}
extern "C" {
    pub fn ipv6_push_frag_opts(skb: *mut sk_buff, opt: *mut ipv6_txoptions, proto: *mut u8_);
}
extern "C" {
    pub fn ipv6_skip_exthdr(
        arg1: *const sk_buff,
        start: core::ffi::c_int,
        nexthdrp: *mut u8_,
        frag_offp: *mut __be16,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_ext_hdr(nexthdr: u8_) -> bool_;
}
pub const IP6_FH_F_FRAG: core::ffi::c_uint = 1;
pub const IP6_FH_F_AUTH: core::ffi::c_uint = 2;
pub const IP6_FH_F_SKIP_RH: core::ffi::c_uint = 4;
pub type _bindgen_ty_299 = core::ffi::c_uint;
extern "C" {
    pub fn ipv6_find_hdr(
        skb: *const sk_buff,
        offset: *mut core::ffi::c_uint,
        target: core::ffi::c_int,
        fragoff: *mut core::ffi::c_ushort,
        fragflg: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_find_tlv(
        skb: *const sk_buff,
        offset: core::ffi::c_int,
        type_: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fl6_update_dst(
        fl6: *mut flowi6,
        opt: *const ipv6_txoptions,
        orig: *mut in6_addr,
    ) -> *mut in6_addr;
}
extern "C" {
    pub static mut ip6_min_hopcount: static_key_false;
}
extern "C" {
    pub fn do_ipv6_setsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_setsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_ipv6_getsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: sockptr_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_getsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: *mut core::ffi::c_char,
        optlen: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __ip6_datagram_connect(
        sk: *mut sock,
        addr: *mut sockaddr,
        addr_len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_datagram_connect(
        sk: *mut sock,
        addr: *mut sockaddr,
        addr_len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_datagram_connect_v6_only(
        sk: *mut sock,
        addr: *mut sockaddr,
        addr_len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_datagram_dst_update(sk: *mut sock, fix_sk_saddr: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_datagram_release_cb(sk: *mut sock);
}
extern "C" {
    pub fn ipv6_recv_error(
        sk: *mut sock,
        msg: *mut msghdr,
        len: core::ffi::c_int,
        addr_len: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_recv_rxpmtu(
        sk: *mut sock,
        msg: *mut msghdr,
        len: core::ffi::c_int,
        addr_len: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_icmp_error(
        sk: *mut sock,
        skb: *mut sk_buff,
        err: core::ffi::c_int,
        port: __be16,
        info: u32_,
        payload: *mut u8_,
    );
}
extern "C" {
    pub fn ipv6_local_error(sk: *mut sock, err: core::ffi::c_int, fl6: *mut flowi6, info: u32_);
}
extern "C" {
    pub fn ipv6_local_rxpmtu(sk: *mut sock, fl6: *mut flowi6, mtu: u32_);
}
extern "C" {
    pub fn inet6_cleanup_sock(sk: *mut sock);
}
extern "C" {
    pub fn inet6_sock_destruct(sk: *mut sock);
}
extern "C" {
    pub fn inet6_release(sock: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet6_bind(
        sock: *mut socket,
        uaddr: *mut sockaddr,
        addr_len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet6_getname(
        sock: *mut socket,
        uaddr: *mut sockaddr,
        peer: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet6_ioctl(
        sock: *mut socket,
        cmd: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet6_compat_ioctl(
        sock: *mut socket,
        cmd: core::ffi::c_uint,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet6_hash_connect(
        death_row: *mut inet_timewait_death_row,
        sk: *mut sock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet6_sendmsg(sock: *mut socket, msg: *mut msghdr, size: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet6_recvmsg(
        sock: *mut socket,
        msg: *mut msghdr,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static inet6_stream_ops: proto_ops;
}
extern "C" {
    pub static inet6_dgram_ops: proto_ops;
}
extern "C" {
    pub static inet6_sockraw_ops: proto_ops;
}
extern "C" {
    pub fn ip6_mc_source(
        add: core::ffi::c_int,
        omode: core::ffi::c_int,
        sk: *mut sock,
        pgsr: *mut group_source_req,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_mc_msfilter(
        sk: *mut sock,
        gsf: *mut group_filter,
        list: *mut __kernel_sockaddr_storage,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_mc_msfget(
        sk: *mut sock,
        gsf: *mut group_filter,
        optval: sockptr_t,
        ss_offset: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ac6_proc_init(net: *mut net) -> core::ffi::c_int;
}
extern "C" {
    pub fn ac6_proc_exit(net: *mut net);
}
extern "C" {
    pub fn raw6_proc_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn raw6_proc_exit();
}
extern "C" {
    pub fn tcp6_proc_init(net: *mut net) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp6_proc_exit(net: *mut net);
}
extern "C" {
    pub fn udp6_proc_init(net: *mut net) -> core::ffi::c_int;
}
extern "C" {
    pub fn udp6_proc_exit(net: *mut net);
}
extern "C" {
    pub fn udplite6_proc_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn udplite6_proc_exit();
}
extern "C" {
    pub fn ipv6_misc_proc_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_misc_proc_exit();
}
extern "C" {
    pub fn snmp6_register_dev(idev: *mut inet6_dev) -> core::ffi::c_int;
}
extern "C" {
    pub fn snmp6_unregister_dev(idev: *mut inet6_dev) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_icmp_sysctl_init(net: *mut net) -> *mut ctl_table;
}
extern "C" {
    pub fn ipv6_route_sysctl_init(net: *mut net) -> *mut ctl_table;
}
extern "C" {
    pub fn ipv6_sysctl_register() -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_sysctl_unregister();
}
extern "C" {
    pub fn ipv6_sock_mc_join(
        sk: *mut sock,
        ifindex: core::ffi::c_int,
        addr: *const in6_addr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_sock_mc_join_ssm(
        sk: *mut sock,
        ifindex: core::ffi::c_int,
        addr: *const in6_addr,
        mode: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_sock_mc_drop(
        sk: *mut sock,
        ifindex: core::ffi::c_int,
        addr: *const in6_addr,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ipv4_addr_key {
    pub addr: __be32,
    pub vif: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inetpeer_addr {
    pub __bindgen_anon_1: inetpeer_addr__bindgen_ty_1,
    pub family: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inetpeer_addr__bindgen_ty_1 {
    pub a4: ipv4_addr_key,
    pub a6: in6_addr,
    pub key: [u32_; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for inetpeer_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for inetpeer_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_peer {
    pub rb_node: rb_node,
    pub daddr: inetpeer_addr,
    pub metrics: [u32_; 17usize],
    pub rate_tokens: u32_,
    pub n_redirects: u32_,
    pub rate_last: core::ffi::c_ulong,
    pub __bindgen_anon_1: inet_peer__bindgen_ty_1,
    pub dtime: __u32,
    pub refcnt: refcount_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inet_peer__bindgen_ty_1 {
    pub __bindgen_anon_1: inet_peer__bindgen_ty_1__bindgen_ty_1,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct inet_peer__bindgen_ty_1__bindgen_ty_1 {
    pub rid: atomic_t,
}
impl Default for inet_peer__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for inet_peer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_peer_base {
    pub rb_root: rb_root,
    pub lock: seqlock_t,
    pub total: core::ffi::c_int,
}
impl Default for inet_peer_base {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn inet_peer_base_init(arg1: *mut inet_peer_base);
}
extern "C" {
    pub fn inet_initpeers();
}
extern "C" {
    pub fn inet_getpeer(
        base: *mut inet_peer_base,
        daddr: *const inetpeer_addr,
        create: core::ffi::c_int,
    ) -> *mut inet_peer;
}
extern "C" {
    pub fn inet_putpeer(p: *mut inet_peer);
}
extern "C" {
    pub fn inet_peer_xrlim_allow(peer: *mut inet_peer, timeout: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn inetpeer_invalidate_tree(arg1: *mut inet_peer_base);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_config {
    pub fc_dst_len: u8_,
    pub fc_dscp: dscp_t,
    pub fc_protocol: u8_,
    pub fc_scope: u8_,
    pub fc_type: u8_,
    pub fc_gw_family: u8_,
    pub fc_table: u32_,
    pub fc_dst: __be32,
    pub __bindgen_anon_1: fib_config__bindgen_ty_1,
    pub fc_oif: core::ffi::c_int,
    pub fc_flags: u32_,
    pub fc_priority: u32_,
    pub fc_prefsrc: __be32,
    pub fc_nh_id: u32_,
    pub fc_mx: *mut nlattr,
    pub fc_mp: *mut rtnexthop,
    pub fc_mx_len: core::ffi::c_int,
    pub fc_mp_len: core::ffi::c_int,
    pub fc_flow: u32_,
    pub fc_nlflags: u32_,
    pub fc_nlinfo: nl_info,
    pub fc_encap: *mut nlattr,
    pub fc_encap_type: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fib_config__bindgen_ty_1 {
    pub fc_gw4: __be32,
    pub fc_gw6: in6_addr,
    _bindgen_union_align: [u32; 4usize],
}
impl Default for fib_config__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for fib_config {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_nh_exception {
    pub fnhe_next: *mut fib_nh_exception,
    pub fnhe_genid: core::ffi::c_int,
    pub fnhe_daddr: __be32,
    pub fnhe_pmtu: u32_,
    pub fnhe_mtu_locked: bool_,
    pub fnhe_gw: __be32,
    pub fnhe_expires: core::ffi::c_ulong,
    pub fnhe_rth_input: *mut rtable,
    pub fnhe_rth_output: *mut rtable,
    pub fnhe_stamp: core::ffi::c_ulong,
    pub rcu: callback_head,
}
impl Default for fib_nh_exception {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fnhe_hash_bucket {
    pub chain: *mut fib_nh_exception,
}
impl Default for fnhe_hash_bucket {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_nh_common {
    pub nhc_dev: *mut net_device,
    pub nhc_dev_tracker: netdevice_tracker,
    pub nhc_oif: core::ffi::c_int,
    pub nhc_scope: core::ffi::c_uchar,
    pub nhc_family: u8_,
    pub nhc_gw_family: u8_,
    pub nhc_flags: core::ffi::c_uchar,
    pub nhc_lwtstate: *mut lwtunnel_state,
    pub nhc_gw: fib_nh_common__bindgen_ty_1,
    pub nhc_weight: core::ffi::c_int,
    pub nhc_upper_bound: atomic_t,
    pub nhc_pcpu_rth_output: *mut *mut rtable,
    pub nhc_rth_input: *mut rtable,
    pub nhc_exceptions: *mut fnhe_hash_bucket,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union fib_nh_common__bindgen_ty_1 {
    pub ipv4: __be32,
    pub ipv6: in6_addr,
    _bindgen_union_align: [u32; 4usize],
}
impl Default for fib_nh_common__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for fib_nh_common {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_nh {
    pub nh_common: fib_nh_common,
    pub nh_hash: hlist_node,
    pub nh_parent: *mut fib_info,
    pub nh_saddr: __be32,
    pub nh_saddr_genid: core::ffi::c_int,
}
impl Default for fib_nh {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nexthop {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct fib_info {
    pub fib_hash: hlist_node,
    pub fib_lhash: hlist_node,
    pub nh_list: list_head,
    pub fib_net: *mut net,
    pub fib_treeref: refcount_t,
    pub fib_clntref: refcount_t,
    pub fib_flags: core::ffi::c_uint,
    pub fib_dead: core::ffi::c_uchar,
    pub fib_protocol: core::ffi::c_uchar,
    pub fib_scope: core::ffi::c_uchar,
    pub fib_type: core::ffi::c_uchar,
    pub fib_prefsrc: __be32,
    pub fib_tb_id: u32_,
    pub fib_priority: u32_,
    pub fib_metrics: *mut dst_metrics,
    pub fib_nhs: core::ffi::c_int,
    pub fib_nh_is_v6: bool_,
    pub nh_updated: bool_,
    pub nh: *mut nexthop,
    pub rcu: callback_head,
    pub fib_nh: __IncompleteArrayField<fib_nh>,
}
impl Default for fib_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_result {
    pub prefix: __be32,
    pub prefixlen: core::ffi::c_uchar,
    pub nh_sel: core::ffi::c_uchar,
    pub type_: core::ffi::c_uchar,
    pub scope: core::ffi::c_uchar,
    pub tclassid: u32_,
    pub nhc: *mut fib_nh_common,
    pub fi: *mut fib_info,
    pub table: *mut fib_table,
    pub fa_head: *mut hlist_head,
}
impl Default for fib_result {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fib_result_nl {
    pub fl_addr: __be32,
    pub fl_mark: u32_,
    pub fl_tos: core::ffi::c_uchar,
    pub fl_scope: core::ffi::c_uchar,
    pub tb_id_in: core::ffi::c_uchar,
    pub tb_id: core::ffi::c_uchar,
    pub prefixlen: core::ffi::c_uchar,
    pub nh_sel: core::ffi::c_uchar,
    pub type_: core::ffi::c_uchar,
    pub scope: core::ffi::c_uchar,
    pub err: core::ffi::c_int,
}
extern "C" {
    pub fn fib_info_update_nhc_saddr(
        net: *mut net,
        nhc: *mut fib_nh_common,
        scope: core::ffi::c_uchar,
    ) -> __be32;
}
extern "C" {
    pub fn fib_result_prefsrc(net: *mut net, res: *mut fib_result) -> __be32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_rt_info {
    pub fi: *mut fib_info,
    pub tb_id: u32_,
    pub dst: __be32,
    pub dst_len: core::ffi::c_int,
    pub dscp: dscp_t,
    pub type_: u8_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: u8,
}
impl Default for fib_rt_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl fib_rt_info {
    #[inline]
    pub fn offload(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trap(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_trap(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn offload_failed(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_offload_failed(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        offload: u8_,
        trap: u8_,
        offload_failed: u8_,
        unused: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let offload: u8 = unsafe { ::core::mem::transmute(offload) };
            offload as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let trap: u8 = unsafe { ::core::mem::transmute(trap) };
            trap as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let offload_failed: u8 = unsafe { ::core::mem::transmute(offload_failed) };
            offload_failed as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_entry_notifier_info {
    pub info: fib_notifier_info,
    pub dst: u32_,
    pub dst_len: core::ffi::c_int,
    pub fi: *mut fib_info,
    pub dscp: dscp_t,
    pub type_: u8_,
    pub tb_id: u32_,
}
impl Default for fib_entry_notifier_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_nh_notifier_info {
    pub info: fib_notifier_info,
    pub fib_nh: *mut fib_nh,
}
impl Default for fib_nh_notifier_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn call_fib4_notifier(
        nb: *mut notifier_block,
        event_type: fib_event_type,
        info: *mut fib_notifier_info,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn call_fib4_notifiers(
        net: *mut net,
        event_type: fib_event_type,
        info: *mut fib_notifier_info,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib4_notifier_init(net: *mut net) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib4_notifier_exit(net: *mut net);
}
extern "C" {
    pub fn fib_info_notify_update(net: *mut net, info: *mut nl_info);
}
extern "C" {
    pub fn fib_notify(
        net: *mut net,
        nb: *mut notifier_block,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
#[repr(C)]
pub struct fib_table {
    pub tb_hlist: hlist_node,
    pub tb_id: u32_,
    pub tb_num_default: core::ffi::c_int,
    pub rcu: callback_head,
    pub tb_data: *mut core::ffi::c_ulong,
    pub __data: __IncompleteArrayField<core::ffi::c_ulong>,
}
impl Default for fib_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib_dump_filter {
    pub table_id: u32_,
    pub filter_set: bool_,
    pub dump_routes: bool_,
    pub dump_exceptions: bool_,
    pub protocol: core::ffi::c_uchar,
    pub rt_type: core::ffi::c_uchar,
    pub flags: core::ffi::c_uint,
    pub dev: *mut net_device,
}
impl Default for fib_dump_filter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn fib_table_lookup(
        tb: *mut fib_table,
        flp: *const flowi4,
        res: *mut fib_result,
        fib_flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_table_insert(
        arg1: *mut net,
        arg2: *mut fib_table,
        arg3: *mut fib_config,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_table_delete(
        arg1: *mut net,
        arg2: *mut fib_table,
        arg3: *mut fib_config,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_table_dump(
        table: *mut fib_table,
        skb: *mut sk_buff,
        cb: *mut netlink_callback,
        filter: *mut fib_dump_filter,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_table_flush(
        net: *mut net,
        table: *mut fib_table,
        flush_all: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_trie_unmerge(main_tb: *mut fib_table) -> *mut fib_table;
}
extern "C" {
    pub fn fib_table_flush_external(table: *mut fib_table);
}
extern "C" {
    pub fn fib_free_table(tb: *mut fib_table);
}
extern "C" {
    pub static mut rtm_ipv4_policy: [nla_policy; 0usize];
}
extern "C" {
    pub fn ip_fib_init();
}
extern "C" {
    pub fn fib_gw_from_via(
        cfg: *mut fib_config,
        nla: *mut nlattr,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_compute_spec_dst(skb: *mut sk_buff) -> __be32;
}
extern "C" {
    pub fn fib_info_nh_uses_dev(fi: *mut fib_info, dev: *const net_device) -> bool_;
}
extern "C" {
    pub fn fib_validate_source(
        skb: *mut sk_buff,
        src: __be32,
        dst: __be32,
        tos: u8_,
        oif: core::ffi::c_int,
        dev: *mut net_device,
        idev: *mut in_device,
        itag: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_unmerge(net: *mut net) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_fib_check_default(gw: __be32, dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_sync_down_dev(
        dev: *mut net_device,
        event: core::ffi::c_ulong,
        force: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_sync_down_addr(dev: *mut net_device, local: __be32) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_sync_up(dev: *mut net_device, nh_flags: core::ffi::c_uchar) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_sync_mtu(dev: *mut net_device, orig_mtu: u32_);
}
extern "C" {
    pub fn fib_nhc_update_mtu(nhc: *mut fib_nh_common, new: u32_, orig: u32_);
}
extern "C" {
    pub fn fib_check_nh(
        net: *mut net,
        nh: *mut fib_nh,
        table: u32_,
        scope: u8_,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_select_multipath(res: *mut fib_result, hash: core::ffi::c_int);
}
extern "C" {
    pub fn fib_select_path(
        net: *mut net,
        res: *mut fib_result,
        fl4: *mut flowi4,
        skb: *const sk_buff,
    );
}
extern "C" {
    pub fn fib_nh_init(
        net: *mut net,
        fib_nh: *mut fib_nh,
        cfg: *mut fib_config,
        nh_weight: core::ffi::c_int,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_nh_release(net: *mut net, fib_nh: *mut fib_nh);
}
extern "C" {
    pub fn fib_nh_common_init(
        net: *mut net,
        nhc: *mut fib_nh_common,
        fc_encap: *mut nlattr,
        fc_encap_type: u16_,
        cfg: *mut core::ffi::c_void,
        gfp_flags: gfp_t,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_nh_common_release(nhc: *mut fib_nh_common);
}
extern "C" {
    pub fn fib_alias_hw_flags_set(net: *mut net, fri: *const fib_rt_info);
}
extern "C" {
    pub fn fib_trie_init();
}
extern "C" {
    pub fn fib_trie_table(id: u32_, alias: *mut fib_table) -> *mut fib_table;
}
extern "C" {
    pub fn fib_lookup_good_nhc(
        nhc: *const fib_nh_common,
        fib_flags: core::ffi::c_int,
        flp: *const flowi4,
    ) -> bool_;
}
extern "C" {
    pub fn fib_flush(net: *mut net);
}
extern "C" {
    pub fn free_fib_info(fi: *mut fib_info);
}
extern "C" {
    pub fn fib_proc_init(net: *mut net) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_proc_exit(net: *mut net);
}
extern "C" {
    pub fn ip_mtu_from_fib_result(res: *mut fib_result, daddr: __be32) -> u32_;
}
extern "C" {
    pub fn ip_valid_fib_dump_req(
        net: *mut net,
        nlh: *const nlmsghdr,
        filter: *mut fib_dump_filter,
        cb: *mut netlink_callback,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_nexthop_info(
        skb: *mut sk_buff,
        nh: *const fib_nh_common,
        rt_family: u8_,
        flags: *mut core::ffi::c_uchar,
        skip_oif: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn fib_add_nexthop(
        skb: *mut sk_buff,
        nh: *const fib_nh_common,
        nh_weight: core::ffi::c_int,
        rt_family: u8_,
        nh_tclassid: u32_,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct arpreq {
    pub arp_pa: sockaddr,
    pub arp_ha: sockaddr,
    pub arp_flags: core::ffi::c_int,
    pub arp_netmask: sockaddr,
    pub arp_dev: [core::ffi::c_char; 16usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct arpreq_old {
    pub arp_pa: sockaddr,
    pub arp_ha: sockaddr,
    pub arp_flags: core::ffi::c_int,
    pub arp_netmask: sockaddr,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct arphdr {
    pub ar_hrd: __be16,
    pub ar_pro: __be16,
    pub ar_hln: core::ffi::c_uchar,
    pub ar_pln: core::ffi::c_uchar,
    pub ar_op: __be16,
}
extern "C" {
    pub static mut arp_tbl: neigh_table;
}
extern "C" {
    pub fn arp_init();
}
extern "C" {
    pub fn arp_ioctl(
        net: *mut net,
        cmd: core::ffi::c_uint,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arp_send(
        type_: core::ffi::c_int,
        ptype: core::ffi::c_int,
        dest_ip: __be32,
        dev: *mut net_device,
        src_ip: __be32,
        dest_hw: *const core::ffi::c_uchar,
        src_hw: *const core::ffi::c_uchar,
        th: *const core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn arp_mc_map(
        addr: __be32,
        haddr: *mut u8_,
        dev: *mut net_device,
        dir: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arp_ifdown(dev: *mut net_device);
}
extern "C" {
    pub fn arp_invalidate(dev: *mut net_device, ip: __be32, force: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn arp_create(
        type_: core::ffi::c_int,
        ptype: core::ffi::c_int,
        dest_ip: __be32,
        dev: *mut net_device,
        src_ip: __be32,
        dest_hw: *const core::ffi::c_uchar,
        src_hw: *const core::ffi::c_uchar,
        target_hw: *const core::ffi::c_uchar,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn arp_xmit(skb: *mut sk_buff);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib6_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib6_nh {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib6_config {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fib6_result {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_stub {
    pub ipv6_sock_mc_join: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            ifindex: core::ffi::c_int,
            addr: *const in6_addr,
        ) -> core::ffi::c_int,
    >,
    pub ipv6_sock_mc_drop: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            ifindex: core::ffi::c_int,
            addr: *const in6_addr,
        ) -> core::ffi::c_int,
    >,
    pub ipv6_dst_lookup_flow: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            sk: *const sock,
            fl6: *mut flowi6,
            final_dst: *const in6_addr,
        ) -> *mut dst_entry,
    >,
    pub ipv6_route_input:
        ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff) -> core::ffi::c_int>,
    pub fib6_get_table:
        ::core::option::Option<unsafe extern "C" fn(net: *mut net, id: u32_) -> *mut fib6_table>,
    pub fib6_lookup: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            oif: core::ffi::c_int,
            fl6: *mut flowi6,
            res: *mut fib6_result,
            flags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub fib6_table_lookup: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            table: *mut fib6_table,
            oif: core::ffi::c_int,
            fl6: *mut flowi6,
            res: *mut fib6_result,
            flags: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub fib6_select_path: ::core::option::Option<
        unsafe extern "C" fn(
            net: *const net,
            res: *mut fib6_result,
            fl6: *mut flowi6,
            oif: core::ffi::c_int,
            oif_match: bool_,
            skb: *const sk_buff,
            strict: core::ffi::c_int,
        ),
    >,
    pub ip6_mtu_from_fib6: ::core::option::Option<
        unsafe extern "C" fn(
            res: *const fib6_result,
            daddr: *const in6_addr,
            saddr: *const in6_addr,
        ) -> u32_,
    >,
    pub fib6_nh_init: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            fib6_nh: *mut fib6_nh,
            cfg: *mut fib6_config,
            gfp_flags: gfp_t,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub fib6_nh_release: ::core::option::Option<unsafe extern "C" fn(fib6_nh: *mut fib6_nh)>,
    pub fib6_nh_release_dsts: ::core::option::Option<unsafe extern "C" fn(fib6_nh: *mut fib6_nh)>,
    pub fib6_update_sernum:
        ::core::option::Option<unsafe extern "C" fn(net: *mut net, rt: *mut fib6_info)>,
    pub ip6_del_rt: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            rt: *mut fib6_info,
            skip_notify: bool_,
        ) -> core::ffi::c_int,
    >,
    pub fib6_rt_update: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, rt: *mut fib6_info, info: *mut nl_info),
    >,
    pub udpv6_encap_enable: ::core::option::Option<unsafe extern "C" fn()>,
    pub ndisc_send_na: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *mut net_device,
            daddr: *const in6_addr,
            solicited_addr: *const in6_addr,
            router: bool_,
            solicited: bool_,
            override_: bool_,
            inc_opt: bool_,
        ),
    >,
    pub xfrm6_local_rxpmtu:
        ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff, mtu: u32_)>,
    pub xfrm6_udp_encap_rcv: ::core::option::Option<
        unsafe extern "C" fn(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub xfrm6_rcv_encap: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            nexthdr: core::ffi::c_int,
            spi: __be32,
            encap_type: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub nd_tbl: *mut neigh_table,
    pub ipv6_fragment: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            sk: *mut sock,
            skb: *mut sk_buff,
            output: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut net,
                    arg2: *mut sock,
                    arg3: *mut sk_buff,
                ) -> core::ffi::c_int,
            >,
        ) -> core::ffi::c_int,
    >,
    pub ipv6_dev_find: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            addr: *const in6_addr,
            dev: *mut net_device,
        ) -> *mut net_device,
    >,
}
impl Default for ipv6_stub {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut ipv6_stub: *const ipv6_stub;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ipv6_bpf_stub {
    pub inet6_bind: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            uaddr: *mut sockaddr,
            addr_len: core::ffi::c_int,
            flags: u32_,
        ) -> core::ffi::c_int,
    >,
    pub udp6_lib_lookup: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            saddr: *const in6_addr,
            sport: __be16,
            daddr: *const in6_addr,
            dport: __be16,
            dif: core::ffi::c_int,
            sdif: core::ffi::c_int,
            tbl: *mut udp_table,
            skb: *mut sk_buff,
        ) -> *mut sock,
    >,
    pub ipv6_setsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            level: core::ffi::c_int,
            optname: core::ffi::c_int,
            optval: sockptr_t,
            optlen: core::ffi::c_uint,
        ) -> core::ffi::c_int,
    >,
    pub ipv6_getsockopt: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            level: core::ffi::c_int,
            optname: core::ffi::c_int,
            optval: sockptr_t,
            optlen: sockptr_t,
        ) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub static mut ipv6_bpf_stub: *const ipv6_bpf_stub;
}
pub const __ND_OPT_PREFIX_INFO_END: core::ffi::c_uint = 0;
pub const ND_OPT_SOURCE_LL_ADDR: core::ffi::c_uint = 1;
pub const ND_OPT_TARGET_LL_ADDR: core::ffi::c_uint = 2;
pub const ND_OPT_PREFIX_INFO: core::ffi::c_uint = 3;
pub const ND_OPT_REDIRECT_HDR: core::ffi::c_uint = 4;
pub const ND_OPT_MTU: core::ffi::c_uint = 5;
pub const ND_OPT_NONCE: core::ffi::c_uint = 14;
pub const __ND_OPT_ARRAY_MAX: core::ffi::c_uint = 15;
pub const ND_OPT_ROUTE_INFO: core::ffi::c_uint = 24;
pub const ND_OPT_RDNSS: core::ffi::c_uint = 25;
pub const ND_OPT_DNSSL: core::ffi::c_uint = 31;
pub const ND_OPT_6CO: core::ffi::c_uint = 34;
pub const ND_OPT_CAPTIVE_PORTAL: core::ffi::c_uint = 37;
pub const ND_OPT_PREF64: core::ffi::c_uint = 38;
pub const __ND_OPT_MAX: core::ffi::c_uint = 39;
pub type _bindgen_ty_300 = core::ffi::c_uint;
pub type ip6_icmp_send_t = ::core::option::Option<
    unsafe extern "C" fn(
        skb: *mut sk_buff,
        type_: u8_,
        code: u8_,
        info: __u32,
        force_saddr: *const in6_addr,
        parm: *const inet6_skb_parm,
    ),
>;
extern "C" {
    pub fn icmp6_send(
        skb: *mut sk_buff,
        type_: u8_,
        code: u8_,
        info: __u32,
        force_saddr: *const in6_addr,
        parm: *const inet6_skb_parm,
    );
}
extern "C" {
    pub fn ip6_err_gen_icmpv6_unreach(
        skb: *mut sk_buff,
        nhs: core::ffi::c_int,
        type_: core::ffi::c_int,
        data_len: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn icmpv6_ndo_send(skb_in: *mut sk_buff, type_: u8_, code: u8_, info: __u32);
}
extern "C" {
    pub fn icmpv6_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn icmpv6_err_convert(
        type_: u8_,
        code: u8_,
        err: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn icmpv6_cleanup();
}
extern "C" {
    pub fn icmpv6_param_prob_reason(
        skb: *mut sk_buff,
        code: u8_,
        pos: core::ffi::c_int,
        reason: skb_drop_reason,
    );
}
extern "C" {
    pub fn icmpv6_flow_init(
        sk: *mut sock,
        fl6: *mut flowi6,
        type_: u8_,
        saddr: *const in6_addr,
        daddr: *const in6_addr,
        oif: core::ffi::c_int,
    );
}
extern "C" {
    pub static mut nd_tbl: neigh_table;
}
#[repr(C)]
pub struct nd_msg {
    pub icmph: icmp6hdr,
    pub target: in6_addr,
    pub opt: __IncompleteArrayField<__u8>,
}
impl Default for nd_msg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct rs_msg {
    pub icmph: icmp6hdr,
    pub opt: __IncompleteArrayField<__u8>,
}
impl Default for rs_msg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ra_msg {
    pub icmph: icmp6hdr,
    pub reachable_time: __be32,
    pub retrans_timer: __be32,
}
impl Default for ra_msg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct rd_msg {
    pub icmph: icmp6hdr,
    pub target: in6_addr,
    pub dest: in6_addr,
    pub opt: __IncompleteArrayField<__u8>,
}
impl Default for rd_msg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct nd_opt_hdr {
    pub nd_opt_type: __u8,
    pub nd_opt_len: __u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ndisc_options {
    pub nd_opt_array: [*mut nd_opt_hdr; 15usize],
    pub nd_useropts: *mut nd_opt_hdr,
    pub nd_useropts_end: *mut nd_opt_hdr,
}
impl Default for ndisc_options {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ndisc_parse_options(
        dev: *const net_device,
        opt: *mut u8_,
        opt_len: core::ffi::c_int,
        ndopts: *mut ndisc_options,
    ) -> *mut ndisc_options;
}
extern "C" {
    pub fn __ndisc_fill_addr_option(
        skb: *mut sk_buff,
        type_: core::ffi::c_int,
        data: *const core::ffi::c_void,
        data_len: core::ffi::c_int,
        pad: core::ffi::c_int,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ndisc_ops {
    pub is_useropt:
        ::core::option::Option<unsafe extern "C" fn(nd_opt_type: u8_) -> core::ffi::c_int>,
    pub parse_options: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *const net_device,
            nd_opt: *mut nd_opt_hdr,
            ndopts: *mut ndisc_options,
        ) -> core::ffi::c_int,
    >,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *const net_device,
            n: *mut neighbour,
            flags: u32_,
            icmp6_type: u8_,
            ndopts: *const ndisc_options,
        ),
    >,
    pub opt_addr_space: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *const net_device,
            icmp6_type: u8_,
            neigh: *mut neighbour,
            ha_buf: *mut u8_,
            ha: *mut *mut u8_,
        ) -> core::ffi::c_int,
    >,
    pub fill_addr_option: ::core::option::Option<
        unsafe extern "C" fn(
            dev: *const net_device,
            skb: *mut sk_buff,
            icmp6_type: u8_,
            ha: *const u8_,
        ),
    >,
    pub prefix_rcv_add_addr: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            dev: *mut net_device,
            pinfo: *const prefix_info,
            in6_dev: *mut inet6_dev,
            addr: *mut in6_addr,
            addr_type: core::ffi::c_int,
            addr_flags: u32_,
            sllao: bool_,
            tokenized: bool_,
            valid_lft: __u32,
            prefered_lft: u32_,
            dev_addr_generated: bool_,
        ),
    >,
}
extern "C" {
    pub fn ndisc_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn ndisc_late_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn ndisc_late_cleanup();
}
extern "C" {
    pub fn ndisc_cleanup();
}
extern "C" {
    pub fn ndisc_rcv(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ndisc_ns_create(
        dev: *mut net_device,
        solicit: *const in6_addr,
        saddr: *const in6_addr,
        nonce: u64_,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn ndisc_send_ns(
        dev: *mut net_device,
        solicit: *const in6_addr,
        daddr: *const in6_addr,
        saddr: *const in6_addr,
        nonce: u64_,
    );
}
extern "C" {
    pub fn ndisc_send_skb(skb: *mut sk_buff, daddr: *const in6_addr, saddr: *const in6_addr);
}
extern "C" {
    pub fn ndisc_send_rs(dev: *mut net_device, saddr: *const in6_addr, daddr: *const in6_addr);
}
extern "C" {
    pub fn ndisc_send_na(
        dev: *mut net_device,
        daddr: *const in6_addr,
        solicited_addr: *const in6_addr,
        router: bool_,
        solicited: bool_,
        override_: bool_,
        inc_opt: bool_,
    );
}
extern "C" {
    pub fn ndisc_send_redirect(skb: *mut sk_buff, target: *const in6_addr);
}
extern "C" {
    pub fn ndisc_mc_map(
        addr: *const in6_addr,
        buf: *mut core::ffi::c_char,
        dev: *mut net_device,
        dir: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ndisc_update(
        dev: *const net_device,
        neigh: *mut neighbour,
        lladdr: *const u8_,
        new: u8_,
        flags: u32_,
        icmp6_type: u8_,
        ndopts: *mut ndisc_options,
    );
}
extern "C" {
    pub fn igmp6_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn igmp6_late_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn igmp6_cleanup();
}
extern "C" {
    pub fn igmp6_late_cleanup();
}
extern "C" {
    pub fn igmp6_event_query(skb: *mut sk_buff);
}
extern "C" {
    pub fn igmp6_event_report(skb: *mut sk_buff);
}
extern "C" {
    pub fn ndisc_ifinfo_sysctl_change(
        ctl: *mut ctl_table,
        write: core::ffi::c_int,
        buffer: *mut core::ffi::c_void,
        lenp: *mut usize,
        ppos: *mut loff_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ndisc_ifinfo_sysctl_strategy(
        ctl: *mut ctl_table,
        oldval: *mut core::ffi::c_void,
        oldlenp: *mut usize,
        newval: *mut core::ffi::c_void,
        newlen: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet6_ifinfo_notify(event: core::ffi::c_int, idev: *mut inet6_dev);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtentry {
    pub rt_pad1: core::ffi::c_ulong,
    pub rt_dst: sockaddr,
    pub rt_gateway: sockaddr,
    pub rt_genmask: sockaddr,
    pub rt_flags: core::ffi::c_ushort,
    pub rt_pad2: core::ffi::c_short,
    pub rt_pad3: core::ffi::c_ulong,
    pub rt_pad4: *mut core::ffi::c_void,
    pub rt_metric: core::ffi::c_short,
    pub rt_dev: *mut core::ffi::c_char,
    pub rt_mtu: core::ffi::c_ulong,
    pub rt_window: core::ffi::c_ulong,
    pub rt_irtt: core::ffi::c_ushort,
}
impl Default for rtentry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct uncached_list {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rtable {
    pub dst: dst_entry,
    pub rt_genid: core::ffi::c_int,
    pub rt_flags: core::ffi::c_uint,
    pub rt_type: __u16,
    pub rt_is_input: __u8,
    pub rt_uses_gateway: __u8,
    pub rt_iif: core::ffi::c_int,
    pub rt_gw_family: u8_,
    pub __bindgen_anon_1: rtable__bindgen_ty_1,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub rt_uncached: list_head,
    pub rt_uncached_list: *mut uncached_list,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rtable__bindgen_ty_1 {
    pub rt_gw4: __be32,
    pub rt_gw6: in6_addr,
    _bindgen_union_align: [u32; 4usize],
}
impl Default for rtable__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for rtable {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl rtable {
    #[inline]
    pub fn rt_mtu_locked(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_rt_mtu_locked(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rt_pmtu(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_rt_pmtu(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        rt_mtu_locked: u32_,
        rt_pmtu: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rt_mtu_locked: u32 = unsafe { ::core::mem::transmute(rt_mtu_locked) };
            rt_mtu_locked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let rt_pmtu: u32 = unsafe { ::core::mem::transmute(rt_pmtu) };
            rt_pmtu as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_rt_acct {
    pub o_bytes: __u32,
    pub o_packets: __u32,
    pub i_bytes: __u32,
    pub i_packets: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rt_cache_stat {
    pub in_slow_tot: core::ffi::c_uint,
    pub in_slow_mc: core::ffi::c_uint,
    pub in_no_route: core::ffi::c_uint,
    pub in_brd: core::ffi::c_uint,
    pub in_martian_dst: core::ffi::c_uint,
    pub in_martian_src: core::ffi::c_uint,
    pub out_slow_tot: core::ffi::c_uint,
    pub out_slow_mc: core::ffi::c_uint,
}
extern "C" {
    pub static mut ip_rt_acct: *mut ip_rt_acct;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_device {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ip_rt_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_cache_flush(net: *mut net);
}
extern "C" {
    pub fn rt_flush_dev(dev: *mut net_device);
}
extern "C" {
    pub fn ip_route_output_key_hash(
        net: *mut net,
        flp: *mut flowi4,
        skb: *const sk_buff,
    ) -> *mut rtable;
}
extern "C" {
    pub fn ip_route_output_key_hash_rcu(
        net: *mut net,
        flp: *mut flowi4,
        res: *mut fib_result,
        skb: *const sk_buff,
    ) -> *mut rtable;
}
extern "C" {
    pub fn ip_route_output_flow(arg1: *mut net, flp: *mut flowi4, sk: *const sock) -> *mut rtable;
}
extern "C" {
    pub fn ip_route_output_tunnel(
        skb: *mut sk_buff,
        dev: *mut net_device,
        net: *mut net,
        saddr: *mut __be32,
        info: *const ip_tunnel_info,
        protocol: u8_,
        use_cache: bool_,
    ) -> *mut rtable;
}
extern "C" {
    pub fn ipv4_blackhole_route(net: *mut net, dst_orig: *mut dst_entry) -> *mut dst_entry;
}
extern "C" {
    pub fn ip_mc_validate_source(
        skb: *mut sk_buff,
        daddr: __be32,
        saddr: __be32,
        tos: u8_,
        dev: *mut net_device,
        in_dev: *mut in_device,
        itag: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_route_input_noref(
        skb: *mut sk_buff,
        dst: __be32,
        src: __be32,
        tos: u8_,
        devin: *mut net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_route_use_hint(
        skb: *mut sk_buff,
        dst: __be32,
        src: __be32,
        tos: u8_,
        devin: *mut net_device,
        hint: *const sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv4_update_pmtu(
        skb: *mut sk_buff,
        net: *mut net,
        mtu: u32_,
        oif: core::ffi::c_int,
        protocol: u8_,
    );
}
extern "C" {
    pub fn ipv4_sk_update_pmtu(skb: *mut sk_buff, sk: *mut sock, mtu: u32_);
}
extern "C" {
    pub fn ipv4_redirect(skb: *mut sk_buff, net: *mut net, oif: core::ffi::c_int, protocol: u8_);
}
extern "C" {
    pub fn ipv4_sk_redirect(skb: *mut sk_buff, sk: *mut sock);
}
extern "C" {
    pub fn ip_rt_send_redirect(skb: *mut sk_buff);
}
extern "C" {
    pub fn inet_addr_type(net: *mut net, addr: __be32) -> core::ffi::c_uint;
}
extern "C" {
    pub fn inet_addr_type_table(net: *mut net, addr: __be32, tb_id: u32_) -> core::ffi::c_uint;
}
extern "C" {
    pub fn inet_dev_addr_type(
        net: *mut net,
        dev: *const net_device,
        addr: __be32,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn inet_addr_type_dev_table(
        net: *mut net,
        dev: *const net_device,
        addr: __be32,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn ip_rt_multicast_event(arg1: *mut in_device);
}
extern "C" {
    pub fn ip_rt_ioctl(
        arg1: *mut net,
        cmd: core::ffi::c_uint,
        rt: *mut rtentry,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_rt_get_source(src: *mut u8_, skb: *mut sk_buff, rt: *mut rtable);
}
extern "C" {
    pub fn rt_dst_alloc(
        dev: *mut net_device,
        flags: core::ffi::c_uint,
        type_: u16_,
        noxfrm: bool_,
    ) -> *mut rtable;
}
extern "C" {
    pub fn rt_dst_clone(dev: *mut net_device, rt: *mut rtable) -> *mut rtable;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_ifaddr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn fib_add_ifaddr(arg1: *mut in_ifaddr);
}
extern "C" {
    pub fn fib_del_ifaddr(arg1: *mut in_ifaddr, arg2: *mut in_ifaddr);
}
extern "C" {
    pub fn fib_modify_prefix_metric(ifa: *mut in_ifaddr, new_metric: u32_);
}
extern "C" {
    pub fn rt_add_uncached_list(rt: *mut rtable);
}
extern "C" {
    pub fn rt_del_uncached_list(rt: *mut rtable);
}
extern "C" {
    pub fn fib_dump_info_fnhe(
        skb: *mut sk_buff,
        cb: *mut netlink_callback,
        table_id: u32_,
        fi: *mut fib_info,
        fa_index: *mut core::ffi::c_int,
        fa_start: core::ffi::c_int,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static ip_tos2prio: [__u8; 16usize];
}
pub const lwtunnel_encap_types_LWTUNNEL_ENCAP_NONE: lwtunnel_encap_types = 0;
pub const lwtunnel_encap_types_LWTUNNEL_ENCAP_MPLS: lwtunnel_encap_types = 1;
pub const lwtunnel_encap_types_LWTUNNEL_ENCAP_IP: lwtunnel_encap_types = 2;
pub const lwtunnel_encap_types_LWTUNNEL_ENCAP_ILA: lwtunnel_encap_types = 3;
pub const lwtunnel_encap_types_LWTUNNEL_ENCAP_IP6: lwtunnel_encap_types = 4;
pub const lwtunnel_encap_types_LWTUNNEL_ENCAP_SEG6: lwtunnel_encap_types = 5;
pub const lwtunnel_encap_types_LWTUNNEL_ENCAP_BPF: lwtunnel_encap_types = 6;
pub const lwtunnel_encap_types_LWTUNNEL_ENCAP_SEG6_LOCAL: lwtunnel_encap_types = 7;
pub const lwtunnel_encap_types_LWTUNNEL_ENCAP_RPL: lwtunnel_encap_types = 8;
pub const lwtunnel_encap_types_LWTUNNEL_ENCAP_IOAM6: lwtunnel_encap_types = 9;
pub const lwtunnel_encap_types_LWTUNNEL_ENCAP_XFRM: lwtunnel_encap_types = 10;
pub const lwtunnel_encap_types___LWTUNNEL_ENCAP_MAX: lwtunnel_encap_types = 11;
pub type lwtunnel_encap_types = core::ffi::c_uint;
pub const lwtunnel_ip_t_LWTUNNEL_IP_UNSPEC: lwtunnel_ip_t = 0;
pub const lwtunnel_ip_t_LWTUNNEL_IP_ID: lwtunnel_ip_t = 1;
pub const lwtunnel_ip_t_LWTUNNEL_IP_DST: lwtunnel_ip_t = 2;
pub const lwtunnel_ip_t_LWTUNNEL_IP_SRC: lwtunnel_ip_t = 3;
pub const lwtunnel_ip_t_LWTUNNEL_IP_TTL: lwtunnel_ip_t = 4;
pub const lwtunnel_ip_t_LWTUNNEL_IP_TOS: lwtunnel_ip_t = 5;
pub const lwtunnel_ip_t_LWTUNNEL_IP_FLAGS: lwtunnel_ip_t = 6;
pub const lwtunnel_ip_t_LWTUNNEL_IP_PAD: lwtunnel_ip_t = 7;
pub const lwtunnel_ip_t_LWTUNNEL_IP_OPTS: lwtunnel_ip_t = 8;
pub const lwtunnel_ip_t___LWTUNNEL_IP_MAX: lwtunnel_ip_t = 9;
pub type lwtunnel_ip_t = core::ffi::c_uint;
pub const lwtunnel_ip6_t_LWTUNNEL_IP6_UNSPEC: lwtunnel_ip6_t = 0;
pub const lwtunnel_ip6_t_LWTUNNEL_IP6_ID: lwtunnel_ip6_t = 1;
pub const lwtunnel_ip6_t_LWTUNNEL_IP6_DST: lwtunnel_ip6_t = 2;
pub const lwtunnel_ip6_t_LWTUNNEL_IP6_SRC: lwtunnel_ip6_t = 3;
pub const lwtunnel_ip6_t_LWTUNNEL_IP6_HOPLIMIT: lwtunnel_ip6_t = 4;
pub const lwtunnel_ip6_t_LWTUNNEL_IP6_TC: lwtunnel_ip6_t = 5;
pub const lwtunnel_ip6_t_LWTUNNEL_IP6_FLAGS: lwtunnel_ip6_t = 6;
pub const lwtunnel_ip6_t_LWTUNNEL_IP6_PAD: lwtunnel_ip6_t = 7;
pub const lwtunnel_ip6_t_LWTUNNEL_IP6_OPTS: lwtunnel_ip6_t = 8;
pub const lwtunnel_ip6_t___LWTUNNEL_IP6_MAX: lwtunnel_ip6_t = 9;
pub type lwtunnel_ip6_t = core::ffi::c_uint;
pub const LWTUNNEL_IP_OPTS_UNSPEC: core::ffi::c_uint = 0;
pub const LWTUNNEL_IP_OPTS_GENEVE: core::ffi::c_uint = 1;
pub const LWTUNNEL_IP_OPTS_VXLAN: core::ffi::c_uint = 2;
pub const LWTUNNEL_IP_OPTS_ERSPAN: core::ffi::c_uint = 3;
pub const __LWTUNNEL_IP_OPTS_MAX: core::ffi::c_uint = 4;
pub type _bindgen_ty_301 = core::ffi::c_uint;
pub const LWTUNNEL_IP_OPT_GENEVE_UNSPEC: core::ffi::c_uint = 0;
pub const LWTUNNEL_IP_OPT_GENEVE_CLASS: core::ffi::c_uint = 1;
pub const LWTUNNEL_IP_OPT_GENEVE_TYPE: core::ffi::c_uint = 2;
pub const LWTUNNEL_IP_OPT_GENEVE_DATA: core::ffi::c_uint = 3;
pub const __LWTUNNEL_IP_OPT_GENEVE_MAX: core::ffi::c_uint = 4;
pub type _bindgen_ty_302 = core::ffi::c_uint;
pub const LWTUNNEL_IP_OPT_VXLAN_UNSPEC: core::ffi::c_uint = 0;
pub const LWTUNNEL_IP_OPT_VXLAN_GBP: core::ffi::c_uint = 1;
pub const __LWTUNNEL_IP_OPT_VXLAN_MAX: core::ffi::c_uint = 2;
pub type _bindgen_ty_303 = core::ffi::c_uint;
pub const LWTUNNEL_IP_OPT_ERSPAN_UNSPEC: core::ffi::c_uint = 0;
pub const LWTUNNEL_IP_OPT_ERSPAN_VER: core::ffi::c_uint = 1;
pub const LWTUNNEL_IP_OPT_ERSPAN_INDEX: core::ffi::c_uint = 2;
pub const LWTUNNEL_IP_OPT_ERSPAN_DIR: core::ffi::c_uint = 3;
pub const LWTUNNEL_IP_OPT_ERSPAN_HWID: core::ffi::c_uint = 4;
pub const __LWTUNNEL_IP_OPT_ERSPAN_MAX: core::ffi::c_uint = 5;
pub type _bindgen_ty_304 = core::ffi::c_uint;
pub const LWT_BPF_PROG_UNSPEC: core::ffi::c_uint = 0;
pub const LWT_BPF_PROG_FD: core::ffi::c_uint = 1;
pub const LWT_BPF_PROG_NAME: core::ffi::c_uint = 2;
pub const __LWT_BPF_PROG_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_305 = core::ffi::c_uint;
pub const LWT_BPF_UNSPEC: core::ffi::c_uint = 0;
pub const LWT_BPF_IN: core::ffi::c_uint = 1;
pub const LWT_BPF_OUT: core::ffi::c_uint = 2;
pub const LWT_BPF_XMIT: core::ffi::c_uint = 3;
pub const LWT_BPF_XMIT_HEADROOM: core::ffi::c_uint = 4;
pub const __LWT_BPF_MAX: core::ffi::c_uint = 5;
pub type _bindgen_ty_306 = core::ffi::c_uint;
pub const LWT_XFRM_UNSPEC: core::ffi::c_uint = 0;
pub const LWT_XFRM_IF_ID: core::ffi::c_uint = 1;
pub const LWT_XFRM_LINK: core::ffi::c_uint = 2;
pub const __LWT_XFRM_MAX: core::ffi::c_uint = 3;
pub type _bindgen_ty_307 = core::ffi::c_uint;
pub const LWTUNNEL_XMIT_DONE: core::ffi::c_uint = 0;
pub const LWTUNNEL_XMIT_CONTINUE: core::ffi::c_uint = 1;
pub type _bindgen_ty_308 = core::ffi::c_uint;
#[repr(C)]
pub struct lwtunnel_state {
    pub type_: __u16,
    pub flags: __u16,
    pub headroom: __u16,
    pub refcnt: atomic_t,
    pub orig_output: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub orig_input:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut sk_buff) -> core::ffi::c_int>,
    pub rcu: callback_head,
    pub data: __IncompleteArrayField<__u8>,
}
impl Default for lwtunnel_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lwtunnel_encap_ops {
    pub build_state: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            encap: *mut nlattr,
            family: core::ffi::c_uint,
            cfg: *const core::ffi::c_void,
            ts: *mut *mut lwtunnel_state,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub destroy_state: ::core::option::Option<unsafe extern "C" fn(lws: *mut lwtunnel_state)>,
    pub output: ::core::option::Option<
        unsafe extern "C" fn(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub input: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff) -> core::ffi::c_int>,
    pub fill_encap: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, lwtstate: *mut lwtunnel_state) -> core::ffi::c_int,
    >,
    pub get_encap_size: ::core::option::Option<
        unsafe extern "C" fn(lwtstate: *mut lwtunnel_state) -> core::ffi::c_int,
    >,
    pub cmp_encap: ::core::option::Option<
        unsafe extern "C" fn(a: *mut lwtunnel_state, b: *mut lwtunnel_state) -> core::ffi::c_int,
    >,
    pub xmit: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff) -> core::ffi::c_int>,
    pub owner: *mut module,
}
impl Default for lwtunnel_encap_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut sysctl_fib_sync_mem: core::ffi::c_uint;
}
extern "C" {
    pub static mut sysctl_fib_sync_mem_min: core::ffi::c_uint;
}
extern "C" {
    pub static mut sysctl_fib_sync_mem_max: core::ffi::c_uint;
}
#[repr(C)]
#[derive(Default)]
pub struct inet_skb_parm {
    pub iif: core::ffi::c_int,
    pub opt: ip_options,
    pub flags: u16_,
    pub frag_max_size: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipcm_cookie {
    pub sockc: sockcm_cookie,
    pub addr: __be32,
    pub oif: core::ffi::c_int,
    pub opt: *mut ip_options_rcu,
    pub ttl: __u8,
    pub tos: __s16,
    pub priority: core::ffi::c_char,
    pub gso_size: __u16,
}
impl Default for ipcm_cookie {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_ra_chain {
    pub next: *mut ip_ra_chain,
    pub sk: *mut sock,
    pub __bindgen_anon_1: ip_ra_chain__bindgen_ty_1,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_ra_chain__bindgen_ty_1 {
    pub destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    pub saved_sk: *mut sock,
    _bindgen_union_align: u64,
}
impl Default for ip_ra_chain__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for ip_ra_chain {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn igmp_mc_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_build_and_send_pkt(
        skb: *mut sk_buff,
        sk: *const sock,
        saddr: __be32,
        daddr: __be32,
        opt: *mut ip_options_rcu,
        tos: u8_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_rcv(
        skb: *mut sk_buff,
        dev: *mut net_device,
        pt: *mut packet_type,
        orig_dev: *mut net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_list_rcv(head: *mut list_head, pt: *mut packet_type, orig_dev: *mut net_device);
}
extern "C" {
    pub fn ip_local_deliver(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_protocol_deliver_rcu(net: *mut net, skb: *mut sk_buff, proto: core::ffi::c_int);
}
extern "C" {
    pub fn ip_mr_input(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_output(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_mc_output(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_do_fragment(
        net: *mut net,
        sk: *mut sock,
        skb: *mut sk_buff,
        output: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                arg2: *mut sock,
                arg3: *mut sk_buff,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_fraglist_iter {
    pub frag: *mut sk_buff,
    pub iph: *mut iphdr,
    pub offset: core::ffi::c_int,
    pub hlen: core::ffi::c_uint,
}
impl Default for ip_fraglist_iter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ip_fraglist_init(
        skb: *mut sk_buff,
        iph: *mut iphdr,
        hlen: core::ffi::c_uint,
        iter: *mut ip_fraglist_iter,
    );
}
extern "C" {
    pub fn ip_fraglist_prepare(skb: *mut sk_buff, iter: *mut ip_fraglist_iter);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ip_frag_state {
    pub DF: bool_,
    pub hlen: core::ffi::c_uint,
    pub ll_rs: core::ffi::c_uint,
    pub mtu: core::ffi::c_uint,
    pub left: core::ffi::c_uint,
    pub offset: core::ffi::c_int,
    pub ptr: core::ffi::c_int,
    pub not_last_frag: __be16,
}
extern "C" {
    pub fn ip_frag_init(
        skb: *mut sk_buff,
        hlen: core::ffi::c_uint,
        ll_rs: core::ffi::c_uint,
        mtu: core::ffi::c_uint,
        DF: bool_,
        state: *mut ip_frag_state,
    );
}
extern "C" {
    pub fn ip_frag_next(skb: *mut sk_buff, state: *mut ip_frag_state) -> *mut sk_buff;
}
extern "C" {
    pub fn ip_send_check(ip: *mut iphdr);
}
extern "C" {
    pub fn __ip_local_out(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_local_out(net: *mut net, sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn __ip_queue_xmit(
        sk: *mut sock,
        skb: *mut sk_buff,
        fl: *mut flowi,
        tos: __u8,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_init();
}
extern "C" {
    pub fn ip_append_data(
        sk: *mut sock,
        fl4: *mut flowi4,
        getfrag: ::core::option::Option<
            unsafe extern "C" fn(
                from: *mut core::ffi::c_void,
                to: *mut core::ffi::c_char,
                offset: core::ffi::c_int,
                len: core::ffi::c_int,
                odd: core::ffi::c_int,
                skb: *mut sk_buff,
            ) -> core::ffi::c_int,
        >,
        from: *mut core::ffi::c_void,
        len: core::ffi::c_int,
        protolen: core::ffi::c_int,
        ipc: *mut ipcm_cookie,
        rt: *mut *mut rtable,
        flags: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_generic_getfrag(
        from: *mut core::ffi::c_void,
        to: *mut core::ffi::c_char,
        offset: core::ffi::c_int,
        len: core::ffi::c_int,
        odd: core::ffi::c_int,
        skb: *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_append_page(
        sk: *mut sock,
        fl4: *mut flowi4,
        page: *mut page,
        offset: core::ffi::c_int,
        size: usize,
        flags: core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn __ip_make_skb(
        sk: *mut sock,
        fl4: *mut flowi4,
        queue: *mut sk_buff_head,
        cork: *mut inet_cork,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn ip_send_skb(net: *mut net, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_push_pending_frames(sk: *mut sock, fl4: *mut flowi4) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_flush_pending_frames(sk: *mut sock);
}
extern "C" {
    pub fn ip_make_skb(
        sk: *mut sock,
        fl4: *mut flowi4,
        getfrag: ::core::option::Option<
            unsafe extern "C" fn(
                from: *mut core::ffi::c_void,
                to: *mut core::ffi::c_char,
                offset: core::ffi::c_int,
                len: core::ffi::c_int,
                odd: core::ffi::c_int,
                skb: *mut sk_buff,
            ) -> core::ffi::c_int,
        >,
        from: *mut core::ffi::c_void,
        length: core::ffi::c_int,
        transhdrlen: core::ffi::c_int,
        ipc: *mut ipcm_cookie,
        rtp: *mut *mut rtable,
        cork: *mut inet_cork,
        flags: core::ffi::c_uint,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn ip_queue_xmit(sk: *mut sock, skb: *mut sk_buff, fl: *mut flowi) -> core::ffi::c_int;
}
extern "C" {
    pub fn __ip4_datagram_connect(
        sk: *mut sock,
        uaddr: *mut sockaddr,
        addr_len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip4_datagram_connect(
        sk: *mut sock,
        uaddr: *mut sockaddr,
        addr_len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip4_datagram_release_cb(sk: *mut sock);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_reply_arg {
    pub iov: [kvec; 1usize],
    pub flags: core::ffi::c_int,
    pub csum: __wsum,
    pub csumoffset: core::ffi::c_int,
    pub bound_dev_if: core::ffi::c_int,
    pub tos: u8_,
    pub uid: kuid_t,
}
impl Default for ip_reply_arg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn ip_send_unicast_reply(
        sk: *mut sock,
        skb: *mut sk_buff,
        sopt: *const ip_options,
        daddr: __be32,
        saddr: __be32,
        arg: *const ip_reply_arg,
        len: core::ffi::c_uint,
        transmit_time: u64_,
    );
}
extern "C" {
    pub fn snmp_fold_field(
        mib: *mut core::ffi::c_void,
        offt: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn inet_get_local_port_range(
        net: *mut net,
        low: *mut core::ffi::c_int,
        high: *mut core::ffi::c_int,
    );
}
extern "C" {
    pub fn inet_current_timestamp() -> __be32;
}
extern "C" {
    pub static mut inet_peer_threshold: core::ffi::c_int;
}
extern "C" {
    pub static mut inet_peer_minttl: core::ffi::c_int;
}
extern "C" {
    pub static mut inet_peer_maxttl: core::ffi::c_int;
}
extern "C" {
    pub fn ipfrag_init();
}
extern "C" {
    pub fn ip_static_sysctl_init();
}
extern "C" {
    pub fn ip_fib_metrics_init(
        net: *mut net,
        fc_mx: *mut nlattr,
        fc_mx_len: core::ffi::c_int,
        extack: *mut netlink_ext_ack,
    ) -> *mut dst_metrics;
}
extern "C" {
    pub fn __ip_select_ident(net: *mut net, iph: *mut iphdr, segs: core::ffi::c_int);
}
extern "C" {
    pub fn ip_call_ra_chain(skb: *mut sk_buff) -> bool_;
}
pub const ip_defrag_users_IP_DEFRAG_LOCAL_DELIVER: ip_defrag_users = 0;
pub const ip_defrag_users_IP_DEFRAG_CALL_RA_CHAIN: ip_defrag_users = 1;
pub const ip_defrag_users_IP_DEFRAG_CONNTRACK_IN: ip_defrag_users = 2;
pub const ip_defrag_users___IP_DEFRAG_CONNTRACK_IN_END: ip_defrag_users = 65537;
pub const ip_defrag_users_IP_DEFRAG_CONNTRACK_OUT: ip_defrag_users = 65538;
pub const ip_defrag_users___IP_DEFRAG_CONNTRACK_OUT_END: ip_defrag_users = 131073;
pub const ip_defrag_users_IP_DEFRAG_CONNTRACK_BRIDGE_IN: ip_defrag_users = 131074;
pub const ip_defrag_users___IP_DEFRAG_CONNTRACK_BRIDGE_IN: ip_defrag_users = 196609;
pub const ip_defrag_users_IP_DEFRAG_VS_IN: ip_defrag_users = 196610;
pub const ip_defrag_users_IP_DEFRAG_VS_OUT: ip_defrag_users = 196611;
pub const ip_defrag_users_IP_DEFRAG_VS_FWD: ip_defrag_users = 196612;
pub const ip_defrag_users_IP_DEFRAG_AF_PACKET: ip_defrag_users = 196613;
pub const ip_defrag_users_IP_DEFRAG_MACVLAN: ip_defrag_users = 196614;
pub type ip_defrag_users = core::ffi::c_uint;
extern "C" {
    pub fn ip_defrag(net: *mut net, skb: *mut sk_buff, user: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_check_defrag(net: *mut net, skb: *mut sk_buff, user: u32_) -> *mut sk_buff;
}
extern "C" {
    pub fn ip_forward(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_options_build(
        skb: *mut sk_buff,
        opt: *mut ip_options,
        daddr: __be32,
        rt: *mut rtable,
    );
}
extern "C" {
    pub fn __ip_options_echo(
        net: *mut net,
        dopt: *mut ip_options,
        skb: *mut sk_buff,
        sopt: *const ip_options,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_options_fragment(skb: *mut sk_buff);
}
extern "C" {
    pub fn __ip_options_compile(
        net: *mut net,
        opt: *mut ip_options,
        skb: *mut sk_buff,
        info: *mut __be32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_options_compile(
        net: *mut net,
        opt: *mut ip_options,
        skb: *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_options_get(
        net: *mut net,
        optp: *mut *mut ip_options_rcu,
        data: sockptr_t,
        optlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_options_undo(opt: *mut ip_options);
}
extern "C" {
    pub fn ip_forward_options(skb: *mut sk_buff);
}
extern "C" {
    pub fn ip_options_rcv_srr(skb: *mut sk_buff, dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv4_pktinfo_prepare(sk: *const sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn ip_cmsg_recv_offset(
        msg: *mut msghdr,
        sk: *mut sock,
        skb: *mut sk_buff,
        tlen: core::ffi::c_int,
        offset: core::ffi::c_int,
    );
}
extern "C" {
    pub fn ip_cmsg_send(
        sk: *mut sock,
        msg: *mut msghdr,
        ipc: *mut ipcm_cookie,
        allow_ipv6: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut ip4_min_ttl: static_key_false;
}
extern "C" {
    pub fn do_ip_setsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_setsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_ip_getsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: sockptr_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_getsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: *mut core::ffi::c_char,
        optlen: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_ra_control(
        sk: *mut sock,
        on: core::ffi::c_uchar,
        destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut sock)>,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_recv_error(
        sk: *mut sock,
        msg: *mut msghdr,
        len: core::ffi::c_int,
        addr_len: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_icmp_error(
        sk: *mut sock,
        skb: *mut sk_buff,
        err: core::ffi::c_int,
        port: __be16,
        info: u32_,
        payload: *mut u8_,
    );
}
extern "C" {
    pub fn ip_local_error(
        sk: *mut sock,
        err: core::ffi::c_int,
        daddr: __be32,
        dport: __be16,
        info: u32_,
    );
}
extern "C" {
    pub fn icmp_global_allow() -> bool_;
}
extern "C" {
    pub static mut sysctl_icmp_msgs_per_sec: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_icmp_msgs_burst: core::ffi::c_int;
}
extern "C" {
    pub fn ip_misc_proc_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn rtm_getroute_parse_ip_proto(
        attr: *mut nlattr,
        ip_proto: *mut u8_,
        family: u8_,
        extack: *mut netlink_ext_ack,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_sock_set_freebind(sk: *mut sock);
}
extern "C" {
    pub fn ip_sock_set_mtu_discover(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip_sock_set_pktinfo(sk: *mut sock);
}
extern "C" {
    pub fn ip_sock_set_recverr(sk: *mut sock);
}
extern "C" {
    pub fn ip_sock_set_tos(sk: *mut sock, val: core::ffi::c_int);
}
extern "C" {
    pub fn __ip_sock_set_tos(sk: *mut sock, val: core::ffi::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_ehash_bucket {
    pub chain: hlist_nulls_head,
}
impl Default for inet_ehash_bucket {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_bind_bucket {
    pub ib_net: possible_net_t,
    pub l3mdev: core::ffi::c_int,
    pub port: core::ffi::c_ushort,
    pub fastreuse: core::ffi::c_schar,
    pub fastreuseport: core::ffi::c_schar,
    pub fastuid: kuid_t,
    pub fast_v6_rcv_saddr: in6_addr,
    pub fast_rcv_saddr: __be32,
    pub fast_sk_family: core::ffi::c_ushort,
    pub fast_ipv6_only: bool_,
    pub node: hlist_node,
    pub owners: hlist_head,
}
impl Default for inet_bind_bucket {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_bind2_bucket {
    pub ib_net: possible_net_t,
    pub l3mdev: core::ffi::c_int,
    pub port: core::ffi::c_ushort,
    pub family: core::ffi::c_ushort,
    pub __bindgen_anon_1: inet_bind2_bucket__bindgen_ty_1,
    pub node: hlist_node,
    pub owners: hlist_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union inet_bind2_bucket__bindgen_ty_1 {
    pub v6_rcv_saddr: in6_addr,
    pub rcv_saddr: __be32,
    _bindgen_union_align: [u32; 4usize],
}
impl Default for inet_bind2_bucket__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for inet_bind2_bucket {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_bind_hashbucket {
    pub lock: spinlock_t,
    pub chain: hlist_head,
}
impl Default for inet_bind_hashbucket {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_listen_hashbucket {
    pub lock: spinlock_t,
    pub nulls_head: hlist_nulls_head,
}
impl Default for inet_listen_hashbucket {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_hashinfo {
    pub ehash: *mut inet_ehash_bucket,
    pub ehash_locks: *mut spinlock_t,
    pub ehash_mask: core::ffi::c_uint,
    pub ehash_locks_mask: core::ffi::c_uint,
    pub bind_bucket_cachep: *mut kmem_cache,
    pub bhash: *mut inet_bind_hashbucket,
    pub bind2_bucket_cachep: *mut kmem_cache,
    pub bhash2: *mut inet_bind_hashbucket,
    pub bhash_size: core::ffi::c_uint,
    pub lhash2_mask: core::ffi::c_uint,
    pub lhash2: *mut inet_listen_hashbucket,
    pub pernet: bool_,
}
impl Default for inet_hashinfo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn inet_ehash_locks_alloc(hashinfo: *mut inet_hashinfo) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_pernet_hashinfo_alloc(
        hashinfo: *mut inet_hashinfo,
        ehash_entries: core::ffi::c_uint,
    ) -> *mut inet_hashinfo;
}
extern "C" {
    pub fn inet_pernet_hashinfo_free(hashinfo: *mut inet_hashinfo);
}
extern "C" {
    pub fn inet_bind_bucket_create(
        cachep: *mut kmem_cache,
        net: *mut net,
        head: *mut inet_bind_hashbucket,
        snum: core::ffi::c_ushort,
        l3mdev: core::ffi::c_int,
    ) -> *mut inet_bind_bucket;
}
extern "C" {
    pub fn inet_bind_bucket_destroy(cachep: *mut kmem_cache, tb: *mut inet_bind_bucket);
}
extern "C" {
    pub fn inet_bind_bucket_match(
        tb: *const inet_bind_bucket,
        net: *const net,
        port: core::ffi::c_ushort,
        l3mdev: core::ffi::c_int,
    ) -> bool_;
}
extern "C" {
    pub fn inet_bind2_bucket_create(
        cachep: *mut kmem_cache,
        net: *mut net,
        head: *mut inet_bind_hashbucket,
        port: core::ffi::c_ushort,
        l3mdev: core::ffi::c_int,
        sk: *const sock,
    ) -> *mut inet_bind2_bucket;
}
extern "C" {
    pub fn inet_bind2_bucket_destroy(cachep: *mut kmem_cache, tb: *mut inet_bind2_bucket);
}
extern "C" {
    pub fn inet_bind2_bucket_find(
        head: *const inet_bind_hashbucket,
        net: *const net,
        port: core::ffi::c_ushort,
        l3mdev: core::ffi::c_int,
        sk: *const sock,
    ) -> *mut inet_bind2_bucket;
}
extern "C" {
    pub fn inet_bind2_bucket_match_addr_any(
        tb: *const inet_bind2_bucket,
        net: *const net,
        port: core::ffi::c_ushort,
        l3mdev: core::ffi::c_int,
        sk: *const sock,
    ) -> bool_;
}
extern "C" {
    pub fn inet_bhash2_addr_any_hashbucket(
        sk: *const sock,
        net: *const net,
        port: core::ffi::c_int,
    ) -> *mut inet_bind_hashbucket;
}
extern "C" {
    pub fn inet_bhash2_update_saddr(
        prev_saddr: *mut inet_bind_hashbucket,
        sk: *mut sock,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_bind_hash(
        sk: *mut sock,
        tb: *mut inet_bind_bucket,
        tb2: *mut inet_bind2_bucket,
        port: core::ffi::c_ushort,
    );
}
extern "C" {
    pub fn __inet_inherit_port(sk: *const sock, child: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_put_port(sk: *mut sock);
}
extern "C" {
    pub fn inet_hashinfo2_init(
        h: *mut inet_hashinfo,
        name: *const core::ffi::c_char,
        numentries: core::ffi::c_ulong,
        scale: core::ffi::c_int,
        low_limit: core::ffi::c_ulong,
        high_limit: core::ffi::c_ulong,
    );
}
extern "C" {
    pub fn inet_hashinfo2_init_mod(h: *mut inet_hashinfo) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_ehash_insert(sk: *mut sock, osk: *mut sock, found_dup_sk: *mut bool_) -> bool_;
}
extern "C" {
    pub fn inet_ehash_nolisten(sk: *mut sock, osk: *mut sock, found_dup_sk: *mut bool_) -> bool_;
}
extern "C" {
    pub fn __inet_hash(sk: *mut sock, osk: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_hash(sk: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_unhash(sk: *mut sock);
}
extern "C" {
    pub fn __inet_lookup_listener(
        net: *mut net,
        hashinfo: *mut inet_hashinfo,
        skb: *mut sk_buff,
        doff: core::ffi::c_int,
        saddr: __be32,
        sport: __be16,
        daddr: __be32,
        hnum: core::ffi::c_ushort,
        dif: core::ffi::c_int,
        sdif: core::ffi::c_int,
    ) -> *mut sock;
}
extern "C" {
    pub fn __inet_lookup_established(
        net: *mut net,
        hashinfo: *mut inet_hashinfo,
        saddr: __be32,
        sport: __be16,
        daddr: __be32,
        hnum: u16_,
        dif: core::ffi::c_int,
        sdif: core::ffi::c_int,
    ) -> *mut sock;
}
extern "C" {
    pub fn inet6_ehashfn(
        net: *const net,
        laddr: *const in6_addr,
        lport: u16_,
        faddr: *const in6_addr,
        fport: __be16,
    ) -> u32_;
}
extern "C" {
    pub fn __inet_hash_connect(
        death_row: *mut inet_timewait_death_row,
        sk: *mut sock,
        port_offset: u64_,
        check_established: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut inet_timewait_death_row,
                arg2: *mut sock,
                arg3: __u16,
                arg4: *mut *mut inet_timewait_sock,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_hash_connect(
        death_row: *mut inet_timewait_death_row,
        sk: *mut sock,
    ) -> core::ffi::c_int;
}
pub const BPF_REG_0: core::ffi::c_uint = 0;
pub const BPF_REG_1: core::ffi::c_uint = 1;
pub const BPF_REG_2: core::ffi::c_uint = 2;
pub const BPF_REG_3: core::ffi::c_uint = 3;
pub const BPF_REG_4: core::ffi::c_uint = 4;
pub const BPF_REG_5: core::ffi::c_uint = 5;
pub const BPF_REG_6: core::ffi::c_uint = 6;
pub const BPF_REG_7: core::ffi::c_uint = 7;
pub const BPF_REG_8: core::ffi::c_uint = 8;
pub const BPF_REG_9: core::ffi::c_uint = 9;
pub const BPF_REG_10: core::ffi::c_uint = 10;
pub const __MAX_BPF_REG: core::ffi::c_uint = 11;
pub type _bindgen_ty_309 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_insn {
    pub code: __u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub off: __s16,
    pub imm: __s32,
}
impl bpf_insn {
    #[inline]
    pub fn dst_reg(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_dst_reg(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn src_reg(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_src_reg(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(dst_reg: __u8, src_reg: __u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let dst_reg: u8 = unsafe { ::core::mem::transmute(dst_reg) };
            dst_reg as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let src_reg: u8 = unsafe { ::core::mem::transmute(src_reg) };
            src_reg as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default)]
pub struct bpf_lpm_trie_key {
    pub prefixlen: __u32,
    pub data: __IncompleteArrayField<__u8>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_cgroup_storage_key {
    pub cgroup_inode_id: __u64,
    pub attach_type: __u32,
}
pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_ORDER_UNSPEC: bpf_cgroup_iter_order = 0;
pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_SELF_ONLY: bpf_cgroup_iter_order = 1;
pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_DESCENDANTS_PRE: bpf_cgroup_iter_order = 2;
pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_DESCENDANTS_POST: bpf_cgroup_iter_order = 3;
pub const bpf_cgroup_iter_order_BPF_CGROUP_ITER_ANCESTORS_UP: bpf_cgroup_iter_order = 4;
pub type bpf_cgroup_iter_order = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter_link_info {
    pub map: bpf_iter_link_info__bindgen_ty_1,
    pub cgroup: bpf_iter_link_info__bindgen_ty_2,
    pub task: bpf_iter_link_info__bindgen_ty_3,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_iter_link_info__bindgen_ty_1 {
    pub map_fd: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_link_info__bindgen_ty_2 {
    pub order: bpf_cgroup_iter_order,
    pub cgroup_fd: __u32,
    pub cgroup_id: __u64,
}
impl Default for bpf_iter_link_info__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_iter_link_info__bindgen_ty_3 {
    pub tid: __u32,
    pub pid: __u32,
    pub pid_fd: __u32,
}
impl Default for bpf_iter_link_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const bpf_cmd_BPF_MAP_CREATE: bpf_cmd = 0;
pub const bpf_cmd_BPF_MAP_LOOKUP_ELEM: bpf_cmd = 1;
pub const bpf_cmd_BPF_MAP_UPDATE_ELEM: bpf_cmd = 2;
pub const bpf_cmd_BPF_MAP_DELETE_ELEM: bpf_cmd = 3;
pub const bpf_cmd_BPF_MAP_GET_NEXT_KEY: bpf_cmd = 4;
pub const bpf_cmd_BPF_PROG_LOAD: bpf_cmd = 5;
pub const bpf_cmd_BPF_OBJ_PIN: bpf_cmd = 6;
pub const bpf_cmd_BPF_OBJ_GET: bpf_cmd = 7;
pub const bpf_cmd_BPF_PROG_ATTACH: bpf_cmd = 8;
pub const bpf_cmd_BPF_PROG_DETACH: bpf_cmd = 9;
pub const bpf_cmd_BPF_PROG_TEST_RUN: bpf_cmd = 10;
pub const bpf_cmd_BPF_PROG_RUN: bpf_cmd = 10;
pub const bpf_cmd_BPF_PROG_GET_NEXT_ID: bpf_cmd = 11;
pub const bpf_cmd_BPF_MAP_GET_NEXT_ID: bpf_cmd = 12;
pub const bpf_cmd_BPF_PROG_GET_FD_BY_ID: bpf_cmd = 13;
pub const bpf_cmd_BPF_MAP_GET_FD_BY_ID: bpf_cmd = 14;
pub const bpf_cmd_BPF_OBJ_GET_INFO_BY_FD: bpf_cmd = 15;
pub const bpf_cmd_BPF_PROG_QUERY: bpf_cmd = 16;
pub const bpf_cmd_BPF_RAW_TRACEPOINT_OPEN: bpf_cmd = 17;
pub const bpf_cmd_BPF_BTF_LOAD: bpf_cmd = 18;
pub const bpf_cmd_BPF_BTF_GET_FD_BY_ID: bpf_cmd = 19;
pub const bpf_cmd_BPF_TASK_FD_QUERY: bpf_cmd = 20;
pub const bpf_cmd_BPF_MAP_LOOKUP_AND_DELETE_ELEM: bpf_cmd = 21;
pub const bpf_cmd_BPF_MAP_FREEZE: bpf_cmd = 22;
pub const bpf_cmd_BPF_BTF_GET_NEXT_ID: bpf_cmd = 23;
pub const bpf_cmd_BPF_MAP_LOOKUP_BATCH: bpf_cmd = 24;
pub const bpf_cmd_BPF_MAP_LOOKUP_AND_DELETE_BATCH: bpf_cmd = 25;
pub const bpf_cmd_BPF_MAP_UPDATE_BATCH: bpf_cmd = 26;
pub const bpf_cmd_BPF_MAP_DELETE_BATCH: bpf_cmd = 27;
pub const bpf_cmd_BPF_LINK_CREATE: bpf_cmd = 28;
pub const bpf_cmd_BPF_LINK_UPDATE: bpf_cmd = 29;
pub const bpf_cmd_BPF_LINK_GET_FD_BY_ID: bpf_cmd = 30;
pub const bpf_cmd_BPF_LINK_GET_NEXT_ID: bpf_cmd = 31;
pub const bpf_cmd_BPF_ENABLE_STATS: bpf_cmd = 32;
pub const bpf_cmd_BPF_ITER_CREATE: bpf_cmd = 33;
pub const bpf_cmd_BPF_LINK_DETACH: bpf_cmd = 34;
pub const bpf_cmd_BPF_PROG_BIND_MAP: bpf_cmd = 35;
pub type bpf_cmd = core::ffi::c_uint;
pub const bpf_map_type_BPF_MAP_TYPE_UNSPEC: bpf_map_type = 0;
pub const bpf_map_type_BPF_MAP_TYPE_HASH: bpf_map_type = 1;
pub const bpf_map_type_BPF_MAP_TYPE_ARRAY: bpf_map_type = 2;
pub const bpf_map_type_BPF_MAP_TYPE_PROG_ARRAY: bpf_map_type = 3;
pub const bpf_map_type_BPF_MAP_TYPE_PERF_EVENT_ARRAY: bpf_map_type = 4;
pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_HASH: bpf_map_type = 5;
pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_ARRAY: bpf_map_type = 6;
pub const bpf_map_type_BPF_MAP_TYPE_STACK_TRACE: bpf_map_type = 7;
pub const bpf_map_type_BPF_MAP_TYPE_CGROUP_ARRAY: bpf_map_type = 8;
pub const bpf_map_type_BPF_MAP_TYPE_LRU_HASH: bpf_map_type = 9;
pub const bpf_map_type_BPF_MAP_TYPE_LRU_PERCPU_HASH: bpf_map_type = 10;
pub const bpf_map_type_BPF_MAP_TYPE_LPM_TRIE: bpf_map_type = 11;
pub const bpf_map_type_BPF_MAP_TYPE_ARRAY_OF_MAPS: bpf_map_type = 12;
pub const bpf_map_type_BPF_MAP_TYPE_HASH_OF_MAPS: bpf_map_type = 13;
pub const bpf_map_type_BPF_MAP_TYPE_DEVMAP: bpf_map_type = 14;
pub const bpf_map_type_BPF_MAP_TYPE_SOCKMAP: bpf_map_type = 15;
pub const bpf_map_type_BPF_MAP_TYPE_CPUMAP: bpf_map_type = 16;
pub const bpf_map_type_BPF_MAP_TYPE_XSKMAP: bpf_map_type = 17;
pub const bpf_map_type_BPF_MAP_TYPE_SOCKHASH: bpf_map_type = 18;
pub const bpf_map_type_BPF_MAP_TYPE_CGROUP_STORAGE: bpf_map_type = 19;
pub const bpf_map_type_BPF_MAP_TYPE_REUSEPORT_SOCKARRAY: bpf_map_type = 20;
pub const bpf_map_type_BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE: bpf_map_type = 21;
pub const bpf_map_type_BPF_MAP_TYPE_QUEUE: bpf_map_type = 22;
pub const bpf_map_type_BPF_MAP_TYPE_STACK: bpf_map_type = 23;
pub const bpf_map_type_BPF_MAP_TYPE_SK_STORAGE: bpf_map_type = 24;
pub const bpf_map_type_BPF_MAP_TYPE_DEVMAP_HASH: bpf_map_type = 25;
pub const bpf_map_type_BPF_MAP_TYPE_STRUCT_OPS: bpf_map_type = 26;
pub const bpf_map_type_BPF_MAP_TYPE_RINGBUF: bpf_map_type = 27;
pub const bpf_map_type_BPF_MAP_TYPE_INODE_STORAGE: bpf_map_type = 28;
pub const bpf_map_type_BPF_MAP_TYPE_TASK_STORAGE: bpf_map_type = 29;
pub const bpf_map_type_BPF_MAP_TYPE_BLOOM_FILTER: bpf_map_type = 30;
pub const bpf_map_type_BPF_MAP_TYPE_USER_RINGBUF: bpf_map_type = 31;
pub type bpf_map_type = core::ffi::c_uint;
pub const bpf_prog_type_BPF_PROG_TYPE_UNSPEC: bpf_prog_type = 0;
pub const bpf_prog_type_BPF_PROG_TYPE_SOCKET_FILTER: bpf_prog_type = 1;
pub const bpf_prog_type_BPF_PROG_TYPE_KPROBE: bpf_prog_type = 2;
pub const bpf_prog_type_BPF_PROG_TYPE_SCHED_CLS: bpf_prog_type = 3;
pub const bpf_prog_type_BPF_PROG_TYPE_SCHED_ACT: bpf_prog_type = 4;
pub const bpf_prog_type_BPF_PROG_TYPE_TRACEPOINT: bpf_prog_type = 5;
pub const bpf_prog_type_BPF_PROG_TYPE_XDP: bpf_prog_type = 6;
pub const bpf_prog_type_BPF_PROG_TYPE_PERF_EVENT: bpf_prog_type = 7;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SKB: bpf_prog_type = 8;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCK: bpf_prog_type = 9;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_IN: bpf_prog_type = 10;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_OUT: bpf_prog_type = 11;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_XMIT: bpf_prog_type = 12;
pub const bpf_prog_type_BPF_PROG_TYPE_SOCK_OPS: bpf_prog_type = 13;
pub const bpf_prog_type_BPF_PROG_TYPE_SK_SKB: bpf_prog_type = 14;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_DEVICE: bpf_prog_type = 15;
pub const bpf_prog_type_BPF_PROG_TYPE_SK_MSG: bpf_prog_type = 16;
pub const bpf_prog_type_BPF_PROG_TYPE_RAW_TRACEPOINT: bpf_prog_type = 17;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCK_ADDR: bpf_prog_type = 18;
pub const bpf_prog_type_BPF_PROG_TYPE_LWT_SEG6LOCAL: bpf_prog_type = 19;
pub const bpf_prog_type_BPF_PROG_TYPE_LIRC_MODE2: bpf_prog_type = 20;
pub const bpf_prog_type_BPF_PROG_TYPE_SK_REUSEPORT: bpf_prog_type = 21;
pub const bpf_prog_type_BPF_PROG_TYPE_FLOW_DISSECTOR: bpf_prog_type = 22;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SYSCTL: bpf_prog_type = 23;
pub const bpf_prog_type_BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE: bpf_prog_type = 24;
pub const bpf_prog_type_BPF_PROG_TYPE_CGROUP_SOCKOPT: bpf_prog_type = 25;
pub const bpf_prog_type_BPF_PROG_TYPE_TRACING: bpf_prog_type = 26;
pub const bpf_prog_type_BPF_PROG_TYPE_STRUCT_OPS: bpf_prog_type = 27;
pub const bpf_prog_type_BPF_PROG_TYPE_EXT: bpf_prog_type = 28;
pub const bpf_prog_type_BPF_PROG_TYPE_LSM: bpf_prog_type = 29;
pub const bpf_prog_type_BPF_PROG_TYPE_SK_LOOKUP: bpf_prog_type = 30;
pub const bpf_prog_type_BPF_PROG_TYPE_SYSCALL: bpf_prog_type = 31;
pub type bpf_prog_type = core::ffi::c_uint;
pub const bpf_attach_type_BPF_CGROUP_INET_INGRESS: bpf_attach_type = 0;
pub const bpf_attach_type_BPF_CGROUP_INET_EGRESS: bpf_attach_type = 1;
pub const bpf_attach_type_BPF_CGROUP_INET_SOCK_CREATE: bpf_attach_type = 2;
pub const bpf_attach_type_BPF_CGROUP_SOCK_OPS: bpf_attach_type = 3;
pub const bpf_attach_type_BPF_SK_SKB_STREAM_PARSER: bpf_attach_type = 4;
pub const bpf_attach_type_BPF_SK_SKB_STREAM_VERDICT: bpf_attach_type = 5;
pub const bpf_attach_type_BPF_CGROUP_DEVICE: bpf_attach_type = 6;
pub const bpf_attach_type_BPF_SK_MSG_VERDICT: bpf_attach_type = 7;
pub const bpf_attach_type_BPF_CGROUP_INET4_BIND: bpf_attach_type = 8;
pub const bpf_attach_type_BPF_CGROUP_INET6_BIND: bpf_attach_type = 9;
pub const bpf_attach_type_BPF_CGROUP_INET4_CONNECT: bpf_attach_type = 10;
pub const bpf_attach_type_BPF_CGROUP_INET6_CONNECT: bpf_attach_type = 11;
pub const bpf_attach_type_BPF_CGROUP_INET4_POST_BIND: bpf_attach_type = 12;
pub const bpf_attach_type_BPF_CGROUP_INET6_POST_BIND: bpf_attach_type = 13;
pub const bpf_attach_type_BPF_CGROUP_UDP4_SENDMSG: bpf_attach_type = 14;
pub const bpf_attach_type_BPF_CGROUP_UDP6_SENDMSG: bpf_attach_type = 15;
pub const bpf_attach_type_BPF_LIRC_MODE2: bpf_attach_type = 16;
pub const bpf_attach_type_BPF_FLOW_DISSECTOR: bpf_attach_type = 17;
pub const bpf_attach_type_BPF_CGROUP_SYSCTL: bpf_attach_type = 18;
pub const bpf_attach_type_BPF_CGROUP_UDP4_RECVMSG: bpf_attach_type = 19;
pub const bpf_attach_type_BPF_CGROUP_UDP6_RECVMSG: bpf_attach_type = 20;
pub const bpf_attach_type_BPF_CGROUP_GETSOCKOPT: bpf_attach_type = 21;
pub const bpf_attach_type_BPF_CGROUP_SETSOCKOPT: bpf_attach_type = 22;
pub const bpf_attach_type_BPF_TRACE_RAW_TP: bpf_attach_type = 23;
pub const bpf_attach_type_BPF_TRACE_FENTRY: bpf_attach_type = 24;
pub const bpf_attach_type_BPF_TRACE_FEXIT: bpf_attach_type = 25;
pub const bpf_attach_type_BPF_MODIFY_RETURN: bpf_attach_type = 26;
pub const bpf_attach_type_BPF_LSM_MAC: bpf_attach_type = 27;
pub const bpf_attach_type_BPF_TRACE_ITER: bpf_attach_type = 28;
pub const bpf_attach_type_BPF_CGROUP_INET4_GETPEERNAME: bpf_attach_type = 29;
pub const bpf_attach_type_BPF_CGROUP_INET6_GETPEERNAME: bpf_attach_type = 30;
pub const bpf_attach_type_BPF_CGROUP_INET4_GETSOCKNAME: bpf_attach_type = 31;
pub const bpf_attach_type_BPF_CGROUP_INET6_GETSOCKNAME: bpf_attach_type = 32;
pub const bpf_attach_type_BPF_XDP_DEVMAP: bpf_attach_type = 33;
pub const bpf_attach_type_BPF_CGROUP_INET_SOCK_RELEASE: bpf_attach_type = 34;
pub const bpf_attach_type_BPF_XDP_CPUMAP: bpf_attach_type = 35;
pub const bpf_attach_type_BPF_SK_LOOKUP: bpf_attach_type = 36;
pub const bpf_attach_type_BPF_XDP: bpf_attach_type = 37;
pub const bpf_attach_type_BPF_SK_SKB_VERDICT: bpf_attach_type = 38;
pub const bpf_attach_type_BPF_SK_REUSEPORT_SELECT: bpf_attach_type = 39;
pub const bpf_attach_type_BPF_SK_REUSEPORT_SELECT_OR_MIGRATE: bpf_attach_type = 40;
pub const bpf_attach_type_BPF_PERF_EVENT: bpf_attach_type = 41;
pub const bpf_attach_type_BPF_TRACE_KPROBE_MULTI: bpf_attach_type = 42;
pub const bpf_attach_type_BPF_LSM_CGROUP: bpf_attach_type = 43;
pub const bpf_attach_type___MAX_BPF_ATTACH_TYPE: bpf_attach_type = 44;
pub type bpf_attach_type = core::ffi::c_uint;
pub const bpf_link_type_BPF_LINK_TYPE_UNSPEC: bpf_link_type = 0;
pub const bpf_link_type_BPF_LINK_TYPE_RAW_TRACEPOINT: bpf_link_type = 1;
pub const bpf_link_type_BPF_LINK_TYPE_TRACING: bpf_link_type = 2;
pub const bpf_link_type_BPF_LINK_TYPE_CGROUP: bpf_link_type = 3;
pub const bpf_link_type_BPF_LINK_TYPE_ITER: bpf_link_type = 4;
pub const bpf_link_type_BPF_LINK_TYPE_NETNS: bpf_link_type = 5;
pub const bpf_link_type_BPF_LINK_TYPE_XDP: bpf_link_type = 6;
pub const bpf_link_type_BPF_LINK_TYPE_PERF_EVENT: bpf_link_type = 7;
pub const bpf_link_type_BPF_LINK_TYPE_KPROBE_MULTI: bpf_link_type = 8;
pub const bpf_link_type_BPF_LINK_TYPE_STRUCT_OPS: bpf_link_type = 9;
pub const bpf_link_type_MAX_BPF_LINK_TYPE: bpf_link_type = 10;
pub type bpf_link_type = core::ffi::c_uint;
pub const BPF_ANY: core::ffi::c_uint = 0;
pub const BPF_NOEXIST: core::ffi::c_uint = 1;
pub const BPF_EXIST: core::ffi::c_uint = 2;
pub const BPF_F_LOCK: core::ffi::c_uint = 4;
pub type _bindgen_ty_310 = core::ffi::c_uint;
pub const BPF_F_NO_PREALLOC: core::ffi::c_uint = 1;
pub const BPF_F_NO_COMMON_LRU: core::ffi::c_uint = 2;
pub const BPF_F_NUMA_NODE: core::ffi::c_uint = 4;
pub const BPF_F_RDONLY: core::ffi::c_uint = 8;
pub const BPF_F_WRONLY: core::ffi::c_uint = 16;
pub const BPF_F_STACK_BUILD_ID: core::ffi::c_uint = 32;
pub const BPF_F_ZERO_SEED: core::ffi::c_uint = 64;
pub const BPF_F_RDONLY_PROG: core::ffi::c_uint = 128;
pub const BPF_F_WRONLY_PROG: core::ffi::c_uint = 256;
pub const BPF_F_CLONE: core::ffi::c_uint = 512;
pub const BPF_F_MMAPABLE: core::ffi::c_uint = 1024;
pub const BPF_F_PRESERVE_ELEMS: core::ffi::c_uint = 2048;
pub const BPF_F_INNER_MAP: core::ffi::c_uint = 4096;
pub type _bindgen_ty_311 = core::ffi::c_uint;
pub const bpf_stats_type_BPF_STATS_RUN_TIME: bpf_stats_type = 0;
pub type bpf_stats_type = core::ffi::c_uint;
pub const bpf_stack_build_id_status_BPF_STACK_BUILD_ID_EMPTY: bpf_stack_build_id_status = 0;
pub const bpf_stack_build_id_status_BPF_STACK_BUILD_ID_VALID: bpf_stack_build_id_status = 1;
pub const bpf_stack_build_id_status_BPF_STACK_BUILD_ID_IP: bpf_stack_build_id_status = 2;
pub type bpf_stack_build_id_status = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_stack_build_id {
    pub status: __s32,
    pub build_id: [core::ffi::c_uchar; 20usize],
    pub __bindgen_anon_1: bpf_stack_build_id__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_stack_build_id__bindgen_ty_1 {
    pub offset: __u64,
    pub ip: __u64,
    _bindgen_union_align: u64,
}
impl Default for bpf_stack_build_id__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_stack_build_id {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_2,
    pub batch: bpf_attr__bindgen_ty_3,
    pub __bindgen_anon_3: bpf_attr__bindgen_ty_4,
    pub __bindgen_anon_4: bpf_attr__bindgen_ty_5,
    pub __bindgen_anon_5: bpf_attr__bindgen_ty_6,
    pub test: bpf_attr__bindgen_ty_7,
    pub __bindgen_anon_6: bpf_attr__bindgen_ty_8,
    pub info: bpf_attr__bindgen_ty_9,
    pub query: bpf_attr__bindgen_ty_10,
    pub raw_tracepoint: bpf_attr__bindgen_ty_11,
    pub __bindgen_anon_7: bpf_attr__bindgen_ty_12,
    pub task_fd_query: bpf_attr__bindgen_ty_13,
    pub link_create: bpf_attr__bindgen_ty_14,
    pub link_update: bpf_attr__bindgen_ty_15,
    pub link_detach: bpf_attr__bindgen_ty_16,
    pub enable_stats: bpf_attr__bindgen_ty_17,
    pub iter_create: bpf_attr__bindgen_ty_18,
    pub prog_bind_map: bpf_attr__bindgen_ty_19,
    _bindgen_union_align: [u64; 18usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_1 {
    pub map_type: __u32,
    pub key_size: __u32,
    pub value_size: __u32,
    pub max_entries: __u32,
    pub map_flags: __u32,
    pub inner_map_fd: __u32,
    pub numa_node: __u32,
    pub map_name: [core::ffi::c_char; 16usize],
    pub map_ifindex: __u32,
    pub btf_fd: __u32,
    pub btf_key_type_id: __u32,
    pub btf_value_type_id: __u32,
    pub btf_vmlinux_value_type_id: __u32,
    pub map_extra: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_2 {
    pub map_fd: __u32,
    pub key: __u64,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_2__bindgen_ty_1,
    pub flags: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    pub value: __u64,
    pub next_key: __u64,
    _bindgen_union_align: u64,
}
impl Default for bpf_attr__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_attr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_3 {
    pub in_batch: __u64,
    pub out_batch: __u64,
    pub keys: __u64,
    pub values: __u64,
    pub count: __u32,
    pub map_fd: __u32,
    pub elem_flags: __u64,
    pub flags: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_4 {
    pub prog_type: __u32,
    pub insn_cnt: __u32,
    pub insns: __u64,
    pub license: __u64,
    pub log_level: __u32,
    pub log_size: __u32,
    pub log_buf: __u64,
    pub kern_version: __u32,
    pub prog_flags: __u32,
    pub prog_name: [core::ffi::c_char; 16usize],
    pub prog_ifindex: __u32,
    pub expected_attach_type: __u32,
    pub prog_btf_fd: __u32,
    pub func_info_rec_size: __u32,
    pub func_info: __u64,
    pub func_info_cnt: __u32,
    pub line_info_rec_size: __u32,
    pub line_info: __u64,
    pub line_info_cnt: __u32,
    pub attach_btf_id: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_4__bindgen_ty_1,
    pub core_relo_cnt: __u32,
    pub fd_array: __u64,
    pub core_relos: __u64,
    pub core_relo_rec_size: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_4__bindgen_ty_1 {
    pub attach_prog_fd: __u32,
    pub attach_btf_obj_fd: __u32,
    _bindgen_union_align: u32,
}
impl Default for bpf_attr__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_attr__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_5 {
    pub pathname: __u64,
    pub bpf_fd: __u32,
    pub file_flags: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_6 {
    pub target_fd: __u32,
    pub attach_bpf_fd: __u32,
    pub attach_type: __u32,
    pub attach_flags: __u32,
    pub replace_bpf_fd: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_7 {
    pub prog_fd: __u32,
    pub retval: __u32,
    pub data_size_in: __u32,
    pub data_size_out: __u32,
    pub data_in: __u64,
    pub data_out: __u64,
    pub repeat: __u32,
    pub duration: __u32,
    pub ctx_size_in: __u32,
    pub ctx_size_out: __u32,
    pub ctx_in: __u64,
    pub ctx_out: __u64,
    pub flags: __u32,
    pub cpu: __u32,
    pub batch_size: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_8 {
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_8__bindgen_ty_1,
    pub next_id: __u32,
    pub open_flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_8__bindgen_ty_1 {
    pub start_id: __u32,
    pub prog_id: __u32,
    pub map_id: __u32,
    pub btf_id: __u32,
    pub link_id: __u32,
    _bindgen_union_align: u32,
}
impl Default for bpf_attr__bindgen_ty_8__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_attr__bindgen_ty_8 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_9 {
    pub bpf_fd: __u32,
    pub info_len: __u32,
    pub info: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_10 {
    pub target_fd: __u32,
    pub attach_type: __u32,
    pub query_flags: __u32,
    pub attach_flags: __u32,
    pub prog_ids: __u64,
    pub prog_cnt: __u32,
    pub prog_attach_flags: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_11 {
    pub name: __u64,
    pub prog_fd: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_12 {
    pub btf: __u64,
    pub btf_log_buf: __u64,
    pub btf_size: __u32,
    pub btf_log_size: __u32,
    pub btf_log_level: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_13 {
    pub pid: __u32,
    pub fd: __u32,
    pub flags: __u32,
    pub buf_len: __u32,
    pub buf: __u64,
    pub prog_id: __u32,
    pub fd_type: __u32,
    pub probe_offset: __u64,
    pub probe_addr: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14 {
    pub prog_fd: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_1,
    pub attach_type: __u32,
    pub flags: __u32,
    pub __bindgen_anon_2: bpf_attr__bindgen_ty_14__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_1 {
    pub target_fd: __u32,
    pub target_ifindex: __u32,
    _bindgen_union_align: u32,
}
impl Default for bpf_attr__bindgen_ty_14__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_attr__bindgen_ty_14__bindgen_ty_2 {
    pub target_btf_id: __u32,
    pub __bindgen_anon_1: bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1,
    pub perf_event: bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_2,
    pub kprobe_multi: bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_3,
    pub tracing: bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_4,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_1 {
    pub iter_info: __u64,
    pub iter_info_len: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_2 {
    pub bpf_cookie: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_3 {
    pub flags: __u32,
    pub cnt: __u32,
    pub syms: __u64,
    pub addrs: __u64,
    pub cookies: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_14__bindgen_ty_2__bindgen_ty_4 {
    pub target_btf_id: __u32,
    pub cookie: __u64,
}
impl Default for bpf_attr__bindgen_ty_14__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_attr__bindgen_ty_14 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_15 {
    pub link_fd: __u32,
    pub new_prog_fd: __u32,
    pub flags: __u32,
    pub old_prog_fd: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_16 {
    pub link_fd: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_17 {
    pub type_: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_18 {
    pub link_fd: __u32,
    pub flags: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_attr__bindgen_ty_19 {
    pub prog_fd: __u32,
    pub map_fd: __u32,
    pub flags: __u32,
}
impl Default for bpf_attr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const bpf_func_id_BPF_FUNC_unspec: bpf_func_id = 0;
pub const bpf_func_id_BPF_FUNC_map_lookup_elem: bpf_func_id = 1;
pub const bpf_func_id_BPF_FUNC_map_update_elem: bpf_func_id = 2;
pub const bpf_func_id_BPF_FUNC_map_delete_elem: bpf_func_id = 3;
pub const bpf_func_id_BPF_FUNC_probe_read: bpf_func_id = 4;
pub const bpf_func_id_BPF_FUNC_ktime_get_ns: bpf_func_id = 5;
pub const bpf_func_id_BPF_FUNC_trace_printk: bpf_func_id = 6;
pub const bpf_func_id_BPF_FUNC_get_prandom_u32: bpf_func_id = 7;
pub const bpf_func_id_BPF_FUNC_get_smp_processor_id: bpf_func_id = 8;
pub const bpf_func_id_BPF_FUNC_skb_store_bytes: bpf_func_id = 9;
pub const bpf_func_id_BPF_FUNC_l3_csum_replace: bpf_func_id = 10;
pub const bpf_func_id_BPF_FUNC_l4_csum_replace: bpf_func_id = 11;
pub const bpf_func_id_BPF_FUNC_tail_call: bpf_func_id = 12;
pub const bpf_func_id_BPF_FUNC_clone_redirect: bpf_func_id = 13;
pub const bpf_func_id_BPF_FUNC_get_current_pid_tgid: bpf_func_id = 14;
pub const bpf_func_id_BPF_FUNC_get_current_uid_gid: bpf_func_id = 15;
pub const bpf_func_id_BPF_FUNC_get_current_comm: bpf_func_id = 16;
pub const bpf_func_id_BPF_FUNC_get_cgroup_classid: bpf_func_id = 17;
pub const bpf_func_id_BPF_FUNC_skb_vlan_push: bpf_func_id = 18;
pub const bpf_func_id_BPF_FUNC_skb_vlan_pop: bpf_func_id = 19;
pub const bpf_func_id_BPF_FUNC_skb_get_tunnel_key: bpf_func_id = 20;
pub const bpf_func_id_BPF_FUNC_skb_set_tunnel_key: bpf_func_id = 21;
pub const bpf_func_id_BPF_FUNC_perf_event_read: bpf_func_id = 22;
pub const bpf_func_id_BPF_FUNC_redirect: bpf_func_id = 23;
pub const bpf_func_id_BPF_FUNC_get_route_realm: bpf_func_id = 24;
pub const bpf_func_id_BPF_FUNC_perf_event_output: bpf_func_id = 25;
pub const bpf_func_id_BPF_FUNC_skb_load_bytes: bpf_func_id = 26;
pub const bpf_func_id_BPF_FUNC_get_stackid: bpf_func_id = 27;
pub const bpf_func_id_BPF_FUNC_csum_diff: bpf_func_id = 28;
pub const bpf_func_id_BPF_FUNC_skb_get_tunnel_opt: bpf_func_id = 29;
pub const bpf_func_id_BPF_FUNC_skb_set_tunnel_opt: bpf_func_id = 30;
pub const bpf_func_id_BPF_FUNC_skb_change_proto: bpf_func_id = 31;
pub const bpf_func_id_BPF_FUNC_skb_change_type: bpf_func_id = 32;
pub const bpf_func_id_BPF_FUNC_skb_under_cgroup: bpf_func_id = 33;
pub const bpf_func_id_BPF_FUNC_get_hash_recalc: bpf_func_id = 34;
pub const bpf_func_id_BPF_FUNC_get_current_task: bpf_func_id = 35;
pub const bpf_func_id_BPF_FUNC_probe_write_user: bpf_func_id = 36;
pub const bpf_func_id_BPF_FUNC_current_task_under_cgroup: bpf_func_id = 37;
pub const bpf_func_id_BPF_FUNC_skb_change_tail: bpf_func_id = 38;
pub const bpf_func_id_BPF_FUNC_skb_pull_data: bpf_func_id = 39;
pub const bpf_func_id_BPF_FUNC_csum_update: bpf_func_id = 40;
pub const bpf_func_id_BPF_FUNC_set_hash_invalid: bpf_func_id = 41;
pub const bpf_func_id_BPF_FUNC_get_numa_node_id: bpf_func_id = 42;
pub const bpf_func_id_BPF_FUNC_skb_change_head: bpf_func_id = 43;
pub const bpf_func_id_BPF_FUNC_xdp_adjust_head: bpf_func_id = 44;
pub const bpf_func_id_BPF_FUNC_probe_read_str: bpf_func_id = 45;
pub const bpf_func_id_BPF_FUNC_get_socket_cookie: bpf_func_id = 46;
pub const bpf_func_id_BPF_FUNC_get_socket_uid: bpf_func_id = 47;
pub const bpf_func_id_BPF_FUNC_set_hash: bpf_func_id = 48;
pub const bpf_func_id_BPF_FUNC_setsockopt: bpf_func_id = 49;
pub const bpf_func_id_BPF_FUNC_skb_adjust_room: bpf_func_id = 50;
pub const bpf_func_id_BPF_FUNC_redirect_map: bpf_func_id = 51;
pub const bpf_func_id_BPF_FUNC_sk_redirect_map: bpf_func_id = 52;
pub const bpf_func_id_BPF_FUNC_sock_map_update: bpf_func_id = 53;
pub const bpf_func_id_BPF_FUNC_xdp_adjust_meta: bpf_func_id = 54;
pub const bpf_func_id_BPF_FUNC_perf_event_read_value: bpf_func_id = 55;
pub const bpf_func_id_BPF_FUNC_perf_prog_read_value: bpf_func_id = 56;
pub const bpf_func_id_BPF_FUNC_getsockopt: bpf_func_id = 57;
pub const bpf_func_id_BPF_FUNC_override_return: bpf_func_id = 58;
pub const bpf_func_id_BPF_FUNC_sock_ops_cb_flags_set: bpf_func_id = 59;
pub const bpf_func_id_BPF_FUNC_msg_redirect_map: bpf_func_id = 60;
pub const bpf_func_id_BPF_FUNC_msg_apply_bytes: bpf_func_id = 61;
pub const bpf_func_id_BPF_FUNC_msg_cork_bytes: bpf_func_id = 62;
pub const bpf_func_id_BPF_FUNC_msg_pull_data: bpf_func_id = 63;
pub const bpf_func_id_BPF_FUNC_bind: bpf_func_id = 64;
pub const bpf_func_id_BPF_FUNC_xdp_adjust_tail: bpf_func_id = 65;
pub const bpf_func_id_BPF_FUNC_skb_get_xfrm_state: bpf_func_id = 66;
pub const bpf_func_id_BPF_FUNC_get_stack: bpf_func_id = 67;
pub const bpf_func_id_BPF_FUNC_skb_load_bytes_relative: bpf_func_id = 68;
pub const bpf_func_id_BPF_FUNC_fib_lookup: bpf_func_id = 69;
pub const bpf_func_id_BPF_FUNC_sock_hash_update: bpf_func_id = 70;
pub const bpf_func_id_BPF_FUNC_msg_redirect_hash: bpf_func_id = 71;
pub const bpf_func_id_BPF_FUNC_sk_redirect_hash: bpf_func_id = 72;
pub const bpf_func_id_BPF_FUNC_lwt_push_encap: bpf_func_id = 73;
pub const bpf_func_id_BPF_FUNC_lwt_seg6_store_bytes: bpf_func_id = 74;
pub const bpf_func_id_BPF_FUNC_lwt_seg6_adjust_srh: bpf_func_id = 75;
pub const bpf_func_id_BPF_FUNC_lwt_seg6_action: bpf_func_id = 76;
pub const bpf_func_id_BPF_FUNC_rc_repeat: bpf_func_id = 77;
pub const bpf_func_id_BPF_FUNC_rc_keydown: bpf_func_id = 78;
pub const bpf_func_id_BPF_FUNC_skb_cgroup_id: bpf_func_id = 79;
pub const bpf_func_id_BPF_FUNC_get_current_cgroup_id: bpf_func_id = 80;
pub const bpf_func_id_BPF_FUNC_get_local_storage: bpf_func_id = 81;
pub const bpf_func_id_BPF_FUNC_sk_select_reuseport: bpf_func_id = 82;
pub const bpf_func_id_BPF_FUNC_skb_ancestor_cgroup_id: bpf_func_id = 83;
pub const bpf_func_id_BPF_FUNC_sk_lookup_tcp: bpf_func_id = 84;
pub const bpf_func_id_BPF_FUNC_sk_lookup_udp: bpf_func_id = 85;
pub const bpf_func_id_BPF_FUNC_sk_release: bpf_func_id = 86;
pub const bpf_func_id_BPF_FUNC_map_push_elem: bpf_func_id = 87;
pub const bpf_func_id_BPF_FUNC_map_pop_elem: bpf_func_id = 88;
pub const bpf_func_id_BPF_FUNC_map_peek_elem: bpf_func_id = 89;
pub const bpf_func_id_BPF_FUNC_msg_push_data: bpf_func_id = 90;
pub const bpf_func_id_BPF_FUNC_msg_pop_data: bpf_func_id = 91;
pub const bpf_func_id_BPF_FUNC_rc_pointer_rel: bpf_func_id = 92;
pub const bpf_func_id_BPF_FUNC_spin_lock: bpf_func_id = 93;
pub const bpf_func_id_BPF_FUNC_spin_unlock: bpf_func_id = 94;
pub const bpf_func_id_BPF_FUNC_sk_fullsock: bpf_func_id = 95;
pub const bpf_func_id_BPF_FUNC_tcp_sock: bpf_func_id = 96;
pub const bpf_func_id_BPF_FUNC_skb_ecn_set_ce: bpf_func_id = 97;
pub const bpf_func_id_BPF_FUNC_get_listener_sock: bpf_func_id = 98;
pub const bpf_func_id_BPF_FUNC_skc_lookup_tcp: bpf_func_id = 99;
pub const bpf_func_id_BPF_FUNC_tcp_check_syncookie: bpf_func_id = 100;
pub const bpf_func_id_BPF_FUNC_sysctl_get_name: bpf_func_id = 101;
pub const bpf_func_id_BPF_FUNC_sysctl_get_current_value: bpf_func_id = 102;
pub const bpf_func_id_BPF_FUNC_sysctl_get_new_value: bpf_func_id = 103;
pub const bpf_func_id_BPF_FUNC_sysctl_set_new_value: bpf_func_id = 104;
pub const bpf_func_id_BPF_FUNC_strtol: bpf_func_id = 105;
pub const bpf_func_id_BPF_FUNC_strtoul: bpf_func_id = 106;
pub const bpf_func_id_BPF_FUNC_sk_storage_get: bpf_func_id = 107;
pub const bpf_func_id_BPF_FUNC_sk_storage_delete: bpf_func_id = 108;
pub const bpf_func_id_BPF_FUNC_send_signal: bpf_func_id = 109;
pub const bpf_func_id_BPF_FUNC_tcp_gen_syncookie: bpf_func_id = 110;
pub const bpf_func_id_BPF_FUNC_skb_output: bpf_func_id = 111;
pub const bpf_func_id_BPF_FUNC_probe_read_user: bpf_func_id = 112;
pub const bpf_func_id_BPF_FUNC_probe_read_kernel: bpf_func_id = 113;
pub const bpf_func_id_BPF_FUNC_probe_read_user_str: bpf_func_id = 114;
pub const bpf_func_id_BPF_FUNC_probe_read_kernel_str: bpf_func_id = 115;
pub const bpf_func_id_BPF_FUNC_tcp_send_ack: bpf_func_id = 116;
pub const bpf_func_id_BPF_FUNC_send_signal_thread: bpf_func_id = 117;
pub const bpf_func_id_BPF_FUNC_jiffies64: bpf_func_id = 118;
pub const bpf_func_id_BPF_FUNC_read_branch_records: bpf_func_id = 119;
pub const bpf_func_id_BPF_FUNC_get_ns_current_pid_tgid: bpf_func_id = 120;
pub const bpf_func_id_BPF_FUNC_xdp_output: bpf_func_id = 121;
pub const bpf_func_id_BPF_FUNC_get_netns_cookie: bpf_func_id = 122;
pub const bpf_func_id_BPF_FUNC_get_current_ancestor_cgroup_id: bpf_func_id = 123;
pub const bpf_func_id_BPF_FUNC_sk_assign: bpf_func_id = 124;
pub const bpf_func_id_BPF_FUNC_ktime_get_boot_ns: bpf_func_id = 125;
pub const bpf_func_id_BPF_FUNC_seq_printf: bpf_func_id = 126;
pub const bpf_func_id_BPF_FUNC_seq_write: bpf_func_id = 127;
pub const bpf_func_id_BPF_FUNC_sk_cgroup_id: bpf_func_id = 128;
pub const bpf_func_id_BPF_FUNC_sk_ancestor_cgroup_id: bpf_func_id = 129;
pub const bpf_func_id_BPF_FUNC_ringbuf_output: bpf_func_id = 130;
pub const bpf_func_id_BPF_FUNC_ringbuf_reserve: bpf_func_id = 131;
pub const bpf_func_id_BPF_FUNC_ringbuf_submit: bpf_func_id = 132;
pub const bpf_func_id_BPF_FUNC_ringbuf_discard: bpf_func_id = 133;
pub const bpf_func_id_BPF_FUNC_ringbuf_query: bpf_func_id = 134;
pub const bpf_func_id_BPF_FUNC_csum_level: bpf_func_id = 135;
pub const bpf_func_id_BPF_FUNC_skc_to_tcp6_sock: bpf_func_id = 136;
pub const bpf_func_id_BPF_FUNC_skc_to_tcp_sock: bpf_func_id = 137;
pub const bpf_func_id_BPF_FUNC_skc_to_tcp_timewait_sock: bpf_func_id = 138;
pub const bpf_func_id_BPF_FUNC_skc_to_tcp_request_sock: bpf_func_id = 139;
pub const bpf_func_id_BPF_FUNC_skc_to_udp6_sock: bpf_func_id = 140;
pub const bpf_func_id_BPF_FUNC_get_task_stack: bpf_func_id = 141;
pub const bpf_func_id_BPF_FUNC_load_hdr_opt: bpf_func_id = 142;
pub const bpf_func_id_BPF_FUNC_store_hdr_opt: bpf_func_id = 143;
pub const bpf_func_id_BPF_FUNC_reserve_hdr_opt: bpf_func_id = 144;
pub const bpf_func_id_BPF_FUNC_inode_storage_get: bpf_func_id = 145;
pub const bpf_func_id_BPF_FUNC_inode_storage_delete: bpf_func_id = 146;
pub const bpf_func_id_BPF_FUNC_d_path: bpf_func_id = 147;
pub const bpf_func_id_BPF_FUNC_copy_from_user: bpf_func_id = 148;
pub const bpf_func_id_BPF_FUNC_snprintf_btf: bpf_func_id = 149;
pub const bpf_func_id_BPF_FUNC_seq_printf_btf: bpf_func_id = 150;
pub const bpf_func_id_BPF_FUNC_skb_cgroup_classid: bpf_func_id = 151;
pub const bpf_func_id_BPF_FUNC_redirect_neigh: bpf_func_id = 152;
pub const bpf_func_id_BPF_FUNC_per_cpu_ptr: bpf_func_id = 153;
pub const bpf_func_id_BPF_FUNC_this_cpu_ptr: bpf_func_id = 154;
pub const bpf_func_id_BPF_FUNC_redirect_peer: bpf_func_id = 155;
pub const bpf_func_id_BPF_FUNC_task_storage_get: bpf_func_id = 156;
pub const bpf_func_id_BPF_FUNC_task_storage_delete: bpf_func_id = 157;
pub const bpf_func_id_BPF_FUNC_get_current_task_btf: bpf_func_id = 158;
pub const bpf_func_id_BPF_FUNC_bprm_opts_set: bpf_func_id = 159;
pub const bpf_func_id_BPF_FUNC_ktime_get_coarse_ns: bpf_func_id = 160;
pub const bpf_func_id_BPF_FUNC_ima_inode_hash: bpf_func_id = 161;
pub const bpf_func_id_BPF_FUNC_sock_from_file: bpf_func_id = 162;
pub const bpf_func_id_BPF_FUNC_check_mtu: bpf_func_id = 163;
pub const bpf_func_id_BPF_FUNC_for_each_map_elem: bpf_func_id = 164;
pub const bpf_func_id_BPF_FUNC_snprintf: bpf_func_id = 165;
pub const bpf_func_id_BPF_FUNC_sys_bpf: bpf_func_id = 166;
pub const bpf_func_id_BPF_FUNC_btf_find_by_name_kind: bpf_func_id = 167;
pub const bpf_func_id_BPF_FUNC_sys_close: bpf_func_id = 168;
pub const bpf_func_id_BPF_FUNC_timer_init: bpf_func_id = 169;
pub const bpf_func_id_BPF_FUNC_timer_set_callback: bpf_func_id = 170;
pub const bpf_func_id_BPF_FUNC_timer_start: bpf_func_id = 171;
pub const bpf_func_id_BPF_FUNC_timer_cancel: bpf_func_id = 172;
pub const bpf_func_id_BPF_FUNC_get_func_ip: bpf_func_id = 173;
pub const bpf_func_id_BPF_FUNC_get_attach_cookie: bpf_func_id = 174;
pub const bpf_func_id_BPF_FUNC_task_pt_regs: bpf_func_id = 175;
pub const bpf_func_id_BPF_FUNC_get_branch_snapshot: bpf_func_id = 176;
pub const bpf_func_id_BPF_FUNC_trace_vprintk: bpf_func_id = 177;
pub const bpf_func_id_BPF_FUNC_skc_to_unix_sock: bpf_func_id = 178;
pub const bpf_func_id_BPF_FUNC_kallsyms_lookup_name: bpf_func_id = 179;
pub const bpf_func_id_BPF_FUNC_find_vma: bpf_func_id = 180;
pub const bpf_func_id_BPF_FUNC_loop: bpf_func_id = 181;
pub const bpf_func_id_BPF_FUNC_strncmp: bpf_func_id = 182;
pub const bpf_func_id_BPF_FUNC_get_func_arg: bpf_func_id = 183;
pub const bpf_func_id_BPF_FUNC_get_func_ret: bpf_func_id = 184;
pub const bpf_func_id_BPF_FUNC_get_func_arg_cnt: bpf_func_id = 185;
pub const bpf_func_id_BPF_FUNC_get_retval: bpf_func_id = 186;
pub const bpf_func_id_BPF_FUNC_set_retval: bpf_func_id = 187;
pub const bpf_func_id_BPF_FUNC_xdp_get_buff_len: bpf_func_id = 188;
pub const bpf_func_id_BPF_FUNC_xdp_load_bytes: bpf_func_id = 189;
pub const bpf_func_id_BPF_FUNC_xdp_store_bytes: bpf_func_id = 190;
pub const bpf_func_id_BPF_FUNC_copy_from_user_task: bpf_func_id = 191;
pub const bpf_func_id_BPF_FUNC_skb_set_tstamp: bpf_func_id = 192;
pub const bpf_func_id_BPF_FUNC_ima_file_hash: bpf_func_id = 193;
pub const bpf_func_id_BPF_FUNC_kptr_xchg: bpf_func_id = 194;
pub const bpf_func_id_BPF_FUNC_map_lookup_percpu_elem: bpf_func_id = 195;
pub const bpf_func_id_BPF_FUNC_skc_to_mptcp_sock: bpf_func_id = 196;
pub const bpf_func_id_BPF_FUNC_dynptr_from_mem: bpf_func_id = 197;
pub const bpf_func_id_BPF_FUNC_ringbuf_reserve_dynptr: bpf_func_id = 198;
pub const bpf_func_id_BPF_FUNC_ringbuf_submit_dynptr: bpf_func_id = 199;
pub const bpf_func_id_BPF_FUNC_ringbuf_discard_dynptr: bpf_func_id = 200;
pub const bpf_func_id_BPF_FUNC_dynptr_read: bpf_func_id = 201;
pub const bpf_func_id_BPF_FUNC_dynptr_write: bpf_func_id = 202;
pub const bpf_func_id_BPF_FUNC_dynptr_data: bpf_func_id = 203;
pub const bpf_func_id_BPF_FUNC_tcp_raw_gen_syncookie_ipv4: bpf_func_id = 204;
pub const bpf_func_id_BPF_FUNC_tcp_raw_gen_syncookie_ipv6: bpf_func_id = 205;
pub const bpf_func_id_BPF_FUNC_tcp_raw_check_syncookie_ipv4: bpf_func_id = 206;
pub const bpf_func_id_BPF_FUNC_tcp_raw_check_syncookie_ipv6: bpf_func_id = 207;
pub const bpf_func_id_BPF_FUNC_ktime_get_tai_ns: bpf_func_id = 208;
pub const bpf_func_id_BPF_FUNC_user_ringbuf_drain: bpf_func_id = 209;
pub const bpf_func_id___BPF_FUNC_MAX_ID: bpf_func_id = 210;
pub type bpf_func_id = core::ffi::c_uint;
pub const BPF_F_RECOMPUTE_CSUM: core::ffi::c_uint = 1;
pub const BPF_F_INVALIDATE_HASH: core::ffi::c_uint = 2;
pub type _bindgen_ty_312 = core::ffi::c_uint;
pub const BPF_F_HDR_FIELD_MASK: core::ffi::c_uint = 15;
pub type _bindgen_ty_313 = core::ffi::c_uint;
pub const BPF_F_PSEUDO_HDR: core::ffi::c_uint = 16;
pub const BPF_F_MARK_MANGLED_0: core::ffi::c_uint = 32;
pub const BPF_F_MARK_ENFORCE: core::ffi::c_uint = 64;
pub type _bindgen_ty_314 = core::ffi::c_uint;
pub const BPF_F_INGRESS: core::ffi::c_uint = 1;
pub type _bindgen_ty_315 = core::ffi::c_uint;
pub const BPF_F_TUNINFO_IPV6: core::ffi::c_uint = 1;
pub type _bindgen_ty_316 = core::ffi::c_uint;
pub const BPF_F_SKIP_FIELD_MASK: core::ffi::c_uint = 255;
pub const BPF_F_USER_STACK: core::ffi::c_uint = 256;
pub const BPF_F_FAST_STACK_CMP: core::ffi::c_uint = 512;
pub const BPF_F_REUSE_STACKID: core::ffi::c_uint = 1024;
pub const BPF_F_USER_BUILD_ID: core::ffi::c_uint = 2048;
pub type _bindgen_ty_317 = core::ffi::c_uint;
pub const BPF_F_ZERO_CSUM_TX: core::ffi::c_uint = 2;
pub const BPF_F_DONT_FRAGMENT: core::ffi::c_uint = 4;
pub const BPF_F_SEQ_NUMBER: core::ffi::c_uint = 8;
pub type _bindgen_ty_318 = core::ffi::c_uint;
pub const BPF_F_TUNINFO_FLAGS: core::ffi::c_uint = 16;
pub type _bindgen_ty_319 = core::ffi::c_uint;
pub const BPF_F_INDEX_MASK: core::ffi::c_ulong = 4294967295;
pub const BPF_F_CURRENT_CPU: core::ffi::c_ulong = 4294967295;
pub const BPF_F_CTXLEN_MASK: core::ffi::c_ulong = 4503595332403200;
pub type _bindgen_ty_320 = core::ffi::c_ulong;
pub const BPF_F_CURRENT_NETNS: core::ffi::c_int = -1;
pub type _bindgen_ty_321 = core::ffi::c_int;
pub const BPF_CSUM_LEVEL_QUERY: core::ffi::c_uint = 0;
pub const BPF_CSUM_LEVEL_INC: core::ffi::c_uint = 1;
pub const BPF_CSUM_LEVEL_DEC: core::ffi::c_uint = 2;
pub const BPF_CSUM_LEVEL_RESET: core::ffi::c_uint = 3;
pub type _bindgen_ty_322 = core::ffi::c_uint;
pub const BPF_F_ADJ_ROOM_FIXED_GSO: core::ffi::c_uint = 1;
pub const BPF_F_ADJ_ROOM_ENCAP_L3_IPV4: core::ffi::c_uint = 2;
pub const BPF_F_ADJ_ROOM_ENCAP_L3_IPV6: core::ffi::c_uint = 4;
pub const BPF_F_ADJ_ROOM_ENCAP_L4_GRE: core::ffi::c_uint = 8;
pub const BPF_F_ADJ_ROOM_ENCAP_L4_UDP: core::ffi::c_uint = 16;
pub const BPF_F_ADJ_ROOM_NO_CSUM_RESET: core::ffi::c_uint = 32;
pub const BPF_F_ADJ_ROOM_ENCAP_L2_ETH: core::ffi::c_uint = 64;
pub type _bindgen_ty_323 = core::ffi::c_uint;
pub const BPF_ADJ_ROOM_ENCAP_L2_MASK: core::ffi::c_uint = 255;
pub const BPF_ADJ_ROOM_ENCAP_L2_SHIFT: core::ffi::c_uint = 56;
pub type _bindgen_ty_324 = core::ffi::c_uint;
pub const BPF_F_SYSCTL_BASE_NAME: core::ffi::c_uint = 1;
pub type _bindgen_ty_325 = core::ffi::c_uint;
pub const BPF_LOCAL_STORAGE_GET_F_CREATE: core::ffi::c_uint = 1;
pub const BPF_SK_STORAGE_GET_F_CREATE: core::ffi::c_uint = 1;
pub type _bindgen_ty_326 = core::ffi::c_uint;
pub const BPF_F_GET_BRANCH_RECORDS_SIZE: core::ffi::c_uint = 1;
pub type _bindgen_ty_327 = core::ffi::c_uint;
pub const BPF_RB_NO_WAKEUP: core::ffi::c_uint = 1;
pub const BPF_RB_FORCE_WAKEUP: core::ffi::c_uint = 2;
pub type _bindgen_ty_328 = core::ffi::c_uint;
pub const BPF_RB_AVAIL_DATA: core::ffi::c_uint = 0;
pub const BPF_RB_RING_SIZE: core::ffi::c_uint = 1;
pub const BPF_RB_CONS_POS: core::ffi::c_uint = 2;
pub const BPF_RB_PROD_POS: core::ffi::c_uint = 3;
pub type _bindgen_ty_329 = core::ffi::c_uint;
pub const BPF_RINGBUF_BUSY_BIT: core::ffi::c_uint = 2147483648;
pub const BPF_RINGBUF_DISCARD_BIT: core::ffi::c_uint = 1073741824;
pub const BPF_RINGBUF_HDR_SZ: core::ffi::c_uint = 8;
pub type _bindgen_ty_330 = core::ffi::c_uint;
pub const BPF_SK_LOOKUP_F_REPLACE: core::ffi::c_uint = 1;
pub const BPF_SK_LOOKUP_F_NO_REUSEPORT: core::ffi::c_uint = 2;
pub type _bindgen_ty_331 = core::ffi::c_uint;
pub const bpf_adj_room_mode_BPF_ADJ_ROOM_NET: bpf_adj_room_mode = 0;
pub const bpf_adj_room_mode_BPF_ADJ_ROOM_MAC: bpf_adj_room_mode = 1;
pub type bpf_adj_room_mode = core::ffi::c_uint;
pub const bpf_hdr_start_off_BPF_HDR_START_MAC: bpf_hdr_start_off = 0;
pub const bpf_hdr_start_off_BPF_HDR_START_NET: bpf_hdr_start_off = 1;
pub type bpf_hdr_start_off = core::ffi::c_uint;
pub const bpf_lwt_encap_mode_BPF_LWT_ENCAP_SEG6: bpf_lwt_encap_mode = 0;
pub const bpf_lwt_encap_mode_BPF_LWT_ENCAP_SEG6_INLINE: bpf_lwt_encap_mode = 1;
pub const bpf_lwt_encap_mode_BPF_LWT_ENCAP_IP: bpf_lwt_encap_mode = 2;
pub type bpf_lwt_encap_mode = core::ffi::c_uint;
pub const BPF_F_BPRM_SECUREEXEC: core::ffi::c_uint = 1;
pub type _bindgen_ty_332 = core::ffi::c_uint;
pub const BPF_F_BROADCAST: core::ffi::c_uint = 8;
pub const BPF_F_EXCLUDE_INGRESS: core::ffi::c_uint = 16;
pub type _bindgen_ty_333 = core::ffi::c_uint;
pub const BPF_SKB_TSTAMP_UNSPEC: core::ffi::c_uint = 0;
pub const BPF_SKB_TSTAMP_DELIVERY_MONO: core::ffi::c_uint = 1;
pub type _bindgen_ty_334 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sk_buff {
    pub len: __u32,
    pub pkt_type: __u32,
    pub mark: __u32,
    pub queue_mapping: __u32,
    pub protocol: __u32,
    pub vlan_present: __u32,
    pub vlan_tci: __u32,
    pub vlan_proto: __u32,
    pub priority: __u32,
    pub ingress_ifindex: __u32,
    pub ifindex: __u32,
    pub tc_index: __u32,
    pub cb: [__u32; 5usize],
    pub hash: __u32,
    pub tc_classid: __u32,
    pub data: __u32,
    pub data_end: __u32,
    pub napi_id: __u32,
    pub family: __u32,
    pub remote_ip4: __u32,
    pub local_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub local_ip6: [__u32; 4usize],
    pub remote_port: __u32,
    pub local_port: __u32,
    pub data_meta: __u32,
    pub __bindgen_anon_1: __sk_buff__bindgen_ty_1,
    pub tstamp: __u64,
    pub wire_len: __u32,
    pub gso_segs: __u32,
    pub __bindgen_anon_2: __sk_buff__bindgen_ty_2,
    pub gso_size: __u32,
    pub tstamp_type: __u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub hwtstamp: __u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sk_buff__bindgen_ty_1 {
    pub flow_keys: *mut bpf_flow_keys,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for __sk_buff__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl __sk_buff__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sk_buff__bindgen_ty_2 {
    pub sk: *mut bpf_sock,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for __sk_buff__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl __sk_buff__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for __sk_buff {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl __sk_buff {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tunnel_key {
    pub tunnel_id: __u32,
    pub __bindgen_anon_1: bpf_tunnel_key__bindgen_ty_1,
    pub tunnel_tos: __u8,
    pub tunnel_ttl: __u8,
    pub __bindgen_anon_2: bpf_tunnel_key__bindgen_ty_2,
    pub tunnel_label: __u32,
    pub __bindgen_anon_3: bpf_tunnel_key__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_tunnel_key__bindgen_ty_1 {
    pub remote_ipv4: __u32,
    pub remote_ipv6: [__u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for bpf_tunnel_key__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_tunnel_key__bindgen_ty_2 {
    pub tunnel_ext: __u16,
    pub tunnel_flags: __be16,
    _bindgen_union_align: u16,
}
impl Default for bpf_tunnel_key__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_tunnel_key__bindgen_ty_3 {
    pub local_ipv4: __u32,
    pub local_ipv6: [__u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for bpf_tunnel_key__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_tunnel_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_xfrm_state {
    pub reqid: __u32,
    pub spi: __u32,
    pub family: __u16,
    pub ext: __u16,
    pub __bindgen_anon_1: bpf_xfrm_state__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_xfrm_state__bindgen_ty_1 {
    pub remote_ipv4: __u32,
    pub remote_ipv6: [__u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for bpf_xfrm_state__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_xfrm_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const bpf_ret_code_BPF_OK: bpf_ret_code = 0;
pub const bpf_ret_code_BPF_DROP: bpf_ret_code = 2;
pub const bpf_ret_code_BPF_REDIRECT: bpf_ret_code = 7;
pub const bpf_ret_code_BPF_LWT_REROUTE: bpf_ret_code = 128;
pub const bpf_ret_code_BPF_FLOW_DISSECTOR_CONTINUE: bpf_ret_code = 129;
pub type bpf_ret_code = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_sock {
    pub bound_dev_if: __u32,
    pub family: __u32,
    pub type_: __u32,
    pub protocol: __u32,
    pub mark: __u32,
    pub priority: __u32,
    pub src_ip4: __u32,
    pub src_ip6: [__u32; 4usize],
    pub src_port: __u32,
    pub dst_port: __be16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub dst_ip4: __u32,
    pub dst_ip6: [__u32; 4usize],
    pub state: __u32,
    pub rx_queue_mapping: __s32,
}
impl bpf_sock {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_tcp_sock {
    pub snd_cwnd: __u32,
    pub srtt_us: __u32,
    pub rtt_min: __u32,
    pub snd_ssthresh: __u32,
    pub rcv_nxt: __u32,
    pub snd_nxt: __u32,
    pub snd_una: __u32,
    pub mss_cache: __u32,
    pub ecn_flags: __u32,
    pub rate_delivered: __u32,
    pub rate_interval_us: __u32,
    pub packets_out: __u32,
    pub retrans_out: __u32,
    pub total_retrans: __u32,
    pub segs_in: __u32,
    pub data_segs_in: __u32,
    pub segs_out: __u32,
    pub data_segs_out: __u32,
    pub lost_out: __u32,
    pub sacked_out: __u32,
    pub bytes_received: __u64,
    pub bytes_acked: __u64,
    pub dsack_dups: __u32,
    pub delivered: __u32,
    pub delivered_ce: __u32,
    pub icsk_retransmits: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sock_tuple {
    pub __bindgen_anon_1: bpf_sock_tuple__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_tuple__bindgen_ty_1 {
    pub ipv4: bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1,
    pub ipv6: bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 9usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_sock_tuple__bindgen_ty_1__bindgen_ty_1 {
    pub saddr: __be32,
    pub daddr: __be32,
    pub sport: __be16,
    pub dport: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_sock_tuple__bindgen_ty_1__bindgen_ty_2 {
    pub saddr: [__be32; 4usize],
    pub daddr: [__be32; 4usize],
    pub sport: __be16,
    pub dport: __be16,
}
impl Default for bpf_sock_tuple__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_sock_tuple {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_xdp_sock {
    pub queue_id: __u32,
}
pub const xdp_action_XDP_ABORTED: xdp_action = 0;
pub const xdp_action_XDP_DROP: xdp_action = 1;
pub const xdp_action_XDP_PASS: xdp_action = 2;
pub const xdp_action_XDP_TX: xdp_action = 3;
pub const xdp_action_XDP_REDIRECT: xdp_action = 4;
pub type xdp_action = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xdp_md {
    pub data: __u32,
    pub data_end: __u32,
    pub data_meta: __u32,
    pub ingress_ifindex: __u32,
    pub rx_queue_index: __u32,
    pub egress_ifindex: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_devmap_val {
    pub ifindex: __u32,
    pub bpf_prog: bpf_devmap_val__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_devmap_val__bindgen_ty_1 {
    pub fd: core::ffi::c_int,
    pub id: __u32,
    _bindgen_union_align: u32,
}
impl Default for bpf_devmap_val__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_devmap_val {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cpumap_val {
    pub qsize: __u32,
    pub bpf_prog: bpf_cpumap_val__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_cpumap_val__bindgen_ty_1 {
    pub fd: core::ffi::c_int,
    pub id: __u32,
    _bindgen_union_align: u32,
}
impl Default for bpf_cpumap_val__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_cpumap_val {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const sk_action_SK_DROP: sk_action = 0;
pub const sk_action_SK_PASS: sk_action = 1;
pub type sk_action = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_msg_md {
    pub __bindgen_anon_1: sk_msg_md__bindgen_ty_1,
    pub __bindgen_anon_2: sk_msg_md__bindgen_ty_2,
    pub family: __u32,
    pub remote_ip4: __u32,
    pub local_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub local_ip6: [__u32; 4usize],
    pub remote_port: __u32,
    pub local_port: __u32,
    pub size: __u32,
    pub __bindgen_anon_3: sk_msg_md__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_msg_md__bindgen_ty_1 {
    pub data: *mut core::ffi::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for sk_msg_md__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_msg_md__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_msg_md__bindgen_ty_2 {
    pub data_end: *mut core::ffi::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for sk_msg_md__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_msg_md__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_msg_md__bindgen_ty_3 {
    pub sk: *mut bpf_sock,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for sk_msg_md__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_msg_md__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for sk_msg_md {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_reuseport_md {
    pub __bindgen_anon_1: sk_reuseport_md__bindgen_ty_1,
    pub __bindgen_anon_2: sk_reuseport_md__bindgen_ty_2,
    pub len: __u32,
    pub eth_protocol: __u32,
    pub ip_protocol: __u32,
    pub bind_inany: __u32,
    pub hash: __u32,
    pub __bindgen_anon_3: sk_reuseport_md__bindgen_ty_3,
    pub __bindgen_anon_4: sk_reuseport_md__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_reuseport_md__bindgen_ty_1 {
    pub data: *mut core::ffi::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for sk_reuseport_md__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_reuseport_md__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_reuseport_md__bindgen_ty_2 {
    pub data_end: *mut core::ffi::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for sk_reuseport_md__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_reuseport_md__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_reuseport_md__bindgen_ty_3 {
    pub sk: *mut bpf_sock,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for sk_reuseport_md__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_reuseport_md__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sk_reuseport_md__bindgen_ty_4 {
    pub migrating_sk: *mut bpf_sock,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for sk_reuseport_md__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sk_reuseport_md__bindgen_ty_4 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for sk_reuseport_md {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog_info {
    pub type_: __u32,
    pub id: __u32,
    pub tag: [__u8; 8usize],
    pub jited_prog_len: __u32,
    pub xlated_prog_len: __u32,
    pub jited_prog_insns: __u64,
    pub xlated_prog_insns: __u64,
    pub load_time: __u64,
    pub created_by_uid: __u32,
    pub nr_map_ids: __u32,
    pub map_ids: __u64,
    pub name: [core::ffi::c_char; 16usize],
    pub ifindex: __u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub netns_dev: __u64,
    pub netns_ino: __u64,
    pub nr_jited_ksyms: __u32,
    pub nr_jited_func_lens: __u32,
    pub jited_ksyms: __u64,
    pub jited_func_lens: __u64,
    pub btf_id: __u32,
    pub func_info_rec_size: __u32,
    pub func_info: __u64,
    pub nr_func_info: __u32,
    pub nr_line_info: __u32,
    pub line_info: __u64,
    pub jited_line_info: __u64,
    pub nr_jited_line_info: __u32,
    pub line_info_rec_size: __u32,
    pub jited_line_info_rec_size: __u32,
    pub nr_prog_tags: __u32,
    pub prog_tags: __u64,
    pub run_time_ns: __u64,
    pub run_cnt: __u64,
    pub recursion_misses: __u64,
    pub verified_insns: __u32,
    pub attach_btf_obj_id: __u32,
    pub attach_btf_id: __u32,
}
impl bpf_prog_info {
    #[inline]
    pub fn gpl_compatible(&self) -> __u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_gpl_compatible(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(gpl_compatible: __u32) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let gpl_compatible: u32 = unsafe { ::core::mem::transmute(gpl_compatible) };
            gpl_compatible as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_map_info {
    pub type_: __u32,
    pub id: __u32,
    pub key_size: __u32,
    pub value_size: __u32,
    pub max_entries: __u32,
    pub map_flags: __u32,
    pub name: [core::ffi::c_char; 16usize],
    pub ifindex: __u32,
    pub btf_vmlinux_value_type_id: __u32,
    pub netns_dev: __u64,
    pub netns_ino: __u64,
    pub btf_id: __u32,
    pub btf_key_type_id: __u32,
    pub btf_value_type_id: __u32,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub map_extra: __u64,
}
impl bpf_map_info {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_btf_info {
    pub btf: __u64,
    pub btf_size: __u32,
    pub id: __u32,
    pub name: __u64,
    pub name_len: __u32,
    pub kernel_btf: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link_info {
    pub type_: __u32,
    pub id: __u32,
    pub prog_id: __u32,
    pub __bindgen_anon_1: bpf_link_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1 {
    pub raw_tracepoint: bpf_link_info__bindgen_ty_1__bindgen_ty_1,
    pub tracing: bpf_link_info__bindgen_ty_1__bindgen_ty_2,
    pub cgroup: bpf_link_info__bindgen_ty_1__bindgen_ty_3,
    pub iter: bpf_link_info__bindgen_ty_1__bindgen_ty_4,
    pub netns: bpf_link_info__bindgen_ty_1__bindgen_ty_5,
    pub xdp: bpf_link_info__bindgen_ty_1__bindgen_ty_6,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_1 {
    pub tp_name: __u64,
    pub tp_name_len: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_2 {
    pub attach_type: __u32,
    pub target_obj_id: __u32,
    pub target_btf_id: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_3 {
    pub cgroup_id: __u64,
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4 {
    pub target_name: __u64,
    pub target_name_len: __u32,
    pub __bindgen_anon_1: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub map: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1__bindgen_ty_1 {
    pub map_id: __u32,
}
impl Default for bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    pub cgroup: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1,
    pub task: bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_1 {
    pub cgroup_id: __u64,
    pub order: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2__bindgen_ty_2 {
    pub tid: __u32,
    pub pid: __u32,
}
impl Default for bpf_link_info__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_link_info__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_5 {
    pub netns_ino: __u32,
    pub attach_type: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_info__bindgen_ty_1__bindgen_ty_6 {
    pub ifindex: __u32,
}
impl Default for bpf_link_info__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_link_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sock_addr {
    pub user_family: __u32,
    pub user_ip4: __u32,
    pub user_ip6: [__u32; 4usize],
    pub user_port: __u32,
    pub family: __u32,
    pub type_: __u32,
    pub protocol: __u32,
    pub msg_src_ip4: __u32,
    pub msg_src_ip6: [__u32; 4usize],
    pub __bindgen_anon_1: bpf_sock_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_addr__bindgen_ty_1 {
    pub sk: *mut bpf_sock,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_sock_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_sock_addr__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_sock_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sock_ops {
    pub op: __u32,
    pub __bindgen_anon_1: bpf_sock_ops__bindgen_ty_1,
    pub family: __u32,
    pub remote_ip4: __u32,
    pub local_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub local_ip6: [__u32; 4usize],
    pub remote_port: __u32,
    pub local_port: __u32,
    pub is_fullsock: __u32,
    pub snd_cwnd: __u32,
    pub srtt_us: __u32,
    pub bpf_sock_ops_cb_flags: __u32,
    pub state: __u32,
    pub rtt_min: __u32,
    pub snd_ssthresh: __u32,
    pub rcv_nxt: __u32,
    pub snd_nxt: __u32,
    pub snd_una: __u32,
    pub mss_cache: __u32,
    pub ecn_flags: __u32,
    pub rate_delivered: __u32,
    pub rate_interval_us: __u32,
    pub packets_out: __u32,
    pub retrans_out: __u32,
    pub total_retrans: __u32,
    pub segs_in: __u32,
    pub data_segs_in: __u32,
    pub segs_out: __u32,
    pub data_segs_out: __u32,
    pub lost_out: __u32,
    pub sacked_out: __u32,
    pub sk_txhash: __u32,
    pub bytes_received: __u64,
    pub bytes_acked: __u64,
    pub __bindgen_anon_2: bpf_sock_ops__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_sock_ops__bindgen_ty_3,
    pub __bindgen_anon_4: bpf_sock_ops__bindgen_ty_4,
    pub skb_len: __u32,
    pub skb_tcp_flags: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_1 {
    pub args: [__u32; 4usize],
    pub reply: __u32,
    pub replylong: [__u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for bpf_sock_ops__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_2 {
    pub sk: *mut bpf_sock,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_sock_ops__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_sock_ops__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_3 {
    pub skb_data: *mut core::ffi::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_sock_ops__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_sock_ops__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops__bindgen_ty_4 {
    pub skb_data_end: *mut core::ffi::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_sock_ops__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_sock_ops__bindgen_ty_4 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_sock_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const BPF_SOCK_OPS_RTO_CB_FLAG: core::ffi::c_uint = 1;
pub const BPF_SOCK_OPS_RETRANS_CB_FLAG: core::ffi::c_uint = 2;
pub const BPF_SOCK_OPS_STATE_CB_FLAG: core::ffi::c_uint = 4;
pub const BPF_SOCK_OPS_RTT_CB_FLAG: core::ffi::c_uint = 8;
pub const BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG: core::ffi::c_uint = 16;
pub const BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG: core::ffi::c_uint = 32;
pub const BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG: core::ffi::c_uint = 64;
pub const BPF_SOCK_OPS_ALL_CB_FLAGS: core::ffi::c_uint = 127;
pub type _bindgen_ty_335 = core::ffi::c_uint;
pub const BPF_SOCK_OPS_VOID: core::ffi::c_uint = 0;
pub const BPF_SOCK_OPS_TIMEOUT_INIT: core::ffi::c_uint = 1;
pub const BPF_SOCK_OPS_RWND_INIT: core::ffi::c_uint = 2;
pub const BPF_SOCK_OPS_TCP_CONNECT_CB: core::ffi::c_uint = 3;
pub const BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB: core::ffi::c_uint = 4;
pub const BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB: core::ffi::c_uint = 5;
pub const BPF_SOCK_OPS_NEEDS_ECN: core::ffi::c_uint = 6;
pub const BPF_SOCK_OPS_BASE_RTT: core::ffi::c_uint = 7;
pub const BPF_SOCK_OPS_RTO_CB: core::ffi::c_uint = 8;
pub const BPF_SOCK_OPS_RETRANS_CB: core::ffi::c_uint = 9;
pub const BPF_SOCK_OPS_STATE_CB: core::ffi::c_uint = 10;
pub const BPF_SOCK_OPS_TCP_LISTEN_CB: core::ffi::c_uint = 11;
pub const BPF_SOCK_OPS_RTT_CB: core::ffi::c_uint = 12;
pub const BPF_SOCK_OPS_PARSE_HDR_OPT_CB: core::ffi::c_uint = 13;
pub const BPF_SOCK_OPS_HDR_OPT_LEN_CB: core::ffi::c_uint = 14;
pub const BPF_SOCK_OPS_WRITE_HDR_OPT_CB: core::ffi::c_uint = 15;
pub type _bindgen_ty_336 = core::ffi::c_uint;
pub const BPF_TCP_ESTABLISHED: core::ffi::c_uint = 1;
pub const BPF_TCP_SYN_SENT: core::ffi::c_uint = 2;
pub const BPF_TCP_SYN_RECV: core::ffi::c_uint = 3;
pub const BPF_TCP_FIN_WAIT1: core::ffi::c_uint = 4;
pub const BPF_TCP_FIN_WAIT2: core::ffi::c_uint = 5;
pub const BPF_TCP_TIME_WAIT: core::ffi::c_uint = 6;
pub const BPF_TCP_CLOSE: core::ffi::c_uint = 7;
pub const BPF_TCP_CLOSE_WAIT: core::ffi::c_uint = 8;
pub const BPF_TCP_LAST_ACK: core::ffi::c_uint = 9;
pub const BPF_TCP_LISTEN: core::ffi::c_uint = 10;
pub const BPF_TCP_CLOSING: core::ffi::c_uint = 11;
pub const BPF_TCP_NEW_SYN_RECV: core::ffi::c_uint = 12;
pub const BPF_TCP_MAX_STATES: core::ffi::c_uint = 13;
pub type _bindgen_ty_337 = core::ffi::c_uint;
pub const TCP_BPF_IW: core::ffi::c_uint = 1001;
pub const TCP_BPF_SNDCWND_CLAMP: core::ffi::c_uint = 1002;
pub const TCP_BPF_DELACK_MAX: core::ffi::c_uint = 1003;
pub const TCP_BPF_RTO_MIN: core::ffi::c_uint = 1004;
pub const TCP_BPF_SYN: core::ffi::c_uint = 1005;
pub const TCP_BPF_SYN_IP: core::ffi::c_uint = 1006;
pub const TCP_BPF_SYN_MAC: core::ffi::c_uint = 1007;
pub type _bindgen_ty_338 = core::ffi::c_uint;
pub const BPF_LOAD_HDR_OPT_TCP_SYN: core::ffi::c_uint = 1;
pub type _bindgen_ty_339 = core::ffi::c_uint;
pub const BPF_WRITE_HDR_TCP_CURRENT_MSS: core::ffi::c_uint = 1;
pub const BPF_WRITE_HDR_TCP_SYNACK_COOKIE: core::ffi::c_uint = 2;
pub type _bindgen_ty_340 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_perf_event_value {
    pub counter: __u64,
    pub enabled: __u64,
    pub running: __u64,
}
pub const BPF_DEVCG_ACC_MKNOD: core::ffi::c_uint = 1;
pub const BPF_DEVCG_ACC_READ: core::ffi::c_uint = 2;
pub const BPF_DEVCG_ACC_WRITE: core::ffi::c_uint = 4;
pub type _bindgen_ty_341 = core::ffi::c_uint;
pub const BPF_DEVCG_DEV_BLOCK: core::ffi::c_uint = 1;
pub const BPF_DEVCG_DEV_CHAR: core::ffi::c_uint = 2;
pub type _bindgen_ty_342 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_cgroup_dev_ctx {
    pub access_type: __u32,
    pub major: __u32,
    pub minor: __u32,
}
#[repr(C)]
#[derive(Default)]
pub struct bpf_raw_tracepoint_args {
    pub args: __IncompleteArrayField<__u64>,
}
pub const BPF_FIB_LOOKUP_DIRECT: core::ffi::c_uint = 1;
pub const BPF_FIB_LOOKUP_OUTPUT: core::ffi::c_uint = 2;
pub type _bindgen_ty_343 = core::ffi::c_uint;
pub const BPF_FIB_LKUP_RET_SUCCESS: core::ffi::c_uint = 0;
pub const BPF_FIB_LKUP_RET_BLACKHOLE: core::ffi::c_uint = 1;
pub const BPF_FIB_LKUP_RET_UNREACHABLE: core::ffi::c_uint = 2;
pub const BPF_FIB_LKUP_RET_PROHIBIT: core::ffi::c_uint = 3;
pub const BPF_FIB_LKUP_RET_NOT_FWDED: core::ffi::c_uint = 4;
pub const BPF_FIB_LKUP_RET_FWD_DISABLED: core::ffi::c_uint = 5;
pub const BPF_FIB_LKUP_RET_UNSUPP_LWT: core::ffi::c_uint = 6;
pub const BPF_FIB_LKUP_RET_NO_NEIGH: core::ffi::c_uint = 7;
pub const BPF_FIB_LKUP_RET_FRAG_NEEDED: core::ffi::c_uint = 8;
pub type _bindgen_ty_344 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_fib_lookup {
    pub family: __u8,
    pub l4_protocol: __u8,
    pub sport: __be16,
    pub dport: __be16,
    pub __bindgen_anon_1: bpf_fib_lookup__bindgen_ty_1,
    pub ifindex: __u32,
    pub __bindgen_anon_2: bpf_fib_lookup__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_fib_lookup__bindgen_ty_3,
    pub __bindgen_anon_4: bpf_fib_lookup__bindgen_ty_4,
    pub h_vlan_proto: __be16,
    pub h_vlan_TCI: __be16,
    pub smac: [__u8; 6usize],
    pub dmac: [__u8; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_1 {
    pub tot_len: __u16,
    pub mtu_result: __u16,
    _bindgen_union_align: u16,
}
impl Default for bpf_fib_lookup__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_2 {
    pub tos: __u8,
    pub flowinfo: __be32,
    pub rt_metric: __u32,
    _bindgen_union_align: u32,
}
impl Default for bpf_fib_lookup__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_3 {
    pub ipv4_src: __be32,
    pub ipv6_src: [__u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for bpf_fib_lookup__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_fib_lookup__bindgen_ty_4 {
    pub ipv4_dst: __be32,
    pub ipv6_dst: [__u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for bpf_fib_lookup__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_fib_lookup {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_redir_neigh {
    pub nh_family: __u32,
    pub __bindgen_anon_1: bpf_redir_neigh__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_redir_neigh__bindgen_ty_1 {
    pub ipv4_nh: __be32,
    pub ipv6_nh: [__u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for bpf_redir_neigh__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_redir_neigh {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const bpf_check_mtu_flags_BPF_MTU_CHK_SEGS: bpf_check_mtu_flags = 1;
pub type bpf_check_mtu_flags = core::ffi::c_uint;
pub const bpf_check_mtu_ret_BPF_MTU_CHK_RET_SUCCESS: bpf_check_mtu_ret = 0;
pub const bpf_check_mtu_ret_BPF_MTU_CHK_RET_FRAG_NEEDED: bpf_check_mtu_ret = 1;
pub const bpf_check_mtu_ret_BPF_MTU_CHK_RET_SEGS_TOOBIG: bpf_check_mtu_ret = 2;
pub type bpf_check_mtu_ret = core::ffi::c_uint;
pub const bpf_task_fd_type_BPF_FD_TYPE_RAW_TRACEPOINT: bpf_task_fd_type = 0;
pub const bpf_task_fd_type_BPF_FD_TYPE_TRACEPOINT: bpf_task_fd_type = 1;
pub const bpf_task_fd_type_BPF_FD_TYPE_KPROBE: bpf_task_fd_type = 2;
pub const bpf_task_fd_type_BPF_FD_TYPE_KRETPROBE: bpf_task_fd_type = 3;
pub const bpf_task_fd_type_BPF_FD_TYPE_UPROBE: bpf_task_fd_type = 4;
pub const bpf_task_fd_type_BPF_FD_TYPE_URETPROBE: bpf_task_fd_type = 5;
pub type bpf_task_fd_type = core::ffi::c_uint;
pub const BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG: core::ffi::c_uint = 1;
pub const BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL: core::ffi::c_uint = 2;
pub const BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP: core::ffi::c_uint = 4;
pub type _bindgen_ty_345 = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_flow_keys {
    pub nhoff: __u16,
    pub thoff: __u16,
    pub addr_proto: __u16,
    pub is_frag: __u8,
    pub is_first_frag: __u8,
    pub is_encap: __u8,
    pub ip_proto: __u8,
    pub n_proto: __be16,
    pub sport: __be16,
    pub dport: __be16,
    pub __bindgen_anon_1: bpf_flow_keys__bindgen_ty_1,
    pub flags: __u32,
    pub flow_label: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_flow_keys__bindgen_ty_1 {
    pub __bindgen_anon_1: bpf_flow_keys__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_flow_keys__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u32; 8usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_flow_keys__bindgen_ty_1__bindgen_ty_1 {
    pub ipv4_src: __be32,
    pub ipv4_dst: __be32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_flow_keys__bindgen_ty_1__bindgen_ty_2 {
    pub ipv6_src: [__u32; 4usize],
    pub ipv6_dst: [__u32; 4usize],
}
impl Default for bpf_flow_keys__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_flow_keys {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_func_info {
    pub insn_off: __u32,
    pub type_id: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_line_info {
    pub insn_off: __u32,
    pub file_name_off: __u32,
    pub line_off: __u32,
    pub line_col: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_spin_lock {
    pub val: __u32,
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct bpf_timer {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize], u8>,
}
impl bpf_timer {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default, Copy, Clone)]
pub struct bpf_dynptr {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize], u8>,
}
impl bpf_dynptr {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 16usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_sysctl {
    pub write: __u32,
    pub file_pos: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sockopt {
    pub __bindgen_anon_1: bpf_sockopt__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_sockopt__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_sockopt__bindgen_ty_3,
    pub level: __s32,
    pub optname: __s32,
    pub optlen: __s32,
    pub retval: __s32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sockopt__bindgen_ty_1 {
    pub sk: *mut bpf_sock,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_sockopt__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_sockopt__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sockopt__bindgen_ty_2 {
    pub optval: *mut core::ffi::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_sockopt__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_sockopt__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sockopt__bindgen_ty_3 {
    pub optval_end: *mut core::ffi::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_sockopt__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_sockopt__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_sockopt {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_pidns_info {
    pub pid: __u32,
    pub tgid: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sk_lookup {
    pub __bindgen_anon_1: bpf_sk_lookup__bindgen_ty_1,
    pub family: __u32,
    pub protocol: __u32,
    pub remote_ip4: __u32,
    pub remote_ip6: [__u32; 4usize],
    pub remote_port: __be16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub local_ip4: __u32,
    pub local_ip6: [__u32; 4usize],
    pub local_port: __u32,
    pub ingress_ifindex: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sk_lookup__bindgen_ty_1 {
    pub __bindgen_anon_1: bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1,
    pub cookie: __u64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1 {
    pub sk: *mut bpf_sock,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_sk_lookup__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_sk_lookup__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_sk_lookup {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_sk_lookup {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_ptr {
    pub ptr: *mut core::ffi::c_void,
    pub type_id: __u32,
    pub flags: __u32,
}
impl Default for btf_ptr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const BTF_F_COMPACT: core::ffi::c_uint = 1;
pub const BTF_F_NONAME: core::ffi::c_uint = 2;
pub const BTF_F_PTR_RAW: core::ffi::c_uint = 4;
pub const BTF_F_ZERO: core::ffi::c_uint = 8;
pub type _bindgen_ty_346 = core::ffi::c_uint;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_BYTE_OFFSET: bpf_core_relo_kind = 0;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_BYTE_SIZE: bpf_core_relo_kind = 1;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_EXISTS: bpf_core_relo_kind = 2;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_SIGNED: bpf_core_relo_kind = 3;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_LSHIFT_U64: bpf_core_relo_kind = 4;
pub const bpf_core_relo_kind_BPF_CORE_FIELD_RSHIFT_U64: bpf_core_relo_kind = 5;
pub const bpf_core_relo_kind_BPF_CORE_TYPE_ID_LOCAL: bpf_core_relo_kind = 6;
pub const bpf_core_relo_kind_BPF_CORE_TYPE_ID_TARGET: bpf_core_relo_kind = 7;
pub const bpf_core_relo_kind_BPF_CORE_TYPE_EXISTS: bpf_core_relo_kind = 8;
pub const bpf_core_relo_kind_BPF_CORE_TYPE_SIZE: bpf_core_relo_kind = 9;
pub const bpf_core_relo_kind_BPF_CORE_ENUMVAL_EXISTS: bpf_core_relo_kind = 10;
pub const bpf_core_relo_kind_BPF_CORE_ENUMVAL_VALUE: bpf_core_relo_kind = 11;
pub const bpf_core_relo_kind_BPF_CORE_TYPE_MATCHES: bpf_core_relo_kind = 12;
pub type bpf_core_relo_kind = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_core_relo {
    pub insn_off: __u32,
    pub type_id: __u32,
    pub access_str_off: __u32,
    pub kind: bpf_core_relo_kind,
}
impl Default for bpf_core_relo {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sock_filter {
    pub code: __u16,
    pub jt: __u8,
    pub jf: __u8,
    pub k: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock_fprog {
    pub len: core::ffi::c_ushort,
    pub filter: *mut sock_filter,
}
impl Default for sock_fprog {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn kallsyms_on_each_symbol(
        fn_: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut core::ffi::c_void,
                arg2: *const core::ffi::c_char,
                arg3: *mut module,
                arg4: core::ffi::c_ulong,
            ) -> core::ffi::c_int,
        >,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kallsyms_lookup_name(name: *const core::ffi::c_char) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn kallsyms_lookup_size_offset(
        addr: core::ffi::c_ulong,
        symbolsize: *mut core::ffi::c_ulong,
        offset: *mut core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kallsyms_lookup(
        addr: core::ffi::c_ulong,
        symbolsize: *mut core::ffi::c_ulong,
        offset: *mut core::ffi::c_ulong,
        modname: *mut *mut core::ffi::c_char,
        namebuf: *mut core::ffi::c_char,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn sprint_symbol(
        buffer: *mut core::ffi::c_char,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sprint_symbol_build_id(
        buffer: *mut core::ffi::c_char,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sprint_symbol_no_offset(
        buffer: *mut core::ffi::c_char,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sprint_backtrace(
        buffer: *mut core::ffi::c_char,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sprint_backtrace_build_id(
        buffer: *mut core::ffi::c_char,
        address: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lookup_symbol_name(
        addr: core::ffi::c_ulong,
        symname: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn lookup_symbol_attrs(
        addr: core::ffi::c_ulong,
        size: *mut core::ffi::c_ulong,
        offset: *mut core::ffi::c_ulong,
        modname: *mut core::ffi::c_char,
        name: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn kallsyms_show_value(cred: *const cred) -> bool_;
}
pub type bpfptr_t = sockptr_t;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_header {
    pub magic: __u16,
    pub version: __u8,
    pub flags: __u8,
    pub hdr_len: __u32,
    pub type_off: __u32,
    pub type_len: __u32,
    pub str_off: __u32,
    pub str_len: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_type {
    pub name_off: __u32,
    pub info: __u32,
    pub __bindgen_anon_1: btf_type__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union btf_type__bindgen_ty_1 {
    pub size: __u32,
    pub type_: __u32,
    _bindgen_union_align: u32,
}
impl Default for btf_type__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for btf_type {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const BTF_KIND_UNKN: core::ffi::c_uint = 0;
pub const BTF_KIND_INT: core::ffi::c_uint = 1;
pub const BTF_KIND_PTR: core::ffi::c_uint = 2;
pub const BTF_KIND_ARRAY: core::ffi::c_uint = 3;
pub const BTF_KIND_STRUCT: core::ffi::c_uint = 4;
pub const BTF_KIND_UNION: core::ffi::c_uint = 5;
pub const BTF_KIND_ENUM: core::ffi::c_uint = 6;
pub const BTF_KIND_FWD: core::ffi::c_uint = 7;
pub const BTF_KIND_TYPEDEF: core::ffi::c_uint = 8;
pub const BTF_KIND_VOLATILE: core::ffi::c_uint = 9;
pub const BTF_KIND_CONST: core::ffi::c_uint = 10;
pub const BTF_KIND_RESTRICT: core::ffi::c_uint = 11;
pub const BTF_KIND_FUNC: core::ffi::c_uint = 12;
pub const BTF_KIND_FUNC_PROTO: core::ffi::c_uint = 13;
pub const BTF_KIND_VAR: core::ffi::c_uint = 14;
pub const BTF_KIND_DATASEC: core::ffi::c_uint = 15;
pub const BTF_KIND_FLOAT: core::ffi::c_uint = 16;
pub const BTF_KIND_DECL_TAG: core::ffi::c_uint = 17;
pub const BTF_KIND_TYPE_TAG: core::ffi::c_uint = 18;
pub const BTF_KIND_ENUM64: core::ffi::c_uint = 19;
pub const NR_BTF_KINDS: core::ffi::c_uint = 20;
pub const BTF_KIND_MAX: core::ffi::c_uint = 19;
pub type _bindgen_ty_347 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_enum {
    pub name_off: __u32,
    pub val: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_array {
    pub type_: __u32,
    pub index_type: __u32,
    pub nelems: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_member {
    pub name_off: __u32,
    pub type_: __u32,
    pub offset: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_param {
    pub name_off: __u32,
    pub type_: __u32,
}
pub const BTF_VAR_STATIC: core::ffi::c_uint = 0;
pub const BTF_VAR_GLOBAL_ALLOCATED: core::ffi::c_uint = 1;
pub const BTF_VAR_GLOBAL_EXTERN: core::ffi::c_uint = 2;
pub type _bindgen_ty_348 = core::ffi::c_uint;
pub const btf_func_linkage_BTF_FUNC_STATIC: btf_func_linkage = 0;
pub const btf_func_linkage_BTF_FUNC_GLOBAL: btf_func_linkage = 1;
pub const btf_func_linkage_BTF_FUNC_EXTERN: btf_func_linkage = 2;
pub type btf_func_linkage = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_var {
    pub linkage: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_var_secinfo {
    pub type_: __u32,
    pub offset: __u32,
    pub size: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_decl_tag {
    pub component_idx: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_enum64 {
    pub name_off: __u32,
    pub val_lo32: __u32,
    pub val_hi32: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_show {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_id_set {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_kfunc_id_set {
    pub owner: *mut module,
    pub set: *mut btf_id_set8,
}
impl Default for btf_kfunc_id_set {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_id_dtor_kfunc {
    pub btf_id: u32_,
    pub kfunc_btf_id: u32_,
}
pub type btf_dtor_kfunc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>;
extern "C" {
    pub static btf_fops: file_operations;
}
extern "C" {
    pub fn btf_get(btf: *mut btf);
}
extern "C" {
    pub fn btf_put(btf: *mut btf);
}
extern "C" {
    pub fn btf_new_fd(attr: *const bpf_attr, uattr: bpfptr_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_get_by_fd(fd: core::ffi::c_int) -> *mut btf;
}
extern "C" {
    pub fn btf_get_info_by_fd(
        btf: *const btf,
        attr: *const bpf_attr,
        uattr: *mut bpf_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_type_id_size(
        btf: *const btf,
        type_id: *mut u32_,
        ret_size: *mut u32_,
    ) -> *const btf_type;
}
extern "C" {
    pub fn btf_type_seq_show(
        btf: *const btf,
        type_id: u32_,
        obj: *mut core::ffi::c_void,
        m: *mut seq_file,
    );
}
extern "C" {
    pub fn btf_type_seq_show_flags(
        btf: *const btf,
        type_id: u32_,
        obj: *mut core::ffi::c_void,
        m: *mut seq_file,
        flags: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_type_snprintf_show(
        btf: *const btf,
        type_id: u32_,
        obj: *mut core::ffi::c_void,
        buf: *mut core::ffi::c_char,
        len: core::ffi::c_int,
        flags: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_get_fd_by_id(id: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_obj_id(btf: *const btf) -> u32_;
}
extern "C" {
    pub fn btf_is_kernel(btf: *const btf) -> bool_;
}
extern "C" {
    pub fn btf_is_module(btf: *const btf) -> bool_;
}
extern "C" {
    pub fn btf_try_get_module(btf: *const btf) -> *mut module;
}
extern "C" {
    pub fn btf_nr_types(btf: *const btf) -> u32_;
}
extern "C" {
    pub fn btf_member_is_reg_int(
        btf: *const btf,
        s: *const btf_type,
        m: *const btf_member,
        expected_offset: u32_,
        expected_size: u32_,
    ) -> bool_;
}
extern "C" {
    pub fn btf_find_spin_lock(btf: *const btf, t: *const btf_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_find_timer(btf: *const btf, t: *const btf_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_parse_kptrs(btf: *const btf, t: *const btf_type) -> *mut bpf_map_value_off;
}
extern "C" {
    pub fn btf_type_is_void(t: *const btf_type) -> bool_;
}
extern "C" {
    pub fn btf_find_by_name_kind(btf: *const btf, name: *const core::ffi::c_char, kind: u8_)
        -> s32;
}
extern "C" {
    pub fn btf_type_skip_modifiers(btf: *const btf, id: u32_, res_id: *mut u32_)
        -> *const btf_type;
}
extern "C" {
    pub fn btf_type_resolve_ptr(btf: *const btf, id: u32_, res_id: *mut u32_) -> *const btf_type;
}
extern "C" {
    pub fn btf_type_resolve_func_ptr(
        btf: *const btf,
        id: u32_,
        res_id: *mut u32_,
    ) -> *const btf_type;
}
extern "C" {
    pub fn btf_resolve_size(
        btf: *const btf,
        type_: *const btf_type,
        type_size: *mut u32_,
    ) -> *const btf_type;
}
extern "C" {
    pub fn btf_type_str(t: *const btf_type) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn btf_type_by_id(btf: *const btf, type_id: u32_) -> *const btf_type;
}
extern "C" {
    pub fn btf_name_by_offset(btf: *const btf, offset: u32_) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn btf_parse_vmlinux() -> *mut btf;
}
extern "C" {
    pub fn bpf_prog_get_target_btf(prog: *const bpf_prog) -> *mut btf;
}
extern "C" {
    pub fn btf_kfunc_id_set_contains(
        btf: *const btf,
        prog_type: bpf_prog_type,
        kfunc_btf_id: u32_,
    ) -> *mut u32_;
}
extern "C" {
    pub fn register_btf_kfunc_id_set(
        prog_type: bpf_prog_type,
        s: *const btf_kfunc_id_set,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_find_dtor_kfunc(btf: *mut btf, btf_id: u32_) -> s32;
}
extern "C" {
    pub fn register_btf_id_dtor_kfuncs(
        dtors: *const btf_id_dtor_kfunc,
        add_cnt: u32_,
        owner: *mut module,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut rcu_trace_lock_map: lockdep_map;
}
extern "C" {
    pub fn rcu_read_unlock_trace_special(t: *mut task_struct);
}
extern "C" {
    pub fn call_rcu_tasks_trace(rhp: *mut callback_head, func: rcu_callback_t);
}
extern "C" {
    pub fn synchronize_rcu_tasks_trace();
}
extern "C" {
    pub fn rcu_barrier_tasks_trace();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_verifier_env {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_verifier_log {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_local_storage_map {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ftrace_ops {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut btf_idr: idr;
}
extern "C" {
    pub static mut btf_idr_lock: spinlock_t;
}
extern "C" {
    pub static mut btf_kobj: *mut kobject;
}
pub type bpf_callback_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: u64_, arg2: u64_, arg3: u64_, arg4: u64_, arg5: u64_) -> u64_,
>;
pub type bpf_iter_init_seq_priv_t = ::core::option::Option<
    unsafe extern "C" fn(
        private_data: *mut core::ffi::c_void,
        aux: *mut bpf_iter_aux_info,
    ) -> core::ffi::c_int,
>;
pub type bpf_iter_fini_seq_priv_t =
    ::core::option::Option<unsafe extern "C" fn(private_data: *mut core::ffi::c_void)>;
pub type bpf_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const core::ffi::c_void,
        arg2: *const bpf_insn,
    ) -> core::ffi::c_uint,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_seq_info {
    pub seq_ops: *const seq_operations,
    pub init_seq_private: bpf_iter_init_seq_priv_t,
    pub fini_seq_private: bpf_iter_fini_seq_priv_t,
    pub seq_priv_size: u32_,
}
impl Default for bpf_iter_seq_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_map_ops {
    pub map_alloc_check:
        ::core::option::Option<unsafe extern "C" fn(attr: *mut bpf_attr) -> core::ffi::c_int>,
    pub map_alloc:
        ::core::option::Option<unsafe extern "C" fn(attr: *mut bpf_attr) -> *mut bpf_map>,
    pub map_release:
        ::core::option::Option<unsafe extern "C" fn(map: *mut bpf_map, map_file: *mut file)>,
    pub map_free: ::core::option::Option<unsafe extern "C" fn(map: *mut bpf_map)>,
    pub map_get_next_key: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut core::ffi::c_void,
            next_key: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub map_release_uref: ::core::option::Option<unsafe extern "C" fn(map: *mut bpf_map)>,
    pub map_lookup_elem_sys_only: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut core::ffi::c_void,
        ) -> *mut core::ffi::c_void,
    >,
    pub map_lookup_batch: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            attr: *const bpf_attr,
            uattr: *mut bpf_attr,
        ) -> core::ffi::c_int,
    >,
    pub map_lookup_and_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
            flags: u64_,
        ) -> core::ffi::c_int,
    >,
    pub map_lookup_and_delete_batch: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            attr: *const bpf_attr,
            uattr: *mut bpf_attr,
        ) -> core::ffi::c_int,
    >,
    pub map_update_batch: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            attr: *const bpf_attr,
            uattr: *mut bpf_attr,
        ) -> core::ffi::c_int,
    >,
    pub map_delete_batch: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            attr: *const bpf_attr,
            uattr: *mut bpf_attr,
        ) -> core::ffi::c_int,
    >,
    pub map_lookup_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut core::ffi::c_void,
        ) -> *mut core::ffi::c_void,
    >,
    pub map_update_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
            flags: u64_,
        ) -> core::ffi::c_int,
    >,
    pub map_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub map_push_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            value: *mut core::ffi::c_void,
            flags: u64_,
        ) -> core::ffi::c_int,
    >,
    pub map_pop_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, value: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub map_peek_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, value: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub map_lookup_percpu_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            key: *mut core::ffi::c_void,
            cpu: u32_,
        ) -> *mut core::ffi::c_void,
    >,
    pub map_fd_get_ptr: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            map_file: *mut file,
            fd: core::ffi::c_int,
        ) -> *mut core::ffi::c_void,
    >,
    pub map_fd_put_ptr: ::core::option::Option<unsafe extern "C" fn(ptr: *mut core::ffi::c_void)>,
    pub map_gen_lookup: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, insn_buf: *mut bpf_insn) -> core::ffi::c_int,
    >,
    pub map_fd_sys_lookup_elem:
        ::core::option::Option<unsafe extern "C" fn(ptr: *mut core::ffi::c_void) -> u32_>,
    pub map_seq_show_elem: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: *mut core::ffi::c_void, m: *mut seq_file),
    >,
    pub map_check_btf: ::core::option::Option<
        unsafe extern "C" fn(
            map: *const bpf_map,
            btf: *const btf,
            key_type: *const btf_type,
            value_type: *const btf_type,
        ) -> core::ffi::c_int,
    >,
    pub map_poke_track: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, aux: *mut bpf_prog_aux) -> core::ffi::c_int,
    >,
    pub map_poke_untrack:
        ::core::option::Option<unsafe extern "C" fn(map: *mut bpf_map, aux: *mut bpf_prog_aux)>,
    pub map_poke_run: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, key: u32_, old: *mut bpf_prog, new: *mut bpf_prog),
    >,
    pub map_direct_value_addr: ::core::option::Option<
        unsafe extern "C" fn(map: *const bpf_map, imm: *mut u64_, off: u32_) -> core::ffi::c_int,
    >,
    pub map_direct_value_meta: ::core::option::Option<
        unsafe extern "C" fn(map: *const bpf_map, imm: u64_, off: *mut u32_) -> core::ffi::c_int,
    >,
    pub map_mmap: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, vma: *mut vm_area_struct) -> core::ffi::c_int,
    >,
    pub map_poll: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            filp: *mut file,
            pts: *mut poll_table_struct,
        ) -> __poll_t,
    >,
    pub map_local_storage_charge: ::core::option::Option<
        unsafe extern "C" fn(
            smap: *mut bpf_local_storage_map,
            owner: *mut core::ffi::c_void,
            size: u32_,
        ) -> core::ffi::c_int,
    >,
    pub map_local_storage_uncharge: ::core::option::Option<
        unsafe extern "C" fn(
            smap: *mut bpf_local_storage_map,
            owner: *mut core::ffi::c_void,
            size: u32_,
        ),
    >,
    pub map_owner_storage_ptr: ::core::option::Option<
        unsafe extern "C" fn(owner: *mut core::ffi::c_void) -> *mut *mut bpf_local_storage,
    >,
    pub map_redirect: ::core::option::Option<
        unsafe extern "C" fn(map: *mut bpf_map, ifindex: u32_, flags: u64_) -> core::ffi::c_int,
    >,
    pub map_meta_equal: ::core::option::Option<
        unsafe extern "C" fn(meta0: *const bpf_map, meta1: *const bpf_map) -> bool_,
    >,
    pub map_set_for_each_callback_args: ::core::option::Option<
        unsafe extern "C" fn(
            env: *mut bpf_verifier_env,
            caller: *mut bpf_func_state,
            callee: *mut bpf_func_state,
        ) -> core::ffi::c_int,
    >,
    pub map_for_each_callback: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_map,
            callback_fn: bpf_callback_t,
            callback_ctx: *mut core::ffi::c_void,
            flags: u64_,
        ) -> core::ffi::c_int,
    >,
    pub map_btf_id: *mut core::ffi::c_int,
    pub iter_seq_info: *const bpf_iter_seq_info,
}
impl Default for bpf_map_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const BPF_MAP_VALUE_OFF_MAX: core::ffi::c_uint = 8;
pub const BPF_MAP_OFF_ARR_MAX: core::ffi::c_uint = 10;
pub type _bindgen_ty_349 = core::ffi::c_uint;
pub const bpf_kptr_type_BPF_KPTR_UNREF: bpf_kptr_type = 0;
pub const bpf_kptr_type_BPF_KPTR_REF: bpf_kptr_type = 1;
pub type bpf_kptr_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_map_value_off_desc {
    pub offset: u32_,
    pub type_: bpf_kptr_type,
    pub kptr: bpf_map_value_off_desc__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_map_value_off_desc__bindgen_ty_1 {
    pub btf: *mut btf,
    pub module: *mut module,
    pub dtor: btf_dtor_kfunc_t,
    pub btf_id: u32_,
}
impl Default for bpf_map_value_off_desc__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_map_value_off_desc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct bpf_map_value_off {
    pub nr_off: u32_,
    pub off: __IncompleteArrayField<bpf_map_value_off_desc>,
}
impl Default for bpf_map_value_off {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_map_off_arr {
    pub cnt: u32_,
    pub field_off: [u32_; 10usize],
    pub field_sz: [u8_; 10usize],
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct bpf_map {
    pub ops: *const bpf_map_ops,
    pub inner_map_meta: *mut bpf_map,
    pub security: *mut core::ffi::c_void,
    pub map_type: bpf_map_type,
    pub key_size: u32_,
    pub value_size: u32_,
    pub max_entries: u32_,
    pub map_extra: u64_,
    pub map_flags: u32_,
    pub spin_lock_off: core::ffi::c_int,
    pub kptr_off_tab: *mut bpf_map_value_off,
    pub timer_off: core::ffi::c_int,
    pub id: u32_,
    pub numa_node: core::ffi::c_int,
    pub btf_key_type_id: u32_,
    pub btf_value_type_id: u32_,
    pub btf_vmlinux_value_type_id: u32_,
    pub btf: *mut btf,
    pub objcg: *mut obj_cgroup,
    pub name: [core::ffi::c_char; 16usize],
    pub off_arr: *mut bpf_map_off_arr,
    pub refcnt: atomic64_t,
    pub usercnt: atomic64_t,
    pub work: work_struct,
    pub freeze_mutex: mutex,
    pub writecnt: atomic64_t,
    pub owner: bpf_map__bindgen_ty_1,
    pub bypass_spec_v1: bool_,
    pub frozen: bool_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_map__bindgen_ty_1 {
    pub lock: spinlock_t,
    pub type_: bpf_prog_type,
    pub jited: bool_,
    pub xdp_has_frags: bool_,
}
impl Default for bpf_map__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn copy_map_value_locked(
        map: *mut bpf_map,
        dst: *mut core::ffi::c_void,
        src: *mut core::ffi::c_void,
        lock_src: bool_,
    );
}
extern "C" {
    pub fn bpf_timer_cancel_and_free(timer: *mut core::ffi::c_void);
}
extern "C" {
    pub fn bpf_obj_name_cpy(
        dst: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
        size: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_offload_dev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_map_dev_ops {
    pub map_get_next_key: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_offloaded_map,
            key: *mut core::ffi::c_void,
            next_key: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub map_lookup_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_offloaded_map,
            key: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub map_update_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_offloaded_map,
            key: *mut core::ffi::c_void,
            value: *mut core::ffi::c_void,
            flags: u64_,
        ) -> core::ffi::c_int,
    >,
    pub map_delete_elem: ::core::option::Option<
        unsafe extern "C" fn(
            map: *mut bpf_offloaded_map,
            key: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct bpf_offloaded_map {
    pub map: bpf_map,
    pub netdev: *mut net_device,
    pub dev_ops: *const bpf_map_dev_ops,
    pub dev_priv: *mut core::ffi::c_void,
    pub offloads: list_head,
}
impl Default for bpf_offloaded_map {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn map_check_no_btf(
        map: *const bpf_map,
        btf: *const btf,
        key_type: *const btf_type,
        value_type: *const btf_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_map_meta_equal(meta0: *const bpf_map, meta1: *const bpf_map) -> bool_;
}
extern "C" {
    pub static bpf_map_offload_ops: bpf_map_ops;
}
pub const bpf_type_flag_PTR_MAYBE_NULL: bpf_type_flag = 256;
pub const bpf_type_flag_MEM_RDONLY: bpf_type_flag = 512;
pub const bpf_type_flag_MEM_ALLOC: bpf_type_flag = 1024;
pub const bpf_type_flag_MEM_USER: bpf_type_flag = 2048;
pub const bpf_type_flag_MEM_PERCPU: bpf_type_flag = 4096;
pub const bpf_type_flag_OBJ_RELEASE: bpf_type_flag = 8192;
pub const bpf_type_flag_PTR_UNTRUSTED: bpf_type_flag = 16384;
pub const bpf_type_flag_MEM_UNINIT: bpf_type_flag = 32768;
pub const bpf_type_flag_DYNPTR_TYPE_LOCAL: bpf_type_flag = 65536;
pub const bpf_type_flag_DYNPTR_TYPE_RINGBUF: bpf_type_flag = 131072;
pub const bpf_type_flag_MEM_FIXED_SIZE: bpf_type_flag = 262144;
pub const bpf_type_flag___BPF_TYPE_FLAG_MAX: bpf_type_flag = 262145;
pub const bpf_type_flag___BPF_TYPE_LAST_FLAG: bpf_type_flag = 262144;
pub type bpf_type_flag = core::ffi::c_uint;
pub const bpf_arg_type_ARG_DONTCARE: bpf_arg_type = 0;
pub const bpf_arg_type_ARG_CONST_MAP_PTR: bpf_arg_type = 1;
pub const bpf_arg_type_ARG_PTR_TO_MAP_KEY: bpf_arg_type = 2;
pub const bpf_arg_type_ARG_PTR_TO_MAP_VALUE: bpf_arg_type = 3;
pub const bpf_arg_type_ARG_PTR_TO_MEM: bpf_arg_type = 4;
pub const bpf_arg_type_ARG_CONST_SIZE: bpf_arg_type = 5;
pub const bpf_arg_type_ARG_CONST_SIZE_OR_ZERO: bpf_arg_type = 6;
pub const bpf_arg_type_ARG_PTR_TO_CTX: bpf_arg_type = 7;
pub const bpf_arg_type_ARG_ANYTHING: bpf_arg_type = 8;
pub const bpf_arg_type_ARG_PTR_TO_SPIN_LOCK: bpf_arg_type = 9;
pub const bpf_arg_type_ARG_PTR_TO_SOCK_COMMON: bpf_arg_type = 10;
pub const bpf_arg_type_ARG_PTR_TO_INT: bpf_arg_type = 11;
pub const bpf_arg_type_ARG_PTR_TO_LONG: bpf_arg_type = 12;
pub const bpf_arg_type_ARG_PTR_TO_SOCKET: bpf_arg_type = 13;
pub const bpf_arg_type_ARG_PTR_TO_BTF_ID: bpf_arg_type = 14;
pub const bpf_arg_type_ARG_PTR_TO_ALLOC_MEM: bpf_arg_type = 15;
pub const bpf_arg_type_ARG_CONST_ALLOC_SIZE_OR_ZERO: bpf_arg_type = 16;
pub const bpf_arg_type_ARG_PTR_TO_BTF_ID_SOCK_COMMON: bpf_arg_type = 17;
pub const bpf_arg_type_ARG_PTR_TO_PERCPU_BTF_ID: bpf_arg_type = 18;
pub const bpf_arg_type_ARG_PTR_TO_FUNC: bpf_arg_type = 19;
pub const bpf_arg_type_ARG_PTR_TO_STACK: bpf_arg_type = 20;
pub const bpf_arg_type_ARG_PTR_TO_CONST_STR: bpf_arg_type = 21;
pub const bpf_arg_type_ARG_PTR_TO_TIMER: bpf_arg_type = 22;
pub const bpf_arg_type_ARG_PTR_TO_KPTR: bpf_arg_type = 23;
pub const bpf_arg_type_ARG_PTR_TO_DYNPTR: bpf_arg_type = 24;
pub const bpf_arg_type___BPF_ARG_TYPE_MAX: bpf_arg_type = 25;
pub const bpf_arg_type_ARG_PTR_TO_MAP_VALUE_OR_NULL: bpf_arg_type = 259;
pub const bpf_arg_type_ARG_PTR_TO_MEM_OR_NULL: bpf_arg_type = 260;
pub const bpf_arg_type_ARG_PTR_TO_CTX_OR_NULL: bpf_arg_type = 263;
pub const bpf_arg_type_ARG_PTR_TO_SOCKET_OR_NULL: bpf_arg_type = 269;
pub const bpf_arg_type_ARG_PTR_TO_ALLOC_MEM_OR_NULL: bpf_arg_type = 271;
pub const bpf_arg_type_ARG_PTR_TO_STACK_OR_NULL: bpf_arg_type = 276;
pub const bpf_arg_type_ARG_PTR_TO_BTF_ID_OR_NULL: bpf_arg_type = 270;
pub const bpf_arg_type_ARG_PTR_TO_UNINIT_MEM: bpf_arg_type = 32772;
pub const bpf_arg_type_ARG_PTR_TO_FIXED_SIZE_MEM: bpf_arg_type = 262148;
pub const bpf_arg_type___BPF_ARG_TYPE_LIMIT: bpf_arg_type = 524287;
pub type bpf_arg_type = core::ffi::c_uint;
pub const bpf_return_type_RET_INTEGER: bpf_return_type = 0;
pub const bpf_return_type_RET_VOID: bpf_return_type = 1;
pub const bpf_return_type_RET_PTR_TO_MAP_VALUE: bpf_return_type = 2;
pub const bpf_return_type_RET_PTR_TO_SOCKET: bpf_return_type = 3;
pub const bpf_return_type_RET_PTR_TO_TCP_SOCK: bpf_return_type = 4;
pub const bpf_return_type_RET_PTR_TO_SOCK_COMMON: bpf_return_type = 5;
pub const bpf_return_type_RET_PTR_TO_ALLOC_MEM: bpf_return_type = 6;
pub const bpf_return_type_RET_PTR_TO_MEM_OR_BTF_ID: bpf_return_type = 7;
pub const bpf_return_type_RET_PTR_TO_BTF_ID: bpf_return_type = 8;
pub const bpf_return_type___BPF_RET_TYPE_MAX: bpf_return_type = 9;
pub const bpf_return_type_RET_PTR_TO_MAP_VALUE_OR_NULL: bpf_return_type = 258;
pub const bpf_return_type_RET_PTR_TO_SOCKET_OR_NULL: bpf_return_type = 259;
pub const bpf_return_type_RET_PTR_TO_TCP_SOCK_OR_NULL: bpf_return_type = 260;
pub const bpf_return_type_RET_PTR_TO_SOCK_COMMON_OR_NULL: bpf_return_type = 261;
pub const bpf_return_type_RET_PTR_TO_ALLOC_MEM_OR_NULL: bpf_return_type = 1286;
pub const bpf_return_type_RET_PTR_TO_DYNPTR_MEM_OR_NULL: bpf_return_type = 262;
pub const bpf_return_type_RET_PTR_TO_BTF_ID_OR_NULL: bpf_return_type = 264;
pub const bpf_return_type___BPF_RET_TYPE_LIMIT: bpf_return_type = 524287;
pub type bpf_return_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_proto {
    pub func: ::core::option::Option<
        unsafe extern "C" fn(r1: u64_, r2: u64_, r3: u64_, r4: u64_, r5: u64_) -> u64_,
    >,
    pub gpl_only: bool_,
    pub pkt_access: bool_,
    pub ret_type: bpf_return_type,
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_func_proto__bindgen_ty_2,
    pub ret_btf_id: *mut core::ffi::c_int,
    pub allowed: ::core::option::Option<unsafe extern "C" fn(prog: *const bpf_prog) -> bool_>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_func_proto__bindgen_ty_1 {
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_1__bindgen_ty_1,
    pub arg_type: [bpf_arg_type; 5usize],
    _bindgen_union_align: [u32; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_proto__bindgen_ty_1__bindgen_ty_1 {
    pub arg1_type: bpf_arg_type,
    pub arg2_type: bpf_arg_type,
    pub arg3_type: bpf_arg_type,
    pub arg4_type: bpf_arg_type,
    pub arg5_type: bpf_arg_type,
}
impl Default for bpf_func_proto__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_func_proto__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_func_proto__bindgen_ty_2 {
    pub __bindgen_anon_1: bpf_func_proto__bindgen_ty_2__bindgen_ty_1,
    pub arg_btf_id: [*mut u32_; 5usize],
    pub __bindgen_anon_2: bpf_func_proto__bindgen_ty_2__bindgen_ty_2,
    pub arg_size: [usize; 5usize],
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_func_proto__bindgen_ty_2__bindgen_ty_1 {
    pub arg1_btf_id: *mut u32_,
    pub arg2_btf_id: *mut u32_,
    pub arg3_btf_id: *mut u32_,
    pub arg4_btf_id: *mut u32_,
    pub arg5_btf_id: *mut u32_,
}
impl Default for bpf_func_proto__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_func_proto__bindgen_ty_2__bindgen_ty_2 {
    pub arg1_size: usize,
    pub arg2_size: usize,
    pub arg3_size: usize,
    pub arg4_size: usize,
    pub arg5_size: usize,
}
impl Default for bpf_func_proto__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_func_proto {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_context {
    _unused: [u8; 0],
}
pub const bpf_access_type_BPF_READ: bpf_access_type = 1;
pub const bpf_access_type_BPF_WRITE: bpf_access_type = 2;
pub type bpf_access_type = core::ffi::c_uint;
pub const bpf_reg_type_NOT_INIT: bpf_reg_type = 0;
pub const bpf_reg_type_SCALAR_VALUE: bpf_reg_type = 1;
pub const bpf_reg_type_PTR_TO_CTX: bpf_reg_type = 2;
pub const bpf_reg_type_CONST_PTR_TO_MAP: bpf_reg_type = 3;
pub const bpf_reg_type_PTR_TO_MAP_VALUE: bpf_reg_type = 4;
pub const bpf_reg_type_PTR_TO_MAP_KEY: bpf_reg_type = 5;
pub const bpf_reg_type_PTR_TO_STACK: bpf_reg_type = 6;
pub const bpf_reg_type_PTR_TO_PACKET_META: bpf_reg_type = 7;
pub const bpf_reg_type_PTR_TO_PACKET: bpf_reg_type = 8;
pub const bpf_reg_type_PTR_TO_PACKET_END: bpf_reg_type = 9;
pub const bpf_reg_type_PTR_TO_FLOW_KEYS: bpf_reg_type = 10;
pub const bpf_reg_type_PTR_TO_SOCKET: bpf_reg_type = 11;
pub const bpf_reg_type_PTR_TO_SOCK_COMMON: bpf_reg_type = 12;
pub const bpf_reg_type_PTR_TO_TCP_SOCK: bpf_reg_type = 13;
pub const bpf_reg_type_PTR_TO_TP_BUFFER: bpf_reg_type = 14;
pub const bpf_reg_type_PTR_TO_XDP_SOCK: bpf_reg_type = 15;
pub const bpf_reg_type_PTR_TO_BTF_ID: bpf_reg_type = 16;
pub const bpf_reg_type_PTR_TO_MEM: bpf_reg_type = 17;
pub const bpf_reg_type_PTR_TO_BUF: bpf_reg_type = 18;
pub const bpf_reg_type_PTR_TO_FUNC: bpf_reg_type = 19;
pub const bpf_reg_type_PTR_TO_DYNPTR: bpf_reg_type = 20;
pub const bpf_reg_type___BPF_REG_TYPE_MAX: bpf_reg_type = 21;
pub const bpf_reg_type_PTR_TO_MAP_VALUE_OR_NULL: bpf_reg_type = 260;
pub const bpf_reg_type_PTR_TO_SOCKET_OR_NULL: bpf_reg_type = 267;
pub const bpf_reg_type_PTR_TO_SOCK_COMMON_OR_NULL: bpf_reg_type = 268;
pub const bpf_reg_type_PTR_TO_TCP_SOCK_OR_NULL: bpf_reg_type = 269;
pub const bpf_reg_type_PTR_TO_BTF_ID_OR_NULL: bpf_reg_type = 272;
pub const bpf_reg_type___BPF_REG_TYPE_LIMIT: bpf_reg_type = 524287;
pub type bpf_reg_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_insn_access_aux {
    pub reg_type: bpf_reg_type,
    pub __bindgen_anon_1: bpf_insn_access_aux__bindgen_ty_1,
    pub log: *mut bpf_verifier_log,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_insn_access_aux__bindgen_ty_1 {
    pub ctx_field_size: core::ffi::c_int,
    pub __bindgen_anon_1: bpf_insn_access_aux__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_insn_access_aux__bindgen_ty_1__bindgen_ty_1 {
    pub btf: *mut btf,
    pub btf_id: u32_,
}
impl Default for bpf_insn_access_aux__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_insn_access_aux__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_insn_access_aux {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog_ops {
    pub test_run: ::core::option::Option<
        unsafe extern "C" fn(
            prog: *mut bpf_prog,
            kattr: *const bpf_attr,
            uattr: *mut bpf_attr,
        ) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_verifier_ops {
    pub get_func_proto: ::core::option::Option<
        unsafe extern "C" fn(func_id: bpf_func_id, prog: *const bpf_prog) -> *const bpf_func_proto,
    >,
    pub is_valid_access: ::core::option::Option<
        unsafe extern "C" fn(
            off: core::ffi::c_int,
            size: core::ffi::c_int,
            type_: bpf_access_type,
            prog: *const bpf_prog,
            info: *mut bpf_insn_access_aux,
        ) -> bool_,
    >,
    pub gen_prologue: ::core::option::Option<
        unsafe extern "C" fn(
            insn: *mut bpf_insn,
            direct_write: bool_,
            prog: *const bpf_prog,
        ) -> core::ffi::c_int,
    >,
    pub gen_ld_abs: ::core::option::Option<
        unsafe extern "C" fn(orig: *const bpf_insn, insn_buf: *mut bpf_insn) -> core::ffi::c_int,
    >,
    pub convert_ctx_access: ::core::option::Option<
        unsafe extern "C" fn(
            type_: bpf_access_type,
            src: *const bpf_insn,
            dst: *mut bpf_insn,
            prog: *mut bpf_prog,
            target_size: *mut u32_,
        ) -> u32_,
    >,
    pub btf_struct_access: ::core::option::Option<
        unsafe extern "C" fn(
            log: *mut bpf_verifier_log,
            btf: *const btf,
            t: *const btf_type,
            off: core::ffi::c_int,
            size: core::ffi::c_int,
            atype: bpf_access_type,
            next_btf_id: *mut u32_,
            flag: *mut bpf_type_flag,
        ) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog_offload_ops {
    pub insn_hook: ::core::option::Option<
        unsafe extern "C" fn(
            env: *mut bpf_verifier_env,
            insn_idx: core::ffi::c_int,
            prev_insn_idx: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    pub finalize: ::core::option::Option<
        unsafe extern "C" fn(env: *mut bpf_verifier_env) -> core::ffi::c_int,
    >,
    pub replace_insn: ::core::option::Option<
        unsafe extern "C" fn(
            env: *mut bpf_verifier_env,
            off: u32_,
            insn: *mut bpf_insn,
        ) -> core::ffi::c_int,
    >,
    pub remove_insns: ::core::option::Option<
        unsafe extern "C" fn(env: *mut bpf_verifier_env, off: u32_, cnt: u32_) -> core::ffi::c_int,
    >,
    pub prepare:
        ::core::option::Option<unsafe extern "C" fn(prog: *mut bpf_prog) -> core::ffi::c_int>,
    pub translate:
        ::core::option::Option<unsafe extern "C" fn(prog: *mut bpf_prog) -> core::ffi::c_int>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(prog: *mut bpf_prog)>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_offload {
    pub prog: *mut bpf_prog,
    pub netdev: *mut net_device,
    pub offdev: *mut bpf_offload_dev,
    pub dev_priv: *mut core::ffi::c_void,
    pub offloads: list_head,
    pub dev_state: bool_,
    pub opt_failed: bool_,
    pub jited_image: *mut core::ffi::c_void,
    pub jited_len: u32_,
}
impl Default for bpf_prog_offload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const bpf_cgroup_storage_type_BPF_CGROUP_STORAGE_SHARED: bpf_cgroup_storage_type = 0;
pub const bpf_cgroup_storage_type_BPF_CGROUP_STORAGE_PERCPU: bpf_cgroup_storage_type = 1;
pub const bpf_cgroup_storage_type___BPF_CGROUP_STORAGE_MAX: bpf_cgroup_storage_type = 2;
pub type bpf_cgroup_storage_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_func_model {
    pub ret_size: u8_,
    pub nr_args: u8_,
    pub arg_size: [u8_; 12usize],
    pub arg_flags: [u8_; 12usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tramp_links {
    pub links: [*mut bpf_tramp_link; 38usize],
    pub nr_links: core::ffi::c_int,
}
impl Default for bpf_tramp_links {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn arch_prepare_bpf_trampoline(
        tr: *mut bpf_tramp_image,
        image: *mut core::ffi::c_void,
        image_end: *mut core::ffi::c_void,
        m: *const btf_func_model,
        flags: u32_,
        tlinks: *mut bpf_tramp_links,
        orig_call: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __bpf_prog_enter(prog: *mut bpf_prog, run_ctx: *mut bpf_tramp_run_ctx) -> u64_;
}
extern "C" {
    pub fn __bpf_prog_exit(prog: *mut bpf_prog, start: u64_, run_ctx: *mut bpf_tramp_run_ctx);
}
extern "C" {
    pub fn __bpf_prog_enter_sleepable(prog: *mut bpf_prog, run_ctx: *mut bpf_tramp_run_ctx)
        -> u64_;
}
extern "C" {
    pub fn __bpf_prog_exit_sleepable(
        prog: *mut bpf_prog,
        start: u64_,
        run_ctx: *mut bpf_tramp_run_ctx,
    );
}
extern "C" {
    pub fn __bpf_prog_enter_lsm_cgroup(
        prog: *mut bpf_prog,
        run_ctx: *mut bpf_tramp_run_ctx,
    ) -> u64_;
}
extern "C" {
    pub fn __bpf_prog_exit_lsm_cgroup(
        prog: *mut bpf_prog,
        start: u64_,
        run_ctx: *mut bpf_tramp_run_ctx,
    );
}
extern "C" {
    pub fn __bpf_prog_enter_struct_ops(
        prog: *mut bpf_prog,
        run_ctx: *mut bpf_tramp_run_ctx,
    ) -> u64_;
}
extern "C" {
    pub fn __bpf_prog_exit_struct_ops(
        prog: *mut bpf_prog,
        start: u64_,
        run_ctx: *mut bpf_tramp_run_ctx,
    );
}
extern "C" {
    pub fn __bpf_tramp_enter(tr: *mut bpf_tramp_image);
}
extern "C" {
    pub fn __bpf_tramp_exit(tr: *mut bpf_tramp_image);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_ksym {
    pub start: core::ffi::c_ulong,
    pub end: core::ffi::c_ulong,
    pub name: [core::ffi::c_char; 512usize],
    pub lnode: list_head,
    pub tnode: latch_tree_node,
    pub prog: bool_,
}
impl Default for bpf_ksym {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const bpf_tramp_prog_type_BPF_TRAMP_FENTRY: bpf_tramp_prog_type = 0;
pub const bpf_tramp_prog_type_BPF_TRAMP_FEXIT: bpf_tramp_prog_type = 1;
pub const bpf_tramp_prog_type_BPF_TRAMP_MODIFY_RETURN: bpf_tramp_prog_type = 2;
pub const bpf_tramp_prog_type_BPF_TRAMP_MAX: bpf_tramp_prog_type = 3;
pub const bpf_tramp_prog_type_BPF_TRAMP_REPLACE: bpf_tramp_prog_type = 4;
pub type bpf_tramp_prog_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tramp_image {
    pub image: *mut core::ffi::c_void,
    pub ksym: bpf_ksym,
    pub pcref: percpu_ref,
    pub ip_after_call: *mut core::ffi::c_void,
    pub ip_epilogue: *mut core::ffi::c_void,
    pub __bindgen_anon_1: bpf_tramp_image__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_tramp_image__bindgen_ty_1 {
    pub rcu: callback_head,
    pub work: work_struct,
    _bindgen_union_align: [u64; 4usize],
}
impl Default for bpf_tramp_image__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_tramp_image {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_trampoline {
    pub hlist: hlist_node,
    pub fops: *mut ftrace_ops,
    pub mutex: mutex,
    pub refcnt: refcount_t,
    pub flags: u32_,
    pub key: u64_,
    pub func: bpf_trampoline__bindgen_ty_1,
    pub extension_prog: *mut bpf_prog,
    pub progs_hlist: [hlist_head; 3usize],
    pub progs_cnt: [core::ffi::c_int; 3usize],
    pub cur_image: *mut bpf_tramp_image,
    pub selector: u64_,
    pub mod_: *mut module,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_trampoline__bindgen_ty_1 {
    pub model: btf_func_model,
    pub addr: *mut core::ffi::c_void,
    pub ftrace_managed: bool_,
}
impl Default for bpf_trampoline__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_trampoline {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_attach_target_info {
    pub fmodel: btf_func_model,
    pub tgt_addr: core::ffi::c_long,
    pub tgt_name: *const core::ffi::c_char,
    pub tgt_type: *const btf_type,
}
impl Default for bpf_attach_target_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_dispatcher_prog {
    pub prog: *mut bpf_prog,
    pub users: refcount_t,
}
impl Default for bpf_dispatcher_prog {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_dispatcher {
    pub mutex: mutex,
    pub func: *mut core::ffi::c_void,
    pub progs: [bpf_dispatcher_prog; 48usize],
    pub num_progs: core::ffi::c_int,
    pub image: *mut core::ffi::c_void,
    pub rw_image: *mut core::ffi::c_void,
    pub image_off: u32_,
    pub ksym: bpf_ksym,
}
impl Default for bpf_dispatcher {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_func_info_aux {
    pub linkage: u16_,
    pub unreliable: bool_,
}
pub const bpf_jit_poke_reason_BPF_POKE_REASON_TAIL_CALL: bpf_jit_poke_reason = 0;
pub type bpf_jit_poke_reason = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_jit_poke_descriptor {
    pub tailcall_target: *mut core::ffi::c_void,
    pub tailcall_bypass: *mut core::ffi::c_void,
    pub bypass_addr: *mut core::ffi::c_void,
    pub aux: *mut core::ffi::c_void,
    pub __bindgen_anon_1: bpf_jit_poke_descriptor__bindgen_ty_1,
    pub tailcall_target_stable: bool_,
    pub adj_off: u8_,
    pub reason: u16_,
    pub insn_idx: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_jit_poke_descriptor__bindgen_ty_1 {
    pub tail_call: bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1 {
    pub map: *mut bpf_map,
    pub key: u32_,
}
impl Default for bpf_jit_poke_descriptor__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_jit_poke_descriptor__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_jit_poke_descriptor {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_ctx_arg_aux {
    pub offset: u32_,
    pub reg_type: bpf_reg_type,
    pub btf_id: u32_,
}
impl Default for bpf_ctx_arg_aux {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct btf_mod_pair {
    pub btf: *mut btf,
    pub module: *mut module,
}
impl Default for btf_mod_pair {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_kfunc_desc_tab {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_aux {
    pub refcnt: atomic64_t,
    pub used_map_cnt: u32_,
    pub used_btf_cnt: u32_,
    pub max_ctx_offset: u32_,
    pub max_pkt_offset: u32_,
    pub max_tp_access: u32_,
    pub stack_depth: u32_,
    pub id: u32_,
    pub func_cnt: u32_,
    pub func_idx: u32_,
    pub attach_btf_id: u32_,
    pub ctx_arg_info_size: u32_,
    pub max_rdonly_access: u32_,
    pub max_rdwr_access: u32_,
    pub attach_btf: *mut btf,
    pub ctx_arg_info: *const bpf_ctx_arg_aux,
    pub dst_mutex: mutex,
    pub dst_prog: *mut bpf_prog,
    pub dst_trampoline: *mut bpf_trampoline,
    pub saved_dst_prog_type: bpf_prog_type,
    pub saved_dst_attach_type: bpf_attach_type,
    pub verifier_zext: bool_,
    pub offload_requested: bool_,
    pub attach_btf_trace: bool_,
    pub func_proto_unreliable: bool_,
    pub sleepable: bool_,
    pub tail_call_reachable: bool_,
    pub xdp_has_frags: bool_,
    pub attach_func_proto: *const btf_type,
    pub attach_func_name: *const core::ffi::c_char,
    pub func: *mut *mut bpf_prog,
    pub jit_data: *mut core::ffi::c_void,
    pub poke_tab: *mut bpf_jit_poke_descriptor,
    pub kfunc_tab: *mut bpf_kfunc_desc_tab,
    pub kfunc_btf_tab: *mut bpf_kfunc_btf_tab,
    pub size_poke_tab: u32_,
    pub ksym: bpf_ksym,
    pub ops: *const bpf_prog_ops,
    pub used_maps: *mut *mut bpf_map,
    pub used_maps_mutex: mutex,
    pub used_btfs: *mut btf_mod_pair,
    pub prog: *mut bpf_prog,
    pub user: *mut user_struct,
    pub load_time: u64_,
    pub verified_insns: u32_,
    pub cgroup_atype: core::ffi::c_int,
    pub cgroup_storage: [*mut bpf_map; 2usize],
    pub name: [core::ffi::c_char; 16usize],
    pub security: *mut core::ffi::c_void,
    pub offload: *mut bpf_prog_offload,
    pub btf: *mut btf,
    pub func_info: *mut bpf_func_info,
    pub func_info_aux: *mut bpf_func_info_aux,
    pub linfo: *mut bpf_line_info,
    pub jited_linfo: *mut *mut core::ffi::c_void,
    pub func_info_cnt: u32_,
    pub nr_linfo: u32_,
    pub linfo_idx: u32_,
    pub num_exentries: u32_,
    pub extable: *mut exception_table_entry,
    pub __bindgen_anon_1: bpf_prog_aux__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_prog_aux__bindgen_ty_1 {
    pub work: work_struct,
    pub rcu: callback_head,
    _bindgen_union_align: [u64; 4usize],
}
impl Default for bpf_prog_aux__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_prog_aux {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct bpf_prog {
    pub pages: u16_,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub type_: bpf_prog_type,
    pub expected_attach_type: bpf_attach_type,
    pub len: u32_,
    pub jited_len: u32_,
    pub tag: [u8_; 8usize],
    pub stats: *mut bpf_prog_stats,
    pub active: *mut core::ffi::c_int,
    pub bpf_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *const core::ffi::c_void,
            insn: *const bpf_insn,
        ) -> core::ffi::c_uint,
    >,
    pub aux: *mut bpf_prog_aux,
    pub orig_prog: *mut sock_fprog_kern,
    pub __bindgen_anon_1: bpf_prog__bindgen_ty_1,
}
#[repr(C)]
pub struct bpf_prog__bindgen_ty_1 {
    pub __bindgen_anon_1: __BindgenUnionField<bpf_prog__bindgen_ty_1__bindgen_ty_1>,
    pub __bindgen_anon_2: __BindgenUnionField<bpf_prog__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 0usize],
}
#[repr(C)]
#[derive(Default)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_1 {
    pub __empty_insns: bpf_prog__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub insns: __IncompleteArrayField<sock_filter>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {}
#[repr(C)]
#[derive(Default)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_2 {
    pub __empty_insnsi: bpf_prog__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub insnsi: __IncompleteArrayField<bpf_insn>,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {}
impl Default for bpf_prog__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_prog {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_prog {
    #[inline]
    pub fn jited(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_jited(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn jit_requested(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_jit_requested(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn gpl_compatible(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_gpl_compatible(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cb_access(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_cb_access(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dst_needed(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_dst_needed(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blinding_requested(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_blinding_requested(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn blinded(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_blinded(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_func(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_is_func(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn kprobe_override(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_kprobe_override(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_callchain_buf(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_has_callchain_buf(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enforce_expected_attach_type(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_enforce_expected_attach_type(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn call_get_stack(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_call_get_stack(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn call_get_func_ip(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_call_get_func_ip(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tstamp_type_access(&self) -> u16_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_tstamp_type_access(&mut self, val: u16_) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        jited: u16_,
        jit_requested: u16_,
        gpl_compatible: u16_,
        cb_access: u16_,
        dst_needed: u16_,
        blinding_requested: u16_,
        blinded: u16_,
        is_func: u16_,
        kprobe_override: u16_,
        has_callchain_buf: u16_,
        enforce_expected_attach_type: u16_,
        call_get_stack: u16_,
        call_get_func_ip: u16_,
        tstamp_type_access: u16_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let jited: u16 = unsafe { ::core::mem::transmute(jited) };
            jited as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let jit_requested: u16 = unsafe { ::core::mem::transmute(jit_requested) };
            jit_requested as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let gpl_compatible: u16 = unsafe { ::core::mem::transmute(gpl_compatible) };
            gpl_compatible as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let cb_access: u16 = unsafe { ::core::mem::transmute(cb_access) };
            cb_access as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let dst_needed: u16 = unsafe { ::core::mem::transmute(dst_needed) };
            dst_needed as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let blinding_requested: u16 = unsafe { ::core::mem::transmute(blinding_requested) };
            blinding_requested as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let blinded: u16 = unsafe { ::core::mem::transmute(blinded) };
            blinded as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let is_func: u16 = unsafe { ::core::mem::transmute(is_func) };
            is_func as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let kprobe_override: u16 = unsafe { ::core::mem::transmute(kprobe_override) };
            kprobe_override as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let has_callchain_buf: u16 = unsafe { ::core::mem::transmute(has_callchain_buf) };
            has_callchain_buf as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let enforce_expected_attach_type: u16 =
                unsafe { ::core::mem::transmute(enforce_expected_attach_type) };
            enforce_expected_attach_type as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let call_get_stack: u16 = unsafe { ::core::mem::transmute(call_get_stack) };
            call_get_stack as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let call_get_func_ip: u16 = unsafe { ::core::mem::transmute(call_get_func_ip) };
            call_get_func_ip as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let tstamp_type_access: u16 = unsafe { ::core::mem::transmute(tstamp_type_access) };
            tstamp_type_access as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_array_aux {
    pub poke_progs: list_head,
    pub map: *mut bpf_map,
    pub poke_mutex: mutex,
    pub work: work_struct,
}
impl Default for bpf_array_aux {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link {
    pub refcnt: atomic64_t,
    pub id: u32_,
    pub type_: bpf_link_type,
    pub ops: *const bpf_link_ops,
    pub prog: *mut bpf_prog,
    pub work: work_struct,
}
impl Default for bpf_link {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_link_ops {
    pub release: ::core::option::Option<unsafe extern "C" fn(link: *mut bpf_link)>,
    pub dealloc: ::core::option::Option<unsafe extern "C" fn(link: *mut bpf_link)>,
    pub detach:
        ::core::option::Option<unsafe extern "C" fn(link: *mut bpf_link) -> core::ffi::c_int>,
    pub update_prog: ::core::option::Option<
        unsafe extern "C" fn(
            link: *mut bpf_link,
            new_prog: *mut bpf_prog,
            old_prog: *mut bpf_prog,
        ) -> core::ffi::c_int,
    >,
    pub show_fdinfo:
        ::core::option::Option<unsafe extern "C" fn(link: *const bpf_link, seq: *mut seq_file)>,
    pub fill_link_info: ::core::option::Option<
        unsafe extern "C" fn(link: *const bpf_link, info: *mut bpf_link_info) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tramp_link {
    pub link: bpf_link,
    pub tramp_hlist: hlist_node,
    pub cookie: u64_,
}
impl Default for bpf_tramp_link {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_shim_tramp_link {
    pub link: bpf_tramp_link,
    pub trampoline: *mut bpf_trampoline,
}
impl Default for bpf_shim_tramp_link {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tracing_link {
    pub link: bpf_tramp_link,
    pub attach_type: bpf_attach_type,
    pub trampoline: *mut bpf_trampoline,
    pub tgt_prog: *mut bpf_prog,
}
impl Default for bpf_tracing_link {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_link_primer {
    pub link: *mut bpf_link,
    pub file: *mut file,
    pub fd: core::ffi::c_int,
    pub id: u32_,
}
impl Default for bpf_link_primer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_struct_ops_value {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_struct_ops {
    pub verifier_ops: *const bpf_verifier_ops,
    pub init: ::core::option::Option<unsafe extern "C" fn(btf: *mut btf) -> core::ffi::c_int>,
    pub check_member: ::core::option::Option<
        unsafe extern "C" fn(t: *const btf_type, member: *const btf_member) -> core::ffi::c_int,
    >,
    pub init_member: ::core::option::Option<
        unsafe extern "C" fn(
            t: *const btf_type,
            member: *const btf_member,
            kdata: *mut core::ffi::c_void,
            udata: *const core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub reg: ::core::option::Option<
        unsafe extern "C" fn(kdata: *mut core::ffi::c_void) -> core::ffi::c_int,
    >,
    pub unreg: ::core::option::Option<unsafe extern "C" fn(kdata: *mut core::ffi::c_void)>,
    pub type_: *const btf_type,
    pub value_type: *const btf_type,
    pub name: *const core::ffi::c_char,
    pub func_models: [btf_func_model; 64usize],
    pub type_id: u32_,
    pub value_id: u32_,
}
impl Default for bpf_struct_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct bpf_array {
    pub map: bpf_map,
    pub elem_size: u32_,
    pub index_mask: u32_,
    pub aux: *mut bpf_array_aux,
    pub __bindgen_anon_1: bpf_array__bindgen_ty_1,
}
#[repr(C)]
pub struct bpf_array__bindgen_ty_1 {
    pub value: __BindgenUnionField<[core::ffi::c_char; 0usize]>,
    pub ptrs: __BindgenUnionField<[*mut core::ffi::c_void; 0usize]>,
    pub pptrs: __BindgenUnionField<[*mut core::ffi::c_void; 0usize]>,
    pub bindgen_union_field: [u64; 0usize],
}
impl Default for bpf_array__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_array {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_event_entry {
    pub event: *mut perf_event,
    pub perf_file: *mut file,
    pub map_file: *mut file,
    pub rcu: callback_head,
}
impl Default for bpf_event_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn bpf_prog_map_compatible(map: *mut bpf_map, fp: *const bpf_prog) -> bool_;
}
extern "C" {
    pub fn bpf_prog_calc_tag(fp: *mut bpf_prog) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_get_trace_printk_proto() -> *const bpf_func_proto;
}
extern "C" {
    pub fn bpf_get_trace_vprintk_proto() -> *const bpf_func_proto;
}
pub type bpf_ctx_copy_t = ::core::option::Option<
    unsafe extern "C" fn(
        dst: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        off: core::ffi::c_ulong,
        len: core::ffi::c_ulong,
    ) -> core::ffi::c_ulong,
>;
pub type bpf_convert_ctx_access_t = ::core::option::Option<
    unsafe extern "C" fn(
        type_: bpf_access_type,
        src: *const bpf_insn,
        dst: *mut bpf_insn,
        prog: *mut bpf_prog,
        target_size: *mut u32_,
    ) -> u32_,
>;
extern "C" {
    pub fn bpf_event_output(
        map: *mut bpf_map,
        flags: u64_,
        meta: *mut core::ffi::c_void,
        meta_size: u64_,
        ctx: *mut core::ffi::c_void,
        ctx_size: u64_,
        ctx_copy: bpf_ctx_copy_t,
    ) -> u64_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_array_item {
    pub prog: *mut bpf_prog,
    pub __bindgen_anon_1: bpf_prog_array_item__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_prog_array_item__bindgen_ty_1 {
    pub cgroup_storage: [*mut bpf_cgroup_storage; 2usize],
    pub bpf_cookie: u64_,
    _bindgen_union_align: [u64; 2usize],
}
impl Default for bpf_prog_array_item__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_prog_array_item {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct bpf_prog_array {
    pub rcu: callback_head,
    pub items: __IncompleteArrayField<bpf_prog_array_item>,
}
impl Default for bpf_prog_array {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct bpf_empty_prog_array {
    pub hdr: bpf_prog_array,
    pub null_prog: *mut bpf_prog,
}
impl Default for bpf_empty_prog_array {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut bpf_empty_prog_array: bpf_empty_prog_array;
}
extern "C" {
    pub fn bpf_prog_array_alloc(prog_cnt: u32_, flags: gfp_t) -> *mut bpf_prog_array;
}
extern "C" {
    pub fn bpf_prog_array_free(progs: *mut bpf_prog_array);
}
extern "C" {
    pub fn bpf_prog_array_free_sleepable(progs: *mut bpf_prog_array);
}
extern "C" {
    pub fn bpf_prog_array_length(progs: *mut bpf_prog_array) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_array_is_empty(array: *mut bpf_prog_array) -> bool_;
}
extern "C" {
    pub fn bpf_prog_array_copy_to_user(
        progs: *mut bpf_prog_array,
        prog_ids: *mut __u32,
        cnt: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_array_delete_safe(progs: *mut bpf_prog_array, old_prog: *mut bpf_prog);
}
extern "C" {
    pub fn bpf_prog_array_delete_safe_at(
        array: *mut bpf_prog_array,
        index: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_array_update_at(
        array: *mut bpf_prog_array,
        index: core::ffi::c_int,
        prog: *mut bpf_prog,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_array_copy_info(
        array: *mut bpf_prog_array,
        prog_ids: *mut u32_,
        request_cnt: u32_,
        prog_cnt: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_array_copy(
        old_array: *mut bpf_prog_array,
        exclude_prog: *mut bpf_prog,
        include_prog: *mut bpf_prog,
        bpf_cookie: u64_,
        new_array: *mut *mut bpf_prog_array,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_run_ctx {}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cg_run_ctx {
    pub run_ctx: bpf_run_ctx,
    pub prog_item: *const bpf_prog_array_item,
    pub retval: core::ffi::c_int,
}
impl Default for bpf_cg_run_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_trace_run_ctx {
    pub run_ctx: bpf_run_ctx,
    pub bpf_cookie: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_tramp_run_ctx {
    pub run_ctx: bpf_run_ctx,
    pub bpf_cookie: u64_,
    pub saved_run_ctx: *mut bpf_run_ctx,
}
impl Default for bpf_tramp_run_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type bpf_prog_run_fn = ::core::option::Option<
    unsafe extern "C" fn(prog: *const bpf_prog, ctx: *const core::ffi::c_void) -> u32_,
>;
extern "C" {
    pub static mut bpf_prog_active: core::ffi::c_int;
}
extern "C" {
    pub static mut bpf_stats_enabled_mutex: mutex;
}
extern "C" {
    pub static bpf_map_fops: file_operations;
}
extern "C" {
    pub static bpf_prog_fops: file_operations;
}
extern "C" {
    pub static bpf_iter_fops: file_operations;
}
extern "C" {
    pub static sk_filter_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static sk_filter_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static tc_cls_act_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static tc_cls_act_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static xdp_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static xdp_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static cg_skb_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static cg_skb_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static cg_sock_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static cg_sock_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static cg_sock_addr_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static cg_sock_addr_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static lwt_in_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static lwt_in_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static lwt_out_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static lwt_out_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static lwt_xmit_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static lwt_xmit_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static lwt_seg6local_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static lwt_seg6local_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static sock_ops_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static sock_ops_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static sk_skb_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static sk_skb_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static sk_msg_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static sk_msg_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static flow_dissector_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static flow_dissector_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static cg_dev_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static cg_dev_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static cg_sysctl_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static cg_sysctl_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static cg_sockopt_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static cg_sockopt_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static sk_reuseport_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static sk_reuseport_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static sk_lookup_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static sk_lookup_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static bpf_syscall_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static bpf_syscall_verifier_ops: bpf_verifier_ops;
}
extern "C" {
    pub static array_map_ops: bpf_map_ops;
}
extern "C" {
    pub static percpu_array_map_ops: bpf_map_ops;
}
extern "C" {
    pub static prog_array_map_ops: bpf_map_ops;
}
extern "C" {
    pub static perf_event_array_map_ops: bpf_map_ops;
}
extern "C" {
    pub static cgroup_array_map_ops: bpf_map_ops;
}
extern "C" {
    pub static cgroup_storage_map_ops: bpf_map_ops;
}
extern "C" {
    pub static htab_map_ops: bpf_map_ops;
}
extern "C" {
    pub static htab_percpu_map_ops: bpf_map_ops;
}
extern "C" {
    pub static htab_lru_map_ops: bpf_map_ops;
}
extern "C" {
    pub static htab_lru_percpu_map_ops: bpf_map_ops;
}
extern "C" {
    pub static trie_map_ops: bpf_map_ops;
}
extern "C" {
    pub static stack_trace_map_ops: bpf_map_ops;
}
extern "C" {
    pub static array_of_maps_map_ops: bpf_map_ops;
}
extern "C" {
    pub static htab_of_maps_map_ops: bpf_map_ops;
}
extern "C" {
    pub static task_storage_map_ops: bpf_map_ops;
}
extern "C" {
    pub static dev_map_ops: bpf_map_ops;
}
extern "C" {
    pub static dev_map_hash_ops: bpf_map_ops;
}
extern "C" {
    pub static sk_storage_map_ops: bpf_map_ops;
}
extern "C" {
    pub static cpu_map_ops: bpf_map_ops;
}
extern "C" {
    pub static sock_map_ops: bpf_map_ops;
}
extern "C" {
    pub static sock_hash_ops: bpf_map_ops;
}
extern "C" {
    pub static reuseport_array_ops: bpf_map_ops;
}
extern "C" {
    pub static queue_map_ops: bpf_map_ops;
}
extern "C" {
    pub static stack_map_ops: bpf_map_ops;
}
extern "C" {
    pub static ringbuf_map_ops: bpf_map_ops;
}
extern "C" {
    pub static bloom_filter_map_ops: bpf_map_ops;
}
extern "C" {
    pub static user_ringbuf_map_ops: bpf_map_ops;
}
extern "C" {
    pub static bpf_offload_prog_ops: bpf_prog_ops;
}
extern "C" {
    pub static tc_cls_act_analyzer_ops: bpf_verifier_ops;
}
extern "C" {
    pub static xdp_analyzer_ops: bpf_verifier_ops;
}
extern "C" {
    pub fn bpf_prog_get(ufd: u32_) -> *mut bpf_prog;
}
extern "C" {
    pub fn bpf_prog_get_type_dev(
        ufd: u32_,
        type_: bpf_prog_type,
        attach_drv: bool_,
    ) -> *mut bpf_prog;
}
extern "C" {
    pub fn bpf_prog_add(prog: *mut bpf_prog, i: core::ffi::c_int);
}
extern "C" {
    pub fn bpf_prog_sub(prog: *mut bpf_prog, i: core::ffi::c_int);
}
extern "C" {
    pub fn bpf_prog_inc(prog: *mut bpf_prog);
}
extern "C" {
    pub fn bpf_prog_inc_not_zero(prog: *mut bpf_prog) -> *mut bpf_prog;
}
extern "C" {
    pub fn bpf_prog_put(prog: *mut bpf_prog);
}
extern "C" {
    pub fn bpf_prog_free_id(prog: *mut bpf_prog, do_idr_lock: bool_);
}
extern "C" {
    pub fn bpf_map_free_id(map: *mut bpf_map, do_idr_lock: bool_);
}
extern "C" {
    pub fn bpf_map_kptr_off_contains(
        map: *mut bpf_map,
        offset: u32_,
    ) -> *mut bpf_map_value_off_desc;
}
extern "C" {
    pub fn bpf_map_free_kptr_off_tab(map: *mut bpf_map);
}
extern "C" {
    pub fn bpf_map_copy_kptr_off_tab(map: *const bpf_map) -> *mut bpf_map_value_off;
}
extern "C" {
    pub fn bpf_map_equal_kptr_off_tab(map_a: *const bpf_map, map_b: *const bpf_map) -> bool_;
}
extern "C" {
    pub fn bpf_map_free_kptrs(map: *mut bpf_map, map_value: *mut core::ffi::c_void);
}
extern "C" {
    pub fn bpf_map_get(ufd: u32_) -> *mut bpf_map;
}
extern "C" {
    pub fn bpf_map_get_with_uref(ufd: u32_) -> *mut bpf_map;
}
extern "C" {
    pub fn __bpf_map_get(f: fd) -> *mut bpf_map;
}
extern "C" {
    pub fn bpf_map_inc(map: *mut bpf_map);
}
extern "C" {
    pub fn bpf_map_inc_with_uref(map: *mut bpf_map);
}
extern "C" {
    pub fn bpf_map_inc_not_zero(map: *mut bpf_map) -> *mut bpf_map;
}
extern "C" {
    pub fn bpf_map_put_with_uref(map: *mut bpf_map);
}
extern "C" {
    pub fn bpf_map_put(map: *mut bpf_map);
}
extern "C" {
    pub fn bpf_map_area_alloc(size: u64_, numa_node: core::ffi::c_int) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn bpf_map_area_mmapable_alloc(
        size: u64_,
        numa_node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn bpf_map_area_free(base: *mut core::ffi::c_void);
}
extern "C" {
    pub fn bpf_map_write_active(map: *const bpf_map) -> bool_;
}
extern "C" {
    pub fn bpf_map_init_from_attr(map: *mut bpf_map, attr: *mut bpf_attr);
}
extern "C" {
    pub fn generic_map_lookup_batch(
        map: *mut bpf_map,
        attr: *const bpf_attr,
        uattr: *mut bpf_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_map_update_batch(
        map: *mut bpf_map,
        attr: *const bpf_attr,
        uattr: *mut bpf_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn generic_map_delete_batch(
        map: *mut bpf_map,
        attr: *const bpf_attr,
        uattr: *mut bpf_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_map_get_curr_or_next(id: *mut u32_) -> *mut bpf_map;
}
extern "C" {
    pub fn bpf_prog_get_curr_or_next(id: *mut u32_) -> *mut bpf_prog;
}
extern "C" {
    pub fn bpf_map_kmalloc_node(
        map: *const bpf_map,
        size: usize,
        flags: gfp_t,
        node: core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn bpf_map_kzalloc(
        map: *const bpf_map,
        size: usize,
        flags: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn bpf_map_alloc_percpu(
        map: *const bpf_map,
        size: usize,
        align: usize,
        flags: gfp_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub static mut sysctl_unprivileged_bpf_disabled: core::ffi::c_int;
}
extern "C" {
    pub fn bpf_map_new_fd(map: *mut bpf_map, flags: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_new_fd(prog: *mut bpf_prog) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_link_init(
        link: *mut bpf_link,
        type_: bpf_link_type,
        ops: *const bpf_link_ops,
        prog: *mut bpf_prog,
    );
}
extern "C" {
    pub fn bpf_link_prime(link: *mut bpf_link, primer: *mut bpf_link_primer) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_link_settle(primer: *mut bpf_link_primer) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_link_cleanup(primer: *mut bpf_link_primer);
}
extern "C" {
    pub fn bpf_link_inc(link: *mut bpf_link);
}
extern "C" {
    pub fn bpf_link_put(link: *mut bpf_link);
}
extern "C" {
    pub fn bpf_link_new_fd(link: *mut bpf_link) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_link_new_file(link: *mut bpf_link, reserved_fd: *mut core::ffi::c_int) -> *mut file;
}
extern "C" {
    pub fn bpf_link_get_from_fd(ufd: u32_) -> *mut bpf_link;
}
extern "C" {
    pub fn bpf_link_get_curr_or_next(id: *mut u32_) -> *mut bpf_link;
}
extern "C" {
    pub fn bpf_obj_pin_user(ufd: u32_, pathname: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_obj_get_user(
        pathname: *const core::ffi::c_char,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
pub const bpf_iter_task_type_BPF_TASK_ITER_ALL: bpf_iter_task_type = 0;
pub const bpf_iter_task_type_BPF_TASK_ITER_TID: bpf_iter_task_type = 1;
pub const bpf_iter_task_type_BPF_TASK_ITER_TGID: bpf_iter_task_type = 2;
pub type bpf_iter_task_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_aux_info {
    pub map: *mut bpf_map,
    pub cgroup: bpf_iter_aux_info__bindgen_ty_1,
    pub task: bpf_iter_aux_info__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_aux_info__bindgen_ty_1 {
    pub start: *mut cgroup,
    pub order: bpf_cgroup_iter_order,
}
impl Default for bpf_iter_aux_info__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_aux_info__bindgen_ty_2 {
    pub type_: bpf_iter_task_type,
    pub pid: u32_,
}
impl Default for bpf_iter_aux_info__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_iter_aux_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type bpf_iter_attach_target_t = ::core::option::Option<
    unsafe extern "C" fn(
        prog: *mut bpf_prog,
        linfo: *mut bpf_iter_link_info,
        aux: *mut bpf_iter_aux_info,
    ) -> core::ffi::c_int,
>;
pub type bpf_iter_detach_target_t =
    ::core::option::Option<unsafe extern "C" fn(aux: *mut bpf_iter_aux_info)>;
pub type bpf_iter_show_fdinfo_t =
    ::core::option::Option<unsafe extern "C" fn(aux: *const bpf_iter_aux_info, seq: *mut seq_file)>;
pub type bpf_iter_fill_link_info_t = ::core::option::Option<
    unsafe extern "C" fn(
        aux: *const bpf_iter_aux_info,
        info: *mut bpf_link_info,
    ) -> core::ffi::c_int,
>;
pub type bpf_iter_get_func_proto_t = ::core::option::Option<
    unsafe extern "C" fn(func_id: bpf_func_id, prog: *const bpf_prog) -> *const bpf_func_proto,
>;
pub const bpf_iter_feature_BPF_ITER_RESCHED: bpf_iter_feature = 1;
pub type bpf_iter_feature = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_reg {
    pub target: *const core::ffi::c_char,
    pub attach_target: bpf_iter_attach_target_t,
    pub detach_target: bpf_iter_detach_target_t,
    pub show_fdinfo: bpf_iter_show_fdinfo_t,
    pub fill_link_info: bpf_iter_fill_link_info_t,
    pub get_func_proto: bpf_iter_get_func_proto_t,
    pub ctx_arg_info_size: u32_,
    pub feature: u32_,
    pub ctx_arg_info: [bpf_ctx_arg_aux; 2usize],
    pub seq_info: *const bpf_iter_seq_info,
}
impl Default for bpf_iter_reg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter_meta {
    pub __bindgen_anon_1: bpf_iter_meta__bindgen_ty_1,
    pub session_id: u64_,
    pub seq_num: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter_meta__bindgen_ty_1 {
    pub seq: *mut seq_file,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_iter_meta__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_iter_meta__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_iter_meta {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_iter__bpf_map_elem {
    pub __bindgen_anon_1: bpf_iter__bpf_map_elem__bindgen_ty_1,
    pub __bindgen_anon_2: bpf_iter__bpf_map_elem__bindgen_ty_2,
    pub __bindgen_anon_3: bpf_iter__bpf_map_elem__bindgen_ty_3,
    pub __bindgen_anon_4: bpf_iter__bpf_map_elem__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter__bpf_map_elem__bindgen_ty_1 {
    pub meta: *mut bpf_iter_meta,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_iter__bpf_map_elem__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_iter__bpf_map_elem__bindgen_ty_1 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter__bpf_map_elem__bindgen_ty_2 {
    pub map: *mut bpf_map,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_iter__bpf_map_elem__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_iter__bpf_map_elem__bindgen_ty_2 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter__bpf_map_elem__bindgen_ty_3 {
    pub key: *mut core::ffi::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_iter__bpf_map_elem__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_iter__bpf_map_elem__bindgen_ty_3 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_iter__bpf_map_elem__bindgen_ty_4 {
    pub value: *mut core::ffi::c_void,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    _bindgen_union_align: u64,
}
impl Default for bpf_iter__bpf_map_elem__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl bpf_iter__bpf_map_elem__bindgen_ty_4 {
    #[inline]
    pub fn new_bitfield_1() -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit
    }
}
impl Default for bpf_iter__bpf_map_elem {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn bpf_iter_reg_target(reg_info: *const bpf_iter_reg) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_iter_unreg_target(reg_info: *const bpf_iter_reg);
}
extern "C" {
    pub fn bpf_iter_prog_supported(prog: *mut bpf_prog) -> bool_;
}
extern "C" {
    pub fn bpf_iter_get_func_proto(
        func_id: bpf_func_id,
        prog: *const bpf_prog,
    ) -> *const bpf_func_proto;
}
extern "C" {
    pub fn bpf_iter_link_attach(
        attr: *const bpf_attr,
        uattr: bpfptr_t,
        prog: *mut bpf_prog,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_iter_new_fd(link: *mut bpf_link) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_link_is_iter(link: *mut bpf_link) -> bool_;
}
extern "C" {
    pub fn bpf_iter_get_info(meta: *mut bpf_iter_meta, in_stop: bool_) -> *mut bpf_prog;
}
extern "C" {
    pub fn bpf_iter_run_prog(prog: *mut bpf_prog, ctx: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_iter_map_show_fdinfo(aux: *const bpf_iter_aux_info, seq: *mut seq_file);
}
extern "C" {
    pub fn bpf_iter_map_fill_link_info(
        aux: *const bpf_iter_aux_info,
        info: *mut bpf_link_info,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn map_set_for_each_callback_args(
        env: *mut bpf_verifier_env,
        caller: *mut bpf_func_state,
        callee: *mut bpf_func_state,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_percpu_hash_copy(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_percpu_array_copy(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_percpu_hash_update(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
        flags: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_percpu_array_update(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
        flags: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_stackmap_copy(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_fd_array_map_update_elem(
        map: *mut bpf_map,
        map_file: *mut file,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
        map_flags: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_fd_array_map_lookup_elem(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_fd_htab_map_update_elem(
        map: *mut bpf_map,
        map_file: *mut file,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
        map_flags: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_fd_htab_map_lookup_elem(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_get_file_flag(flags: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_check_uarg_tail_zero(
        uaddr: bpfptr_t,
        expected_size: usize,
        actual_size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_check(
        fp: *mut *mut bpf_prog,
        attr: *mut bpf_attr,
        uattr: bpfptr_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_patch_call_args(insn: *mut bpf_insn, stack_depth: u32_);
}
extern "C" {
    pub fn bpf_get_btf_vmlinux() -> *mut btf;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_dtab_netdev {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cpu_map_entry {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __dev_flush();
}
extern "C" {
    pub fn dev_xdp_enqueue(
        dev: *mut net_device,
        xdpf: *mut xdp_frame,
        dev_rx: *mut net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_map_enqueue(
        dst: *mut bpf_dtab_netdev,
        xdpf: *mut xdp_frame,
        dev_rx: *mut net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_map_enqueue_multi(
        xdpf: *mut xdp_frame,
        dev_rx: *mut net_device,
        map: *mut bpf_map,
        exclude_ingress: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_map_generic_redirect(
        dst: *mut bpf_dtab_netdev,
        skb: *mut sk_buff,
        xdp_prog: *mut bpf_prog,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_map_redirect_multi(
        dev: *mut net_device,
        skb: *mut sk_buff,
        xdp_prog: *mut bpf_prog,
        map: *mut bpf_map,
        exclude_ingress: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cpu_map_flush();
}
extern "C" {
    pub fn cpu_map_enqueue(
        rcpu: *mut bpf_cpu_map_entry,
        xdpf: *mut xdp_frame,
        dev_rx: *mut net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cpu_map_generic_redirect(
        rcpu: *mut bpf_cpu_map_entry,
        skb: *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_get_type_path(
        name: *const core::ffi::c_char,
        type_: bpf_prog_type,
    ) -> *mut bpf_prog;
}
extern "C" {
    pub fn array_map_alloc_check(attr: *mut bpf_attr) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_test_run_xdp(
        prog: *mut bpf_prog,
        kattr: *const bpf_attr,
        uattr: *mut bpf_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_test_run_skb(
        prog: *mut bpf_prog,
        kattr: *const bpf_attr,
        uattr: *mut bpf_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_test_run_tracing(
        prog: *mut bpf_prog,
        kattr: *const bpf_attr,
        uattr: *mut bpf_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_test_run_flow_dissector(
        prog: *mut bpf_prog,
        kattr: *const bpf_attr,
        uattr: *mut bpf_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_test_run_raw_tp(
        prog: *mut bpf_prog,
        kattr: *const bpf_attr,
        uattr: *mut bpf_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_test_run_sk_lookup(
        prog: *mut bpf_prog,
        kattr: *const bpf_attr,
        uattr: *mut bpf_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_ctx_access(
        off: core::ffi::c_int,
        size: core::ffi::c_int,
        type_: bpf_access_type,
        prog: *const bpf_prog,
        info: *mut bpf_insn_access_aux,
    ) -> bool_;
}
extern "C" {
    pub fn btf_struct_access(
        log: *mut bpf_verifier_log,
        btf: *const btf,
        t: *const btf_type,
        off: core::ffi::c_int,
        size: core::ffi::c_int,
        atype: bpf_access_type,
        next_btf_id: *mut u32_,
        flag: *mut bpf_type_flag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_struct_ids_match(
        log: *mut bpf_verifier_log,
        btf: *const btf,
        id: u32_,
        off: core::ffi::c_int,
        need_btf: *const btf,
        need_type_id: u32_,
        strict: bool_,
    ) -> bool_;
}
extern "C" {
    pub fn btf_distill_func_proto(
        log: *mut bpf_verifier_log,
        btf: *mut btf,
        func_proto: *const btf_type,
        func_name: *const core::ffi::c_char,
        m: *mut btf_func_model,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_kfunc_arg_meta {
    pub r0_size: u64_,
    pub r0_rdonly: bool_,
    pub ref_obj_id: core::ffi::c_int,
    pub flags: u32_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_reg_state {
    _unused: [u8; 0],
}
extern "C" {
    pub fn btf_check_subprog_arg_match(
        env: *mut bpf_verifier_env,
        subprog: core::ffi::c_int,
        regs: *mut bpf_reg_state,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_check_subprog_call(
        env: *mut bpf_verifier_env,
        subprog: core::ffi::c_int,
        regs: *mut bpf_reg_state,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_check_kfunc_arg_match(
        env: *mut bpf_verifier_env,
        btf: *const btf,
        func_id: u32_,
        regs: *mut bpf_reg_state,
        meta: *mut bpf_kfunc_arg_meta,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_prepare_func_args(
        env: *mut bpf_verifier_env,
        subprog: core::ffi::c_int,
        reg: *mut bpf_reg_state,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_check_type_match(
        log: *mut bpf_verifier_log,
        prog: *const bpf_prog,
        btf: *mut btf,
        t: *const btf_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_by_id(id: u32_) -> *mut bpf_prog;
}
extern "C" {
    pub fn bpf_link_by_id(id: u32_) -> *mut bpf_link;
}
extern "C" {
    pub fn bpf_base_func_proto(func_id: bpf_func_id) -> *const bpf_func_proto;
}
extern "C" {
    pub fn bpf_task_storage_free(task: *mut task_struct);
}
extern "C" {
    pub fn bpf_prog_has_kfunc_call(prog: *const bpf_prog) -> bool_;
}
extern "C" {
    pub fn bpf_jit_find_kfunc_model(
        prog: *const bpf_prog,
        insn: *const bpf_insn,
    ) -> *const btf_func_model;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_core_ctx {
    pub log: *mut bpf_verifier_log,
    pub btf: *const btf,
}
impl Default for bpf_core_ctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn bpf_core_apply(
        ctx: *mut bpf_core_ctx,
        relo: *const bpf_core_relo,
        relo_idx: core::ffi::c_int,
        insn: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_inc_misses_counter(prog: *mut bpf_prog);
}
extern "C" {
    pub fn __bpf_free_used_btfs(aux: *mut bpf_prog_aux, used_btfs: *mut btf_mod_pair, len: u32_);
}
extern "C" {
    pub fn __bpf_free_used_maps(aux: *mut bpf_prog_aux, used_maps: *mut *mut bpf_map, len: u32_);
}
extern "C" {
    pub fn bpf_prog_get_ok(arg1: *mut bpf_prog, arg2: *mut bpf_prog_type, arg3: bool_) -> bool_;
}
extern "C" {
    pub fn bpf_prog_offload_compile(prog: *mut bpf_prog) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_offload_destroy(prog: *mut bpf_prog);
}
extern "C" {
    pub fn bpf_prog_offload_info_fill(
        info: *mut bpf_prog_info,
        prog: *mut bpf_prog,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_map_offload_info_fill(
        info: *mut bpf_map_info,
        map: *mut bpf_map,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_map_offload_lookup_elem(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_map_offload_update_elem(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
        flags: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_map_offload_delete_elem(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_map_offload_get_next_key(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        next_key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_offload_prog_map_match(prog: *mut bpf_prog, map: *mut bpf_map) -> bool_;
}
extern "C" {
    pub fn bpf_offload_dev_create(
        ops: *const bpf_prog_offload_ops,
        priv_: *mut core::ffi::c_void,
    ) -> *mut bpf_offload_dev;
}
extern "C" {
    pub fn bpf_offload_dev_destroy(offdev: *mut bpf_offload_dev);
}
extern "C" {
    pub fn bpf_offload_dev_priv(offdev: *mut bpf_offload_dev) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn bpf_offload_dev_netdev_register(
        offdev: *mut bpf_offload_dev,
        netdev: *mut net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_offload_dev_netdev_unregister(offdev: *mut bpf_offload_dev, netdev: *mut net_device);
}
extern "C" {
    pub fn bpf_offload_dev_match(prog: *mut bpf_prog, netdev: *mut net_device) -> bool_;
}
extern "C" {
    pub fn unpriv_ebpf_notify(new_state: core::ffi::c_int);
}
extern "C" {
    pub fn bpf_prog_offload_init(prog: *mut bpf_prog, attr: *mut bpf_attr) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_map_offload_map_alloc(attr: *mut bpf_attr) -> *mut bpf_map;
}
extern "C" {
    pub fn bpf_map_offload_map_free(map: *mut bpf_map);
}
extern "C" {
    pub fn bpf_prog_test_run_syscall(
        prog: *mut bpf_prog,
        kattr: *const bpf_attr,
        uattr: *mut bpf_attr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_map_get_from_fd(attr: *const bpf_attr, prog: *mut bpf_prog) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_map_prog_detach(attr: *const bpf_attr, ptype: bpf_prog_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_map_update_elem_sys(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
        flags: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_map_bpf_prog_query(attr: *const bpf_attr, uattr: *mut bpf_attr)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn sock_map_unhash(sk: *mut sock);
}
extern "C" {
    pub fn sock_map_destroy(sk: *mut sock);
}
extern "C" {
    pub fn sock_map_close(sk: *mut sock, timeout: core::ffi::c_long);
}
extern "C" {
    pub fn bpf_sk_reuseport_detach(sk: *mut sock);
}
extern "C" {
    pub fn bpf_fd_reuseport_array_lookup_elem(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_fd_reuseport_array_update_elem(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
        map_flags: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static bpf_map_lookup_elem_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_map_update_elem_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_map_delete_elem_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_map_push_elem_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_map_pop_elem_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_map_peek_elem_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_map_lookup_percpu_elem_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_prandom_u32_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_smp_processor_id_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_numa_node_id_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_tail_call_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ktime_get_ns_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ktime_get_boot_ns_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ktime_get_tai_ns_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_current_pid_tgid_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_current_uid_gid_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_current_comm_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_stackid_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_stack_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_task_stack_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_stackid_proto_pe: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_stack_proto_pe: bpf_func_proto;
}
extern "C" {
    pub static bpf_sock_map_update_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_sock_hash_update_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_current_cgroup_id_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_current_ancestor_cgroup_id_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_cgroup_classid_curr_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_msg_redirect_hash_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_msg_redirect_map_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_sk_redirect_hash_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_sk_redirect_map_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_spin_lock_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_spin_unlock_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_local_storage_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_strtol_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_strtoul_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_tcp_sock_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_jiffies64_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_ns_current_pid_tgid_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_event_output_data_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ringbuf_output_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ringbuf_reserve_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ringbuf_submit_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ringbuf_discard_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ringbuf_query_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ringbuf_reserve_dynptr_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ringbuf_submit_dynptr_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ringbuf_discard_dynptr_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_skc_to_tcp6_sock_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_skc_to_tcp_sock_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_skc_to_tcp_timewait_sock_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_skc_to_tcp_request_sock_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_skc_to_udp6_sock_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_skc_to_unix_sock_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_skc_to_mptcp_sock_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_copy_from_user_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_snprintf_btf_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_snprintf_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_per_cpu_ptr_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_this_cpu_ptr_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_ktime_get_coarse_ns_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_sock_from_file_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_socket_ptr_cookie_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_task_storage_get_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_task_storage_delete_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_for_each_map_elem_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_btf_find_by_name_kind_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_sk_setsockopt_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_sk_getsockopt_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_unlocked_sk_setsockopt_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_unlocked_sk_getsockopt_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_find_vma_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_loop_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_copy_from_user_task_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_set_retval_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_get_retval_proto: bpf_func_proto;
}
extern "C" {
    pub static bpf_user_ringbuf_drain_proto: bpf_func_proto;
}
extern "C" {
    pub fn tracing_prog_func_proto(
        func_id: bpf_func_id,
        prog: *const bpf_prog,
    ) -> *const bpf_func_proto;
}
extern "C" {
    pub fn bpf_user_rnd_init_once();
}
extern "C" {
    pub fn bpf_user_rnd_u32(r1: u64_, r2: u64_, r3: u64_, r4: u64_, r5: u64_) -> u64_;
}
extern "C" {
    pub fn bpf_get_raw_cpu_id(r1: u64_, r2: u64_, r3: u64_, r4: u64_, r5: u64_) -> u64_;
}
extern "C" {
    pub fn bpf_sock_common_is_valid_access(
        off: core::ffi::c_int,
        size: core::ffi::c_int,
        type_: bpf_access_type,
        info: *mut bpf_insn_access_aux,
    ) -> bool_;
}
extern "C" {
    pub fn bpf_sock_is_valid_access(
        off: core::ffi::c_int,
        size: core::ffi::c_int,
        type_: bpf_access_type,
        info: *mut bpf_insn_access_aux,
    ) -> bool_;
}
extern "C" {
    pub fn bpf_sock_convert_ctx_access(
        type_: bpf_access_type,
        si: *const bpf_insn,
        insn_buf: *mut bpf_insn,
        prog: *mut bpf_prog,
        target_size: *mut u32_,
    ) -> u32_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_reuseport_kern {
    pub skb: *mut sk_buff,
    pub sk: *mut sock,
    pub selected_sk: *mut sock,
    pub migrating_sk: *mut sock,
    pub data_end: *mut core::ffi::c_void,
    pub hash: u32_,
    pub reuseport_id: u32_,
    pub bind_inany: bool_,
}
impl Default for sk_reuseport_kern {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn bpf_tcp_sock_is_valid_access(
        off: core::ffi::c_int,
        size: core::ffi::c_int,
        type_: bpf_access_type,
        info: *mut bpf_insn_access_aux,
    ) -> bool_;
}
extern "C" {
    pub fn bpf_tcp_sock_convert_ctx_access(
        type_: bpf_access_type,
        si: *const bpf_insn,
        insn_buf: *mut bpf_insn,
        prog: *mut bpf_prog,
        target_size: *mut u32_,
    ) -> u32_;
}
extern "C" {
    pub fn bpf_xdp_sock_is_valid_access(
        off: core::ffi::c_int,
        size: core::ffi::c_int,
        type_: bpf_access_type,
        info: *mut bpf_insn_access_aux,
    ) -> bool_;
}
extern "C" {
    pub fn bpf_xdp_sock_convert_ctx_access(
        type_: bpf_access_type,
        si: *const bpf_insn,
        insn_buf: *mut bpf_insn,
        prog: *mut bpf_prog,
        target_size: *mut u32_,
    ) -> u32_;
}
pub const bpf_text_poke_type_BPF_MOD_CALL: bpf_text_poke_type = 0;
pub const bpf_text_poke_type_BPF_MOD_JUMP: bpf_text_poke_type = 1;
pub type bpf_text_poke_type = core::ffi::c_uint;
extern "C" {
    pub fn bpf_arch_text_poke(
        ip: *mut core::ffi::c_void,
        t: bpf_text_poke_type,
        addr1: *mut core::ffi::c_void,
        addr2: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_arch_text_copy(
        dst: *mut core::ffi::c_void,
        src: *mut core::ffi::c_void,
        len: usize,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn bpf_arch_text_invalidate(dst: *mut core::ffi::c_void, len: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn btf_id_set_contains(set: *const btf_id_set, id: u32_) -> bool_;
}
extern "C" {
    pub fn bpf_bprintf_prepare(
        fmt: *mut core::ffi::c_char,
        fmt_size: u32_,
        raw_args: *const u64_,
        bin_buf: *mut *mut u32_,
        num_args: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_bprintf_cleanup();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_dynptr_kern {
    pub data: *mut core::ffi::c_void,
    pub size: u32_,
    pub offset: u32_,
}
impl Default for bpf_dynptr_kern {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const bpf_dynptr_type_BPF_DYNPTR_TYPE_INVALID: bpf_dynptr_type = 0;
pub const bpf_dynptr_type_BPF_DYNPTR_TYPE_LOCAL: bpf_dynptr_type = 1;
pub const bpf_dynptr_type_BPF_DYNPTR_TYPE_RINGBUF: bpf_dynptr_type = 2;
pub type bpf_dynptr_type = core::ffi::c_uint;
extern "C" {
    pub fn bpf_dynptr_init(
        ptr: *mut bpf_dynptr_kern,
        data: *mut core::ffi::c_void,
        type_: bpf_dynptr_type,
        offset: u32_,
        size: u32_,
    );
}
extern "C" {
    pub fn bpf_dynptr_set_null(ptr: *mut bpf_dynptr_kern);
}
extern "C" {
    pub fn bpf_dynptr_check_size(size: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_dynptr_get_size(ptr: *mut bpf_dynptr_kern) -> u32_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_key {
    pub key: *mut key,
    pub has_ref: bool_,
}
impl Default for bpf_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn set_memory_ro(addr: core::ffi::c_ulong, numpages: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_memory_rw(addr: core::ffi::c_ulong, numpages: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_memory_x(addr: core::ffi::c_ulong, numpages: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_memory_nx(addr: core::ffi::c_ulong, numpages: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_memory_rw_nx(
        addr: core::ffi::c_ulong,
        numpages: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_direct_map_invalid_noflush(page: *mut page) -> core::ffi::c_int;
}
extern "C" {
    pub fn set_direct_map_default_noflush(page: *mut page) -> core::ffi::c_int;
}
extern "C" {
    pub fn kernel_page_present(page: *mut page) -> bool_;
}
extern "C" {
    pub static byte_rev_table: [u8_; 256usize];
}
extern "C" {
    pub fn crc32_le(crc: u32_, p: *const core::ffi::c_uchar, len: usize) -> u32_;
}
extern "C" {
    pub fn crc32_be(crc: u32_, p: *const core::ffi::c_uchar, len: usize) -> u32_;
}
extern "C" {
    pub fn crc32_le_shift(crc: u32_, len: usize) -> u32_;
}
extern "C" {
    pub fn __crc32c_le(crc: u32_, p: *const core::ffi::c_uchar, len: usize) -> u32_;
}
extern "C" {
    pub fn __crc32c_le_shift(crc: u32_, len: usize) -> u32_;
}
extern "C" {
    pub fn eth_platform_get_mac_address(dev: *mut device, mac_addr: *mut u8_) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_get_ethdev_address(
        dev: *mut device,
        netdev: *mut net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn arch_get_platform_mac_address() -> *mut core::ffi::c_uchar;
}
extern "C" {
    pub fn nvmem_get_mac_address(
        dev: *mut device,
        addrbuf: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_get_mac_address(
        dev: *mut device,
        addr: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn device_get_ethdev_address(dev: *mut device, netdev: *mut net_device)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn fwnode_get_mac_address(
        fwnode: *mut fwnode_handle,
        addr: *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn eth_get_headlen(
        dev: *const net_device,
        data: *const core::ffi::c_void,
        len: u32_,
    ) -> u32_;
}
extern "C" {
    pub fn eth_type_trans(skb: *mut sk_buff, dev: *mut net_device) -> __be16;
}
extern "C" {
    pub static eth_header_ops: header_ops;
}
extern "C" {
    pub fn eth_header(
        skb: *mut sk_buff,
        dev: *mut net_device,
        type_: core::ffi::c_ushort,
        daddr: *const core::ffi::c_void,
        saddr: *const core::ffi::c_void,
        len: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn eth_header_cache(
        neigh: *const neighbour,
        hh: *mut hh_cache,
        type_: __be16,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn eth_header_cache_update(
        hh: *mut hh_cache,
        dev: *const net_device,
        haddr: *const core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn eth_header_parse_protocol(skb: *const sk_buff) -> __be16;
}
extern "C" {
    pub fn eth_prepare_mac_addr_change(
        dev: *mut net_device,
        p: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn eth_commit_mac_addr_change(dev: *mut net_device, p: *mut core::ffi::c_void);
}
extern "C" {
    pub fn eth_mac_addr(dev: *mut net_device, p: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn eth_validate_addr(dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn alloc_etherdev_mqs(
        sizeof_priv: core::ffi::c_int,
        txqs: core::ffi::c_uint,
        rxqs: core::ffi::c_uint,
    ) -> *mut net_device;
}
extern "C" {
    pub fn devm_alloc_etherdev_mqs(
        dev: *mut device,
        sizeof_priv: core::ffi::c_int,
        txqs: core::ffi::c_uint,
        rxqs: core::ffi::c_uint,
    ) -> *mut net_device;
}
extern "C" {
    pub fn eth_gro_receive(head: *mut list_head, skb: *mut sk_buff) -> *mut sk_buff;
}
extern "C" {
    pub fn eth_gro_complete(skb: *mut sk_buff, nhoff: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub static eth_reserved_addr_base: [u8_; 6usize];
}
pub const vlan_ioctl_cmds_ADD_VLAN_CMD: vlan_ioctl_cmds = 0;
pub const vlan_ioctl_cmds_DEL_VLAN_CMD: vlan_ioctl_cmds = 1;
pub const vlan_ioctl_cmds_SET_VLAN_INGRESS_PRIORITY_CMD: vlan_ioctl_cmds = 2;
pub const vlan_ioctl_cmds_SET_VLAN_EGRESS_PRIORITY_CMD: vlan_ioctl_cmds = 3;
pub const vlan_ioctl_cmds_GET_VLAN_INGRESS_PRIORITY_CMD: vlan_ioctl_cmds = 4;
pub const vlan_ioctl_cmds_GET_VLAN_EGRESS_PRIORITY_CMD: vlan_ioctl_cmds = 5;
pub const vlan_ioctl_cmds_SET_VLAN_NAME_TYPE_CMD: vlan_ioctl_cmds = 6;
pub const vlan_ioctl_cmds_SET_VLAN_FLAG_CMD: vlan_ioctl_cmds = 7;
pub const vlan_ioctl_cmds_GET_VLAN_REALDEV_NAME_CMD: vlan_ioctl_cmds = 8;
pub const vlan_ioctl_cmds_GET_VLAN_VID_CMD: vlan_ioctl_cmds = 9;
pub type vlan_ioctl_cmds = core::ffi::c_uint;
pub const vlan_flags_VLAN_FLAG_REORDER_HDR: vlan_flags = 1;
pub const vlan_flags_VLAN_FLAG_GVRP: vlan_flags = 2;
pub const vlan_flags_VLAN_FLAG_LOOSE_BINDING: vlan_flags = 4;
pub const vlan_flags_VLAN_FLAG_MVRP: vlan_flags = 8;
pub const vlan_flags_VLAN_FLAG_BRIDGE_BINDING: vlan_flags = 16;
pub type vlan_flags = core::ffi::c_uint;
pub const vlan_name_types_VLAN_NAME_TYPE_PLUS_VID: vlan_name_types = 0;
pub const vlan_name_types_VLAN_NAME_TYPE_RAW_PLUS_VID: vlan_name_types = 1;
pub const vlan_name_types_VLAN_NAME_TYPE_PLUS_VID_NO_PAD: vlan_name_types = 2;
pub const vlan_name_types_VLAN_NAME_TYPE_RAW_PLUS_VID_NO_PAD: vlan_name_types = 3;
pub const vlan_name_types_VLAN_NAME_TYPE_HIGHEST: vlan_name_types = 4;
pub type vlan_name_types = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vlan_ioctl_args {
    pub cmd: core::ffi::c_int,
    pub device1: [core::ffi::c_char; 24usize],
    pub u: vlan_ioctl_args__bindgen_ty_1,
    pub vlan_qos: core::ffi::c_short,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vlan_ioctl_args__bindgen_ty_1 {
    pub device2: [core::ffi::c_char; 24usize],
    pub VID: core::ffi::c_int,
    pub skb_priority: core::ffi::c_uint,
    pub name_type: core::ffi::c_uint,
    pub bind_type: core::ffi::c_uint,
    pub flag: core::ffi::c_uint,
    _bindgen_union_align: [u32; 6usize],
}
impl Default for vlan_ioctl_args__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for vlan_ioctl_args {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vlan_hdr {
    pub h_vlan_TCI: __be16,
    pub h_vlan_encapsulated_proto: __be16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vlan_ethhdr {
    pub __bindgen_anon_1: vlan_ethhdr__bindgen_ty_1,
    pub h_vlan_proto: __be16,
    pub h_vlan_TCI: __be16,
    pub h_vlan_encapsulated_proto: __be16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vlan_ethhdr__bindgen_ty_1 {
    pub __bindgen_anon_1: vlan_ethhdr__bindgen_ty_1__bindgen_ty_1,
    pub addrs: vlan_ethhdr__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u8; 12usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vlan_ethhdr__bindgen_ty_1__bindgen_ty_1 {
    pub h_dest: [core::ffi::c_uchar; 6usize],
    pub h_source: [core::ffi::c_uchar; 6usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vlan_ethhdr__bindgen_ty_1__bindgen_ty_2 {
    pub h_dest: [core::ffi::c_uchar; 6usize],
    pub h_source: [core::ffi::c_uchar; 6usize],
}
impl Default for vlan_ethhdr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for vlan_ethhdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn vlan_ioctl_set(
        hook: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut net, arg2: *mut core::ffi::c_void) -> core::ffi::c_int,
        >,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vlan_pcpu_stats {
    pub rx_packets: u64_stats_t,
    pub rx_bytes: u64_stats_t,
    pub rx_multicast: u64_stats_t,
    pub tx_packets: u64_stats_t,
    pub tx_bytes: u64_stats_t,
    pub syncp: u64_stats_sync,
    pub rx_errors: u32_,
    pub tx_dropped: u32_,
}
extern "C" {
    pub fn __vlan_find_dev_deep_rcu(
        real_dev: *mut net_device,
        vlan_proto: __be16,
        vlan_id: u16_,
    ) -> *mut net_device;
}
extern "C" {
    pub fn vlan_for_each(
        dev: *mut net_device,
        action: ::core::option::Option<
            unsafe extern "C" fn(
                dev: *mut net_device,
                vid: core::ffi::c_int,
                arg: *mut core::ffi::c_void,
            ) -> core::ffi::c_int,
        >,
        arg: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vlan_dev_real_dev(dev: *const net_device) -> *mut net_device;
}
extern "C" {
    pub fn vlan_dev_vlan_id(dev: *const net_device) -> u16_;
}
extern "C" {
    pub fn vlan_dev_vlan_proto(dev: *const net_device) -> __be16;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vlan_priority_tci_mapping {
    pub priority: u32_,
    pub vlan_qos: u16_,
    pub next: *mut vlan_priority_tci_mapping,
}
impl Default for vlan_priority_tci_mapping {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netpoll {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vlan_dev_priv {
    pub nr_ingress_mappings: core::ffi::c_uint,
    pub ingress_priority_map: [u32_; 8usize],
    pub nr_egress_mappings: core::ffi::c_uint,
    pub egress_priority_map: [*mut vlan_priority_tci_mapping; 16usize],
    pub vlan_proto: __be16,
    pub vlan_id: u16_,
    pub flags: u16_,
    pub real_dev: *mut net_device,
    pub dev_tracker: netdevice_tracker,
    pub real_dev_addr: [core::ffi::c_uchar; 6usize],
    pub dent: *mut proc_dir_entry,
    pub vlan_pcpu_stats: *mut vlan_pcpu_stats,
}
impl Default for vlan_dev_priv {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn vlan_do_receive(skb: *mut *mut sk_buff) -> bool_;
}
extern "C" {
    pub fn vlan_vid_add(dev: *mut net_device, proto: __be16, vid: u16_) -> core::ffi::c_int;
}
extern "C" {
    pub fn vlan_vid_del(dev: *mut net_device, proto: __be16, vid: u16_);
}
extern "C" {
    pub fn vlan_vids_add_by_dev(
        dev: *mut net_device,
        by_dev: *const net_device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vlan_vids_del_by_dev(dev: *mut net_device, by_dev: *const net_device);
}
extern "C" {
    pub fn vlan_uses_dev(dev: *const net_device) -> bool_;
}
extern "C" {
    pub static sha1_zero_message_hash: [u8_; 20usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha1_state {
    pub state: [u32_; 5usize],
    pub count: u64_,
    pub buffer: [u8_; 64usize],
}
impl Default for sha1_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct shash_desc {
    _unused: [u8; 0],
}
extern "C" {
    pub fn crypto_sha1_update(
        desc: *mut shash_desc,
        data: *const u8_,
        len: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn crypto_sha1_finup(
        desc: *mut shash_desc,
        data: *const u8_,
        len: core::ffi::c_uint,
        hash: *mut u8_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sha1_init(buf: *mut __u32);
}
extern "C" {
    pub fn sha1_transform(digest: *mut __u32, data: *const core::ffi::c_char, W: *mut __u32);
}
pub const TCA_STATS_UNSPEC: core::ffi::c_uint = 0;
pub const TCA_STATS_BASIC: core::ffi::c_uint = 1;
pub const TCA_STATS_RATE_EST: core::ffi::c_uint = 2;
pub const TCA_STATS_QUEUE: core::ffi::c_uint = 3;
pub const TCA_STATS_APP: core::ffi::c_uint = 4;
pub const TCA_STATS_RATE_EST64: core::ffi::c_uint = 5;
pub const TCA_STATS_PAD: core::ffi::c_uint = 6;
pub const TCA_STATS_BASIC_HW: core::ffi::c_uint = 7;
pub const TCA_STATS_PKT64: core::ffi::c_uint = 8;
pub const __TCA_STATS_MAX: core::ffi::c_uint = 9;
pub type _bindgen_ty_350 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct gnet_stats_basic {
    pub bytes: __u64,
    pub packets: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct gnet_stats_rate_est {
    pub bps: __u32,
    pub pps: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct gnet_stats_rate_est64 {
    pub bps: __u64,
    pub pps: __u64,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct gnet_stats_queue {
    pub qlen: __u32,
    pub backlog: __u32,
    pub drops: __u32,
    pub requeues: __u32,
    pub overlimits: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct gnet_estimator {
    pub interval: core::ffi::c_schar,
    pub ewma_log: core::ffi::c_uchar,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Default, Copy, Clone)]
pub struct gnet_stats_basic_sync {
    pub bytes: u64_stats_t,
    pub packets: u64_stats_t,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_rate_estimator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gnet_dump {
    pub lock: *mut spinlock_t,
    pub skb: *mut sk_buff,
    pub tail: *mut nlattr,
    pub compat_tc_stats: core::ffi::c_int,
    pub compat_xstats: core::ffi::c_int,
    pub padattr: core::ffi::c_int,
    pub xstats: *mut core::ffi::c_void,
    pub xstats_len: core::ffi::c_int,
    pub tc_stats: tc_stats,
}
impl Default for gnet_dump {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn gnet_stats_basic_sync_init(b: *mut gnet_stats_basic_sync);
}
extern "C" {
    pub fn gnet_stats_start_copy(
        skb: *mut sk_buff,
        type_: core::ffi::c_int,
        lock: *mut spinlock_t,
        d: *mut gnet_dump,
        padattr: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gnet_stats_start_copy_compat(
        skb: *mut sk_buff,
        type_: core::ffi::c_int,
        tc_stats_type: core::ffi::c_int,
        xstats_type: core::ffi::c_int,
        lock: *mut spinlock_t,
        d: *mut gnet_dump,
        padattr: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gnet_stats_copy_basic(
        d: *mut gnet_dump,
        cpu: *mut gnet_stats_basic_sync,
        b: *mut gnet_stats_basic_sync,
        running: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gnet_stats_add_basic(
        bstats: *mut gnet_stats_basic_sync,
        cpu: *mut gnet_stats_basic_sync,
        b: *mut gnet_stats_basic_sync,
        running: bool_,
    );
}
extern "C" {
    pub fn gnet_stats_copy_basic_hw(
        d: *mut gnet_dump,
        cpu: *mut gnet_stats_basic_sync,
        b: *mut gnet_stats_basic_sync,
        running: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gnet_stats_copy_rate_est(
        d: *mut gnet_dump,
        ptr: *mut *mut net_rate_estimator,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gnet_stats_copy_queue(
        d: *mut gnet_dump,
        cpu_q: *mut gnet_stats_queue,
        q: *mut gnet_stats_queue,
        qlen: __u32,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gnet_stats_add_queue(
        qstats: *mut gnet_stats_queue,
        cpu_q: *const gnet_stats_queue,
        q: *const gnet_stats_queue,
    );
}
extern "C" {
    pub fn gnet_stats_copy_app(
        d: *mut gnet_dump,
        st: *mut core::ffi::c_void,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gnet_stats_finish_copy(d: *mut gnet_dump) -> core::ffi::c_int;
}
extern "C" {
    pub fn gen_new_estimator(
        bstats: *mut gnet_stats_basic_sync,
        cpu_bstats: *mut gnet_stats_basic_sync,
        rate_est: *mut *mut net_rate_estimator,
        lock: *mut spinlock_t,
        running: bool_,
        opt: *mut nlattr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gen_kill_estimator(ptr: *mut *mut net_rate_estimator);
}
extern "C" {
    pub fn gen_replace_estimator(
        bstats: *mut gnet_stats_basic_sync,
        cpu_bstats: *mut gnet_stats_basic_sync,
        ptr: *mut *mut net_rate_estimator,
        lock: *mut spinlock_t,
        running: bool_,
        opt: *mut nlattr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn gen_estimator_active(ptr: *mut *mut net_rate_estimator) -> bool_;
}
extern "C" {
    pub fn gen_estimator_read(
        ptr: *mut *mut net_rate_estimator,
        sample: *mut gnet_stats_rate_est64,
    ) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match {
    pub dissector: *mut flow_dissector,
    pub mask: *mut core::ffi::c_void,
    pub key: *mut core::ffi::c_void,
}
impl Default for flow_match {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_meta {
    pub key: *mut flow_dissector_key_meta,
    pub mask: *mut flow_dissector_key_meta,
}
impl Default for flow_match_meta {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_basic {
    pub key: *mut flow_dissector_key_basic,
    pub mask: *mut flow_dissector_key_basic,
}
impl Default for flow_match_basic {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_control {
    pub key: *mut flow_dissector_key_control,
    pub mask: *mut flow_dissector_key_control,
}
impl Default for flow_match_control {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_eth_addrs {
    pub key: *mut flow_dissector_key_eth_addrs,
    pub mask: *mut flow_dissector_key_eth_addrs,
}
impl Default for flow_match_eth_addrs {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_vlan {
    pub key: *mut flow_dissector_key_vlan,
    pub mask: *mut flow_dissector_key_vlan,
}
impl Default for flow_match_vlan {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_ipv4_addrs {
    pub key: *mut flow_dissector_key_ipv4_addrs,
    pub mask: *mut flow_dissector_key_ipv4_addrs,
}
impl Default for flow_match_ipv4_addrs {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_ipv6_addrs {
    pub key: *mut flow_dissector_key_ipv6_addrs,
    pub mask: *mut flow_dissector_key_ipv6_addrs,
}
impl Default for flow_match_ipv6_addrs {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_ip {
    pub key: *mut flow_dissector_key_ip,
    pub mask: *mut flow_dissector_key_ip,
}
impl Default for flow_match_ip {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_ports {
    pub key: *mut flow_dissector_key_ports,
    pub mask: *mut flow_dissector_key_ports,
}
impl Default for flow_match_ports {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_ports_range {
    pub key: *mut flow_dissector_key_ports_range,
    pub mask: *mut flow_dissector_key_ports_range,
}
impl Default for flow_match_ports_range {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_icmp {
    pub key: *mut flow_dissector_key_icmp,
    pub mask: *mut flow_dissector_key_icmp,
}
impl Default for flow_match_icmp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_tcp {
    pub key: *mut flow_dissector_key_tcp,
    pub mask: *mut flow_dissector_key_tcp,
}
impl Default for flow_match_tcp {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_mpls {
    pub key: *mut flow_dissector_key_mpls,
    pub mask: *mut flow_dissector_key_mpls,
}
impl Default for flow_match_mpls {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_enc_keyid {
    pub key: *mut flow_dissector_key_keyid,
    pub mask: *mut flow_dissector_key_keyid,
}
impl Default for flow_match_enc_keyid {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_enc_opts {
    pub key: *mut flow_dissector_key_enc_opts,
    pub mask: *mut flow_dissector_key_enc_opts,
}
impl Default for flow_match_enc_opts {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_ct {
    pub key: *mut flow_dissector_key_ct,
    pub mask: *mut flow_dissector_key_ct,
}
impl Default for flow_match_ct {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_pppoe {
    pub key: *mut flow_dissector_key_pppoe,
    pub mask: *mut flow_dissector_key_pppoe,
}
impl Default for flow_match_pppoe {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_match_l2tpv3 {
    pub key: *mut flow_dissector_key_l2tpv3,
    pub mask: *mut flow_dissector_key_l2tpv3,
}
impl Default for flow_match_l2tpv3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn flow_rule_match_meta(rule: *const flow_rule, out: *mut flow_match_meta);
}
extern "C" {
    pub fn flow_rule_match_basic(rule: *const flow_rule, out: *mut flow_match_basic);
}
extern "C" {
    pub fn flow_rule_match_control(rule: *const flow_rule, out: *mut flow_match_control);
}
extern "C" {
    pub fn flow_rule_match_eth_addrs(rule: *const flow_rule, out: *mut flow_match_eth_addrs);
}
extern "C" {
    pub fn flow_rule_match_vlan(rule: *const flow_rule, out: *mut flow_match_vlan);
}
extern "C" {
    pub fn flow_rule_match_cvlan(rule: *const flow_rule, out: *mut flow_match_vlan);
}
extern "C" {
    pub fn flow_rule_match_ipv4_addrs(rule: *const flow_rule, out: *mut flow_match_ipv4_addrs);
}
extern "C" {
    pub fn flow_rule_match_ipv6_addrs(rule: *const flow_rule, out: *mut flow_match_ipv6_addrs);
}
extern "C" {
    pub fn flow_rule_match_ip(rule: *const flow_rule, out: *mut flow_match_ip);
}
extern "C" {
    pub fn flow_rule_match_ports(rule: *const flow_rule, out: *mut flow_match_ports);
}
extern "C" {
    pub fn flow_rule_match_ports_range(rule: *const flow_rule, out: *mut flow_match_ports_range);
}
extern "C" {
    pub fn flow_rule_match_tcp(rule: *const flow_rule, out: *mut flow_match_tcp);
}
extern "C" {
    pub fn flow_rule_match_icmp(rule: *const flow_rule, out: *mut flow_match_icmp);
}
extern "C" {
    pub fn flow_rule_match_mpls(rule: *const flow_rule, out: *mut flow_match_mpls);
}
extern "C" {
    pub fn flow_rule_match_enc_control(rule: *const flow_rule, out: *mut flow_match_control);
}
extern "C" {
    pub fn flow_rule_match_enc_ipv4_addrs(rule: *const flow_rule, out: *mut flow_match_ipv4_addrs);
}
extern "C" {
    pub fn flow_rule_match_enc_ipv6_addrs(rule: *const flow_rule, out: *mut flow_match_ipv6_addrs);
}
extern "C" {
    pub fn flow_rule_match_enc_ip(rule: *const flow_rule, out: *mut flow_match_ip);
}
extern "C" {
    pub fn flow_rule_match_enc_ports(rule: *const flow_rule, out: *mut flow_match_ports);
}
extern "C" {
    pub fn flow_rule_match_enc_keyid(rule: *const flow_rule, out: *mut flow_match_enc_keyid);
}
extern "C" {
    pub fn flow_rule_match_enc_opts(rule: *const flow_rule, out: *mut flow_match_enc_opts);
}
extern "C" {
    pub fn flow_rule_match_ct(rule: *const flow_rule, out: *mut flow_match_ct);
}
extern "C" {
    pub fn flow_rule_match_pppoe(rule: *const flow_rule, out: *mut flow_match_pppoe);
}
extern "C" {
    pub fn flow_rule_match_l2tpv3(rule: *const flow_rule, out: *mut flow_match_l2tpv3);
}
pub const flow_action_id_FLOW_ACTION_ACCEPT: flow_action_id = 0;
pub const flow_action_id_FLOW_ACTION_DROP: flow_action_id = 1;
pub const flow_action_id_FLOW_ACTION_TRAP: flow_action_id = 2;
pub const flow_action_id_FLOW_ACTION_GOTO: flow_action_id = 3;
pub const flow_action_id_FLOW_ACTION_REDIRECT: flow_action_id = 4;
pub const flow_action_id_FLOW_ACTION_MIRRED: flow_action_id = 5;
pub const flow_action_id_FLOW_ACTION_REDIRECT_INGRESS: flow_action_id = 6;
pub const flow_action_id_FLOW_ACTION_MIRRED_INGRESS: flow_action_id = 7;
pub const flow_action_id_FLOW_ACTION_VLAN_PUSH: flow_action_id = 8;
pub const flow_action_id_FLOW_ACTION_VLAN_POP: flow_action_id = 9;
pub const flow_action_id_FLOW_ACTION_VLAN_MANGLE: flow_action_id = 10;
pub const flow_action_id_FLOW_ACTION_TUNNEL_ENCAP: flow_action_id = 11;
pub const flow_action_id_FLOW_ACTION_TUNNEL_DECAP: flow_action_id = 12;
pub const flow_action_id_FLOW_ACTION_MANGLE: flow_action_id = 13;
pub const flow_action_id_FLOW_ACTION_ADD: flow_action_id = 14;
pub const flow_action_id_FLOW_ACTION_CSUM: flow_action_id = 15;
pub const flow_action_id_FLOW_ACTION_MARK: flow_action_id = 16;
pub const flow_action_id_FLOW_ACTION_PTYPE: flow_action_id = 17;
pub const flow_action_id_FLOW_ACTION_PRIORITY: flow_action_id = 18;
pub const flow_action_id_FLOW_ACTION_WAKE: flow_action_id = 19;
pub const flow_action_id_FLOW_ACTION_QUEUE: flow_action_id = 20;
pub const flow_action_id_FLOW_ACTION_SAMPLE: flow_action_id = 21;
pub const flow_action_id_FLOW_ACTION_POLICE: flow_action_id = 22;
pub const flow_action_id_FLOW_ACTION_CT: flow_action_id = 23;
pub const flow_action_id_FLOW_ACTION_CT_METADATA: flow_action_id = 24;
pub const flow_action_id_FLOW_ACTION_MPLS_PUSH: flow_action_id = 25;
pub const flow_action_id_FLOW_ACTION_MPLS_POP: flow_action_id = 26;
pub const flow_action_id_FLOW_ACTION_MPLS_MANGLE: flow_action_id = 27;
pub const flow_action_id_FLOW_ACTION_GATE: flow_action_id = 28;
pub const flow_action_id_FLOW_ACTION_PPPOE_PUSH: flow_action_id = 29;
pub const flow_action_id_FLOW_ACTION_JUMP: flow_action_id = 30;
pub const flow_action_id_FLOW_ACTION_PIPE: flow_action_id = 31;
pub const flow_action_id_FLOW_ACTION_VLAN_PUSH_ETH: flow_action_id = 32;
pub const flow_action_id_FLOW_ACTION_VLAN_POP_ETH: flow_action_id = 33;
pub const flow_action_id_FLOW_ACTION_CONTINUE: flow_action_id = 34;
pub const flow_action_id_NUM_FLOW_ACTIONS: flow_action_id = 35;
pub type flow_action_id = core::ffi::c_uint;
pub const flow_action_mangle_base_FLOW_ACT_MANGLE_UNSPEC: flow_action_mangle_base = 0;
pub const flow_action_mangle_base_FLOW_ACT_MANGLE_HDR_TYPE_ETH: flow_action_mangle_base = 1;
pub const flow_action_mangle_base_FLOW_ACT_MANGLE_HDR_TYPE_IP4: flow_action_mangle_base = 2;
pub const flow_action_mangle_base_FLOW_ACT_MANGLE_HDR_TYPE_IP6: flow_action_mangle_base = 3;
pub const flow_action_mangle_base_FLOW_ACT_MANGLE_HDR_TYPE_TCP: flow_action_mangle_base = 4;
pub const flow_action_mangle_base_FLOW_ACT_MANGLE_HDR_TYPE_UDP: flow_action_mangle_base = 5;
pub type flow_action_mangle_base = core::ffi::c_uint;
pub const flow_action_hw_stats_bit_FLOW_ACTION_HW_STATS_IMMEDIATE_BIT: flow_action_hw_stats_bit = 0;
pub const flow_action_hw_stats_bit_FLOW_ACTION_HW_STATS_DELAYED_BIT: flow_action_hw_stats_bit = 1;
pub const flow_action_hw_stats_bit_FLOW_ACTION_HW_STATS_DISABLED_BIT: flow_action_hw_stats_bit = 2;
pub const flow_action_hw_stats_bit_FLOW_ACTION_HW_STATS_NUM_BITS: flow_action_hw_stats_bit = 3;
pub type flow_action_hw_stats_bit = core::ffi::c_uint;
pub const flow_action_hw_stats_FLOW_ACTION_HW_STATS_IMMEDIATE: flow_action_hw_stats = 1;
pub const flow_action_hw_stats_FLOW_ACTION_HW_STATS_DELAYED: flow_action_hw_stats = 2;
pub const flow_action_hw_stats_FLOW_ACTION_HW_STATS_ANY: flow_action_hw_stats = 3;
pub const flow_action_hw_stats_FLOW_ACTION_HW_STATS_DISABLED: flow_action_hw_stats = 4;
pub const flow_action_hw_stats_FLOW_ACTION_HW_STATS_DONT_CARE: flow_action_hw_stats = 7;
pub type flow_action_hw_stats = core::ffi::c_uint;
pub type action_destr = ::core::option::Option<unsafe extern "C" fn(priv_: *mut core::ffi::c_void)>;
#[repr(C)]
#[derive(Default)]
pub struct flow_action_cookie {
    pub cookie_len: u32_,
    pub cookie: __IncompleteArrayField<u8_>,
}
extern "C" {
    pub fn flow_action_cookie_create(
        data: *mut core::ffi::c_void,
        len: core::ffi::c_uint,
        gfp: gfp_t,
    ) -> *mut flow_action_cookie;
}
extern "C" {
    pub fn flow_action_cookie_destroy(cookie: *mut flow_action_cookie);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_action_entry {
    pub id: flow_action_id,
    pub hw_index: u32_,
    pub hw_stats: flow_action_hw_stats,
    pub destructor: action_destr,
    pub destructor_priv: *mut core::ffi::c_void,
    pub __bindgen_anon_1: flow_action_entry__bindgen_ty_1,
    pub cookie: *mut flow_action_cookie,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flow_action_entry__bindgen_ty_1 {
    pub chain_index: u32_,
    pub dev: *mut net_device,
    pub vlan: flow_action_entry__bindgen_ty_1__bindgen_ty_1,
    pub vlan_push_eth: flow_action_entry__bindgen_ty_1__bindgen_ty_2,
    pub mangle: flow_action_entry__bindgen_ty_1__bindgen_ty_3,
    pub tunnel: *mut ip_tunnel_info,
    pub csum_flags: u32_,
    pub mark: u32_,
    pub ptype: u16_,
    pub priority: u32_,
    pub queue: flow_action_entry__bindgen_ty_1__bindgen_ty_4,
    pub sample: flow_action_entry__bindgen_ty_1__bindgen_ty_5,
    pub police: flow_action_entry__bindgen_ty_1__bindgen_ty_6,
    pub ct: flow_action_entry__bindgen_ty_1__bindgen_ty_7,
    pub ct_metadata: flow_action_entry__bindgen_ty_1__bindgen_ty_8,
    pub mpls_push: flow_action_entry__bindgen_ty_1__bindgen_ty_9,
    pub mpls_pop: flow_action_entry__bindgen_ty_1__bindgen_ty_10,
    pub mpls_mangle: flow_action_entry__bindgen_ty_1__bindgen_ty_11,
    pub gate: flow_action_entry__bindgen_ty_1__bindgen_ty_12,
    pub pppoe: flow_action_entry__bindgen_ty_1__bindgen_ty_13,
    _bindgen_union_align: [u64; 9usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_1 {
    pub vid: u16_,
    pub proto: __be16,
    pub prio: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_2 {
    pub dst: [core::ffi::c_uchar; 6usize],
    pub src: [core::ffi::c_uchar; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_3 {
    pub htype: flow_action_mangle_base,
    pub offset: u32_,
    pub mask: u32_,
    pub val: u32_,
}
impl Default for flow_action_entry__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_4 {
    pub ctx: u32_,
    pub index: u32_,
    pub vf: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_5 {
    pub psample_group: *mut psample_group,
    pub rate: u32_,
    pub trunc_size: u32_,
    pub truncate: bool_,
}
impl Default for flow_action_entry__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_6 {
    pub burst: u32_,
    pub rate_bytes_ps: u64_,
    pub peakrate_bytes_ps: u64_,
    pub avrate: u32_,
    pub overhead: u16_,
    pub burst_pkt: u64_,
    pub rate_pkt_ps: u64_,
    pub mtu: u32_,
    pub exceed: flow_action_entry__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
    pub notexceed: flow_action_entry__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    pub act_id: flow_action_id,
    pub extval: u32_,
}
impl Default for flow_action_entry__bindgen_ty_1__bindgen_ty_6__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for flow_action_entry__bindgen_ty_1__bindgen_ty_6 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_7 {
    pub action: core::ffi::c_int,
    pub zone: u16_,
    pub flow_table: *mut nf_flowtable,
}
impl Default for flow_action_entry__bindgen_ty_1__bindgen_ty_7 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_8 {
    pub cookie: core::ffi::c_ulong,
    pub mark: u32_,
    pub labels: [u32_; 4usize],
    pub orig_dir: bool_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_9 {
    pub label: u32_,
    pub proto: __be16,
    pub tc: u8_,
    pub bos: u8_,
    pub ttl: u8_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_10 {
    pub proto: __be16,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_11 {
    pub label: u32_,
    pub tc: u8_,
    pub bos: u8_,
    pub ttl: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_12 {
    pub prio: s32,
    pub basetime: u64_,
    pub cycletime: u64_,
    pub cycletimeext: u64_,
    pub num_entries: u32_,
    pub entries: *mut action_gate_entry,
}
impl Default for flow_action_entry__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct flow_action_entry__bindgen_ty_1__bindgen_ty_13 {
    pub sid: u16_,
}
impl Default for flow_action_entry__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for flow_action_entry {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct flow_action {
    pub num_entries: core::ffi::c_uint,
    pub entries: __IncompleteArrayField<flow_action_entry>,
}
impl Default for flow_action {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct flow_rule {
    pub match_: flow_match,
    pub action: flow_action,
}
impl Default for flow_rule {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn flow_rule_alloc(num_actions: core::ffi::c_uint) -> *mut flow_rule;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_stats {
    pub pkts: u64_,
    pub bytes: u64_,
    pub drops: u64_,
    pub lastused: u64_,
    pub used_hw_stats: flow_action_hw_stats,
    pub used_hw_stats_valid: bool_,
}
impl Default for flow_stats {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const flow_block_command_FLOW_BLOCK_BIND: flow_block_command = 0;
pub const flow_block_command_FLOW_BLOCK_UNBIND: flow_block_command = 1;
pub type flow_block_command = core::ffi::c_uint;
pub const flow_block_binder_type_FLOW_BLOCK_BINDER_TYPE_UNSPEC: flow_block_binder_type = 0;
pub const flow_block_binder_type_FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS: flow_block_binder_type = 1;
pub const flow_block_binder_type_FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS: flow_block_binder_type = 2;
pub const flow_block_binder_type_FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP: flow_block_binder_type = 3;
pub const flow_block_binder_type_FLOW_BLOCK_BINDER_TYPE_RED_MARK: flow_block_binder_type = 4;
pub type flow_block_binder_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_block {
    pub cb_list: list_head,
}
impl Default for flow_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_block_offload {
    pub command: flow_block_command,
    pub binder_type: flow_block_binder_type,
    pub block_shared: bool_,
    pub unlocked_driver_cb: bool_,
    pub net: *mut net,
    pub block: *mut flow_block,
    pub cb_list: list_head,
    pub driver_block_list: *mut list_head,
    pub extack: *mut netlink_ext_ack,
    pub sch: *mut Qdisc,
    pub cb_list_head: *mut list_head,
}
impl Default for flow_block_offload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub type flow_setup_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        type_: tc_setup_type,
        type_data: *mut core::ffi::c_void,
        cb_priv: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_block_indr {
    pub list: list_head,
    pub dev: *mut net_device,
    pub sch: *mut Qdisc,
    pub binder_type: flow_block_binder_type,
    pub data: *mut core::ffi::c_void,
    pub cb_priv: *mut core::ffi::c_void,
    pub cleanup: ::core::option::Option<unsafe extern "C" fn(block_cb: *mut flow_block_cb)>,
}
impl Default for flow_block_indr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_block_cb {
    pub driver_list: list_head,
    pub list: list_head,
    pub cb: flow_setup_cb_t,
    pub cb_ident: *mut core::ffi::c_void,
    pub cb_priv: *mut core::ffi::c_void,
    pub release: ::core::option::Option<unsafe extern "C" fn(cb_priv: *mut core::ffi::c_void)>,
    pub indr: flow_block_indr,
    pub refcnt: core::ffi::c_uint,
}
impl Default for flow_block_cb {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn flow_block_cb_alloc(
        cb: flow_setup_cb_t,
        cb_ident: *mut core::ffi::c_void,
        cb_priv: *mut core::ffi::c_void,
        release: ::core::option::Option<unsafe extern "C" fn(cb_priv: *mut core::ffi::c_void)>,
    ) -> *mut flow_block_cb;
}
extern "C" {
    pub fn flow_indr_block_cb_alloc(
        cb: flow_setup_cb_t,
        cb_ident: *mut core::ffi::c_void,
        cb_priv: *mut core::ffi::c_void,
        release: ::core::option::Option<unsafe extern "C" fn(cb_priv: *mut core::ffi::c_void)>,
        bo: *mut flow_block_offload,
        dev: *mut net_device,
        sch: *mut Qdisc,
        data: *mut core::ffi::c_void,
        indr_cb_priv: *mut core::ffi::c_void,
        cleanup: ::core::option::Option<unsafe extern "C" fn(block_cb: *mut flow_block_cb)>,
    ) -> *mut flow_block_cb;
}
extern "C" {
    pub fn flow_block_cb_free(block_cb: *mut flow_block_cb);
}
extern "C" {
    pub fn flow_block_cb_lookup(
        block: *mut flow_block,
        cb: flow_setup_cb_t,
        cb_ident: *mut core::ffi::c_void,
    ) -> *mut flow_block_cb;
}
extern "C" {
    pub fn flow_block_cb_priv(block_cb: *mut flow_block_cb) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn flow_block_cb_incref(block_cb: *mut flow_block_cb);
}
extern "C" {
    pub fn flow_block_cb_decref(block_cb: *mut flow_block_cb) -> core::ffi::c_uint;
}
extern "C" {
    pub fn flow_block_cb_is_busy(
        cb: flow_setup_cb_t,
        cb_ident: *mut core::ffi::c_void,
        driver_block_list: *mut list_head,
    ) -> bool_;
}
extern "C" {
    pub fn flow_block_cb_setup_simple(
        f: *mut flow_block_offload,
        driver_list: *mut list_head,
        cb: flow_setup_cb_t,
        cb_ident: *mut core::ffi::c_void,
        cb_priv: *mut core::ffi::c_void,
        ingress_only: bool_,
    ) -> core::ffi::c_int;
}
pub const flow_cls_command_FLOW_CLS_REPLACE: flow_cls_command = 0;
pub const flow_cls_command_FLOW_CLS_DESTROY: flow_cls_command = 1;
pub const flow_cls_command_FLOW_CLS_STATS: flow_cls_command = 2;
pub const flow_cls_command_FLOW_CLS_TMPLT_CREATE: flow_cls_command = 3;
pub const flow_cls_command_FLOW_CLS_TMPLT_DESTROY: flow_cls_command = 4;
pub type flow_cls_command = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_cls_common_offload {
    pub chain_index: u32_,
    pub protocol: __be16,
    pub prio: u32_,
    pub extack: *mut netlink_ext_ack,
}
impl Default for flow_cls_common_offload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flow_cls_offload {
    pub common: flow_cls_common_offload,
    pub command: flow_cls_command,
    pub cookie: core::ffi::c_ulong,
    pub rule: *mut flow_rule,
    pub stats: flow_stats,
    pub classid: u32_,
}
impl Default for flow_cls_offload {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const offload_act_command_FLOW_ACT_REPLACE: offload_act_command = 0;
pub const offload_act_command_FLOW_ACT_DESTROY: offload_act_command = 1;
pub const offload_act_command_FLOW_ACT_STATS: offload_act_command = 2;
pub type offload_act_command = core::ffi::c_uint;
#[repr(C)]
pub struct flow_offload_action {
    pub extack: *mut netlink_ext_ack,
    pub command: offload_act_command,
    pub id: flow_action_id,
    pub index: u32_,
    pub stats: flow_stats,
    pub action: flow_action,
}
impl Default for flow_offload_action {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn offload_action_alloc(num_actions: core::ffi::c_uint) -> *mut flow_offload_action;
}
pub type flow_indr_block_bind_cb_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut net_device,
        sch: *mut Qdisc,
        cb_priv: *mut core::ffi::c_void,
        type_: tc_setup_type,
        type_data: *mut core::ffi::c_void,
        data: *mut core::ffi::c_void,
        cleanup: ::core::option::Option<unsafe extern "C" fn(block_cb: *mut flow_block_cb)>,
    ) -> core::ffi::c_int,
>;
extern "C" {
    pub fn flow_indr_dev_register(
        cb: flow_indr_block_bind_cb_t,
        cb_priv: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn flow_indr_dev_unregister(
        cb: flow_indr_block_bind_cb_t,
        cb_priv: *mut core::ffi::c_void,
        release: ::core::option::Option<unsafe extern "C" fn(cb_priv: *mut core::ffi::c_void)>,
    );
}
extern "C" {
    pub fn flow_indr_dev_setup_offload(
        dev: *mut net_device,
        sch: *mut Qdisc,
        type_: tc_setup_type,
        data: *mut core::ffi::c_void,
        bo: *mut flow_block_offload,
        cleanup: ::core::option::Option<unsafe extern "C" fn(block_cb: *mut flow_block_cb)>,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn flow_indr_dev_exists() -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qdisc_walker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_walker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qdisc_rate_table {
    pub rate: tc_ratespec,
    pub data: [u32_; 256usize],
    pub next: *mut qdisc_rate_table,
    pub refcnt: core::ffi::c_int,
}
impl Default for qdisc_rate_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const qdisc_state_t___QDISC_STATE_SCHED: qdisc_state_t = 0;
pub const qdisc_state_t___QDISC_STATE_DEACTIVATED: qdisc_state_t = 1;
pub const qdisc_state_t___QDISC_STATE_MISSED: qdisc_state_t = 2;
pub const qdisc_state_t___QDISC_STATE_DRAINING: qdisc_state_t = 3;
pub type qdisc_state_t = core::ffi::c_uint;
pub const qdisc_state2_t___QDISC_STATE2_RUNNING: qdisc_state2_t = 0;
pub type qdisc_state2_t = core::ffi::c_uint;
#[repr(C)]
pub struct qdisc_size_table {
    pub rcu: callback_head,
    pub list: list_head,
    pub szopts: tc_sizespec,
    pub refcnt: core::ffi::c_int,
    pub data: __IncompleteArrayField<u16_>,
}
impl Default for qdisc_size_table {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct qdisc_skb_head {
    pub head: *mut sk_buff,
    pub tail: *mut sk_buff,
    pub qlen: __u32,
    pub lock: spinlock_t,
}
impl Default for qdisc_skb_head {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(64))]
pub struct Qdisc {
    pub enqueue: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            sch: *mut Qdisc,
            to_free: *mut *mut sk_buff,
        ) -> core::ffi::c_int,
    >,
    pub dequeue: ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc) -> *mut sk_buff>,
    pub flags: core::ffi::c_uint,
    pub limit: u32_,
    pub ops: *const Qdisc_ops,
    pub stab: *mut qdisc_size_table,
    pub hash: hlist_node,
    pub handle: u32_,
    pub parent: u32_,
    pub dev_queue: *mut netdev_queue,
    pub rate_est: *mut net_rate_estimator,
    pub cpu_bstats: *mut gnet_stats_basic_sync,
    pub cpu_qstats: *mut gnet_stats_queue,
    pub pad: core::ffi::c_int,
    pub refcnt: refcount_t,
    pub __bindgen_padding_0: [u64; 3usize],
    pub gso_skb: sk_buff_head,
    pub q: qdisc_skb_head,
    pub bstats: gnet_stats_basic_sync,
    pub qstats: gnet_stats_queue,
    pub state: core::ffi::c_ulong,
    pub state2: core::ffi::c_ulong,
    pub next_sched: *mut Qdisc,
    pub skb_bad_txq: sk_buff_head,
    pub __bindgen_padding_1: [u64; 6usize],
    pub busylock: spinlock_t,
    pub seqlock: spinlock_t,
    pub rcu: callback_head,
    pub dev_tracker: netdevice_tracker,
    pub privdata: __IncompleteArrayField<core::ffi::c_long>,
}
impl Default for Qdisc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct Qdisc_class_ops {
    pub flags: core::ffi::c_uint,
    pub select_queue: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut tcmsg) -> *mut netdev_queue,
    >,
    pub graft: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            cl: core::ffi::c_ulong,
            arg2: *mut Qdisc,
            arg3: *mut *mut Qdisc,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub leaf: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, cl: core::ffi::c_ulong) -> *mut Qdisc,
    >,
    pub qlen_notify:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: core::ffi::c_ulong)>,
    pub find: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, classid: u32_) -> core::ffi::c_ulong,
    >,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: u32_,
            arg3: u32_,
            arg4: *mut *mut nlattr,
            arg5: *mut core::ffi::c_ulong,
            arg6: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub delete: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: core::ffi::c_ulong,
            arg3: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub walk:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg: *mut qdisc_walker)>,
    pub tcf_block: ::core::option::Option<
        unsafe extern "C" fn(
            sch: *mut Qdisc,
            arg: core::ffi::c_ulong,
            extack: *mut netlink_ext_ack,
        ) -> *mut tcf_block,
    >,
    pub bind_tcf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: core::ffi::c_ulong,
            classid: u32_,
        ) -> core::ffi::c_ulong,
    >,
    pub unbind_tcf:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc, arg2: core::ffi::c_ulong)>,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: core::ffi::c_ulong,
            skb: *mut sk_buff,
            arg3: *mut tcmsg,
        ) -> core::ffi::c_int,
    >,
    pub dump_stats: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut Qdisc,
            arg2: core::ffi::c_ulong,
            arg3: *mut gnet_dump,
        ) -> core::ffi::c_int,
    >,
}
pub const qdisc_class_ops_flags_QDISC_CLASS_OPS_DOIT_UNLOCKED: qdisc_class_ops_flags = 1;
pub type qdisc_class_ops_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Qdisc_ops {
    pub next: *mut Qdisc_ops,
    pub cl_ops: *const Qdisc_class_ops,
    pub id: [core::ffi::c_char; 16usize],
    pub priv_size: core::ffi::c_int,
    pub static_flags: core::ffi::c_uint,
    pub enqueue: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            sch: *mut Qdisc,
            to_free: *mut *mut sk_buff,
        ) -> core::ffi::c_int,
    >,
    pub dequeue: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>,
    pub peek: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc) -> *mut sk_buff>,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            sch: *mut Qdisc,
            arg: *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub reset: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>,
    pub destroy: ::core::option::Option<unsafe extern "C" fn(arg1: *mut Qdisc)>,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            sch: *mut Qdisc,
            arg: *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub attach: ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc)>,
    pub change_tx_queue_len: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: core::ffi::c_uint) -> core::ffi::c_int,
    >,
    pub change_real_num_tx: ::core::option::Option<
        unsafe extern "C" fn(sch: *mut Qdisc, new_real_tx: core::ffi::c_uint),
    >,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub dump_stats: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut Qdisc, arg2: *mut gnet_dump) -> core::ffi::c_int,
    >,
    pub ingress_block_set:
        ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc, block_index: u32_)>,
    pub egress_block_set:
        ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc, block_index: u32_)>,
    pub ingress_block_get: ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc) -> u32_>,
    pub egress_block_get: ::core::option::Option<unsafe extern "C" fn(sch: *mut Qdisc) -> u32_>,
    pub owner: *mut module,
}
impl Default for Qdisc_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_result {
    pub __bindgen_anon_1: tcf_result__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcf_result__bindgen_ty_1 {
    pub __bindgen_anon_1: tcf_result__bindgen_ty_1__bindgen_ty_1,
    pub goto_tp: *const tcf_proto,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcf_result__bindgen_ty_1__bindgen_ty_1 {
    pub class: core::ffi::c_ulong,
    pub classid: u32_,
}
impl Default for tcf_result__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for tcf_result {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_proto_ops {
    pub head: list_head,
    pub kind: [core::ffi::c_char; 16usize],
    pub classify: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const tcf_proto,
            arg3: *mut tcf_result,
        ) -> core::ffi::c_int,
    >,
    pub init:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut tcf_proto) -> core::ffi::c_int>,
    pub destroy: ::core::option::Option<
        unsafe extern "C" fn(tp: *mut tcf_proto, rtnl_held: bool_, extack: *mut netlink_ext_ack),
    >,
    pub get: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut tcf_proto, handle: u32_) -> *mut core::ffi::c_void,
    >,
    pub put:
        ::core::option::Option<unsafe extern "C" fn(tp: *mut tcf_proto, f: *mut core::ffi::c_void)>,
    pub change: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            arg1: *mut sk_buff,
            arg2: *mut tcf_proto,
            arg3: core::ffi::c_ulong,
            handle: u32_,
            arg4: *mut *mut nlattr,
            arg5: *mut *mut core::ffi::c_void,
            arg6: u32_,
            arg7: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub delete: ::core::option::Option<
        unsafe extern "C" fn(
            tp: *mut tcf_proto,
            arg: *mut core::ffi::c_void,
            last: *mut bool_,
            rtnl_held: bool_,
            arg1: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub delete_empty: ::core::option::Option<unsafe extern "C" fn(tp: *mut tcf_proto) -> bool_>,
    pub walk: ::core::option::Option<
        unsafe extern "C" fn(tp: *mut tcf_proto, arg: *mut tcf_walker, rtnl_held: bool_),
    >,
    pub reoffload: ::core::option::Option<
        unsafe extern "C" fn(
            tp: *mut tcf_proto,
            add: bool_,
            cb: flow_setup_cb_t,
            cb_priv: *mut core::ffi::c_void,
            extack: *mut netlink_ext_ack,
        ) -> core::ffi::c_int,
    >,
    pub hw_add: ::core::option::Option<
        unsafe extern "C" fn(tp: *mut tcf_proto, type_data: *mut core::ffi::c_void),
    >,
    pub hw_del: ::core::option::Option<
        unsafe extern "C" fn(tp: *mut tcf_proto, type_data: *mut core::ffi::c_void),
    >,
    pub bind_class: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut core::ffi::c_void,
            arg2: u32_,
            arg3: core::ffi::c_ulong,
            arg4: *mut core::ffi::c_void,
            arg5: core::ffi::c_ulong,
        ),
    >,
    pub tmplt_create: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            chain: *mut tcf_chain,
            tca: *mut *mut nlattr,
            extack: *mut netlink_ext_ack,
        ) -> *mut core::ffi::c_void,
    >,
    pub tmplt_destroy:
        ::core::option::Option<unsafe extern "C" fn(tmplt_priv: *mut core::ffi::c_void)>,
    pub dump: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut net,
            arg2: *mut tcf_proto,
            arg3: *mut core::ffi::c_void,
            skb: *mut sk_buff,
            arg4: *mut tcmsg,
            arg5: bool_,
        ) -> core::ffi::c_int,
    >,
    pub terse_dump: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            tp: *mut tcf_proto,
            fh: *mut core::ffi::c_void,
            skb: *mut sk_buff,
            t: *mut tcmsg,
            rtnl_held: bool_,
        ) -> core::ffi::c_int,
    >,
    pub tmplt_dump: ::core::option::Option<
        unsafe extern "C" fn(
            skb: *mut sk_buff,
            net: *mut net,
            tmplt_priv: *mut core::ffi::c_void,
        ) -> core::ffi::c_int,
    >,
    pub owner: *mut module,
    pub flags: core::ffi::c_int,
}
impl Default for tcf_proto_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
pub const tcf_proto_ops_flags_TCF_PROTO_OPS_DOIT_UNLOCKED: tcf_proto_ops_flags = 1;
pub type tcf_proto_ops_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_proto {
    pub next: *mut tcf_proto,
    pub root: *mut core::ffi::c_void,
    pub classify: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut sk_buff,
            arg2: *const tcf_proto,
            arg3: *mut tcf_result,
        ) -> core::ffi::c_int,
    >,
    pub protocol: __be16,
    pub prio: u32_,
    pub data: *mut core::ffi::c_void,
    pub ops: *const tcf_proto_ops,
    pub chain: *mut tcf_chain,
    pub lock: spinlock_t,
    pub deleting: bool_,
    pub refcnt: refcount_t,
    pub rcu: callback_head,
    pub destroy_ht_node: hlist_node,
}
impl Default for tcf_proto {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qdisc_skb_cb {
    pub __bindgen_anon_1: qdisc_skb_cb__bindgen_ty_1,
    pub data: [core::ffi::c_uchar; 20usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct qdisc_skb_cb__bindgen_ty_1 {
    pub pkt_len: core::ffi::c_uint,
    pub slave_dev_queue_mapping: u16_,
    pub tc_classid: u16_,
}
pub type tcf_chain_head_change_t = ::core::option::Option<
    unsafe extern "C" fn(tp_head: *mut tcf_proto, priv_: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_chain {
    pub filter_chain_lock: mutex,
    pub filter_chain: *mut tcf_proto,
    pub list: list_head,
    pub block: *mut tcf_block,
    pub index: u32_,
    pub refcnt: core::ffi::c_uint,
    pub action_refcnt: core::ffi::c_uint,
    pub explicitly_created: bool_,
    pub flushing: bool_,
    pub tmplt_ops: *const tcf_proto_ops,
    pub tmplt_priv: *mut core::ffi::c_void,
    pub rcu: callback_head,
}
impl Default for tcf_chain {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_block {
    pub lock: mutex,
    pub chain_list: list_head,
    pub index: u32_,
    pub classid: u32_,
    pub refcnt: refcount_t,
    pub net: *mut net,
    pub q: *mut Qdisc,
    pub cb_lock: rw_semaphore,
    pub flow_block: flow_block,
    pub owner_list: list_head,
    pub keep_dst: bool_,
    pub offloadcnt: atomic_t,
    pub nooffloaddevcnt: core::ffi::c_uint,
    pub lockeddevcnt: core::ffi::c_uint,
    pub chain0: tcf_block__bindgen_ty_1,
    pub rcu: callback_head,
    pub proto_destroy_ht: [hlist_head; 128usize],
    pub proto_destroy_lock: mutex,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcf_block__bindgen_ty_1 {
    pub chain: *mut tcf_chain,
    pub filter_chain_list: list_head,
}
impl Default for tcf_block__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for tcf_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut noop_qdisc: Qdisc;
}
extern "C" {
    pub static mut noop_qdisc_ops: Qdisc_ops;
}
extern "C" {
    pub static mut pfifo_fast_ops: Qdisc_ops;
}
extern "C" {
    pub static mut mq_qdisc_ops: Qdisc_ops;
}
extern "C" {
    pub static mut noqueue_qdisc_ops: Qdisc_ops;
}
extern "C" {
    pub static mut default_qdisc_ops: *const Qdisc_ops;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Qdisc_class_common {
    pub classid: u32_,
    pub hnode: hlist_node,
}
impl Default for Qdisc_class_common {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Qdisc_class_hash {
    pub hash: *mut hlist_head,
    pub hashsize: core::ffi::c_uint,
    pub hashmask: core::ffi::c_uint,
    pub hashelems: core::ffi::c_uint,
}
impl Default for Qdisc_class_hash {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn qdisc_class_hash_init(arg1: *mut Qdisc_class_hash) -> core::ffi::c_int;
}
extern "C" {
    pub fn qdisc_class_hash_insert(arg1: *mut Qdisc_class_hash, arg2: *mut Qdisc_class_common);
}
extern "C" {
    pub fn qdisc_class_hash_remove(arg1: *mut Qdisc_class_hash, arg2: *mut Qdisc_class_common);
}
extern "C" {
    pub fn qdisc_class_hash_grow(arg1: *mut Qdisc, arg2: *mut Qdisc_class_hash);
}
extern "C" {
    pub fn qdisc_class_hash_destroy(arg1: *mut Qdisc_class_hash);
}
extern "C" {
    pub fn dev_qdisc_change_tx_queue_len(dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn dev_qdisc_change_real_num_tx(dev: *mut net_device, new_real_tx: core::ffi::c_uint);
}
extern "C" {
    pub fn dev_init_scheduler(dev: *mut net_device);
}
extern "C" {
    pub fn dev_shutdown(dev: *mut net_device);
}
extern "C" {
    pub fn dev_activate(dev: *mut net_device);
}
extern "C" {
    pub fn dev_deactivate(dev: *mut net_device);
}
extern "C" {
    pub fn dev_deactivate_many(head: *mut list_head);
}
extern "C" {
    pub fn dev_graft_qdisc(dev_queue: *mut netdev_queue, qdisc: *mut Qdisc) -> *mut Qdisc;
}
extern "C" {
    pub fn qdisc_reset(qdisc: *mut Qdisc);
}
extern "C" {
    pub fn qdisc_put(qdisc: *mut Qdisc);
}
extern "C" {
    pub fn qdisc_put_unlocked(qdisc: *mut Qdisc);
}
extern "C" {
    pub fn qdisc_tree_reduce_backlog(qdisc: *mut Qdisc, n: core::ffi::c_int, len: core::ffi::c_int);
}
extern "C" {
    pub fn qdisc_offload_dump_helper(
        q: *mut Qdisc,
        type_: tc_setup_type,
        type_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn qdisc_offload_graft_helper(
        dev: *mut net_device,
        sch: *mut Qdisc,
        new: *mut Qdisc,
        old: *mut Qdisc,
        type_: tc_setup_type,
        type_data: *mut core::ffi::c_void,
        extack: *mut netlink_ext_ack,
    );
}
extern "C" {
    pub fn qdisc_offload_query_caps(
        dev: *mut net_device,
        type_: tc_setup_type,
        caps: *mut core::ffi::c_void,
        caps_len: usize,
    );
}
extern "C" {
    pub fn qdisc_alloc(
        dev_queue: *mut netdev_queue,
        ops: *const Qdisc_ops,
        extack: *mut netlink_ext_ack,
    ) -> *mut Qdisc;
}
extern "C" {
    pub fn qdisc_free(qdisc: *mut Qdisc);
}
extern "C" {
    pub fn qdisc_create_dflt(
        dev_queue: *mut netdev_queue,
        ops: *const Qdisc_ops,
        parentid: u32_,
        extack: *mut netlink_ext_ack,
    ) -> *mut Qdisc;
}
extern "C" {
    pub fn __qdisc_calculate_pkt_len(skb: *mut sk_buff, stab: *const qdisc_size_table);
}
extern "C" {
    pub fn skb_do_redirect(arg1: *mut sk_buff) -> core::ffi::c_int;
}
pub const net_xmit_qdisc_t___NET_XMIT_STOLEN: net_xmit_qdisc_t = 65536;
pub const net_xmit_qdisc_t___NET_XMIT_BYPASS: net_xmit_qdisc_t = 131072;
pub type net_xmit_qdisc_t = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct psched_ratecfg {
    pub rate_bytes_ps: u64_,
    pub mult: u32_,
    pub overhead: u16_,
    pub mpu: u16_,
    pub linklayer: u8_,
    pub shift: u8_,
}
extern "C" {
    pub fn psched_ratecfg_precompute(
        r: *mut psched_ratecfg,
        conf: *const tc_ratespec,
        rate64: u64_,
    );
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct psched_pktrate {
    pub rate_pkts_ps: u64_,
    pub mult: u32_,
    pub shift: u8_,
}
extern "C" {
    pub fn psched_ppscfg_precompute(r: *mut psched_pktrate, pktrate64: u64_);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mini_Qdisc {
    pub filter_list: *mut tcf_proto,
    pub block: *mut tcf_block,
    pub cpu_bstats: *mut gnet_stats_basic_sync,
    pub cpu_qstats: *mut gnet_stats_queue,
    pub rcu_state: core::ffi::c_ulong,
}
impl Default for mini_Qdisc {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mini_Qdisc_pair {
    pub miniq1: mini_Qdisc,
    pub miniq2: mini_Qdisc,
    pub p_miniq: *mut *mut mini_Qdisc,
}
impl Default for mini_Qdisc_pair {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn mini_qdisc_pair_swap(miniqp: *mut mini_Qdisc_pair, tp_head: *mut tcf_proto);
}
extern "C" {
    pub fn mini_qdisc_pair_init(
        miniqp: *mut mini_Qdisc_pair,
        qdisc: *mut Qdisc,
        p_miniq: *mut *mut mini_Qdisc,
    );
}
extern "C" {
    pub fn mini_qdisc_pair_block_init(miniqp: *mut mini_Qdisc_pair, block: *mut tcf_block);
}
extern "C" {
    pub fn mq_change_real_num_tx(sch: *mut Qdisc, new_real_tx: core::ffi::c_uint);
}
extern "C" {
    pub fn sch_frag_xmit_hook(
        skb: *mut sk_buff,
        xmit: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff) -> core::ffi::c_int>,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct compat_sock_fprog {
    pub len: u16_,
    pub filter: compat_uptr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sock_fprog_kern {
    pub len: u16_,
    pub filter: *mut sock_filter,
}
impl Default for sock_fprog_kern {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Default)]
pub struct bpf_binary_header {
    pub size: u32_,
    pub __bindgen_padding_0: [u8; 4usize],
    pub image: __IncompleteArrayField<u8_>,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Default, Copy, Clone)]
pub struct bpf_prog_stats {
    pub cnt: u64_stats_t,
    pub nsecs: u64_stats_t,
    pub misses: u64_stats_t,
    pub syncp: u64_stats_sync,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_filter {
    pub refcnt: refcount_t,
    pub rcu: callback_head,
    pub prog: *mut bpf_prog,
}
impl Default for sk_filter {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut bpf_stats_enabled_key: static_key_false;
}
extern "C" {
    pub static mut nf_conn_btf_access_lock: mutex;
}
extern "C" {
    pub static mut nfct_btf_struct_access: ::core::option::Option<
        unsafe extern "C" fn(
            log: *mut bpf_verifier_log,
            btf: *const btf,
            t: *const btf_type,
            off: core::ffi::c_int,
            size: core::ffi::c_int,
            atype: bpf_access_type,
            next_btf_id: *mut u32_,
            flag: *mut bpf_type_flag,
        ) -> core::ffi::c_int,
    >;
}
pub type bpf_dispatcher_fn = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *const core::ffi::c_void,
        insnsi: *const bpf_insn,
        bpf_func: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const core::ffi::c_void,
                arg2: *const bpf_insn,
            ) -> core::ffi::c_uint,
        >,
    ) -> core::ffi::c_uint,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_skb_data_end {
    pub qdisc_cb: qdisc_skb_cb,
    pub data_meta: *mut core::ffi::c_void,
    pub data_end: *mut core::ffi::c_void,
}
impl Default for bpf_skb_data_end {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_nh_params {
    pub nh_family: u32_,
    pub __bindgen_anon_1: bpf_nh_params__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_nh_params__bindgen_ty_1 {
    pub ipv4_nh: u32_,
    pub ipv6_nh: in6_addr,
    _bindgen_union_align: [u32; 4usize],
}
impl Default for bpf_nh_params__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_nh_params {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_redirect_info {
    pub flags: u32_,
    pub tgt_index: u32_,
    pub tgt_value: *mut core::ffi::c_void,
    pub map: *mut bpf_map,
    pub map_id: u32_,
    pub map_type: bpf_map_type,
    pub kern_flags: u32_,
    pub nh: bpf_nh_params,
}
impl Default for bpf_redirect_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut bpf_redirect_info: bpf_redirect_info;
}
extern "C" {
    pub static mut bpf_master_redirect_enabled_key: static_key_false;
}
extern "C" {
    pub fn xdp_master_redirect(xdp: *mut xdp_buff) -> u32_;
}
extern "C" {
    pub fn bpf_prog_change_xdp(prev_prog: *mut bpf_prog, prog: *mut bpf_prog);
}
extern "C" {
    pub fn sk_filter_trim_cap(
        sk: *mut sock,
        skb: *mut sk_buff,
        cap: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_select_runtime(fp: *mut bpf_prog, err: *mut core::ffi::c_int) -> *mut bpf_prog;
}
extern "C" {
    pub fn bpf_prog_free(fp: *mut bpf_prog);
}
extern "C" {
    pub fn bpf_opcode_in_insntable(code: u8_) -> bool_;
}
extern "C" {
    pub fn bpf_prog_free_linfo(prog: *mut bpf_prog);
}
extern "C" {
    pub fn bpf_prog_fill_jited_linfo(prog: *mut bpf_prog, insn_to_jit_off: *const u32_);
}
extern "C" {
    pub fn bpf_prog_alloc_jited_linfo(prog: *mut bpf_prog) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_jit_attempt_done(prog: *mut bpf_prog);
}
extern "C" {
    pub fn bpf_prog_alloc(size: core::ffi::c_uint, gfp_extra_flags: gfp_t) -> *mut bpf_prog;
}
extern "C" {
    pub fn bpf_prog_alloc_no_stats(
        size: core::ffi::c_uint,
        gfp_extra_flags: gfp_t,
    ) -> *mut bpf_prog;
}
extern "C" {
    pub fn bpf_prog_realloc(
        fp_old: *mut bpf_prog,
        size: core::ffi::c_uint,
        gfp_extra_flags: gfp_t,
    ) -> *mut bpf_prog;
}
extern "C" {
    pub fn __bpf_prog_free(fp: *mut bpf_prog);
}
pub type bpf_aux_classic_check_t = ::core::option::Option<
    unsafe extern "C" fn(filter: *mut sock_filter, flen: core::ffi::c_uint) -> core::ffi::c_int,
>;
extern "C" {
    pub fn bpf_prog_create(
        pfp: *mut *mut bpf_prog,
        fprog: *mut sock_fprog_kern,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_create_from_user(
        pfp: *mut *mut bpf_prog,
        fprog: *mut sock_fprog,
        trans: bpf_aux_classic_check_t,
        save_orig: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_prog_destroy(fp: *mut bpf_prog);
}
extern "C" {
    pub fn sk_attach_filter(fprog: *mut sock_fprog, sk: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_attach_bpf(ufd: u32_, sk: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_reuseport_attach_filter(fprog: *mut sock_fprog, sk: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_reuseport_attach_bpf(ufd: u32_, sk: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_reuseport_prog_free(prog: *mut bpf_prog);
}
extern "C" {
    pub fn sk_detach_filter(sk: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_get_filter(
        sk: *mut sock,
        optval: sockptr_t,
        len: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn sk_filter_charge(sk: *mut sock, fp: *mut sk_filter) -> bool_;
}
extern "C" {
    pub fn sk_filter_uncharge(sk: *mut sock, fp: *mut sk_filter);
}
extern "C" {
    pub fn __bpf_call_base(r1: u64_, r2: u64_, r3: u64_, r4: u64_, r5: u64_) -> u64_;
}
extern "C" {
    pub fn bpf_int_jit_compile(prog: *mut bpf_prog) -> *mut bpf_prog;
}
extern "C" {
    pub fn bpf_jit_compile(prog: *mut bpf_prog);
}
extern "C" {
    pub fn bpf_jit_needs_zext() -> bool_;
}
extern "C" {
    pub fn bpf_jit_supports_subprog_tailcalls() -> bool_;
}
extern "C" {
    pub fn bpf_jit_supports_kfunc_call() -> bool_;
}
extern "C" {
    pub fn bpf_helper_changes_pkt_data(func: *mut core::ffi::c_void) -> bool_;
}
extern "C" {
    pub fn bpf_patch_insn_single(
        prog: *mut bpf_prog,
        off: u32_,
        patch: *const bpf_insn,
        len: u32_,
    ) -> *mut bpf_prog;
}
extern "C" {
    pub fn bpf_remove_insns(prog: *mut bpf_prog, off: u32_, cnt: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_clear_redirect_map(map: *mut bpf_map);
}
extern "C" {
    pub fn xdp_do_generic_redirect(
        dev: *mut net_device,
        skb: *mut sk_buff,
        xdp: *mut xdp_buff,
        prog: *mut bpf_prog,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn xdp_do_redirect(
        dev: *mut net_device,
        xdp: *mut xdp_buff,
        prog: *mut bpf_prog,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn xdp_do_redirect_frame(
        dev: *mut net_device,
        xdp: *mut xdp_buff,
        xdpf: *mut xdp_frame,
        prog: *mut bpf_prog,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn xdp_do_flush();
}
extern "C" {
    pub fn bpf_warn_invalid_xdp_action(dev: *mut net_device, prog: *mut bpf_prog, act: u32_);
}
extern "C" {
    pub fn bpf_run_sk_reuseport(
        reuse: *mut sock_reuseport,
        sk: *mut sock,
        prog: *mut bpf_prog,
        skb: *mut sk_buff,
        migrating_sk: *mut sock,
        hash: u32_,
    ) -> *mut sock;
}
extern "C" {
    pub fn bpf_prog_kallsyms_del_all(fp: *mut bpf_prog);
}
extern "C" {
    pub fn bpf_internal_load_pointer_neg_helper(
        skb: *const sk_buff,
        k: core::ffi::c_int,
        size: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sock_addr_kern {
    pub sk: *mut sock,
    pub uaddr: *mut sockaddr,
    pub tmp_reg: u64_,
    pub t_ctx: *mut core::ffi::c_void,
}
impl Default for bpf_sock_addr_kern {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sock_ops_kern {
    pub sk: *mut sock,
    pub __bindgen_anon_1: bpf_sock_ops_kern__bindgen_ty_1,
    pub syn_skb: *mut sk_buff,
    pub skb: *mut sk_buff,
    pub skb_data_end: *mut core::ffi::c_void,
    pub op: u8_,
    pub is_fullsock: u8_,
    pub remaining_opt_len: u8_,
    pub temp: u64_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_sock_ops_kern__bindgen_ty_1 {
    pub args: [u32_; 4usize],
    pub reply: u32_,
    pub replylong: [u32_; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
impl Default for bpf_sock_ops_kern__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_sock_ops_kern {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sysctl_kern {
    pub head: *mut ctl_table_header,
    pub table: *mut ctl_table,
    pub cur_val: *mut core::ffi::c_void,
    pub cur_len: usize,
    pub new_val: *mut core::ffi::c_void,
    pub new_len: usize,
    pub new_updated: core::ffi::c_int,
    pub write: core::ffi::c_int,
    pub ppos: *mut loff_t,
    pub tmp_reg: u64_,
}
impl Default for bpf_sysctl_kern {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_sockopt_buf {
    pub data: [u8_; 32usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sockopt_kern {
    pub sk: *mut sock,
    pub optval: *mut u8_,
    pub optval_end: *mut u8_,
    pub level: s32,
    pub optname: s32,
    pub optlen: s32,
    pub current_task: *mut task_struct,
    pub tmp_reg: u64_,
}
impl Default for bpf_sockopt_kern {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn copy_bpf_fprog_from_user(
        dst: *mut sock_fprog,
        src: sockptr_t,
        len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sk_lookup_kern {
    pub family: u16_,
    pub protocol: u16_,
    pub sport: __be16,
    pub dport: u16_,
    pub v4: bpf_sk_lookup_kern__bindgen_ty_1,
    pub v6: bpf_sk_lookup_kern__bindgen_ty_2,
    pub selected_sk: *mut sock,
    pub ingress_ifindex: u32_,
    pub no_reuseport: bool_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_sk_lookup_kern__bindgen_ty_1 {
    pub saddr: __be32,
    pub daddr: __be32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_sk_lookup_kern__bindgen_ty_2 {
    pub saddr: *const in6_addr,
    pub daddr: *const in6_addr,
}
impl Default for bpf_sk_lookup_kern__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_sk_lookup_kern {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut bpf_sk_lookup_enabled: static_key_false;
}
extern "C" {
    pub static mut reuseport_lock: spinlock_t;
}
#[repr(C)]
pub struct sock_reuseport {
    pub rcu: callback_head,
    pub max_socks: u16_,
    pub num_socks: u16_,
    pub num_closed_socks: u16_,
    pub synq_overflow_ts: core::ffi::c_uint,
    pub reuseport_id: core::ffi::c_uint,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub prog: *mut bpf_prog,
    pub socks: __IncompleteArrayField<*mut sock>,
}
impl Default for sock_reuseport {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl sock_reuseport {
    #[inline]
    pub fn bind_inany(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bind_inany(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_conns(&self) -> core::ffi::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_conns(&mut self, val: core::ffi::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        bind_inany: core::ffi::c_uint,
        has_conns: core::ffi::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let bind_inany: u32 = unsafe { ::core::mem::transmute(bind_inany) };
            bind_inany as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_conns: u32 = unsafe { ::core::mem::transmute(has_conns) };
            has_conns as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn reuseport_alloc(sk: *mut sock, bind_inany: bool_) -> core::ffi::c_int;
}
extern "C" {
    pub fn reuseport_add_sock(sk: *mut sock, sk2: *mut sock, bind_inany: bool_)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn reuseport_detach_sock(sk: *mut sock);
}
extern "C" {
    pub fn reuseport_stop_listen_sock(sk: *mut sock);
}
extern "C" {
    pub fn reuseport_select_sock(
        sk: *mut sock,
        hash: u32_,
        skb: *mut sk_buff,
        hdr_len: core::ffi::c_int,
    ) -> *mut sock;
}
extern "C" {
    pub fn reuseport_migrate_sock(
        sk: *mut sock,
        migrating_sk: *mut sock,
        skb: *mut sk_buff,
    ) -> *mut sock;
}
extern "C" {
    pub fn reuseport_attach_prog(sk: *mut sock, prog: *mut bpf_prog) -> core::ffi::c_int;
}
extern "C" {
    pub fn reuseport_detach_prog(sk: *mut sock) -> core::ffi::c_int;
}
pub const INET_ECN_NOT_ECT: core::ffi::c_uint = 0;
pub const INET_ECN_ECT_1: core::ffi::c_uint = 1;
pub const INET_ECN_ECT_0: core::ffi::c_uint = 2;
pub const INET_ECN_CE: core::ffi::c_uint = 3;
pub const INET_ECN_MASK: core::ffi::c_uint = 3;
pub type _bindgen_ty_351 = core::ffi::c_uint;
extern "C" {
    pub static mut sysctl_tunnel_ecn_log: core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mptcp_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mptcp_ext {
    pub __bindgen_anon_1: mptcp_ext__bindgen_ty_1,
    pub data_seq: u64_,
    pub subflow_seq: u32_,
    pub data_len: u16_,
    pub csum: __sum16,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mptcp_ext__bindgen_ty_1 {
    pub data_ack: u64_,
    pub data_ack32: u32_,
    _bindgen_union_align: u64,
}
impl Default for mptcp_ext__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for mptcp_ext {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl mptcp_ext {
    #[inline]
    pub fn use_map(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_map(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsn64(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_dsn64(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_fin(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_data_fin(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_ack(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_ack(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ack64(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ack64(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mpc_map(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mpc_map(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_frozen(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_transient(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reset_transient(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reset_reason(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_reset_reason(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn csum_reqd(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_csum_reqd(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn infinite_map(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_infinite_map(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_map: u8_,
        dsn64: u8_,
        data_fin: u8_,
        use_ack: u8_,
        ack64: u8_,
        mpc_map: u8_,
        frozen: u8_,
        reset_transient: u8_,
        reset_reason: u8_,
        csum_reqd: u8_,
        infinite_map: u8_,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_map: u8 = unsafe { ::core::mem::transmute(use_map) };
            use_map as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dsn64: u8 = unsafe { ::core::mem::transmute(dsn64) };
            dsn64 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let data_fin: u8 = unsafe { ::core::mem::transmute(data_fin) };
            data_fin as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let use_ack: u8 = unsafe { ::core::mem::transmute(use_ack) };
            use_ack as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ack64: u8 = unsafe { ::core::mem::transmute(ack64) };
            ack64 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let mpc_map: u8 = unsafe { ::core::mem::transmute(mpc_map) };
            mpc_map as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let frozen: u8 = unsafe { ::core::mem::transmute(frozen) };
            frozen as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let reset_transient: u8 = unsafe { ::core::mem::transmute(reset_transient) };
            reset_transient as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let reset_reason: u8 = unsafe { ::core::mem::transmute(reset_reason) };
            reset_reason as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let csum_reqd: u8 = unsafe { ::core::mem::transmute(csum_reqd) };
            csum_reqd as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let infinite_map: u8 = unsafe { ::core::mem::transmute(infinite_map) };
            infinite_map as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mptcp_rm_list {
    pub ids: [u8_; 8usize],
    pub nr: u8_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mptcp_addr_info {
    pub id: u8_,
    pub family: sa_family_t,
    pub port: __be16,
    pub __bindgen_anon_1: mptcp_addr_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mptcp_addr_info__bindgen_ty_1 {
    pub addr: in_addr,
    _bindgen_union_align: u32,
}
impl Default for mptcp_addr_info__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for mptcp_addr_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mptcp_out_options {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mptcp_sock {}
extern "C" {
    pub fn __cgroup_bpf_run_lsm_sock(
        ctx: *const core::ffi::c_void,
        insn: *const bpf_insn,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __cgroup_bpf_run_lsm_socket(
        ctx: *const core::ffi::c_void,
        insn: *const bpf_insn,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub fn __cgroup_bpf_run_lsm_current(
        ctx: *const core::ffi::c_void,
        insn: *const bpf_insn,
    ) -> core::ffi::c_uint;
}
extern "C" {
    pub static mut cgroup_bpf_enabled_key: [static_key_false; 23usize];
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cgroup_storage_map {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct bpf_storage_buffer {
    pub rcu: callback_head,
    pub data: __IncompleteArrayField<core::ffi::c_char>,
}
impl Default for bpf_storage_buffer {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cgroup_storage {
    pub __bindgen_anon_1: bpf_cgroup_storage__bindgen_ty_1,
    pub map: *mut bpf_cgroup_storage_map,
    pub key: bpf_cgroup_storage_key,
    pub list_map: list_head,
    pub list_cg: list_head,
    pub node: rb_node,
    pub rcu: callback_head,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bpf_cgroup_storage__bindgen_ty_1 {
    pub buf: *mut bpf_storage_buffer,
    pub percpu_buf: *mut core::ffi::c_void,
    _bindgen_union_align: u64,
}
impl Default for bpf_cgroup_storage__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for bpf_cgroup_storage {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_cgroup_link {
    pub link: bpf_link,
    pub cgroup: *mut cgroup,
    pub type_: bpf_attach_type,
}
impl Default for bpf_cgroup_link {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bpf_prog_list {
    pub node: hlist_node,
    pub prog: *mut bpf_prog,
    pub link: *mut bpf_cgroup_link,
    pub storage: [*mut bpf_cgroup_storage; 2usize],
}
impl Default for bpf_prog_list {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn cgroup_bpf_inherit(cgrp: *mut cgroup) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_bpf_offline(cgrp: *mut cgroup);
}
extern "C" {
    pub fn __cgroup_bpf_run_filter_skb(
        sk: *mut sock,
        skb: *mut sk_buff,
        atype: cgroup_bpf_attach_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cgroup_bpf_run_filter_sk(
        sk: *mut sock,
        atype: cgroup_bpf_attach_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cgroup_bpf_run_filter_sock_addr(
        sk: *mut sock,
        uaddr: *mut sockaddr,
        atype: cgroup_bpf_attach_type,
        t_ctx: *mut core::ffi::c_void,
        flags: *mut u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cgroup_bpf_run_filter_sock_ops(
        sk: *mut sock,
        sock_ops: *mut bpf_sock_ops_kern,
        atype: cgroup_bpf_attach_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cgroup_bpf_check_dev_permission(
        dev_type: core::ffi::c_short,
        major: u32_,
        minor: u32_,
        access: core::ffi::c_short,
        atype: cgroup_bpf_attach_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cgroup_bpf_run_filter_sysctl(
        head: *mut ctl_table_header,
        table: *mut ctl_table,
        write: core::ffi::c_int,
        buf: *mut *mut core::ffi::c_char,
        pcount: *mut usize,
        ppos: *mut loff_t,
        atype: cgroup_bpf_attach_type,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cgroup_bpf_run_filter_setsockopt(
        sock: *mut sock,
        level: *mut core::ffi::c_int,
        optname: *mut core::ffi::c_int,
        optval: *mut core::ffi::c_char,
        optlen: *mut core::ffi::c_int,
        kernel_optval: *mut *mut core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cgroup_bpf_run_filter_getsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: *mut core::ffi::c_char,
        optlen: *mut core::ffi::c_int,
        max_optlen: core::ffi::c_int,
        retval: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cgroup_bpf_run_filter_getsockopt_kern(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: *mut core::ffi::c_void,
        optlen: *mut core::ffi::c_int,
        retval: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_storage_lookup(
        map: *mut bpf_cgroup_storage_map,
        key: *mut core::ffi::c_void,
        locked: bool_,
    ) -> *mut bpf_cgroup_storage;
}
extern "C" {
    pub fn bpf_cgroup_storage_alloc(
        prog: *mut bpf_prog,
        stype: bpf_cgroup_storage_type,
    ) -> *mut bpf_cgroup_storage;
}
extern "C" {
    pub fn bpf_cgroup_storage_free(storage: *mut bpf_cgroup_storage);
}
extern "C" {
    pub fn bpf_cgroup_storage_link(
        storage: *mut bpf_cgroup_storage,
        cgroup: *mut cgroup,
        type_: bpf_attach_type,
    );
}
extern "C" {
    pub fn bpf_cgroup_storage_unlink(storage: *mut bpf_cgroup_storage);
}
extern "C" {
    pub fn bpf_cgroup_storage_assign(aux: *mut bpf_prog_aux, map: *mut bpf_map)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_percpu_cgroup_storage_copy(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn bpf_percpu_cgroup_storage_update(
        map: *mut bpf_map,
        key: *mut core::ffi::c_void,
        value: *mut core::ffi::c_void,
        flags: u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_bpf_prog_attach(
        attr: *const bpf_attr,
        ptype: bpf_prog_type,
        prog: *mut bpf_prog,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_bpf_prog_detach(attr: *const bpf_attr, ptype: bpf_prog_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_bpf_link_attach(attr: *const bpf_attr, prog: *mut bpf_prog) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_bpf_prog_query(attr: *const bpf_attr, uattr: *mut bpf_attr) -> core::ffi::c_int;
}
extern "C" {
    pub fn cgroup_common_func_proto(
        func_id: bpf_func_id,
        prog: *const bpf_prog,
    ) -> *const bpf_func_proto;
}
extern "C" {
    pub fn cgroup_current_func_proto(
        func_id: bpf_func_id,
        prog: *const bpf_prog,
    ) -> *const bpf_func_proto;
}
extern "C" {
    pub static mut tcp_hashinfo: inet_hashinfo;
}
extern "C" {
    pub static mut tcp_orphan_count: core::ffi::c_uint;
}
extern "C" {
    pub fn tcp_orphan_count_sum() -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_time_wait(sk: *mut sock, state: core::ffi::c_int, timeo: core::ffi::c_int);
}
extern "C" {
    pub static mut sysctl_tcp_max_orphans: core::ffi::c_int;
}
extern "C" {
    pub static mut sysctl_tcp_mem: [core::ffi::c_long; 3usize];
}
extern "C" {
    pub static mut tcp_memory_allocated: atomic_long_t;
}
extern "C" {
    pub static mut tcp_memory_per_cpu_fw_alloc: core::ffi::c_int;
}
extern "C" {
    pub static mut tcp_sockets_allocated: percpu_counter;
}
extern "C" {
    pub static mut tcp_memory_pressure: core::ffi::c_ulong;
}
extern "C" {
    pub fn sk_forced_mem_schedule(sk: *mut sock, size: core::ffi::c_int);
}
extern "C" {
    pub fn tcp_check_oom(sk: *mut sock, shift: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub static mut tcp_prot: proto;
}
extern "C" {
    pub fn tcp_tasklet_init();
}
extern "C" {
    pub fn tcp_v4_err(skb: *mut sk_buff, arg1: u32_) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_shutdown(sk: *mut sock, how: core::ffi::c_int);
}
extern "C" {
    pub fn tcp_v4_early_demux(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_v4_rcv(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_remove_empty_skb(sk: *mut sock);
}
extern "C" {
    pub fn tcp_v4_tw_remember_stamp(tw: *mut inet_timewait_sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_sendmsg(sk: *mut sock, msg: *mut msghdr, size: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_sendmsg_locked(sk: *mut sock, msg: *mut msghdr, size: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_sendmsg_fastopen(
        sk: *mut sock,
        msg: *mut msghdr,
        copied: *mut core::ffi::c_int,
        size: usize,
        uarg: *mut ubuf_info,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_sendpage(
        sk: *mut sock,
        page: *mut page,
        offset: core::ffi::c_int,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_sendpage_locked(
        sk: *mut sock,
        page: *mut page,
        offset: core::ffi::c_int,
        size: usize,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn do_tcp_sendpages(
        sk: *mut sock,
        page: *mut page,
        offset: core::ffi::c_int,
        size: usize,
        flags: core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    pub fn tcp_send_mss(
        sk: *mut sock,
        size_goal: *mut core::ffi::c_int,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_push(
        sk: *mut sock,
        flags: core::ffi::c_int,
        mss_now: core::ffi::c_int,
        nonagle: core::ffi::c_int,
        size_goal: core::ffi::c_int,
    );
}
extern "C" {
    pub fn tcp_release_cb(sk: *mut sock);
}
extern "C" {
    pub fn tcp_wfree(skb: *mut sk_buff);
}
extern "C" {
    pub fn tcp_write_timer_handler(sk: *mut sock);
}
extern "C" {
    pub fn tcp_delack_timer_handler(sk: *mut sock);
}
extern "C" {
    pub fn tcp_ioctl(
        sk: *mut sock,
        cmd: core::ffi::c_int,
        arg: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_rcv_state_process(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_rcv_established(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn tcp_rcv_space_adjust(sk: *mut sock);
}
extern "C" {
    pub fn tcp_twsk_unique(
        sk: *mut sock,
        sktw: *mut sock,
        twp: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_twsk_destructor(sk: *mut sock);
}
extern "C" {
    pub fn tcp_twsk_purge(net_exit_list: *mut list_head, family: core::ffi::c_int);
}
extern "C" {
    pub fn tcp_splice_read(
        sk: *mut socket,
        ppos: *mut loff_t,
        pipe: *mut pipe_inode_info,
        len: usize,
        flags: core::ffi::c_uint,
    ) -> isize;
}
extern "C" {
    pub fn tcp_stream_alloc_skb(
        sk: *mut sock,
        size: core::ffi::c_int,
        gfp: gfp_t,
        force_schedule: bool_,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn tcp_enter_quickack_mode(sk: *mut sock, max_quickacks: core::ffi::c_uint);
}
pub const tcp_tw_status_TCP_TW_SUCCESS: tcp_tw_status = 0;
pub const tcp_tw_status_TCP_TW_RST: tcp_tw_status = 1;
pub const tcp_tw_status_TCP_TW_ACK: tcp_tw_status = 2;
pub const tcp_tw_status_TCP_TW_SYN: tcp_tw_status = 3;
pub type tcp_tw_status = core::ffi::c_uint;
extern "C" {
    pub fn tcp_timewait_state_process(
        tw: *mut inet_timewait_sock,
        skb: *mut sk_buff,
        th: *const tcphdr,
    ) -> tcp_tw_status;
}
extern "C" {
    pub fn tcp_check_req(
        sk: *mut sock,
        skb: *mut sk_buff,
        req: *mut request_sock,
        fastopen: bool_,
        lost_race: *mut bool_,
    ) -> *mut sock;
}
extern "C" {
    pub fn tcp_child_process(
        parent: *mut sock,
        child: *mut sock,
        skb: *mut sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_enter_loss(sk: *mut sock);
}
extern "C" {
    pub fn tcp_cwnd_reduction(
        sk: *mut sock,
        newly_acked_sacked: core::ffi::c_int,
        newly_lost: core::ffi::c_int,
        flag: core::ffi::c_int,
    );
}
extern "C" {
    pub fn tcp_clear_retrans(tp: *mut tcp_sock);
}
extern "C" {
    pub fn tcp_update_metrics(sk: *mut sock);
}
extern "C" {
    pub fn tcp_init_metrics(sk: *mut sock);
}
extern "C" {
    pub fn tcp_metrics_init();
}
extern "C" {
    pub fn tcp_peer_is_proven(req: *mut request_sock, dst: *mut dst_entry) -> bool_;
}
extern "C" {
    pub fn __tcp_close(sk: *mut sock, timeout: core::ffi::c_long);
}
extern "C" {
    pub fn tcp_close(sk: *mut sock, timeout: core::ffi::c_long);
}
extern "C" {
    pub fn tcp_init_sock(sk: *mut sock);
}
extern "C" {
    pub fn tcp_init_transfer(sk: *mut sock, bpf_op: core::ffi::c_int, skb: *mut sk_buff);
}
extern "C" {
    pub fn tcp_poll(file: *mut file, sock: *mut socket, wait: *mut poll_table_struct) -> __poll_t;
}
extern "C" {
    pub fn do_tcp_getsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: sockptr_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_getsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: *mut core::ffi::c_char,
        optlen: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_bpf_bypass_getsockopt(level: core::ffi::c_int, optname: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn do_tcp_setsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_setsockopt(
        sk: *mut sock,
        level: core::ffi::c_int,
        optname: core::ffi::c_int,
        optval: sockptr_t,
        optlen: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_set_keepalive(sk: *mut sock, val: core::ffi::c_int);
}
extern "C" {
    pub fn tcp_syn_ack_timeout(req: *const request_sock);
}
extern "C" {
    pub fn tcp_recvmsg(
        sk: *mut sock,
        msg: *mut msghdr,
        len: usize,
        flags: core::ffi::c_int,
        addr_len: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_set_rcvlowat(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_set_window_clamp(sk: *mut sock, val: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_update_recv_tstamps(skb: *mut sk_buff, tss: *mut scm_timestamping_internal);
}
extern "C" {
    pub fn tcp_recv_timestamp(
        msg: *mut msghdr,
        sk: *const sock,
        tss: *mut scm_timestamping_internal,
    );
}
extern "C" {
    pub fn tcp_data_ready(sk: *mut sock);
}
extern "C" {
    pub fn tcp_mmap(
        file: *mut file,
        sock: *mut socket,
        vma: *mut vm_area_struct,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_parse_options(
        net: *const net,
        skb: *const sk_buff,
        opt_rx: *mut tcp_options_received,
        estab: core::ffi::c_int,
        foc: *mut tcp_fastopen_cookie,
    );
}
extern "C" {
    pub fn tcp_parse_md5sig_option(th: *const tcphdr) -> *const u8_;
}
extern "C" {
    pub fn tcp_v4_get_syncookie(
        sk: *mut sock,
        iph: *mut iphdr,
        th: *mut tcphdr,
        cookie: *mut u32_,
    ) -> u16_;
}
extern "C" {
    pub fn tcp_v6_get_syncookie(
        sk: *mut sock,
        iph: *mut ipv6hdr,
        th: *mut tcphdr,
        cookie: *mut u32_,
    ) -> u16_;
}
extern "C" {
    pub fn tcp_parse_mss_option(th: *const tcphdr, user_mss: u16_) -> u16_;
}
extern "C" {
    pub fn tcp_get_syncookie_mss(
        rsk_ops: *mut request_sock_ops,
        af_ops: *const tcp_request_sock_ops,
        sk: *mut sock,
        th: *mut tcphdr,
    ) -> u16_;
}
extern "C" {
    pub fn tcp_v4_send_check(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn tcp_v4_mtu_reduced(sk: *mut sock);
}
extern "C" {
    pub fn tcp_req_err(sk: *mut sock, seq: u32_, abort: bool_);
}
extern "C" {
    pub fn tcp_ld_RTO_revert(sk: *mut sock, seq: u32_);
}
extern "C" {
    pub fn tcp_v4_conn_request(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_create_openreq_child(
        sk: *const sock,
        req: *mut request_sock,
        skb: *mut sk_buff,
    ) -> *mut sock;
}
extern "C" {
    pub fn tcp_ca_openreq_child(sk: *mut sock, dst: *const dst_entry);
}
extern "C" {
    pub fn tcp_v4_syn_recv_sock(
        sk: *const sock,
        skb: *mut sk_buff,
        req: *mut request_sock,
        dst: *mut dst_entry,
        req_unhash: *mut request_sock,
        own_req: *mut bool_,
    ) -> *mut sock;
}
extern "C" {
    pub fn tcp_v4_do_rcv(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_v4_connect(
        sk: *mut sock,
        uaddr: *mut sockaddr,
        addr_len: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_connect(sk: *mut sock) -> core::ffi::c_int;
}
pub const tcp_synack_type_TCP_SYNACK_NORMAL: tcp_synack_type = 0;
pub const tcp_synack_type_TCP_SYNACK_FASTOPEN: tcp_synack_type = 1;
pub const tcp_synack_type_TCP_SYNACK_COOKIE: tcp_synack_type = 2;
pub type tcp_synack_type = core::ffi::c_uint;
extern "C" {
    pub fn tcp_make_synack(
        sk: *const sock,
        dst: *mut dst_entry,
        req: *mut request_sock,
        foc: *mut tcp_fastopen_cookie,
        synack_type: tcp_synack_type,
        syn_skb: *mut sk_buff,
    ) -> *mut sk_buff;
}
extern "C" {
    pub fn tcp_disconnect(sk: *mut sock, flags: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_finish_connect(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn tcp_send_rcvq(sk: *mut sock, msg: *mut msghdr, size: usize) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_sk_rx_dst_set(sk: *mut sock, skb: *const sk_buff);
}
extern "C" {
    pub fn tcp_get_cookie_sock(
        sk: *mut sock,
        skb: *mut sk_buff,
        req: *mut request_sock,
        dst: *mut dst_entry,
        tsoff: u32_,
    ) -> *mut sock;
}
extern "C" {
    pub fn __cookie_v4_check(
        iph: *const iphdr,
        th: *const tcphdr,
        cookie: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cookie_v4_check(sk: *mut sock, skb: *mut sk_buff) -> *mut sock;
}
extern "C" {
    pub fn cookie_tcp_reqsk_alloc(
        ops: *const request_sock_ops,
        af_ops: *const tcp_request_sock_ops,
        sk: *mut sock,
        skb: *mut sk_buff,
    ) -> *mut request_sock;
}
extern "C" {
    pub fn tcp_skb_entail(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn tcp_mark_push(tp: *mut tcp_sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn __tcp_push_pending_frames(
        sk: *mut sock,
        cur_mss: core::ffi::c_uint,
        nonagle: core::ffi::c_int,
    );
}
extern "C" {
    pub fn __tcp_retransmit_skb(
        sk: *mut sock,
        skb: *mut sk_buff,
        segs: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_retransmit_skb(
        sk: *mut sock,
        skb: *mut sk_buff,
        segs: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_retransmit_timer(sk: *mut sock);
}
extern "C" {
    pub fn tcp_xmit_retransmit_queue(arg1: *mut sock);
}
extern "C" {
    pub fn tcp_simple_retransmit(arg1: *mut sock);
}
extern "C" {
    pub fn tcp_enter_recovery(sk: *mut sock, ece_ack: bool_);
}
extern "C" {
    pub fn tcp_trim_head(arg1: *mut sock, arg2: *mut sk_buff, arg3: u32_) -> core::ffi::c_int;
}
pub const tcp_queue_TCP_FRAG_IN_WRITE_QUEUE: tcp_queue = 0;
pub const tcp_queue_TCP_FRAG_IN_RTX_QUEUE: tcp_queue = 1;
pub type tcp_queue = core::ffi::c_uint;
extern "C" {
    pub fn tcp_fragment(
        sk: *mut sock,
        tcp_queue: tcp_queue,
        skb: *mut sk_buff,
        len: u32_,
        mss_now: core::ffi::c_uint,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_send_probe0(arg1: *mut sock);
}
extern "C" {
    pub fn tcp_send_partial(arg1: *mut sock);
}
extern "C" {
    pub fn tcp_write_wakeup(arg1: *mut sock, mib: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_send_fin(sk: *mut sock);
}
extern "C" {
    pub fn tcp_send_active_reset(sk: *mut sock, priority: gfp_t);
}
extern "C" {
    pub fn tcp_send_synack(arg1: *mut sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_push_one(arg1: *mut sock, mss_now: core::ffi::c_uint);
}
extern "C" {
    pub fn __tcp_send_ack(sk: *mut sock, rcv_nxt: u32_);
}
extern "C" {
    pub fn tcp_send_ack(sk: *mut sock);
}
extern "C" {
    pub fn tcp_send_delayed_ack(sk: *mut sock);
}
extern "C" {
    pub fn tcp_send_loss_probe(sk: *mut sock);
}
extern "C" {
    pub fn tcp_schedule_loss_probe(sk: *mut sock, advancing_rto: bool_) -> bool_;
}
extern "C" {
    pub fn tcp_skb_collapse_tstamp(skb: *mut sk_buff, next_skb: *const sk_buff);
}
extern "C" {
    pub fn tcp_rearm_rto(sk: *mut sock);
}
extern "C" {
    pub fn tcp_synack_rtt_meas(sk: *mut sock, req: *mut request_sock);
}
extern "C" {
    pub fn tcp_reset(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn tcp_skb_mark_lost_uncond_verify(tp: *mut tcp_sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn tcp_fin(sk: *mut sock);
}
extern "C" {
    pub fn tcp_check_space(sk: *mut sock);
}
extern "C" {
    pub fn tcp_init_xmit_timers(arg1: *mut sock);
}
extern "C" {
    pub fn tcp_sync_mss(sk: *mut sock, pmtu: u32_) -> core::ffi::c_uint;
}
extern "C" {
    pub fn tcp_current_mss(sk: *mut sock) -> core::ffi::c_uint;
}
extern "C" {
    pub fn tcp_clamp_probe0_to_user_timeout(sk: *const sock, when: u32_) -> u32_;
}
extern "C" {
    pub fn tcp_get_info(arg1: *mut sock, arg2: *mut tcp_info);
}
extern "C" {
    pub fn tcp_read_sock(
        sk: *mut sock,
        desc: *mut read_descriptor_t,
        recv_actor: sk_read_actor_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_read_skb(sk: *mut sock, recv_actor: skb_read_actor_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_recv_skb(sk: *mut sock, seq: u32_, off: *mut u32_) -> *mut sk_buff;
}
extern "C" {
    pub fn tcp_read_done(sk: *mut sock, len: usize);
}
extern "C" {
    pub fn tcp_initialize_rcv_mss(sk: *mut sock);
}
extern "C" {
    pub fn tcp_mtu_to_mss(sk: *mut sock, pmtu: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_mss_to_mtu(sk: *mut sock, mss: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_mtup_init(sk: *mut sock);
}
extern "C" {
    pub fn __tcp_select_window(sk: *mut sock) -> u32_;
}
extern "C" {
    pub fn tcp_send_window_probe(sk: *mut sock);
}
extern "C" {
    pub fn tcp_mstamp_refresh(tp: *mut tcp_sock);
}
#[repr(C)]
pub struct tcp_skb_cb {
    pub seq: __u32,
    pub end_seq: __u32,
    pub __bindgen_anon_1: tcp_skb_cb__bindgen_ty_1,
    pub tcp_flags: __u8,
    pub sacked: __u8,
    pub ip_dsfield: __u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub ack_seq: __u32,
    pub __bindgen_anon_2: tcp_skb_cb__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcp_skb_cb__bindgen_ty_1 {
    pub tcp_tw_isn: __u32,
    pub __bindgen_anon_1: tcp_skb_cb__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_skb_cb__bindgen_ty_1__bindgen_ty_1 {
    pub tcp_gso_segs: u16_,
    pub tcp_gso_size: u16_,
}
impl Default for tcp_skb_cb__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
pub struct tcp_skb_cb__bindgen_ty_2 {
    pub tx: __BindgenUnionField<tcp_skb_cb__bindgen_ty_2__bindgen_ty_1>,
    pub header: __BindgenUnionField<tcp_skb_cb__bindgen_ty_2__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 3usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_skb_cb__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub delivered: __u32,
    pub first_tx_mstamp: u64_,
    pub delivered_mstamp: u64_,
}
impl tcp_skb_cb__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn is_app_limited(&self) -> __u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_app_limited(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn delivered_ce(&self) -> __u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_delivered_ce(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> __u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: __u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_app_limited: __u32,
        delivered_ce: __u32,
        unused: __u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_app_limited: u32 = unsafe { ::core::mem::transmute(is_app_limited) };
            is_app_limited as u64
        });
        __bindgen_bitfield_unit.set(1usize, 20u8, {
            let delivered_ce: u32 = unsafe { ::core::mem::transmute(delivered_ce) };
            delivered_ce as u64
        });
        __bindgen_bitfield_unit.set(21usize, 11u8, {
            let unused: u32 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
pub struct tcp_skb_cb__bindgen_ty_2__bindgen_ty_2 {
    pub h4: __BindgenUnionField<inet_skb_parm>,
    pub h6: __BindgenUnionField<inet6_skb_parm>,
    pub bindgen_union_field: [u32; 6usize],
}
impl Default for tcp_skb_cb__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for tcp_skb_cb__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for tcp_skb_cb {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl tcp_skb_cb {
    #[inline]
    pub fn txstamp_ack(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_txstamp_ack(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eor(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_eor(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_rxtstamp(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_has_rxtstamp(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unused(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_unused(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        txstamp_ack: __u8,
        eor: __u8,
        has_rxtstamp: __u8,
        unused: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let txstamp_ack: u8 = unsafe { ::core::mem::transmute(txstamp_ack) };
            txstamp_ack as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let eor: u8 = unsafe { ::core::mem::transmute(eor) };
            eor as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_rxtstamp: u8 = unsafe { ::core::mem::transmute(has_rxtstamp) };
            has_rxtstamp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let unused: u8 = unsafe { ::core::mem::transmute(unused) };
            unused as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub static ipv4_specific: inet_connection_sock_af_ops;
}
extern "C" {
    pub static ipv6_specific: inet_connection_sock_af_ops;
}
extern "C" {
    pub fn tcp_v6_early_demux(skb: *mut sk_buff);
}
pub const tcp_ca_event_CA_EVENT_TX_START: tcp_ca_event = 0;
pub const tcp_ca_event_CA_EVENT_CWND_RESTART: tcp_ca_event = 1;
pub const tcp_ca_event_CA_EVENT_COMPLETE_CWR: tcp_ca_event = 2;
pub const tcp_ca_event_CA_EVENT_LOSS: tcp_ca_event = 3;
pub const tcp_ca_event_CA_EVENT_ECN_NO_CE: tcp_ca_event = 4;
pub const tcp_ca_event_CA_EVENT_ECN_IS_CE: tcp_ca_event = 5;
pub type tcp_ca_event = core::ffi::c_uint;
pub const tcp_ca_ack_event_flags_CA_ACK_SLOWPATH: tcp_ca_ack_event_flags = 1;
pub const tcp_ca_ack_event_flags_CA_ACK_WIN_UPDATE: tcp_ca_ack_event_flags = 2;
pub const tcp_ca_ack_event_flags_CA_ACK_ECE: tcp_ca_ack_event_flags = 4;
pub type tcp_ca_ack_event_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_cc_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ack_sample {
    pub pkts_acked: u32_,
    pub rtt_us: s32,
    pub in_flight: u32_,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rate_sample {
    pub prior_mstamp: u64_,
    pub prior_delivered: u32_,
    pub prior_delivered_ce: u32_,
    pub delivered: s32,
    pub delivered_ce: s32,
    pub interval_us: core::ffi::c_long,
    pub snd_interval_us: u32_,
    pub rcv_interval_us: u32_,
    pub rtt_us: core::ffi::c_long,
    pub losses: core::ffi::c_int,
    pub acked_sacked: u32_,
    pub prior_in_flight: u32_,
    pub last_end_seq: u32_,
    pub is_app_limited: bool_,
    pub is_retrans: bool_,
    pub is_ack_delayed: bool_,
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct tcp_congestion_ops {
    pub ssthresh: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> u32_>,
    pub cong_avoid:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, ack: u32_, acked: u32_)>,
    pub set_state: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, new_state: u8_)>,
    pub cwnd_event: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, ev: tcp_ca_event)>,
    pub in_ack_event: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, flags: u32_)>,
    pub pkts_acked:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, sample: *const ack_sample)>,
    pub min_tso_segs: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> u32_>,
    pub cong_control:
        ::core::option::Option<unsafe extern "C" fn(sk: *mut sock, rs: *const rate_sample)>,
    pub undo_cwnd: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> u32_>,
    pub sndbuf_expand: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> u32_>,
    pub get_info: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            ext: u32_,
            attr: *mut core::ffi::c_int,
            info: *mut tcp_cc_info,
        ) -> usize,
    >,
    pub name: [core::ffi::c_char; 16usize],
    pub owner: *mut module,
    pub list: list_head,
    pub key: u32_,
    pub flags: u32_,
    pub init: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub release: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
}
impl Default for tcp_congestion_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn tcp_register_congestion_control(type_: *mut tcp_congestion_ops) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_unregister_congestion_control(type_: *mut tcp_congestion_ops);
}
extern "C" {
    pub fn tcp_assign_congestion_control(sk: *mut sock);
}
extern "C" {
    pub fn tcp_init_congestion_control(sk: *mut sock);
}
extern "C" {
    pub fn tcp_cleanup_congestion_control(sk: *mut sock);
}
extern "C" {
    pub fn tcp_set_default_congestion_control(
        net: *mut net,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_get_default_congestion_control(net: *mut net, name: *mut core::ffi::c_char);
}
extern "C" {
    pub fn tcp_get_available_congestion_control(buf: *mut core::ffi::c_char, len: usize);
}
extern "C" {
    pub fn tcp_get_allowed_congestion_control(buf: *mut core::ffi::c_char, len: usize);
}
extern "C" {
    pub fn tcp_set_allowed_congestion_control(allowed: *mut core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_set_congestion_control(
        sk: *mut sock,
        name: *const core::ffi::c_char,
        load: bool_,
        cap_net_admin: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_slow_start(tp: *mut tcp_sock, acked: u32_) -> u32_;
}
extern "C" {
    pub fn tcp_cong_avoid_ai(tp: *mut tcp_sock, w: u32_, acked: u32_);
}
extern "C" {
    pub fn tcp_reno_ssthresh(sk: *mut sock) -> u32_;
}
extern "C" {
    pub fn tcp_reno_undo_cwnd(sk: *mut sock) -> u32_;
}
extern "C" {
    pub fn tcp_reno_cong_avoid(sk: *mut sock, ack: u32_, acked: u32_);
}
extern "C" {
    pub static mut tcp_reno: tcp_congestion_ops;
}
extern "C" {
    pub fn tcp_ca_find(name: *const core::ffi::c_char) -> *mut tcp_congestion_ops;
}
extern "C" {
    pub fn tcp_ca_find_key(key: u32_) -> *mut tcp_congestion_ops;
}
extern "C" {
    pub fn tcp_ca_get_key_by_name(
        net: *mut net,
        name: *const core::ffi::c_char,
        ecn_ca: *mut bool_,
    ) -> u32_;
}
extern "C" {
    pub fn tcp_ca_get_name_by_key(
        key: u32_,
        buffer: *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn tcp_set_ca_state(sk: *mut sock, ca_state: u8_);
}
extern "C" {
    pub fn tcp_rate_skb_sent(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn tcp_rate_skb_delivered(sk: *mut sock, skb: *mut sk_buff, rs: *mut rate_sample);
}
extern "C" {
    pub fn tcp_rate_gen(
        sk: *mut sock,
        delivered: u32_,
        lost: u32_,
        is_sack_reneg: bool_,
        rs: *mut rate_sample,
    );
}
extern "C" {
    pub fn tcp_rate_check_app_limited(sk: *mut sock);
}
extern "C" {
    pub fn tcp_enter_cwr(sk: *mut sock);
}
extern "C" {
    pub fn tcp_init_cwnd(tp: *const tcp_sock, dst: *const dst_entry) -> __u32;
}
extern "C" {
    pub fn tcp_add_backlog(sk: *mut sock, skb: *mut sk_buff, reason: *mut skb_drop_reason)
        -> bool_;
}
extern "C" {
    pub fn tcp_filter(sk: *mut sock, skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_set_state(sk: *mut sock, state: core::ffi::c_int);
}
extern "C" {
    pub fn tcp_done(sk: *mut sock);
}
extern "C" {
    pub fn tcp_abort(sk: *mut sock, err: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_cwnd_restart(sk: *mut sock, delta: s32);
}
extern "C" {
    pub fn tcp_select_initial_window(
        sk: *const sock,
        __space: core::ffi::c_int,
        mss: __u32,
        rcv_wnd: *mut __u32,
        window_clamp: *mut __u32,
        wscale_ok: core::ffi::c_int,
        rcv_wscale: *mut __u8,
        init_rcv_wnd: __u32,
    );
}
extern "C" {
    pub fn tcp_cleanup_rbuf(sk: *mut sock, copied: core::ffi::c_int);
}
extern "C" {
    pub fn tcp_openreq_init_rwin(
        req: *mut request_sock,
        sk_listener: *const sock,
        dst: *const dst_entry,
    );
}
extern "C" {
    pub fn tcp_enter_memory_pressure(sk: *mut sock);
}
extern "C" {
    pub fn tcp_leave_memory_pressure(sk: *mut sock);
}
extern "C" {
    pub fn tcp_oow_rate_limited(
        net: *mut net,
        skb: *const sk_buff,
        mib_idx: core::ffi::c_int,
        last_oow_ack_time: *mut u32_,
    ) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcp_md5_addr {
    pub a4: in_addr,
    pub a6: in6_addr,
    _bindgen_union_align: [u32; 4usize],
}
impl Default for tcp_md5_addr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_md5sig_key {
    pub node: hlist_node,
    pub keylen: u8_,
    pub family: u8_,
    pub prefixlen: u8_,
    pub flags: u8_,
    pub addr: tcp_md5_addr,
    pub l3index: core::ffi::c_int,
    pub key: [u8_; 80usize],
    pub rcu: callback_head,
}
impl Default for tcp_md5sig_key {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_md5sig_info {
    pub head: hlist_head,
    pub rcu: callback_head,
}
impl Default for tcp_md5sig_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp4_pseudohdr {
    pub saddr: __be32,
    pub daddr: __be32,
    pub pad: __u8,
    pub protocol: __u8,
    pub len: __be16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp6_pseudohdr {
    pub saddr: in6_addr,
    pub daddr: in6_addr,
    pub len: __be32,
    pub protocol: __be32,
}
impl Default for tcp6_pseudohdr {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tcp_md5sum_block {
    pub ip4: tcp4_pseudohdr,
    pub ip6: tcp6_pseudohdr,
    _bindgen_union_align: [u32; 10usize],
}
impl Default for tcp_md5sum_block {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_md5sig_pool {
    pub md5_req: *mut ahash_request,
    pub scratch: *mut core::ffi::c_void,
}
impl Default for tcp_md5sig_pool {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn tcp_v4_md5_hash_skb(
        md5_hash: *mut core::ffi::c_char,
        key: *const tcp_md5sig_key,
        sk: *const sock,
        skb: *const sk_buff,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_md5_do_add(
        sk: *mut sock,
        addr: *const tcp_md5_addr,
        family: core::ffi::c_int,
        prefixlen: u8_,
        l3index: core::ffi::c_int,
        flags: u8_,
        newkey: *const u8_,
        newkeylen: u8_,
        gfp: gfp_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_md5_do_del(
        sk: *mut sock,
        addr: *const tcp_md5_addr,
        family: core::ffi::c_int,
        prefixlen: u8_,
        l3index: core::ffi::c_int,
        flags: u8_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_v4_md5_lookup(sk: *const sock, addr_sk: *const sock) -> *mut tcp_md5sig_key;
}
extern "C" {
    pub fn tcp_alloc_md5sig_pool() -> bool_;
}
extern "C" {
    pub fn tcp_get_md5sig_pool() -> *mut tcp_md5sig_pool;
}
extern "C" {
    pub fn tcp_md5_hash_skb_data(
        arg1: *mut tcp_md5sig_pool,
        arg2: *const sk_buff,
        header_len: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_md5_hash_key(
        hp: *mut tcp_md5sig_pool,
        key: *const tcp_md5sig_key,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_fastopen_cache_get(sk: *mut sock, mss: *mut u16_, cookie: *mut tcp_fastopen_cookie);
}
extern "C" {
    pub fn tcp_fastopen_cache_set(
        sk: *mut sock,
        mss: u16_,
        cookie: *mut tcp_fastopen_cookie,
        syn_lost: bool_,
        try_exp: u16_,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_fastopen_request {
    pub cookie: tcp_fastopen_cookie,
    pub data: *mut msghdr,
    pub size: usize,
    pub copied: core::ffi::c_int,
    pub uarg: *mut ubuf_info,
}
impl Default for tcp_fastopen_request {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn tcp_free_fastopen_req(tp: *mut tcp_sock);
}
extern "C" {
    pub fn tcp_fastopen_destroy_cipher(sk: *mut sock);
}
extern "C" {
    pub fn tcp_fastopen_ctx_destroy(net: *mut net);
}
extern "C" {
    pub fn tcp_fastopen_reset_cipher(
        net: *mut net,
        sk: *mut sock,
        primary_key: *mut core::ffi::c_void,
        backup_key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_fastopen_get_cipher(
        net: *mut net,
        icsk: *mut inet_connection_sock,
        key: *mut u64_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_fastopen_add_skb(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn tcp_try_fastopen(
        sk: *mut sock,
        skb: *mut sk_buff,
        req: *mut request_sock,
        foc: *mut tcp_fastopen_cookie,
        dst: *const dst_entry,
    ) -> *mut sock;
}
extern "C" {
    pub fn tcp_fastopen_init_key_once(net: *mut net);
}
extern "C" {
    pub fn tcp_fastopen_cookie_check(
        sk: *mut sock,
        mss: *mut u16_,
        cookie: *mut tcp_fastopen_cookie,
    ) -> bool_;
}
extern "C" {
    pub fn tcp_fastopen_defer_connect(sk: *mut sock, err: *mut core::ffi::c_int) -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_fastopen_context {
    pub key: [siphash_key_t; 2usize],
    pub num: core::ffi::c_int,
    pub rcu: callback_head,
}
impl Default for tcp_fastopen_context {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn tcp_fastopen_active_disable(sk: *mut sock);
}
extern "C" {
    pub fn tcp_fastopen_active_should_disable(sk: *mut sock) -> bool_;
}
extern "C" {
    pub fn tcp_fastopen_active_disable_ofo_check(sk: *mut sock);
}
extern "C" {
    pub fn tcp_fastopen_active_detect_blackhole(sk: *mut sock, expired: bool_);
}
pub const tcp_chrono_TCP_CHRONO_UNSPEC: tcp_chrono = 0;
pub const tcp_chrono_TCP_CHRONO_BUSY: tcp_chrono = 1;
pub const tcp_chrono_TCP_CHRONO_RWND_LIMITED: tcp_chrono = 2;
pub const tcp_chrono_TCP_CHRONO_SNDBUF_LIMITED: tcp_chrono = 3;
pub const tcp_chrono___TCP_CHRONO_MAX: tcp_chrono = 4;
pub type tcp_chrono = core::ffi::c_uint;
extern "C" {
    pub fn tcp_chrono_start(sk: *mut sock, type_: tcp_chrono);
}
extern "C" {
    pub fn tcp_chrono_stop(sk: *mut sock, type_: tcp_chrono);
}
extern "C" {
    pub fn tcp_write_queue_purge(sk: *mut sock);
}
extern "C" {
    pub fn tcp_rbtree_insert(root: *mut rb_root, skb: *mut sk_buff);
}
pub const tcp_seq_states_TCP_SEQ_STATE_LISTENING: tcp_seq_states = 0;
pub const tcp_seq_states_TCP_SEQ_STATE_ESTABLISHED: tcp_seq_states = 1;
pub type tcp_seq_states = core::ffi::c_uint;
extern "C" {
    pub fn tcp_seq_start(seq: *mut seq_file, pos: *mut loff_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn tcp_seq_next(
        seq: *mut seq_file,
        v: *mut core::ffi::c_void,
        pos: *mut loff_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn tcp_seq_stop(seq: *mut seq_file, v: *mut core::ffi::c_void);
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_seq_afinfo {
    pub family: sa_family_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_iter_state {
    pub p: seq_net_private,
    pub state: tcp_seq_states,
    pub syn_wait_sk: *mut sock,
    pub bucket: core::ffi::c_int,
    pub offset: core::ffi::c_int,
    pub sbucket: core::ffi::c_int,
    pub num: core::ffi::c_int,
    pub last_pos: loff_t,
}
impl Default for tcp_iter_state {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut tcp_request_sock_ops: request_sock_ops;
}
extern "C" {
    pub static mut tcp6_request_sock_ops: request_sock_ops;
}
extern "C" {
    pub fn tcp_v4_destroy_sock(sk: *mut sock);
}
extern "C" {
    pub fn tcp_gso_segment(skb: *mut sk_buff, features: netdev_features_t) -> *mut sk_buff;
}
extern "C" {
    pub fn tcp_gro_receive(head: *mut list_head, skb: *mut sk_buff) -> *mut sk_buff;
}
extern "C" {
    pub fn tcp_gro_complete(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn __tcp_v4_send_check(skb: *mut sk_buff, saddr: __be32, daddr: __be32);
}
extern "C" {
    pub fn tcp_stream_memory_free(sk: *const sock, wake: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn tcp4_proc_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp4_proc_exit();
}
extern "C" {
    pub fn tcp_rtx_synack(sk: *const sock, req: *mut request_sock) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_conn_request(
        rsk_ops: *mut request_sock_ops,
        af_ops: *const tcp_request_sock_ops,
        sk: *mut sock,
        skb: *mut sk_buff,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_sock_af_ops {}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tcp_request_sock_ops {
    pub mss_clamp: u16_,
    pub route_req: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *const sock,
            skb: *mut sk_buff,
            fl: *mut flowi,
            req: *mut request_sock,
        ) -> *mut dst_entry,
    >,
    pub init_seq: ::core::option::Option<unsafe extern "C" fn(skb: *const sk_buff) -> u32_>,
    pub init_ts_off:
        ::core::option::Option<unsafe extern "C" fn(net: *const net, skb: *const sk_buff) -> u32_>,
    pub send_synack: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *const sock,
            dst: *mut dst_entry,
            fl: *mut flowi,
            req: *mut request_sock,
            foc: *mut tcp_fastopen_cookie,
            synack_type: tcp_synack_type,
            syn_skb: *mut sk_buff,
        ) -> core::ffi::c_int,
    >,
}
extern "C" {
    pub static tcp_request_sock_ipv4_ops: tcp_request_sock_ops;
}
extern "C" {
    pub static tcp_request_sock_ipv6_ops: tcp_request_sock_ops;
}
extern "C" {
    pub fn tcpv4_offload_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_v4_init();
}
extern "C" {
    pub fn tcp_init();
}
extern "C" {
    pub fn tcp_mark_skb_lost(sk: *mut sock, skb: *mut sk_buff);
}
extern "C" {
    pub fn tcp_newreno_mark_lost(sk: *mut sock, snd_una_advanced: bool_);
}
extern "C" {
    pub fn tcp_rack_skb_timeout(tp: *mut tcp_sock, skb: *mut sk_buff, reo_wnd: u32_) -> s32;
}
extern "C" {
    pub fn tcp_rack_mark_lost(sk: *mut sock) -> bool_;
}
extern "C" {
    pub fn tcp_rack_advance(tp: *mut tcp_sock, sacked: u8_, end_seq: u32_, xmit_time: u64_);
}
extern "C" {
    pub fn tcp_rack_reo_timeout(sk: *mut sock);
}
extern "C" {
    pub fn tcp_rack_update_reo_wnd(sk: *mut sock, rs: *mut rate_sample);
}
extern "C" {
    pub fn tcp_peek_len(sock: *mut socket) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_pace_kick(timer: *mut hrtimer) -> hrtimer_restart;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tcp_ulp_ops {
    pub list: list_head,
    pub init: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock) -> core::ffi::c_int>,
    pub update: ::core::option::Option<
        unsafe extern "C" fn(
            sk: *mut sock,
            p: *mut proto,
            write_space: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
        ),
    >,
    pub release: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    pub get_info: ::core::option::Option<
        unsafe extern "C" fn(sk: *const sock, skb: *mut sk_buff) -> core::ffi::c_int,
    >,
    pub get_info_size: ::core::option::Option<unsafe extern "C" fn(sk: *const sock) -> usize>,
    pub clone: ::core::option::Option<
        unsafe extern "C" fn(req: *const request_sock, newsk: *mut sock, priority: gfp_t),
    >,
    pub name: [core::ffi::c_char; 16usize],
    pub owner: *mut module,
}
impl Default for tcp_ulp_ops {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn tcp_register_ulp(type_: *mut tcp_ulp_ops) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_unregister_ulp(type_: *mut tcp_ulp_ops);
}
extern "C" {
    pub fn tcp_set_ulp(sk: *mut sock, name: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_get_available_ulp(buf: *mut core::ffi::c_char, len: usize);
}
extern "C" {
    pub fn tcp_cleanup_ulp(sk: *mut sock);
}
extern "C" {
    pub fn tcp_update_ulp(
        sk: *mut sock,
        p: *mut proto,
        write_space: ::core::option::Option<unsafe extern "C" fn(sk: *mut sock)>,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sk_msg {
    _unused: [u8; 0],
}
extern "C" {
    pub fn tcp_bpf_get_proto(sk: *mut sock, psock: *mut sk_psock) -> *mut proto;
}
extern "C" {
    pub fn tcp_bpf_update_proto(
        sk: *mut sock,
        psock: *mut sk_psock,
        restore: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn tcp_bpf_clone(sk: *const sock, newsk: *mut sock);
}
extern "C" {
    pub fn tcp_bpf_sendmsg_redir(
        sk: *mut sock,
        msg: *mut sk_msg,
        bytes: u32_,
        flags: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut tcp_tx_delay_enabled: static_key_false;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_rt_info {
    pub daddr: in6_addr,
    pub saddr: in6_addr,
    pub mark: u_int32_t,
}
impl Default for ip6_rt_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nf_bridge_frag_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_ipv6_ops {
    pub route_input: ::core::option::Option<unsafe extern "C" fn(skb: *mut sk_buff)>,
    pub fragment: ::core::option::Option<
        unsafe extern "C" fn(
            net: *mut net,
            sk: *mut sock,
            skb: *mut sk_buff,
            output: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut net,
                    arg2: *mut sock,
                    arg3: *mut sk_buff,
                ) -> core::ffi::c_int,
            >,
        ) -> core::ffi::c_int,
    >,
    pub reroute: ::core::option::Option<
        unsafe extern "C" fn(skb: *mut sk_buff, entry: *const nf_queue_entry) -> core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct prefix_info {
    pub type_: __u8,
    pub length: __u8,
    pub prefix_len: __u8,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub valid: __be32,
    pub prefered: __be32,
    pub reserved2: __be32,
    pub prefix: in6_addr,
}
impl Default for prefix_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl prefix_info {
    #[inline]
    pub fn reserved(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn autoconf(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_autoconf(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn onlink(&self) -> __u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_onlink(&mut self, val: __u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        reserved: __u8,
        autoconf: __u8,
        onlink: __u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let autoconf: u8 = unsafe { ::core::mem::transmute(autoconf) };
            autoconf as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let onlink: u8 = unsafe { ::core::mem::transmute(onlink) };
            onlink as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_validator_info {
    pub i6vi_addr: in6_addr,
    pub i6vi_dev: *mut inet6_dev,
    pub extack: *mut netlink_ext_ack,
}
impl Default for in6_validator_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ifa6_config {
    pub pfx: *const in6_addr,
    pub plen: core::ffi::c_uint,
    pub ifa_proto: u8_,
    pub peer_pfx: *const in6_addr,
    pub rt_priority: u32_,
    pub ifa_flags: u32_,
    pub preferred_lft: u32_,
    pub valid_lft: u32_,
    pub scope: u16_,
}
impl Default for ifa6_config {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn addrconf_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn addrconf_cleanup();
}
extern "C" {
    pub fn addrconf_add_ifaddr(net: *mut net, arg: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn addrconf_del_ifaddr(net: *mut net, arg: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn addrconf_set_dstaddr(net: *mut net, arg: *mut core::ffi::c_void) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_chk_addr(
        net: *mut net,
        addr: *const in6_addr,
        dev: *const net_device,
        strict: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_chk_addr_and_flags(
        net: *mut net,
        addr: *const in6_addr,
        dev: *const net_device,
        skip_dev_check: bool_,
        strict: core::ffi::c_int,
        banned_flags: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_chk_rpl_srh_loop(
        net: *mut net,
        segs: *const in6_addr,
        nsegs: core::ffi::c_uchar,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_chk_custom_prefix(
        addr: *const in6_addr,
        prefix_len: core::ffi::c_uint,
        dev: *mut net_device,
    ) -> bool_;
}
extern "C" {
    pub fn ipv6_chk_prefix(addr: *const in6_addr, dev: *mut net_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_dev_find(
        net: *mut net,
        addr: *const in6_addr,
        dev: *mut net_device,
    ) -> *mut net_device;
}
extern "C" {
    pub fn ipv6_get_ifaddr(
        net: *mut net,
        addr: *const in6_addr,
        dev: *mut net_device,
        strict: core::ffi::c_int,
    ) -> *mut inet6_ifaddr;
}
extern "C" {
    pub fn ipv6_dev_get_saddr(
        net: *mut net,
        dev: *const net_device,
        daddr: *const in6_addr,
        srcprefs: core::ffi::c_uint,
        saddr: *mut in6_addr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_get_lladdr(
        dev: *mut net_device,
        addr: *mut in6_addr,
        banned_flags: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet_rcv_saddr_equal(sk: *const sock, sk2: *const sock, match_wildcard: bool_) -> bool_;
}
extern "C" {
    pub fn inet_rcv_saddr_any(sk: *const sock) -> bool_;
}
extern "C" {
    pub fn addrconf_join_solict(dev: *mut net_device, addr: *const in6_addr);
}
extern "C" {
    pub fn addrconf_leave_solict(idev: *mut inet6_dev, addr: *const in6_addr);
}
extern "C" {
    pub fn addrconf_add_linklocal(idev: *mut inet6_dev, addr: *const in6_addr, flags: u32_);
}
extern "C" {
    pub fn addrconf_prefix_rcv_add_addr(
        net: *mut net,
        dev: *mut net_device,
        pinfo: *const prefix_info,
        in6_dev: *mut inet6_dev,
        addr: *const in6_addr,
        addr_type: core::ffi::c_int,
        addr_flags: u32_,
        sllao: bool_,
        tokenized: bool_,
        valid_lft: __u32,
        prefered_lft: u32_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_addr_label_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_addr_label_cleanup();
}
extern "C" {
    pub fn ipv6_addr_label_rtnl_register() -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_addr_label(
        net: *mut net,
        addr: *const in6_addr,
        type_: core::ffi::c_int,
        ifindex: core::ffi::c_int,
    ) -> u32_;
}
extern "C" {
    pub fn __ipv6_sock_mc_close(sk: *mut sock);
}
extern "C" {
    pub fn ipv6_sock_mc_close(sk: *mut sock);
}
extern "C" {
    pub fn inet6_mc_check(
        sk: *mut sock,
        mc_addr: *const in6_addr,
        src_addr: *const in6_addr,
    ) -> bool_;
}
extern "C" {
    pub fn ipv6_dev_mc_inc(dev: *mut net_device, addr: *const in6_addr) -> core::ffi::c_int;
}
extern "C" {
    pub fn __ipv6_dev_mc_dec(idev: *mut inet6_dev, addr: *const in6_addr) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_dev_mc_dec(dev: *mut net_device, addr: *const in6_addr) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_mc_up(idev: *mut inet6_dev);
}
extern "C" {
    pub fn ipv6_mc_down(idev: *mut inet6_dev);
}
extern "C" {
    pub fn ipv6_mc_unmap(idev: *mut inet6_dev);
}
extern "C" {
    pub fn ipv6_mc_remap(idev: *mut inet6_dev);
}
extern "C" {
    pub fn ipv6_mc_init_dev(idev: *mut inet6_dev);
}
extern "C" {
    pub fn ipv6_mc_destroy_dev(idev: *mut inet6_dev);
}
extern "C" {
    pub fn ipv6_mc_check_mld(skb: *mut sk_buff) -> core::ffi::c_int;
}
extern "C" {
    pub fn addrconf_dad_failure(skb: *mut sk_buff, ifp: *mut inet6_ifaddr);
}
extern "C" {
    pub fn ipv6_chk_mcast_addr(
        dev: *mut net_device,
        group: *const in6_addr,
        src_addr: *const in6_addr,
    ) -> bool_;
}
extern "C" {
    pub fn ipv6_mc_dad_complete(idev: *mut inet6_dev);
}
extern "C" {
    pub fn addrconf_prefix_rcv(
        dev: *mut net_device,
        opt: *mut u8_,
        len: core::ffi::c_int,
        sllao: bool_,
    );
}
extern "C" {
    pub fn ipv6_sock_ac_join(
        sk: *mut sock,
        ifindex: core::ffi::c_int,
        addr: *const in6_addr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_sock_ac_drop(
        sk: *mut sock,
        ifindex: core::ffi::c_int,
        addr: *const in6_addr,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __ipv6_sock_ac_close(sk: *mut sock);
}
extern "C" {
    pub fn ipv6_sock_ac_close(sk: *mut sock);
}
extern "C" {
    pub fn __ipv6_dev_ac_inc(idev: *mut inet6_dev, addr: *const in6_addr) -> core::ffi::c_int;
}
extern "C" {
    pub fn __ipv6_dev_ac_dec(idev: *mut inet6_dev, addr: *const in6_addr) -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_ac_destroy_dev(idev: *mut inet6_dev);
}
extern "C" {
    pub fn ipv6_chk_acast_addr(net: *mut net, dev: *mut net_device, addr: *const in6_addr)
        -> bool_;
}
extern "C" {
    pub fn ipv6_chk_acast_addr_src(
        net: *mut net,
        dev: *mut net_device,
        addr: *const in6_addr,
    ) -> bool_;
}
extern "C" {
    pub fn ipv6_anycast_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_anycast_cleanup();
}
extern "C" {
    pub fn register_inet6addr_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_inet6addr_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet6addr_notifier_call_chain(
        val: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn register_inet6addr_validator_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn unregister_inet6addr_validator_notifier(nb: *mut notifier_block) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet6addr_validator_notifier_call_chain(
        val: core::ffi::c_ulong,
        v: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn inet6_netconf_notify_devconf(
        net: *mut net,
        event: core::ffi::c_int,
        type_: core::ffi::c_int,
        ifindex: core::ffi::c_int,
        devconf: *mut ipv6_devconf,
    );
}
extern "C" {
    pub fn in6_dev_finish_destroy(idev: *mut inet6_dev);
}
extern "C" {
    pub fn inet6_ifa_finish_destroy(ifp: *mut inet6_ifaddr);
}
extern "C" {
    pub fn if6_proc_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn if6_proc_exit();
}
extern "C" {
    pub static mut nf_ipv6_ops: *const nf_ipv6_ops;
}
extern "C" {
    pub fn __nf_ip6_route(
        net: *mut net,
        dst: *mut *mut dst_entry,
        fl: *mut flowi,
        strict: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn nf_defrag_ipv6_enable(net: *mut net) -> core::ffi::c_int;
}
extern "C" {
    pub fn nf_defrag_ipv6_disable(net: *mut net);
}
extern "C" {
    pub fn nf_ct_frag6_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn nf_ct_frag6_cleanup();
}
extern "C" {
    pub fn nf_ct_frag6_gather(net: *mut net, skb: *mut sk_buff, user: u32_) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct inet_frags_ctl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nft_ct_frag6_pernet {
    pub nf_frag_frags_hdr: *mut ctl_table_header,
    pub fqdir: *mut fqdir,
}
impl Default for nft_ct_frag6_pernet {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn br_ip6_fragment(
        net: *mut net,
        sk: *mut sock,
        skb: *mut sk_buff,
        data: *mut nf_bridge_frag_data,
        output: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut net,
                sk: *mut sock,
                data: *const nf_bridge_frag_data,
                arg2: *mut sk_buff,
            ) -> core::ffi::c_int,
        >,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ip6_route_me_harder(net: *mut net, sk: *mut sock, skb: *mut sk_buff)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn nf_ip6_checksum(
        skb: *mut sk_buff,
        hook: core::ffi::c_uint,
        dataoff: core::ffi::c_uint,
        protocol: u_int8_t,
    ) -> __sum16;
}
extern "C" {
    pub fn ipv6_netfilter_init() -> core::ffi::c_int;
}
extern "C" {
    pub fn ipv6_netfilter_fini();
}
pub const cpuhp_state_CPUHP_INVALID: cpuhp_state = -1;
pub const cpuhp_state_CPUHP_OFFLINE: cpuhp_state = 0;
pub const cpuhp_state_CPUHP_CREATE_THREADS: cpuhp_state = 1;
pub const cpuhp_state_CPUHP_PERF_PREPARE: cpuhp_state = 2;
pub const cpuhp_state_CPUHP_PERF_X86_PREPARE: cpuhp_state = 3;
pub const cpuhp_state_CPUHP_PERF_X86_AMD_UNCORE_PREP: cpuhp_state = 4;
pub const cpuhp_state_CPUHP_PERF_POWER: cpuhp_state = 5;
pub const cpuhp_state_CPUHP_PERF_SUPERH: cpuhp_state = 6;
pub const cpuhp_state_CPUHP_X86_HPET_DEAD: cpuhp_state = 7;
pub const cpuhp_state_CPUHP_X86_APB_DEAD: cpuhp_state = 8;
pub const cpuhp_state_CPUHP_X86_MCE_DEAD: cpuhp_state = 9;
pub const cpuhp_state_CPUHP_VIRT_NET_DEAD: cpuhp_state = 10;
pub const cpuhp_state_CPUHP_SLUB_DEAD: cpuhp_state = 11;
pub const cpuhp_state_CPUHP_DEBUG_OBJ_DEAD: cpuhp_state = 12;
pub const cpuhp_state_CPUHP_MM_WRITEBACK_DEAD: cpuhp_state = 13;
pub const cpuhp_state_CPUHP_MM_DEMOTION_DEAD: cpuhp_state = 14;
pub const cpuhp_state_CPUHP_MM_VMSTAT_DEAD: cpuhp_state = 15;
pub const cpuhp_state_CPUHP_SOFTIRQ_DEAD: cpuhp_state = 16;
pub const cpuhp_state_CPUHP_NET_MVNETA_DEAD: cpuhp_state = 17;
pub const cpuhp_state_CPUHP_CPUIDLE_DEAD: cpuhp_state = 18;
pub const cpuhp_state_CPUHP_ARM64_FPSIMD_DEAD: cpuhp_state = 19;
pub const cpuhp_state_CPUHP_ARM_OMAP_WAKE_DEAD: cpuhp_state = 20;
pub const cpuhp_state_CPUHP_IRQ_POLL_DEAD: cpuhp_state = 21;
pub const cpuhp_state_CPUHP_BLOCK_SOFTIRQ_DEAD: cpuhp_state = 22;
pub const cpuhp_state_CPUHP_BIO_DEAD: cpuhp_state = 23;
pub const cpuhp_state_CPUHP_ACPI_CPUDRV_DEAD: cpuhp_state = 24;
pub const cpuhp_state_CPUHP_S390_PFAULT_DEAD: cpuhp_state = 25;
pub const cpuhp_state_CPUHP_BLK_MQ_DEAD: cpuhp_state = 26;
pub const cpuhp_state_CPUHP_FS_BUFF_DEAD: cpuhp_state = 27;
pub const cpuhp_state_CPUHP_PRINTK_DEAD: cpuhp_state = 28;
pub const cpuhp_state_CPUHP_MM_MEMCQ_DEAD: cpuhp_state = 29;
pub const cpuhp_state_CPUHP_XFS_DEAD: cpuhp_state = 30;
pub const cpuhp_state_CPUHP_PERCPU_CNT_DEAD: cpuhp_state = 31;
pub const cpuhp_state_CPUHP_RADIX_DEAD: cpuhp_state = 32;
pub const cpuhp_state_CPUHP_PAGE_ALLOC: cpuhp_state = 33;
pub const cpuhp_state_CPUHP_NET_DEV_DEAD: cpuhp_state = 34;
pub const cpuhp_state_CPUHP_PCI_XGENE_DEAD: cpuhp_state = 35;
pub const cpuhp_state_CPUHP_IOMMU_IOVA_DEAD: cpuhp_state = 36;
pub const cpuhp_state_CPUHP_LUSTRE_CFS_DEAD: cpuhp_state = 37;
pub const cpuhp_state_CPUHP_AP_ARM_CACHE_B15_RAC_DEAD: cpuhp_state = 38;
pub const cpuhp_state_CPUHP_PADATA_DEAD: cpuhp_state = 39;
pub const cpuhp_state_CPUHP_AP_DTPM_CPU_DEAD: cpuhp_state = 40;
pub const cpuhp_state_CPUHP_RANDOM_PREPARE: cpuhp_state = 41;
pub const cpuhp_state_CPUHP_WORKQUEUE_PREP: cpuhp_state = 42;
pub const cpuhp_state_CPUHP_POWER_NUMA_PREPARE: cpuhp_state = 43;
pub const cpuhp_state_CPUHP_HRTIMERS_PREPARE: cpuhp_state = 44;
pub const cpuhp_state_CPUHP_PROFILE_PREPARE: cpuhp_state = 45;
pub const cpuhp_state_CPUHP_X2APIC_PREPARE: cpuhp_state = 46;
pub const cpuhp_state_CPUHP_SMPCFD_PREPARE: cpuhp_state = 47;
pub const cpuhp_state_CPUHP_RELAY_PREPARE: cpuhp_state = 48;
pub const cpuhp_state_CPUHP_SLAB_PREPARE: cpuhp_state = 49;
pub const cpuhp_state_CPUHP_MD_RAID5_PREPARE: cpuhp_state = 50;
pub const cpuhp_state_CPUHP_RCUTREE_PREP: cpuhp_state = 51;
pub const cpuhp_state_CPUHP_CPUIDLE_COUPLED_PREPARE: cpuhp_state = 52;
pub const cpuhp_state_CPUHP_POWERPC_PMAC_PREPARE: cpuhp_state = 53;
pub const cpuhp_state_CPUHP_POWERPC_MMU_CTX_PREPARE: cpuhp_state = 54;
pub const cpuhp_state_CPUHP_XEN_PREPARE: cpuhp_state = 55;
pub const cpuhp_state_CPUHP_XEN_EVTCHN_PREPARE: cpuhp_state = 56;
pub const cpuhp_state_CPUHP_ARM_SHMOBILE_SCU_PREPARE: cpuhp_state = 57;
pub const cpuhp_state_CPUHP_SH_SH3X_PREPARE: cpuhp_state = 58;
pub const cpuhp_state_CPUHP_NET_FLOW_PREPARE: cpuhp_state = 59;
pub const cpuhp_state_CPUHP_TOPOLOGY_PREPARE: cpuhp_state = 60;
pub const cpuhp_state_CPUHP_NET_IUCV_PREPARE: cpuhp_state = 61;
pub const cpuhp_state_CPUHP_ARM_BL_PREPARE: cpuhp_state = 62;
pub const cpuhp_state_CPUHP_TRACE_RB_PREPARE: cpuhp_state = 63;
pub const cpuhp_state_CPUHP_MM_ZS_PREPARE: cpuhp_state = 64;
pub const cpuhp_state_CPUHP_MM_ZSWP_MEM_PREPARE: cpuhp_state = 65;
pub const cpuhp_state_CPUHP_MM_ZSWP_POOL_PREPARE: cpuhp_state = 66;
pub const cpuhp_state_CPUHP_KVM_PPC_BOOK3S_PREPARE: cpuhp_state = 67;
pub const cpuhp_state_CPUHP_ZCOMP_PREPARE: cpuhp_state = 68;
pub const cpuhp_state_CPUHP_TIMERS_PREPARE: cpuhp_state = 69;
pub const cpuhp_state_CPUHP_MIPS_SOC_PREPARE: cpuhp_state = 70;
pub const cpuhp_state_CPUHP_BP_PREPARE_DYN: cpuhp_state = 71;
pub const cpuhp_state_CPUHP_BP_PREPARE_DYN_END: cpuhp_state = 91;
pub const cpuhp_state_CPUHP_BRINGUP_CPU: cpuhp_state = 92;
pub const cpuhp_state_CPUHP_AP_IDLE_DEAD: cpuhp_state = 93;
pub const cpuhp_state_CPUHP_AP_OFFLINE: cpuhp_state = 94;
pub const cpuhp_state_CPUHP_AP_SCHED_STARTING: cpuhp_state = 95;
pub const cpuhp_state_CPUHP_AP_RCUTREE_DYING: cpuhp_state = 96;
pub const cpuhp_state_CPUHP_AP_CPU_PM_STARTING: cpuhp_state = 97;
pub const cpuhp_state_CPUHP_AP_IRQ_GIC_STARTING: cpuhp_state = 98;
pub const cpuhp_state_CPUHP_AP_IRQ_HIP04_STARTING: cpuhp_state = 99;
pub const cpuhp_state_CPUHP_AP_IRQ_APPLE_AIC_STARTING: cpuhp_state = 100;
pub const cpuhp_state_CPUHP_AP_IRQ_ARMADA_XP_STARTING: cpuhp_state = 101;
pub const cpuhp_state_CPUHP_AP_IRQ_BCM2836_STARTING: cpuhp_state = 102;
pub const cpuhp_state_CPUHP_AP_IRQ_MIPS_GIC_STARTING: cpuhp_state = 103;
pub const cpuhp_state_CPUHP_AP_IRQ_RISCV_STARTING: cpuhp_state = 104;
pub const cpuhp_state_CPUHP_AP_IRQ_LOONGARCH_STARTING: cpuhp_state = 105;
pub const cpuhp_state_CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING: cpuhp_state = 106;
pub const cpuhp_state_CPUHP_AP_ARM_MVEBU_COHERENCY: cpuhp_state = 107;
pub const cpuhp_state_CPUHP_AP_MICROCODE_LOADER: cpuhp_state = 108;
pub const cpuhp_state_CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING: cpuhp_state = 109;
pub const cpuhp_state_CPUHP_AP_PERF_X86_STARTING: cpuhp_state = 110;
pub const cpuhp_state_CPUHP_AP_PERF_X86_AMD_IBS_STARTING: cpuhp_state = 111;
pub const cpuhp_state_CPUHP_AP_PERF_X86_CQM_STARTING: cpuhp_state = 112;
pub const cpuhp_state_CPUHP_AP_PERF_X86_CSTATE_STARTING: cpuhp_state = 113;
pub const cpuhp_state_CPUHP_AP_PERF_XTENSA_STARTING: cpuhp_state = 114;
pub const cpuhp_state_CPUHP_AP_MIPS_OP_LOONGSON3_STARTING: cpuhp_state = 115;
pub const cpuhp_state_CPUHP_AP_ARM_SDEI_STARTING: cpuhp_state = 116;
pub const cpuhp_state_CPUHP_AP_ARM_VFP_STARTING: cpuhp_state = 117;
pub const cpuhp_state_CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING: cpuhp_state = 118;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING: cpuhp_state = 119;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_ACPI_STARTING: cpuhp_state = 120;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_STARTING: cpuhp_state = 121;
pub const cpuhp_state_CPUHP_AP_PERF_RISCV_STARTING: cpuhp_state = 122;
pub const cpuhp_state_CPUHP_AP_ARM_L2X0_STARTING: cpuhp_state = 123;
pub const cpuhp_state_CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING: cpuhp_state = 124;
pub const cpuhp_state_CPUHP_AP_ARM_ARCH_TIMER_STARTING: cpuhp_state = 125;
pub const cpuhp_state_CPUHP_AP_ARM_GLOBAL_TIMER_STARTING: cpuhp_state = 126;
pub const cpuhp_state_CPUHP_AP_JCORE_TIMER_STARTING: cpuhp_state = 127;
pub const cpuhp_state_CPUHP_AP_ARM_TWD_STARTING: cpuhp_state = 128;
pub const cpuhp_state_CPUHP_AP_QCOM_TIMER_STARTING: cpuhp_state = 129;
pub const cpuhp_state_CPUHP_AP_TEGRA_TIMER_STARTING: cpuhp_state = 130;
pub const cpuhp_state_CPUHP_AP_ARMADA_TIMER_STARTING: cpuhp_state = 131;
pub const cpuhp_state_CPUHP_AP_MARCO_TIMER_STARTING: cpuhp_state = 132;
pub const cpuhp_state_CPUHP_AP_MIPS_GIC_TIMER_STARTING: cpuhp_state = 133;
pub const cpuhp_state_CPUHP_AP_ARC_TIMER_STARTING: cpuhp_state = 134;
pub const cpuhp_state_CPUHP_AP_RISCV_TIMER_STARTING: cpuhp_state = 135;
pub const cpuhp_state_CPUHP_AP_CLINT_TIMER_STARTING: cpuhp_state = 136;
pub const cpuhp_state_CPUHP_AP_CSKY_TIMER_STARTING: cpuhp_state = 137;
pub const cpuhp_state_CPUHP_AP_TI_GP_TIMER_STARTING: cpuhp_state = 138;
pub const cpuhp_state_CPUHP_AP_HYPERV_TIMER_STARTING: cpuhp_state = 139;
pub const cpuhp_state_CPUHP_AP_KVM_STARTING: cpuhp_state = 140;
pub const cpuhp_state_CPUHP_AP_KVM_ARM_VGIC_INIT_STARTING: cpuhp_state = 141;
pub const cpuhp_state_CPUHP_AP_KVM_ARM_VGIC_STARTING: cpuhp_state = 142;
pub const cpuhp_state_CPUHP_AP_KVM_ARM_TIMER_STARTING: cpuhp_state = 143;
pub const cpuhp_state_CPUHP_AP_DUMMY_TIMER_STARTING: cpuhp_state = 144;
pub const cpuhp_state_CPUHP_AP_ARM_XEN_STARTING: cpuhp_state = 145;
pub const cpuhp_state_CPUHP_AP_ARM_CORESIGHT_STARTING: cpuhp_state = 146;
pub const cpuhp_state_CPUHP_AP_ARM_CORESIGHT_CTI_STARTING: cpuhp_state = 147;
pub const cpuhp_state_CPUHP_AP_ARM64_ISNDEP_STARTING: cpuhp_state = 148;
pub const cpuhp_state_CPUHP_AP_SMPCFD_DYING: cpuhp_state = 149;
pub const cpuhp_state_CPUHP_AP_X86_TBOOT_DYING: cpuhp_state = 150;
pub const cpuhp_state_CPUHP_AP_ARM_CACHE_B15_RAC_DYING: cpuhp_state = 151;
pub const cpuhp_state_CPUHP_AP_ONLINE: cpuhp_state = 152;
pub const cpuhp_state_CPUHP_TEARDOWN_CPU: cpuhp_state = 153;
pub const cpuhp_state_CPUHP_AP_ONLINE_IDLE: cpuhp_state = 154;
pub const cpuhp_state_CPUHP_AP_SCHED_WAIT_EMPTY: cpuhp_state = 155;
pub const cpuhp_state_CPUHP_AP_SMPBOOT_THREADS: cpuhp_state = 156;
pub const cpuhp_state_CPUHP_AP_X86_VDSO_VMA_ONLINE: cpuhp_state = 157;
pub const cpuhp_state_CPUHP_AP_IRQ_AFFINITY_ONLINE: cpuhp_state = 158;
pub const cpuhp_state_CPUHP_AP_BLK_MQ_ONLINE: cpuhp_state = 159;
pub const cpuhp_state_CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS: cpuhp_state = 160;
pub const cpuhp_state_CPUHP_AP_X86_INTEL_EPB_ONLINE: cpuhp_state = 161;
pub const cpuhp_state_CPUHP_AP_PERF_ONLINE: cpuhp_state = 162;
pub const cpuhp_state_CPUHP_AP_PERF_X86_ONLINE: cpuhp_state = 163;
pub const cpuhp_state_CPUHP_AP_PERF_X86_UNCORE_ONLINE: cpuhp_state = 164;
pub const cpuhp_state_CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE: cpuhp_state = 165;
pub const cpuhp_state_CPUHP_AP_PERF_X86_AMD_POWER_ONLINE: cpuhp_state = 166;
pub const cpuhp_state_CPUHP_AP_PERF_X86_RAPL_ONLINE: cpuhp_state = 167;
pub const cpuhp_state_CPUHP_AP_PERF_X86_CQM_ONLINE: cpuhp_state = 168;
pub const cpuhp_state_CPUHP_AP_PERF_X86_CSTATE_ONLINE: cpuhp_state = 169;
pub const cpuhp_state_CPUHP_AP_PERF_X86_IDXD_ONLINE: cpuhp_state = 170;
pub const cpuhp_state_CPUHP_AP_PERF_S390_CF_ONLINE: cpuhp_state = 171;
pub const cpuhp_state_CPUHP_AP_PERF_S390_SF_ONLINE: cpuhp_state = 172;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_CCI_ONLINE: cpuhp_state = 173;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_CCN_ONLINE: cpuhp_state = 174;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE: cpuhp_state = 175;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE: cpuhp_state = 176;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE: cpuhp_state = 177;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_L3_ONLINE: cpuhp_state = 178;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_PA_ONLINE: cpuhp_state = 179;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE: cpuhp_state = 180;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HISI_PCIE_PMU_ONLINE: cpuhp_state = 181;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE: cpuhp_state = 182;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_L2X0_ONLINE: cpuhp_state = 183;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE: cpuhp_state = 184;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE: cpuhp_state = 185;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE: cpuhp_state = 186;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE: cpuhp_state = 187;
pub const cpuhp_state_CPUHP_AP_PERF_ARM_MARVELL_CN10K_DDR_ONLINE: cpuhp_state = 188;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE: cpuhp_state = 189;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE: cpuhp_state = 190;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE: cpuhp_state = 191;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE: cpuhp_state = 192;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE: cpuhp_state = 193;
pub const cpuhp_state_CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE: cpuhp_state = 194;
pub const cpuhp_state_CPUHP_AP_PERF_CSKY_ONLINE: cpuhp_state = 195;
pub const cpuhp_state_CPUHP_AP_WATCHDOG_ONLINE: cpuhp_state = 196;
pub const cpuhp_state_CPUHP_AP_WORKQUEUE_ONLINE: cpuhp_state = 197;
pub const cpuhp_state_CPUHP_AP_RANDOM_ONLINE: cpuhp_state = 198;
pub const cpuhp_state_CPUHP_AP_RCUTREE_ONLINE: cpuhp_state = 199;
pub const cpuhp_state_CPUHP_AP_BASE_CACHEINFO_ONLINE: cpuhp_state = 200;
pub const cpuhp_state_CPUHP_AP_ONLINE_DYN: cpuhp_state = 201;
pub const cpuhp_state_CPUHP_AP_ONLINE_DYN_END: cpuhp_state = 231;
pub const cpuhp_state_CPUHP_AP_MM_DEMOTION_ONLINE: cpuhp_state = 232;
pub const cpuhp_state_CPUHP_AP_X86_HPET_ONLINE: cpuhp_state = 233;
pub const cpuhp_state_CPUHP_AP_X86_KVM_CLK_ONLINE: cpuhp_state = 234;
pub const cpuhp_state_CPUHP_AP_ACTIVE: cpuhp_state = 235;
pub const cpuhp_state_CPUHP_ONLINE: cpuhp_state = 236;
pub type cpuhp_state = core::ffi::c_int;
extern "C" {
    pub fn __cpuhp_setup_state(
        state: cpuhp_state,
        name: *const core::ffi::c_char,
        invoke: bool_,
        startup: ::core::option::Option<
            unsafe extern "C" fn(cpu: core::ffi::c_uint) -> core::ffi::c_int,
        >,
        teardown: ::core::option::Option<
            unsafe extern "C" fn(cpu: core::ffi::c_uint) -> core::ffi::c_int,
        >,
        multi_instance: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cpuhp_setup_state_cpuslocked(
        state: cpuhp_state,
        name: *const core::ffi::c_char,
        invoke: bool_,
        startup: ::core::option::Option<
            unsafe extern "C" fn(cpu: core::ffi::c_uint) -> core::ffi::c_int,
        >,
        teardown: ::core::option::Option<
            unsafe extern "C" fn(cpu: core::ffi::c_uint) -> core::ffi::c_int,
        >,
        multi_instance: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cpuhp_state_add_instance(
        state: cpuhp_state,
        node: *mut hlist_node,
        invoke: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cpuhp_state_add_instance_cpuslocked(
        state: cpuhp_state,
        node: *mut hlist_node,
        invoke: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __cpuhp_remove_state(state: cpuhp_state, invoke: bool_);
}
extern "C" {
    pub fn __cpuhp_remove_state_cpuslocked(state: cpuhp_state, invoke: bool_);
}
extern "C" {
    pub fn __cpuhp_state_remove_instance(
        state: cpuhp_state,
        node: *mut hlist_node,
        invoke: bool_,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn cpuhp_online_idle(state: cpuhp_state);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu {
    pub node_id: core::ffi::c_int,
    pub hotpluggable: core::ffi::c_int,
    pub dev: device,
}
impl Default for cpu {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn boot_cpu_init();
}
extern "C" {
    pub fn boot_cpu_hotplug_init();
}
extern "C" {
    pub fn cpu_init();
}
extern "C" {
    pub fn trap_init();
}
extern "C" {
    pub fn register_cpu(cpu: *mut cpu, num: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn get_cpu_device(cpu: core::ffi::c_uint) -> *mut device;
}
extern "C" {
    pub fn cpu_is_hotpluggable(cpu: core::ffi::c_uint) -> bool_;
}
extern "C" {
    pub fn arch_match_cpu_phys_id(cpu: core::ffi::c_int, phys_id: u64_) -> bool_;
}
extern "C" {
    pub fn arch_find_n_match_cpu_physical_id(
        cpun: *mut device_node,
        cpu: core::ffi::c_int,
        thread: *mut core::ffi::c_uint,
    ) -> bool_;
}
extern "C" {
    pub fn cpu_add_dev_attr(attr: *mut device_attribute) -> core::ffi::c_int;
}
extern "C" {
    pub fn cpu_remove_dev_attr(attr: *mut device_attribute);
}
extern "C" {
    pub fn cpu_add_dev_attr_group(attrs: *mut attribute_group) -> core::ffi::c_int;
}
extern "C" {
    pub fn cpu_remove_dev_attr_group(attrs: *mut attribute_group);
}
extern "C" {
    pub fn cpu_show_meltdown(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn cpu_show_spectre_v1(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn cpu_show_spectre_v2(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn cpu_show_spec_store_bypass(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn cpu_show_l1tf(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn cpu_show_mds(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn cpu_show_tsx_async_abort(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn cpu_show_itlb_multihit(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn cpu_show_srbds(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn cpu_show_mmio_stale_data(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn cpu_show_retbleed(
        dev: *mut device,
        attr: *mut device_attribute,
        buf: *mut core::ffi::c_char,
    ) -> isize;
}
extern "C" {
    pub fn cpu_device_create(
        parent: *mut device,
        drvdata: *mut core::ffi::c_void,
        groups: *mut *const attribute_group,
        fmt: *const core::ffi::c_char,
        ...
    ) -> *mut device;
}
extern "C" {
    pub fn unregister_cpu(cpu: *mut cpu);
}
extern "C" {
    pub fn arch_cpu_probe(arg1: *const core::ffi::c_char, arg2: usize) -> isize;
}
extern "C" {
    pub fn arch_cpu_release(arg1: *const core::ffi::c_char, arg2: usize) -> isize;
}
extern "C" {
    pub static mut cpuhp_tasks_frozen: bool_;
}
extern "C" {
    pub fn add_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn cpu_device_up(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn notify_cpu_starting(cpu: core::ffi::c_uint);
}
extern "C" {
    pub fn cpu_maps_update_begin();
}
extern "C" {
    pub fn cpu_maps_update_done();
}
extern "C" {
    pub fn bringup_hibernate_cpu(sleep_cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn bringup_nonboot_cpus(setup_max_cpus: core::ffi::c_uint);
}
extern "C" {
    pub static mut cpu_subsys: bus_type;
}
extern "C" {
    pub fn lockdep_is_cpus_held() -> core::ffi::c_int;
}
extern "C" {
    pub fn cpus_write_lock();
}
extern "C" {
    pub fn cpus_write_unlock();
}
extern "C" {
    pub fn cpus_read_lock();
}
extern "C" {
    pub fn cpus_read_unlock();
}
extern "C" {
    pub fn cpus_read_trylock() -> core::ffi::c_int;
}
extern "C" {
    pub fn lockdep_assert_cpus_held();
}
extern "C" {
    pub fn cpu_hotplug_disable();
}
extern "C" {
    pub fn cpu_hotplug_enable();
}
extern "C" {
    pub fn clear_tasks_mm_cpumask(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn remove_cpu(cpu: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn cpu_device_down(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn smp_shutdown_nonboot_cpus(primary_cpu: core::ffi::c_uint);
}
extern "C" {
    pub fn cpu_startup_entry(state: cpuhp_state);
}
extern "C" {
    pub fn cpu_idle_poll_ctrl(enable: bool_);
}
extern "C" {
    pub fn cpu_in_idle(pc: core::ffi::c_ulong) -> bool_;
}
extern "C" {
    pub fn arch_cpu_idle();
}
extern "C" {
    pub fn arch_cpu_idle_prepare();
}
extern "C" {
    pub fn arch_cpu_idle_enter();
}
extern "C" {
    pub fn arch_cpu_idle_exit();
}
extern "C" {
    pub fn arch_cpu_idle_dead();
}
extern "C" {
    pub fn cpu_report_state(cpu: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn cpu_check_up_prepare(cpu: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn cpu_set_state_online(cpu: core::ffi::c_int);
}
extern "C" {
    pub fn play_idle_precise(duration_ns: u64_, latency_ns: u64_);
}
extern "C" {
    pub fn cpu_wait_death(cpu: core::ffi::c_uint, seconds: core::ffi::c_int) -> bool_;
}
extern "C" {
    pub fn cpu_report_death() -> bool_;
}
extern "C" {
    pub fn cpuhp_report_idle_dead();
}
pub const cpuhp_smt_control_CPU_SMT_ENABLED: cpuhp_smt_control = 0;
pub const cpuhp_smt_control_CPU_SMT_DISABLED: cpuhp_smt_control = 1;
pub const cpuhp_smt_control_CPU_SMT_FORCE_DISABLED: cpuhp_smt_control = 2;
pub const cpuhp_smt_control_CPU_SMT_NOT_SUPPORTED: cpuhp_smt_control = 3;
pub const cpuhp_smt_control_CPU_SMT_NOT_IMPLEMENTED: cpuhp_smt_control = 4;
pub type cpuhp_smt_control = core::ffi::c_uint;
extern "C" {
    pub fn cpu_mitigations_off() -> bool_;
}
extern "C" {
    pub fn cpu_mitigations_auto_nosmt() -> bool_;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mfd_cell {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct platform_device {
    pub name: *const core::ffi::c_char,
    pub id: core::ffi::c_int,
    pub id_auto: bool_,
    pub dev: device,
    pub platform_dma_mask: u64_,
    pub dma_parms: device_dma_parameters,
    pub num_resources: u32_,
    pub resource: *mut resource,
    pub id_entry: *const platform_device_id,
    pub driver_override: *const core::ffi::c_char,
    pub mfd_cell: *mut mfd_cell,
    pub archdata: pdev_archdata,
}
impl Default for platform_device {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn platform_device_register(arg1: *mut platform_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_device_unregister(arg1: *mut platform_device);
}
extern "C" {
    pub static mut platform_bus_type: bus_type;
}
extern "C" {
    pub static mut platform_bus: device;
}
extern "C" {
    pub fn platform_get_resource(
        arg1: *mut platform_device,
        arg2: core::ffi::c_uint,
        arg3: core::ffi::c_uint,
    ) -> *mut resource;
}
extern "C" {
    pub fn platform_get_mem_or_io(
        arg1: *mut platform_device,
        arg2: core::ffi::c_uint,
    ) -> *mut resource;
}
extern "C" {
    pub fn platform_find_device_by_driver(
        start: *mut device,
        drv: *const device_driver,
    ) -> *mut device;
}
extern "C" {
    pub fn devm_platform_get_and_ioremap_resource(
        pdev: *mut platform_device,
        index: core::ffi::c_uint,
        res: *mut *mut resource,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_platform_ioremap_resource(
        pdev: *mut platform_device,
        index: core::ffi::c_uint,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn devm_platform_ioremap_resource_byname(
        pdev: *mut platform_device,
        name: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn platform_get_irq(
        arg1: *mut platform_device,
        arg2: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_get_irq_optional(
        arg1: *mut platform_device,
        arg2: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_irq_count(arg1: *mut platform_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_platform_get_irqs_affinity(
        dev: *mut platform_device,
        affd: *mut irq_affinity,
        minvec: core::ffi::c_uint,
        maxvec: core::ffi::c_uint,
        irqs: *mut *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_get_resource_byname(
        arg1: *mut platform_device,
        arg2: core::ffi::c_uint,
        arg3: *const core::ffi::c_char,
    ) -> *mut resource;
}
extern "C" {
    pub fn platform_get_irq_byname(
        arg1: *mut platform_device,
        arg2: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_get_irq_byname_optional(
        dev: *mut platform_device,
        name: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_add_devices(
        arg1: *mut *mut platform_device,
        arg2: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct platform_device_info {
    pub parent: *mut device,
    pub fwnode: *mut fwnode_handle,
    pub of_node_reused: bool_,
    pub name: *const core::ffi::c_char,
    pub id: core::ffi::c_int,
    pub res: *const resource,
    pub num_res: core::ffi::c_uint,
    pub data: *const core::ffi::c_void,
    pub size_data: usize,
    pub dma_mask: u64_,
    pub properties: *const property_entry,
}
impl Default for platform_device_info {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn platform_device_register_full(
        pdevinfo: *const platform_device_info,
    ) -> *mut platform_device;
}
extern "C" {
    pub fn platform_device_alloc(
        name: *const core::ffi::c_char,
        id: core::ffi::c_int,
    ) -> *mut platform_device;
}
extern "C" {
    pub fn platform_device_add_resources(
        pdev: *mut platform_device,
        res: *const resource,
        num: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_device_add_data(
        pdev: *mut platform_device,
        data: *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_device_add(pdev: *mut platform_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_device_del(pdev: *mut platform_device);
}
extern "C" {
    pub fn platform_device_put(pdev: *mut platform_device);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct platform_driver {
    pub probe: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut platform_device) -> core::ffi::c_int,
    >,
    pub remove: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut platform_device) -> core::ffi::c_int,
    >,
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(arg1: *mut platform_device)>,
    pub suspend: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut platform_device, state: pm_message_t) -> core::ffi::c_int,
    >,
    pub resume: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut platform_device) -> core::ffi::c_int,
    >,
    pub driver: device_driver,
    pub id_table: *const platform_device_id,
    pub prevent_deferred_probe: bool_,
    pub driver_managed_dma: bool_,
}
impl Default for platform_driver {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub fn __platform_driver_register(
        arg1: *mut platform_driver,
        arg2: *mut module,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_driver_unregister(arg1: *mut platform_driver);
}
extern "C" {
    pub fn __platform_driver_probe(
        driver: *mut platform_driver,
        probe: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut platform_device) -> core::ffi::c_int,
        >,
        module: *mut module,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn __platform_create_bundle(
        driver: *mut platform_driver,
        probe: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut platform_device) -> core::ffi::c_int,
        >,
        res: *mut resource,
        n_res: core::ffi::c_uint,
        data: *const core::ffi::c_void,
        size: usize,
        module: *mut module,
    ) -> *mut platform_device;
}
extern "C" {
    pub fn __platform_register_drivers(
        drivers: *const *mut platform_driver,
        count: core::ffi::c_uint,
        owner: *mut module,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn platform_unregister_drivers(
        drivers: *const *mut platform_driver,
        count: core::ffi::c_uint,
    );
}
extern "C" {
    pub fn early_platform_cleanup();
}
extern "C" {
    pub fn of_match_device(matches: *const of_device_id, dev: *const device)
        -> *const of_device_id;
}
extern "C" {
    pub fn of_device_add(pdev: *mut platform_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_device_register(ofdev: *mut platform_device) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_device_unregister(ofdev: *mut platform_device);
}
extern "C" {
    pub fn of_device_get_match_data(dev: *const device) -> *const core::ffi::c_void;
}
extern "C" {
    pub fn of_device_modalias(dev: *mut device, str_: *mut core::ffi::c_char, len: isize) -> isize;
}
extern "C" {
    pub fn of_device_request_module(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_device_uevent(dev: *mut device, env: *mut kobj_uevent_env);
}
extern "C" {
    pub fn of_device_uevent_modalias(
        dev: *mut device,
        env: *mut kobj_uevent_env,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_dma_configure_id(
        dev: *mut device,
        np: *mut device_node,
        force_dma: bool_,
        id: *const u32_,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct of_dev_auxdata {
    pub compatible: *mut core::ffi::c_char,
    pub phys_addr: resource_size_t,
    pub name: *mut core::ffi::c_char,
    pub platform_data: *mut core::ffi::c_void,
}
impl Default for of_dev_auxdata {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
extern "C" {
    pub static mut of_default_bus_match_table: [of_device_id; 0usize];
}
extern "C" {
    pub fn of_device_alloc(
        np: *mut device_node,
        bus_id: *const core::ffi::c_char,
        parent: *mut device,
    ) -> *mut platform_device;
}
extern "C" {
    pub fn of_find_device_by_node(np: *mut device_node) -> *mut platform_device;
}
extern "C" {
    pub fn of_platform_bus_probe(
        root: *mut device_node,
        matches: *const of_device_id,
        parent: *mut device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_platform_device_create(
        np: *mut device_node,
        bus_id: *const core::ffi::c_char,
        parent: *mut device,
    ) -> *mut platform_device;
}
extern "C" {
    pub fn of_platform_device_destroy(
        dev: *mut device,
        data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_platform_populate(
        root: *mut device_node,
        matches: *const of_device_id,
        lookup: *const of_dev_auxdata,
        parent: *mut device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_platform_default_populate(
        root: *mut device_node,
        lookup: *const of_dev_auxdata,
        parent: *mut device,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn of_platform_depopulate(parent: *mut device);
}
extern "C" {
    pub fn devm_of_platform_populate(dev: *mut device) -> core::ffi::c_int;
}
extern "C" {
    pub fn devm_of_platform_depopulate(dev: *mut device);
}
pub const BINDER_TYPE_BINDER: core::ffi::c_uint = 1935813253;
pub const BINDER_TYPE_WEAK_BINDER: core::ffi::c_uint = 2002922117;
pub const BINDER_TYPE_HANDLE: core::ffi::c_uint = 1936206469;
pub const BINDER_TYPE_WEAK_HANDLE: core::ffi::c_uint = 2003315333;
pub const BINDER_TYPE_FD: core::ffi::c_uint = 1717840517;
pub const BINDER_TYPE_FDA: core::ffi::c_uint = 1717854597;
pub const BINDER_TYPE_PTR: core::ffi::c_uint = 1886661253;
pub type _bindgen_ty_352 = core::ffi::c_uint;
pub const FLAT_BINDER_FLAG_PRIORITY_MASK: core::ffi::c_uint = 255;
pub const FLAT_BINDER_FLAG_ACCEPTS_FDS: core::ffi::c_uint = 256;
pub const FLAT_BINDER_FLAG_TXN_SECURITY_CTX: core::ffi::c_uint = 4096;
pub type _bindgen_ty_353 = core::ffi::c_uint;
pub type binder_size_t = __u64;
pub type binder_uintptr_t = __u64;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_object_header {
    pub type_: __u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct flat_binder_object {
    pub hdr: binder_object_header,
    pub flags: __u32,
    pub __bindgen_anon_1: flat_binder_object__bindgen_ty_1,
    pub cookie: binder_uintptr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union flat_binder_object__bindgen_ty_1 {
    pub binder: binder_uintptr_t,
    pub handle: __u32,
    _bindgen_union_align: u64,
}
impl Default for flat_binder_object__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for flat_binder_object {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct binder_fd_object {
    pub hdr: binder_object_header,
    pub pad_flags: __u32,
    pub __bindgen_anon_1: binder_fd_object__bindgen_ty_1,
    pub cookie: binder_uintptr_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union binder_fd_object__bindgen_ty_1 {
    pub pad_binder: binder_uintptr_t,
    pub fd: __u32,
    _bindgen_union_align: u64,
}
impl Default for binder_fd_object__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for binder_fd_object {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_buffer_object {
    pub hdr: binder_object_header,
    pub flags: __u32,
    pub buffer: binder_uintptr_t,
    pub length: binder_size_t,
    pub parent: binder_size_t,
    pub parent_offset: binder_size_t,
}
pub const BINDER_BUFFER_FLAG_HAS_PARENT: core::ffi::c_uint = 1;
pub type _bindgen_ty_354 = core::ffi::c_uint;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_fd_array_object {
    pub hdr: binder_object_header,
    pub pad: __u32,
    pub num_fds: binder_size_t,
    pub parent: binder_size_t,
    pub parent_offset: binder_size_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_write_read {
    pub write_size: binder_size_t,
    pub write_consumed: binder_size_t,
    pub write_buffer: binder_uintptr_t,
    pub read_size: binder_size_t,
    pub read_consumed: binder_size_t,
    pub read_buffer: binder_uintptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_version {
    pub protocol_version: __s32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_node_debug_info {
    pub ptr: binder_uintptr_t,
    pub cookie: binder_uintptr_t,
    pub has_strong_ref: __u32,
    pub has_weak_ref: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_node_info_for_ref {
    pub handle: __u32,
    pub strong_count: __u32,
    pub weak_count: __u32,
    pub reserved1: __u32,
    pub reserved2: __u32,
    pub reserved3: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_freeze_info {
    pub pid: __u32,
    pub enable: __u32,
    pub timeout_ms: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_frozen_status_info {
    pub pid: __u32,
    pub sync_recv: __u32,
    pub async_recv: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_extended_error {
    pub id: __u32,
    pub command: __u32,
    pub param: __s32,
}
pub const BINDER_WRITE_READ: core::ffi::c_uint = 3224396289;
pub const BINDER_SET_IDLE_TIMEOUT: core::ffi::c_uint = 1074291203;
pub const BINDER_SET_MAX_THREADS: core::ffi::c_uint = 1074029061;
pub const BINDER_SET_IDLE_PRIORITY: core::ffi::c_uint = 1074029062;
pub const BINDER_SET_CONTEXT_MGR: core::ffi::c_uint = 1074029063;
pub const BINDER_THREAD_EXIT: core::ffi::c_uint = 1074029064;
pub const BINDER_VERSION: core::ffi::c_uint = 3221512713;
pub const BINDER_GET_NODE_DEBUG_INFO: core::ffi::c_uint = 3222823435;
pub const BINDER_GET_NODE_INFO_FOR_REF: core::ffi::c_uint = 3222823436;
pub const BINDER_SET_CONTEXT_MGR_EXT: core::ffi::c_uint = 1075339789;
pub const BINDER_FREEZE: core::ffi::c_uint = 1074553358;
pub const BINDER_GET_FROZEN_INFO: core::ffi::c_uint = 3222037007;
pub const BINDER_ENABLE_ONEWAY_SPAM_DETECTION: core::ffi::c_uint = 1074029072;
pub const BINDER_GET_EXTENDED_ERROR: core::ffi::c_uint = 3222037009;
pub type _bindgen_ty_355 = core::ffi::c_uint;
pub const transaction_flags_TF_ONE_WAY: transaction_flags = 1;
pub const transaction_flags_TF_ROOT_OBJECT: transaction_flags = 4;
pub const transaction_flags_TF_STATUS_CODE: transaction_flags = 8;
pub const transaction_flags_TF_ACCEPT_FDS: transaction_flags = 16;
pub const transaction_flags_TF_CLEAR_BUF: transaction_flags = 32;
pub const transaction_flags_TF_UPDATE_TXN: transaction_flags = 64;
pub type transaction_flags = core::ffi::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct binder_transaction_data {
    pub target: binder_transaction_data__bindgen_ty_1,
    pub cookie: binder_uintptr_t,
    pub code: __u32,
    pub flags: __u32,
    pub sender_pid: __kernel_pid_t,
    pub sender_euid: __kernel_uid32_t,
    pub data_size: binder_size_t,
    pub offsets_size: binder_size_t,
    pub data: binder_transaction_data__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union binder_transaction_data__bindgen_ty_1 {
    pub handle: __u32,
    pub ptr: binder_uintptr_t,
    _bindgen_union_align: u64,
}
impl Default for binder_transaction_data__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union binder_transaction_data__bindgen_ty_2 {
    pub ptr: binder_transaction_data__bindgen_ty_2__bindgen_ty_1,
    pub buf: [__u8; 8usize],
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_transaction_data__bindgen_ty_2__bindgen_ty_1 {
    pub buffer: binder_uintptr_t,
    pub offsets: binder_uintptr_t,
}
impl Default for binder_transaction_data__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
impl Default for binder_transaction_data {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct binder_transaction_data_secctx {
    pub transaction_data: binder_transaction_data,
    pub secctx: binder_uintptr_t,
}
impl Default for binder_transaction_data_secctx {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct binder_transaction_data_sg {
    pub transaction_data: binder_transaction_data,
    pub buffers_size: binder_size_t,
}
impl Default for binder_transaction_data_sg {
    fn default() -> Self {
        unsafe { ::core::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_ptr_cookie {
    pub ptr: binder_uintptr_t,
    pub cookie: binder_uintptr_t,
}
#[repr(C, packed)]
#[derive(Default, Copy, Clone)]
pub struct binder_handle_cookie {
    pub handle: __u32,
    pub cookie: binder_uintptr_t,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_pri_desc {
    pub priority: __s32,
    pub desc: __u32,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct binder_pri_ptr_cookie {
    pub priority: __s32,
    pub ptr: binder_uintptr_t,
    pub cookie: binder_uintptr_t,
}
pub const binder_driver_return_protocol_BR_ERROR: binder_driver_return_protocol = 2147774976;
pub const binder_driver_return_protocol_BR_OK: binder_driver_return_protocol = 29185;
pub const binder_driver_return_protocol_BR_TRANSACTION_SEC_CTX: binder_driver_return_protocol =
    2152231426;
pub const binder_driver_return_protocol_BR_TRANSACTION: binder_driver_return_protocol = 2151707138;
pub const binder_driver_return_protocol_BR_REPLY: binder_driver_return_protocol = 2151707139;
pub const binder_driver_return_protocol_BR_ACQUIRE_RESULT: binder_driver_return_protocol =
    2147774980;
pub const binder_driver_return_protocol_BR_DEAD_REPLY: binder_driver_return_protocol = 29189;
pub const binder_driver_return_protocol_BR_TRANSACTION_COMPLETE: binder_driver_return_protocol =
    29190;
pub const binder_driver_return_protocol_BR_INCREFS: binder_driver_return_protocol = 2148561415;
pub const binder_driver_return_protocol_BR_ACQUIRE: binder_driver_return_protocol = 2148561416;
pub const binder_driver_return_protocol_BR_RELEASE: binder_driver_return_protocol = 2148561417;
pub const binder_driver_return_protocol_BR_DECREFS: binder_driver_return_protocol = 2148561418;
pub const binder_driver_return_protocol_BR_ATTEMPT_ACQUIRE: binder_driver_return_protocol =
    2149085707;
pub const binder_driver_return_protocol_BR_NOOP: binder_driver_return_protocol = 29196;
pub const binder_driver_return_protocol_BR_SPAWN_LOOPER: binder_driver_return_protocol = 29197;
pub const binder_driver_return_protocol_BR_FINISHED: binder_driver_return_protocol = 29198;
pub const binder_driver_return_protocol_BR_DEAD_BINDER: binder_driver_return_protocol = 2148037135;
pub const binder_driver_return_protocol_BR_CLEAR_DEATH_NOTIFICATION_DONE:
    binder_driver_return_protocol = 2148037136;
pub const binder_driver_return_protocol_BR_FAILED_REPLY: binder_driver_return_protocol = 29201;
pub const binder_driver_return_protocol_BR_FROZEN_REPLY: binder_driver_return_protocol = 29202;
pub const binder_driver_return_protocol_BR_ONEWAY_SPAM_SUSPECT: binder_driver_return_protocol =
    29203;
pub type binder_driver_return_protocol = core::ffi::c_uint;
pub const binder_driver_command_protocol_BC_TRANSACTION: binder_driver_command_protocol =
    1077961472;
pub const binder_driver_command_protocol_BC_REPLY: binder_driver_command_protocol = 1077961473;
pub const binder_driver_command_protocol_BC_ACQUIRE_RESULT: binder_driver_command_protocol =
    1074029314;
pub const binder_driver_command_protocol_BC_FREE_BUFFER: binder_driver_command_protocol =
    1074291459;
pub const binder_driver_command_protocol_BC_INCREFS: binder_driver_command_protocol = 1074029316;
pub const binder_driver_command_protocol_BC_ACQUIRE: binder_driver_command_protocol = 1074029317;
pub const binder_driver_command_protocol_BC_RELEASE: binder_driver_command_protocol = 1074029318;
pub const binder_driver_command_protocol_BC_DECREFS: binder_driver_command_protocol = 1074029319;
pub const binder_driver_command_protocol_BC_INCREFS_DONE: binder_driver_command_protocol =
    1074815752;
pub const binder_driver_command_protocol_BC_ACQUIRE_DONE: binder_driver_command_protocol =
    1074815753;
pub const binder_driver_command_protocol_BC_ATTEMPT_ACQUIRE: binder_driver_command_protocol =
    1074291466;
pub const binder_driver_command_protocol_BC_REGISTER_LOOPER: binder_driver_command_protocol = 25355;
pub const binder_driver_command_protocol_BC_ENTER_LOOPER: binder_driver_command_protocol = 25356;
pub const binder_driver_command_protocol_BC_EXIT_LOOPER: binder_driver_command_protocol = 25357;
pub const binder_driver_command_protocol_BC_REQUEST_DEATH_NOTIFICATION:
    binder_driver_command_protocol = 1074553614;
pub const binder_driver_command_protocol_BC_CLEAR_DEATH_NOTIFICATION:
    binder_driver_command_protocol = 1074553615;
pub const binder_driver_command_protocol_BC_DEAD_BINDER_DONE: binder_driver_command_protocol =
    1074291472;
pub const binder_driver_command_protocol_BC_TRANSACTION_SG: binder_driver_command_protocol =
    1078485777;
pub const binder_driver_command_protocol_BC_REPLY_SG: binder_driver_command_protocol = 1078485778;
pub type binder_driver_command_protocol = core::ffi::c_uint;
pub const BINDINGS_GFP_KERNEL: gfp_t = 3264;
pub const BINDINGS___GFP_ZERO: gfp_t = 256;
pub const BINDINGS_EPOLLIN: __poll_t = 1;
pub const BINDINGS_EPOLLOUT: __poll_t = 4;
pub const BINDINGS_EPOLLERR: __poll_t = 8;
pub const BINDINGS_EPOLLHUP: __poll_t = 16;
pub const BINDINGS_MAX_LFS_FILESIZE: loff_t = 9223372036854775807;
pub type __builtin_va_list = *mut core::ffi::c_void;
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_sect_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_notes_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct static_key_mod {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct maple_pnode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct maple_enode {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct clocksource {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct linux_binfmt {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct msgbuf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sem_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sem_undo {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct k_clock {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rt_rq {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_class {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rt_mutex_waiter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mutex_waiter {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct assoc_array_ptr {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct key_user {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tty_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct tty_audit_buf {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct request_queue {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xattr_handler {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct mtd_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct kernfs_root {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct module_param_attrs {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct sched_group_capacity {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dev_pm_qos {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bus_dma_region {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct dma_coherent_mem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct io_tlb_mem {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct time_namespace {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct disk_stats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct gendisk {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct partition_meta_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct swap_iocb {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rt6_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct rt6_statistics {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct fib6_table {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct seg6_pernet_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct ioam6_pernet_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_ct_event_notifier {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct xsk_buff_pool {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct devlink_port {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct vlan_info {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct cpu_rmap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct pcpu_dstats {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netdev_notifier_offload_xstats_rd {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct netdev_notifier_offload_xstats_ru {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct poll_table_page {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct udp_table {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct btf_id_set8 {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct bpf_kfunc_btf_tab {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct psample_group {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct nf_flowtable {
    pub _address: u8,
}
#[repr(C)]
#[derive(Default, Copy, Clone)]
pub struct action_gate_entry {
    pub _address: u8,
}
